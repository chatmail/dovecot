#! /bin/sh -e

## DP: Adds support for SIEVE in Dovecot LDA (deliver)
## DP: Version 0.1.11 (http://www.rename-it.nl/dovecot/1.2/dovecot-1.2-sieve-0.1.12.tar.gz)

. $(dirname $0)/DPATCH

exit 0
@DPATCH@
diff -urN dovecot-1.2.4/dovecot-libsieve/AUTHORS dovecot-1.2.4.debian/dovecot-libsieve/AUTHORS
--- dovecot-1.2.4/dovecot-libsieve/AUTHORS	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/AUTHORS	2008-10-29 00:59:13.000000000 +0100
@@ -0,0 +1,13 @@
+Stephan Bosch <stephan@rename-it.nl>
+
+This plugin is partly based on the original cmusieve plugin for the Dovecot 
+secure IMAP server. It is based only on code relating to interfacing the CMU 
+Sieve implementation to Dovecot, meaning that no CMU code is incorporated in 
+this implementation. 
+
+Both the cmusieve plugin and the Dovecot IMAP server are primarily written by:
+
+Timo Sirainen <tss@iki.fi>
+
+View the AUTHORS files in the Dovecot and Dovecot-Sieve distributions for other 
+contributors. 
diff -urN dovecot-1.2.4/dovecot-libsieve/ChangeLog dovecot-1.2.4.debian/dovecot-libsieve/ChangeLog
--- dovecot-1.2.4/dovecot-libsieve/ChangeLog	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/ChangeLog	2009-08-21 01:04:32.000000000 +0200
@@ -0,0 +1,8114 @@
+2009-08-21  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Updated NEWS file for next release.
+	[645e77f279de] [tip]
+
+2009-08-16  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Updated TODO.
+	[0fe00772366f]
+
+	* Makefile.am, src/testsuite/testsuite-script.c,
+	src/testsuite/testsuite.c, tests/extensions/include/execute.svtest,
+	tests/extensions/include/execute/actions-fileinto.sieve,
+	tests/extensions/include/execute/included/actions-fileinto1.sieve,
+	tests/extensions/include/execute/included/actions-fileinto2.sieve,
+	tests/extensions/include/execute/included/actions-fileinto3.sieve:
+	Testsuite: added action execution test for the include extension
+	with stored binaries.
+	[e94731815d2d]
+
+	* src/lib-sieve/sieve-script.c:
+	Made sure script can be compared to NULL.
+	[cf5487f0c81a]
+
+	* Makefile.am, src/testsuite/Makefile.am, src/testsuite/cmd-test-
+	binary.c, src/testsuite/ext-testsuite.c, src/testsuite/testsuite-
+	binary.c, src/testsuite/testsuite-binary.h, src/testsuite/testsuite-
+	common.c, src/testsuite/testsuite-common.h, src/testsuite/testsuite-
+	script.c, src/testsuite/testsuite-script.h,
+	tests/compile/examples.svtest, tests/execute/examples.svtest:
+	Testsuite: added support for testing binaries stored on disk.
+	[79d330457a69]
+
+	* src/lib-sieve/sieve-error.c:
+	Fixed bug in error reporting when binary-related script object is
+	not set.
+	[48b7ad7a35ab]
+
+2009-08-15  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Updated TODO list.
+	[74e061124cf3]
+
+	* README:
+	Updated documentation.
+	[329e2e31c14f]
+
+	* Makefile.am, tests/extensions/date/basic.svtest,
+	tests/extensions/date/date-parts.svtest,
+	tests/extensions/date/zones.svtest:
+	Testsuite: added tests for the new date extension.
+	[4e9e557052ff]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/plugins/Makefile.am, src
+	/lib-sieve/plugins/date/ext-date.c, src/lib-sieve/sieve-
+	extensions.c:
+	Date extension: now included in default compile.
+	[8dfb24ac1e4c]
+
+	* src/lib-sieve/plugins/date/tst-date.c:
+	Date extension: accidentally committed debug printf.
+	[c296d6bea23e]
+
+	* src/lib-sieve/plugins/date/ext-date-common.c, src/lib-
+	sieve/plugins/date/tst-date.c:
+	Date extension: fixed problems in time zone handling.
+	[870d6b440c38]
+
+	* src/testsuite/testsuite-message.c:
+	Testsuite: added some debug code.\n
+	[f04fc584ca85]
+
+	* src/lib-sieve/plugins/date/ext-date-common.c:
+	Date extension: fixed bug in julian date calculation.
+	[addaeebef178]
+
+	* src/lib-sieve/plugins/date/ext-date-common.c, src/lib-
+	sieve/plugins/date/tst-date.c:
+	Date extension: fixed a few bugs related to date part extraction.
+	[3010ae60056c]
+
+	* src/lib-sieve/plugins/date/tst-date.c:
+	Date extension: fixed errorhandling of gmtime() call.
+	[acf485c1e359]
+
+	* src/lib-sieve/plugins/date/ext-date-common.c, src/lib-
+	sieve/plugins/date/tst-date.c:
+	Date extension: completed implementation.
+	[77fe808ea758]
+
+	* src/lib-sieve/plugins/date/ext-date-common.c:
+	Date extension: all simple integer date parts are fixed-length
+	strings.
+	[0410db763a44]
+
+	* src/lib-sieve/plugins/date/ext-date-common.c, src/lib-
+	sieve/plugins/date/ext-date-common.h, src/lib-sieve/plugins/date
+	/tst-date.c:
+	Date extension: implemented time zone handling.
+	[9cd4612b1680]
+
+	* src/lib-sieve/plugins/date/ext-date-common.c:
+	Date extension: implemented iso8601 date part.
+	[236fb0006d9c]
+
+	* src/lib-sieve/plugins/date/ext-date-common.c:
+	Date extension: implemented a few more date parts.
+	[9d81ee954315]
+
+2009-08-10  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am:
+	Fixed distribution of unfinished features.
+	[03cb0e6d4a35]
+
+2009-08-09  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/date/Makefile.am, src/lib-sieve/plugins/date
+	/ext-date-common.c, src/lib-sieve/plugins/date/ext-date-common.h,
+	src/lib-sieve/plugins/date/ext-date.c, src/lib-sieve/plugins/date
+	/tst-date.c:
+	Date extension: built infrastructure for date part testing.
+	[c679aa4cb12c]
+
+2009-08-08  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.1.11 for changeset 82c5b529b002
+	[45be092f98c7]
+
+	* configure.in:
+	Released v0.1.11 for Dovecot v1.2.3.
+	[82c5b529b002] [0.1.11]
+
+	* NEWS, doc/man/sieve-filter.1:
+	Updated NEWS file for next release.
+	[715bb2f65e82]
+
+2009-08-07  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Merged concurrent changes.
+	[0af8fa38807e]
+
+	* Makefile.am, doc/man/sieve-filter.1:
+	Sieve-filter: created man-page a design for the command line
+	options.
+	[e357bd4f02e8]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c:
+	Include: compare execution result to SIEVE_EXEC_OK and not to zero.
+	[3b956913d5bc]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h:
+	Include: fixed return type of execution function.
+	[824048b8571c]
+
+	* src/lib-sieve/plugins/include/ext-include-binary.c:
+	Fixed erroneous comment in binary implementation.
+	[77d19dfcd085]
+
+2009-08-06  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Fixed typo in TODO file.
+	[d9da9d373bca]
+
+2009-08-05  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Updated TODO.
+	[113dd62b0111]
+
+	* configure.in, src/lib-sieve/Makefile.am, src/lib-
+	sieve/plugins/Makefile.am, src/lib-sieve/plugins/date/Makefile.am,
+	src/lib-sieve/plugins/date/ext-date-common.h, src/lib-
+	sieve/plugins/date/ext-date.c, src/lib-sieve/plugins/date/tst-
+	date.c, src/lib-sieve/sieve-extensions.c:
+	Built skeleton implementation for the date extension (RFC 5260).
+	[ccdc02029e0f]
+
+	* src/lib-sieve/plugins/body/tst-body.c:
+	Body: fixed erroneous return code for invalid optional operand.
+	[2c44457561c9]
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-
+	sieve/sieve-code.c, src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-
+	interpreter.c:
+	Be explicit about signedness of data in binary code representation.
+	Some architectures, like ARM, differ in this respect.
+	[bbb2e488172f]
+
+	* src/lib-sieve/plugins/copy/ext-copy.c, src/lib-
+	sieve/plugins/imap4flags/cmd-flag.c, src/lib-
+	sieve/plugins/imap4flags/ext-imap4flags-common.c, src/lib-
+	sieve/plugins/imap4flags/tag-flags.c, src/lib-sieve/plugins/mailbox
+	/ext-mailbox.c, src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-
+	code.h:
+	Side-effect argumennt registrations were not using the
+	SIEVE_OPT_SIDE_EFFECT constant.
+	[0478be666511]
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-common.h:
+	Removed direct stdint.h includes to prevent portability issues.
+	[6090ba0d6f03]
+
+2009-08-04  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Updated NEWS file for next release.
+	[a317da703765]
+
+	* TODO:
+	Reprioritized and reformatted TODO file.
+	[05117882b72a]
+
+	* src/lib-sieve/sieve.c:
+	Fixed segfault bug in the handling of script open failures.
+	[b33127dc5d1b]
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-common.c:
+	Include: further adjusted log and user messages.
+	[86a000cf54d4]
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	LDA-Sieve plugin: fixed copy-paste mixup between sieve_after and
+	sieve_before. If only a sieve_after script was active, nothing would
+	have been executed. Patch by Mike Abbott.
+	[1c0543e52ed5]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c:
+	Include: fixed bug in /home/stephan substitution in sieve_dir path.
+	[ab82a70d9907]
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-common.h:
+	Include: improved error messages for include failures.
+	[205b0ec811ee]
+
+	* src/lib-sieve/plugins/include/cmd-include.c:
+	Include: removed variables-related FIXME and substituted a permanent
+	error message.
+	[069263b9f3e5]
+
+2009-08-03  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.1.10 for changeset 8ae9b01db362
+	[16bb88837266]
+
+	* NEWS, configure.in:
+	Released v0.1.10 for Dovecot v1.2.2.
+	[8ae9b01db362] [0.1.10]
+
+	* src/testsuite/Makefile.am:
+	Forgot to add header in Makefile.am for testsuite.
+	[7db3f5e8b7dd]
+
+	* src/lib-sieve/plugins/mailbox/Makefile.am:
+	Fixed automake bug in new maibox extension sources.
+	[56e86c8e7419]
+
+2009-08-02  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Added dependency notice to the NEWS file.
+	[85caab9894a0]
+
+	* NEWS:
+	Updated NEWS file for next release.
+	[a5e590c49e86]
+
+	* Makefile.am:
+	Testsuite: made valgrind report all allocated blocks that remain at
+	program end.
+	[d206080c122b]
+
+	* src/testsuite/testsuite-common.c:
+	Testsuite: properly deallocated test name string buffer upon close.
+	[2b592e23b02f]
+
+	* src/lib-sieve/sieve-match.c:
+	Fixed memory leak in matching code caused by earlier fix.
+	[314cacead8aa]
+
+	* src/lib-sieve/sieve.c, src/lib-sieve/sieve.h, src/sieve-
+	tools/sieved.c:
+	Made proper API for loading a binary directly.
+	[f52049f1196d]
+
+	* tests/extensions/imap4flags/flagstore.svtest:
+	Testsuite: added an important test for the imap4flags extension.
+	[baf3540e80fb]
+
+	* Makefile.am, TODO, tests/extensions/imap4flags/flagstore.svtest:
+	Imap4flags: added flag storage tests using mailbox loopback.
+	[cfec3730793e]
+
+	* src/lib-sieve/plugins/imap4flags/ext-imap4flags-common.c,
+	tests/extensions/imap4flags/basic.svtest:
+	Imap4flags: now reads initial flags and keywords from supplied mail.
+	Upon delivery this is empty, which still matches the specification.
+	[bde86aa3a552]
+
+	* src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-result.h:
+	Added access methods for message data en script environment to
+	result object.
+	[ba533745f5e9]
+
+	* Makefile.am, TODO, src/testsuite/cmd-test-message.c, src/testsuite
+	/testsuite-mailstore.c, tests/execute/mailstore.svtest,
+	tests/extensions/mailbox/execute.svtest:
+	Testsuite: added support for testing delivered messages by looping
+	these back as the evaluated message. Added tests for the fileinto
+	command.
+	[f4f4a6c5cba9]
+
+2009-08-01  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README:
+	Updated README.
+	[2bd355dabcfb]
+
+	* TODO, src/lib-sieve/plugins/mailbox/cmd-mailboxexists.c, src/lib-
+	sieve/plugins/mailbox/ext-mailbox.c:
+	Updated TODO and added a FIXME to the mailbox extension (no ACL
+	support yet, but required by RFC).
+	[15fadac299a3]
+
+	* Makefile.am, tests/extensions/mailbox/execute.svtest:
+	Testsuite: added tests for the mailbox extension.
+	[0691a3804073]
+
+	* src/lib-sieve/plugins/mailbox/cmd-mailboxexists.c, src/lib-
+	sieve/plugins/mailbox/ext-mailbox.c:
+	Mailbox extension: finished implementation.
+	[7b772c4fa332]
+
+	* src/lib-sieve/sieve-lexer.c:
+	Small code cleanup in the lexer code.
+	[57307603b757]
+
+	* doc/man/sieve-test.1, doc/man/sievec.1, doc/man/sieved.1:
+	Updated man pages.
+	[963fe9ea3eb1]
+
+2009-07-31  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-script.c:
+	Fixed bug in the derivation of the binary path from the script path.
+	A bare filename would yield a path relative to root.
+	[5d4eb8918bf8]
+
+	* src/testsuite/Makefile.am, src/testsuite/cmd-test-mailbox.c,
+	src/testsuite/ext-testsuite.c, src/testsuite/testsuite-common.h,
+	src/testsuite/testsuite-mailstore.c, src/testsuite/testsuite-
+	mailstore.h, src/testsuite/testsuite-message.c, src/testsuite
+	/testsuite-message.h, src/testsuite/testsuite.c,
+	tests/execute/actions.svtest,
+	tests/extensions/imap4flags/execute.svtest:
+	Testsuite: added support for testing mailbox operations.
+	[c71d7e59d532]
+
+	* autogen.sh, configure.in:
+	Use foreign automake option so it doesn't complain about missing
+	ChangeLog.
+	[f33c8245ef95]
+
+2009-07-30  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/regex/mcht-regex.c:
+	Regex: documented source code a little better.
+	[3c9a22c28156]
+
+	* src/lib-sieve/plugins/mailbox/tag-mailbox-create.c:
+	Mailbox extension: fixed compiler warning.
+	[cc49d7080a14]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/plugins/body/tst-body.c,
+	src/lib-sieve/plugins/enotify/tst-notify-method-capability.c, src
+	/lib-sieve/plugins/environment/tst-environment.c, src/lib-
+	sieve/plugins/imap4flags/tst-hasflag.c, src/lib-sieve/plugins/regex
+	/mcht-regex.c, src/lib-sieve/plugins/relational/mcht-count.c, src
+	/lib-sieve/plugins/variables/tst-string.c, src/lib-sieve/sieve-
+	match.c, src/lib-sieve/sieve-match.h, src/lib-sieve/tst-address.c,
+	src/lib-sieve/tst-header.c, src/testsuite/tst-test-error.c,
+	src/testsuite/tst-test-result.c:
+	Made sieve_match_context use a proper pool in stead of the
+	datastack.
+	[f316a10179f3]
+
+2009-07-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Added TODO item.
+	[8f2945e2714b]
+
+	* src/lib-sieve/plugins/include/ext-include.c:
+	Include: fixed assertion fail caused by missing initialization (bug
+	surfaces only for stored binaries).
+	[d989537882d0]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c:
+	Include: include error message for failed :global include.
+	[449d8ecb0f34]
+
+2009-07-27  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/sieve-tools/sieve-filter.c:
+	Sieve-filter: removed unnecessary MAILBOX_TRANSACTION_FLAG_REFRESH
+	flag for mailbox_transaction_begin().
+	[6ef0cdffb66c]
+
+	* TODO:
+	Reprioritized TODO.
+	[6dcaf8d54055]
+
+	* src/lib-sieve/plugins/mailbox/tag-mailbox-create.c, src/lib-sieve
+	/sieve-actions.c, src/lib-sieve/sieve-actions.h:
+	Mailbox extension: implemented the :create tagged argument for the
+	fileinto command.
+	[b1920ece04e3]
+
+2009-07-26  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/imap4flags/tag-flags.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-actions.h:
+	Sieve-filter: added support for setting flags on message in the
+	source folder.
+	[28badfffdc1c]
+
+	* src/sieve-tools/sieve-filter.c:
+	Sieve-filter: corrected and optimized mail filter loop.
+	[2980d32fb5ef]
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Fixed broken wiki reference in error message.
+	[5c20969f1a50]
+
+	* configure.in, src/lib-sieve/Makefile.am, src/lib-
+	sieve/plugins/mailbox/Makefile.am, src/lib-sieve/plugins/mailbox
+	/cmd-mailboxexists.c, src/lib-sieve/plugins/mailbox/ext-mailbox-
+	common.h, src/lib-sieve/plugins/mailbox/ext-mailbox.c, src/lib-
+	sieve/plugins/mailbox/tag-mailbox-create.c, src/lib-sieve/sieve-
+	extensions.c:
+	Implemented skeleton of the mailbox extension.
+	[ffa5cd58c284]
+
+	* src/lib-sieve/plugins/Makefile.am, src/lib-sieve/plugins/notify/cmd-
+	denotify.c:
+	Notify (deprecated): fixed compiler warnings.
+	[8716323f82c4]
+
+2009-07-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-types.h, src
+	/sieve-tools/sieve-filter.c:
+	Sieve-filter: implemented alternative discard actions.
+	[db78e485cbb2]
+
+	* src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-types.h, src
+	/sieve-tools/sieve-filter.c:
+	Sieve-filter: implemented expunging filtered messages in the source
+	folder (move).
+	[1ea614e1a1a6]
+
+	* src/lib-sieve/sieve.c, src/lib-sieve/sieve.h, src/plugins/lda-sieve
+	/lda-sieve-plugin.c, src/sieve-tools/sieve-filter.c, src/sieve-tools
+	/sieve-test.c:
+	Added means to get keep status from sieve execution through main
+	Sieve library API.
+	[78c065beba2d]
+
+	* src/sieve-tools/sieve-filter.c:
+	Minor changes to the sieve-filter tool.
+	[a922ed52ddd6]
+
+2009-07-24  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h:
+	Restructured store action implementation to properly handle an
+	attempt to store (keep) a message in the folder it originates from.
+	[32f6d1c48ad4]
+
+	* src/lib-sieve/plugins/notify/Makefile.am, src/lib-
+	sieve/plugins/notify/cmd-denotify.c, src/lib-sieve/plugins/notify
+	/cmd-notify.c, src/lib-sieve/plugins/notify/ext-notify-common.c, src
+	/lib-sieve/plugins/notify/ext-notify-common.h, src/lib-
+	sieve/plugins/notify/ext-notify.c:
+	Notify (deprecated): implemented skeleton of the denotify command.
+	[d6efcfec8bb6]
+
+	* src/lib-sieve/sieve-actions.c:
+	Fallback to INBOX when storing into a namespace prefix used wrong
+	storage.
+	[a6a435654c31]
+
+	* .hgtags:
+	Merged concurrent changes.
+	[3b5ee8772a28]
+
+	* .hgtags:
+	Added tag 0.1.9 for changeset fc4b67c99918
+	[2c64466c64c5]
+
+	* NEWS, configure.in:
+	Released v0.1.9 for Dovecot v1.2.1.
+	[fc4b67c99918] [0.1.9]
+
+	* src/sieve-tools/sieve-filter.c:
+	Separated source and destination mail store for sieve-filter tool.
+	[0369e2058441]
+
+2009-07-22  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.1.9 for changeset 247163f96a5c
+	[ca542d793623]
+
+	* NEWS:
+	Updated NEWS file for next release.
+	[247163f96a5c]
+
+	* src/lib-sieve/sieve-actions.c:
+	Showed wrong folder name upon INBOX fallback.
+	[26d14a354b0a]
+
+	* src/lib-sieve/sieve-actions.c:
+	Fixed more code indent problems.
+	[8ddc79659a82]
+
+	* src/lib-sieve/sieve-actions.c:
+	Fixed some code indent problems.
+	[b9e1ef848f38]
+
+	* src/lib-sieve/sieve-actions.c:
+	Made attempt to store in a namespace prefix fall back into INBOX.
+	[28280cfcdc80]
+
+	* src/lib-sieve/sieve-actions.c:
+	Fixed logging of folder namespace prefix in store action.
+	[52226d811da6]
+
+	* src/lib-sieve/sieve-validator.c:
+	Fixed potential segfault argument parameter validation.
+	[b4eb3a3f1088]
+
+2009-07-21  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am, src/testsuite/testsuite.c, tests/execute/smtp.svtest,
+	tests/extensions/enotify/mailto.svtest,
+	tests/extensions/reject/smtp.svtest,
+	tests/extensions/vacation/smtp.svtest:
+	Testsuite: added tests on the envelope of outgoing messages produced
+	by redirect, enotify:mailto, reject and vacation.
+	[dd9b380fec73]
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-envelope.c, src/lib-
+	sieve/ext-reject.c, src/lib-sieve/plugins/enotify/cmd-notify.c, src
+	/lib-sieve/plugins/enotify/ntfy-mailto.c, src/lib-
+	sieve/plugins/enotify/sieve-ext-enotify.h, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/notify/cmd-notify.c, src/lib-sieve/plugins/vacation
+	/cmd-vacation.c, src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-
+	address.c, src/lib-sieve/sieve-address.h, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-sieve
+	/sieve-message.c, src/lib-sieve/sieve-message.h, src/lib-sieve
+	/sieve-result.c, src/lib-sieve/sieve-result.h, src/lib-
+	sieve/sieve.c, src/testsuite/testsuite-common.c, src/testsuite
+	/testsuite-common.h, src/testsuite/testsuite-log.c, src/testsuite
+	/testsuite-message.c, src/testsuite/testsuite-message.h,
+	src/testsuite/testsuite-objects.c, src/testsuite/testsuite-result.c,
+	src/testsuite/testsuite-smtp.c, src/testsuite/testsuite.c:
+	Major rework of envelope address handling: a normalized version of
+	the envelope addresses is maintained in the message context and
+	message context is now also available during action execution.
+	[9ce037c114ae]
+
+2009-07-20  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c, src/lib-
+	sieve/plugins/notify/cmd-notify.c, src/lib-sieve/sieve-address.c,
+	src/sieve-tools/sieve-test.c, src/testsuite/testsuite-smtp.c:
+	Fixed segfault bug: made sure return_path is never used without
+	checking for NULL first.
+	[673b13801182]
+
+	* src/sieve-tools/Makefile.am:
+	Removed the sieve-filter tool from the default build. Need to
+	specify --with-unfinished-features to get this tool built.
+	[6c76e13aa608]
+
+2009-07-19  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/ext-reject.c, src/lib-sieve/sieve-extensions.c:
+	Added compilation support for ereject extension. It is unfinished
+	right now and performs exactly the same action as reject.
+	[7643e9831866]
+
+	* configure.in, dsieve-config.h.in:
+	Fixed bugs in the autoconf structure regarding enabling/disabling
+	unfinished features.
+	[bd0b4c044a85]
+
+	* doc/rfc/draft-ietf-sieve-refuse-reject-07.txt, doc/rfc/reject-
+	ereject.rfc5429.txt:
+	Downloaded RFC for reject and ereject extensions.
+	[15f749935cef]
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-error.c, src/lib-
+	sieve/sieve-script.c:
+	Improved file manipulation error messages regarding EACCES error.
+	[2a5955af450f]
+
+2009-07-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* tests/extensions/subaddress/basic.svtest:
+	Testsuite: added tests for envelope/address test behavior with non-
+	existant subaddress :detail part.
+	[d8d6a44fef3d]
+
+	* src/lib-sieve/ext-envelope.c:
+	Envelope: fixed bug in application of address parts; failure to
+	obtain the part would cause inappropriate match success (bug
+	reported by Ron Lee)
+	[d80b2a61c716]
+
+	* src/lib-sieve/tst-address.c:
+	Added additional headers to the list of allowed headers for the
+	address test.
+	[bbc9fcf1a3fb]
+
+2009-07-17  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/notify/ext-notify.c:
+	Notify (deprecated): added FIXME notice with missing compatibility
+	features.
+	[aed9f105338c]
+
+	* Makefile.am, tests/deprecated/notify/basic.svtest,
+	tests/deprecated/notify/errors.svtest,
+	tests/deprecated/notify/errors/options.sieve,
+	tests/deprecated/notify/execute.svtest,
+	tests/deprecated/notify/execute/duplicates.sieve,
+	tests/deprecated/notify/mailto.svtest:
+	Testsuite: added tests for deprecated notify extension.
+	[7fcca5c65067]
+
+	* src/testsuite/testsuite.c:
+	Testsuite: added support for specifying the available extensions at
+	the commandline.
+	[e492865ee76a]
+
+	* tests/extensions/enotify/errors.svtest,
+	tests/extensions/enotify/errors/from-mailto.sieve:
+	Testsuite: Notify: added test with empty :from argument for notify
+	command.
+	[74b471ab0a90]
+
+	* src/lib-sieve/plugins/notify/cmd-notify.c:
+	Notify (deprecated): fixed segfault bug in the :options argument
+	validation.
+	[038b478613a9]
+
+	* src/lib-sieve/plugins/notify/cmd-notify.c:
+	Notify (deprecated): added runtime check for recipient limit.
+	[1cb03f029e03]
+
+	* src/lib-sieve/plugins/notify/cmd-notify.c:
+	Notify (deprecated): added runtime check for duplicate recipients.
+	[fa74bf0f35fb]
+
+	* src/lib-sieve/plugins/notify/cmd-notify.c:
+	Notify (deprecated): added support for substitutions in the
+	notification message.
+	[d54d06eee248]
+
+	* configure.in, src/lib-sieve/Makefile.am, src/lib-
+	sieve/plugins/Makefile.am, src/lib-
+	sieve/plugins/enotify/Makefile.am, src/lib-sieve/plugins/enotify
+	/ext-notify.c, src/lib-sieve/plugins/notify/Makefile.am, src/lib-
+	sieve/plugins/notify/cmd-denotify.c, src/lib-sieve/plugins/notify
+	/cmd-notify.c, src/lib-sieve/plugins/notify/ext-enotify.c, src/lib-
+	sieve/plugins/notify/ext-notify-common.h, src/lib-
+	sieve/plugins/notify/ext-notify-limits.h, src/lib-
+	sieve/plugins/notify/ext-notify.c:
+	Made deprecated notify extension implementation compatible with
+	cmusieve, except for the denotify command.
+	[68be002473f5]
+
+	* src/lib-sieve/sieve-validator.c:
+	Fixed validator extension validation. It validated the first non-
+	require command before validating the extensions, which produced
+	useless error messages.
+	[ee92d0b9f7b9]
+
+	* src/lib-sieve/cmd-discard.c:
+	Made discard action log a message to avoid confusion about
+	disappearing messages.
+	[f654353b8c13]
+
+2009-07-15  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/testsuite/Makefile.am:
+	Forgot to remove old explicit storage library dependency (patch by
+	Arkadiusz Miskiewicz).
+	[31dab511011e]
+
+	* src/lib-sieve/rfc2822.c, src/lib-sieve/rfc2822.h:
+	Inappropriately ignored return value from fwrite in outgoing message
+	construction.
+	[83f23dfd5b68]
+
+2009-07-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.1.8 for changeset fa7741359396
+	[78b12c497934]
+
+	* NEWS, configure.in:
+	Released v0.1.8 for Dovecot v1.2.1.
+	[fa7741359396] [0.1.8]
+
+2009-07-12  Stephan Bosch  <stephan@rename-it.nl>
+
+	* doc/rfc/deprecated/draft-martin-sieve-notify-01.txt,
+	doc/rfc/deprecated/draft-melnikov-sieve-imapflags-03.txt:
+	Added draft RFCs for deprecated Sieve extensions imapflags and
+	notify (as implemented by cmusieve).
+	[0a2a9e6f9478]
+
+	* src/lib-sieve/plugins/imap4flags/tag-flags.c:
+	Replaced remainng occurences of t_push() .. t_pop() with T_BEGIN {
+	.. } T_END equivalents.
+	[2bd522f7276b]
+
+2009-07-08  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/enotify/Makefile.am, src/lib-
+	sieve/plugins/enotify/cmd-notify.c, src/lib-sieve/plugins/enotify
+	/ext-enotify-common.h, src/lib-sieve/plugins/enotify/ext-notify.c,
+	src/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-ast.h, src/lib-sieve
+	/sieve-extensions.c:
+	Added partial support for the depricated notify extension.
+	[d44acd7f4d09]
+
+	* src/lib-sieve/plugins/imap4flags/ext-imapflags.c, src/lib-sieve
+	/sieve-extensions.c:
+	Apparently, deprecated is spelled with an 'e'.
+	[c9379480f820]
+
+2009-07-06  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-ast.c:
+	Fixed AIX compile problem provisionally.
+	[bd106aa05040]
+
+2009-07-05  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.1.7 for changeset 5f22f0468112
+	[e86a81f4bf28]
+
+	* README, configure.in:
+	Released v0.1.7 for Dovecot v1.2.0.
+	[5f22f0468112] [0.1.7]
+
+	* NEWS:
+	Updated NEWS file for next release.
+	[6b600005be7e]
+
+	* TODO:
+	Updated TODO.
+	[e45e47df32bf]
+
+2009-07-04  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgignore:
+	Added item to .hgignore.
+	[964951d1c9fd]
+
+	* doc/man/sieve-test.1, doc/man/sievec.1, doc/man/sieved.1, src/sieve-
+	tools/sieve-filter.c, src/sieve-tools/sieve-test.c, src/sieve-
+	tools/sievec.c, src/sieve-tools/sieved.c:
+	Improved consistency of sieve tool documentation.
+	[1b4b951a6c0a]
+
+	* src/lib-sieve/sieve-extensions.c:
+	Enhanced extensions configuration, allowing to specify the enabled
+	extensions relatively to the default.
+	[91cc9f2a2404]
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Sieve plugin: forgot to initialize script execution status.
+	[c4af2d059871]
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Sieve plugin: fixed logging for execution of default main script
+	(went to STDERR).
+	[70098e07fa3b]
+
+2009-06-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Updated NEWS file for next release.
+	[2a0e9ce87006]
+
+2009-06-28  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-error.h:
+	Added support for CRLF line breaks in strbuf error handler
+	(ManageSieve fix).
+	[763f2cff0cae]
+
+2009-06-19  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.1.6 for changeset 6856b1027de8
+	[20d4b1c19c92]
+
+	* .hgtags:
+	Added tag 0.1.5 for changeset 61b52e4618e3
+	[6856b1027de8] [0.1.6]
+
+2009-06-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* configure.in:
+	Released v0.1.6 for Dovecot v1.2.rc5.
+	[47f83cfcc68e]
+
+	* NEWS:
+	Updated NEWS file for new release.
+	[e9db961974b1]
+
+2009-06-01  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/body/ext-body-common.c:
+	Body: fixed potential problems wil NUL characters in body parts.
+	[908f479dd046]
+
+	* src/lib-sieve/plugins/body/ext-body-common.c:
+	Body: fixed assert failure caused by ugly code and a change in
+	dovecot.
+	[c9780425e011]
+
+2009-05-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/body/ext-body-common.c:
+	Body: fixed part of the assert fail problems (Dovecot change).
+	[a14922487fd3]
+
+	* src/lib-sieve-tool/mail-raw.c:
+	Adjusted to changes in Dovecot regarding opening a raw stream.
+	[bcd66e758199]
+
+	* src/sieve-tools/Makefile.am:
+	Removed duplicate library dependencies.
+	[bdb7ac7fcbec]
+
+2009-05-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/ext-include-common.c:
+	Fixed compiler warning.
+	[4c5c04dd182a]
+
+2009-05-17  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/ext-include-common.c:
+	Made default of sieve_dir setting match the ManageSieve
+	implementation.
+	[334612126bb7]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c:
+	Fixed indent problems.
+	[f949723e32ef]
+
+2009-04-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS, configure.in:
+	Released v0.1.5 for Dovecot v1.2.rc3.
+	[61b52e4618e3] [0.1.5]
+
+	* src/lib-sieve/sieve-binary.c:
+	Increased binary version number.
+	[6f3609b58136]
+
+	* src/lib-sieve/cmd-require.c, src/lib-sieve/sieve-validator.c, src
+	/lib-sieve/sieve-validator.h, tests/compile/errors.svtest,
+	tests/compile/errors/require.sieve:
+	Improved error message for unknown Sieve extension to account for
+	core commands included as an extension.
+	[c3736fb49332]
+
+2009-04-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Fixed bug in the Sieve plugin's return value that caused omission of
+	delivery when no Sieve scripts are present. Bug spotted by Matthijs
+	Kooijman.
+	[4c858f06b15f]
+
+2009-04-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/environment/ext-environment-common.c:
+	Environment: fixed compiler warning.
+	[afc482d21847]
+
+	* NEWS:
+	Updated NEWS file for upcoming v1.2 release.
+	[f4230bed0845]
+
+	* tests/extensions/environment/rfc.svtest:
+	Testsuite: forgot to add new testcase file.
+	[26e1e01da8bb]
+
+2009-04-12  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am, src/lib-sieve/plugins/environment/ext-environment-
+	common.c, src/lib-sieve/plugins/environment/tst-environment.c:
+	Environment: fixed segfault and fixed some rfc deviations.
+	[831a0a96ea5b]
+
+	* src/lib-sieve/plugins/environment/ext-environment-common.c, src/lib-
+	sieve/plugins/environment/sieve-ext-environment.h,
+	src/testsuite/testsuite.c,
+	tests/extensions/environment/basic.svtest:
+	Environment: activated host environment item.
+	[01b2712fd398]
+
+	* Makefile.am, TODO, configure.in, doc/rfc/environment.rfc5183.txt,
+	src/lib-sieve/Makefile.am, src/lib-sieve/plugins/Makefile.am, src
+	/lib-sieve/plugins/environment/Makefile.am, src/lib-
+	sieve/plugins/environment/ext-environment-common.c, src/lib-
+	sieve/plugins/environment/ext-environment-common.h, src/lib-
+	sieve/plugins/environment/ext-environment.c, src/lib-
+	sieve/plugins/environment/sieve-ext-environment.h, src/lib-
+	sieve/plugins/environment/tst-environment.c, src/lib-sieve/sieve-
+	extensions.c, tests/extensions/environment/basic.svtest:
+	Implemented core support for the environment extension.
+	[9d6ceadb490a]
+
+2009-04-11  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am, tests/extensions/include/included-global/rfc-
+	ex1-spam_tests.sieve, tests/extensions/include/included/rfc-
+	ex1-always_allow.sieve, tests/extensions/include/included/rfc-
+	ex1-mailing_lists.sieve, tests/extensions/include/included/rfc-
+	ex1-spam_tests.sieve, tests/extensions/include/included/rfc-
+	ex2-spam_filter_script.sieve,
+	tests/extensions/include/included/twice-1.sieve,
+	tests/extensions/include/included/twice-2.sieve,
+	tests/extensions/include/rfc-ex1-default.sieve,
+	tests/extensions/include/rfc-ex2-default.sieve,
+	tests/extensions/include/rfc.svtest,
+	tests/extensions/include/twice.svtest:
+	Include: added various tests to the testsuite.
+	[ac4fc49c6be1]
+
+	* src/lib-sieve/plugins/include/ext-include-variables.c:
+	Include: fixed bug in binary save of global variable scope.
+	[593fe13ac0c9]
+
+2009-04-10  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am, README, TODO, src/lib-sieve/plugins/include/cmd-
+	include.c, src/lib-sieve/plugins/include/ext-include-common.c, src
+	/lib-sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c,
+	tests/extensions/include/included/once-2.sieve,
+	tests/extensions/include/included/once-3.sieve,
+	tests/extensions/include/included/once-4.sieve,
+	tests/extensions/include/once.svtest:
+	Include: implemented :once modifier for the include command.
+	[d6e436b78853]
+
+	* src/testsuite/cmd-test.c:
+	Testsuite: fixed minor result passing problem in test code
+	generation.
+	[4c416bcfd49c]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c:
+	Include: improved runtime script handling.
+	[2fd8feba11dd]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c:
+	Include: added runtime check for circular include.
+	[b21eb653f1dd]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c:
+	Fixed a few small indent problems.
+	[e948085b5b67]
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-sieve/sieve-
+	binary-dumper.c, tests/extensions/include/included/once-1.sieve,
+	tests/extensions/include/included/once-2.sieve,
+	tests/extensions/include/once.svtest:
+	Include: added skeleton :once modifier.
+	[08f3b665caee]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c:
+	Include: fixed bug in sub-sub include.
+	[f333ecabb7d4]
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Fixed warnings in revised plugin code.
+	[a92742e9a7c1]
+
+	* doc/man/sieve-test.1:
+	Minor update to the sieve-test manpage
+	[e400b5a9e182]
+
+	* README, src/lib-sieve/plugins/include/ext-include.c:
+	Include: updated implementation status.
+	[3717f4f237d9]
+
+	* doc/rfc/draft-daboo-sieve-include-05.txt, doc/rfc/draft-ietf-sieve-
+	include-01.txt:
+	Replaced include specification with latest draft.
+	[d8f0bdecc0e8]
+
+	* src/lib-sieve/plugins/include/Makefile.am, src/lib-
+	sieve/plugins/include/cmd-global.c, src/lib-sieve/plugins/include
+	/cmd-import.c, src/lib-sieve/plugins/include/ext-include-common.c,
+	src/lib-sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include-variables.c, src/lib-
+	sieve/plugins/include/ext-include-variables.h, src/lib-
+	sieve/plugins/include/ext-include.c,
+	tests/extensions/include/errors.svtest,
+	tests/extensions/include/errors/import-runtime.sieve,
+	tests/extensions/include/errors/variables-inactive.sieve,
+	tests/extensions/include/errors/variables.sieve,
+	tests/extensions/include/included/variables-included1.sieve,
+	tests/extensions/include/included/variables-included2.sieve,
+	tests/extensions/include/included/variables-included3.sieve,
+	tests/extensions/include/variables.svtest:
+	Include: replaced import/export commands with global command as
+	specified in latest draft. Import/export are now DEPRICATED.
+	[6fff255fe757]
+
+	* src/lib-sieve/plugins/subaddress/ext-subaddress.c, src/lib-sieve
+	/sieve-address-parts.c, tests/address.svtest,
+	tests/extensions/subaddress/basic.svtest:
+	Definitively fixed handling group specifications in mailbox lists of
+	address headers.
+	[914c3c1f5f8c]
+
+	* doc/man/sieve-test.1:
+	Fixed minor typo in sieve-test man page.
+	[b3ad017662d1]
+
+	* TODO:
+	Updated TODO.
+	[e89b270850c6]
+
+	* src/lib-sieve/sieve-error-private.h, src/lib-sieve/sieve-error.c,
+	src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-result.h, src/lib-
+	sieve/sieve-script.c, src/lib-sieve/sieve.c, src/lib-sieve/sieve.h,
+	src/plugins/lda-sieve/lda-sieve-plugin.c, src/sieve-tools/sieve-
+	test.c:
+	Major rework of the multiscript support for better error handling.
+	[6dcfb15cf051]
+
+2009-04-09  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Improved plugin debug message.
+	[24847d4c5ef8]
+
+2009-04-08  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Fixed problem of unexecuted before/after global scripts when user
+	script is missing.
+	[4d2503564c59]
+
+2009-04-07  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve-tool/sieve-tool.c:
+	Adjusted to signal handler API changes in Dovecot.
+	[b7e376b7fb07]
+
+2009-04-06  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/subaddress/ext-subaddress.c, src/lib-sieve
+	/sieve-address-parts.c:
+	Fixed segfault bug caused by undisclosed-recipients:; when fed to
+	the subaddress extension.
+	[ec78123ec073]
+
+2009-03-21  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.1.4 for changeset b7eb19f14fa7
+	[38ef3a309167]
+
+	* NEWS, configure.in:
+	Released v0.1.4 for Dovecot v1.2.beta3.
+	[b7eb19f14fa7] [0.1.4]
+
+2009-03-20  Stephan Bosch  <stephan@rename-it.nl>
+
+	* doc/man/sieve-test.1:
+	Documented vnd.dovecot.debug in the sieve-test man page.
+	[3e4cc10a3d89]
+
+	* NEWS:
+	Updated NEWS file.
+	[9daef35779e6]
+
+	* src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-error.h, src/sieve-
+	tools/sieve-filter.c, src/sieve-tools/sieve-test.c, src/sieve-
+	tools/sievec.c, src/sieve-tools/sieved.c:
+	Improved error handling and added debug extension to all applicable
+	Sieve tools.
+	[ae2f39427f14]
+
+2009-03-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS, src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-error.h:
+	Created replaceable error handler for system errors.
+	[539cfb9b9507]
+
+	* TODO, configure.in, src/sieve-tools/Makefile.am, src/sieve-
+	tools/debug/Makefile.am, src/sieve-tools/debug/cmd-debug-print.c,
+	src/sieve-tools/debug/ext-debug-common.h, src/sieve-tools/debug/ext-
+	debug.c, src/sieve-tools/debug/sieve-ext-debug.h, src/sieve-tools
+	/sieve-test.c:
+	Added Dovecot-specific debug extension to the sieve-test tool.
+	[a74dc7f32b71]
+
+	* TODO, src/sieve-tools/sieve-filter.c:
+	Sieve-filter: implemented basic filtering.
+	[8862c90bc395]
+
+2009-03-05  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/sieve-tools/Makefile.am, src/testsuite/Makefile.am:
+	Removed unnecessary linker flags that break Solaris compilation.
+	[45c04b2fe529]
+
+2009-02-24  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/regex/ext-regex-common.h, src/lib-
+	sieve/plugins/relational/ext-relational-common.h, src/lib-sieve
+	/sieve-address-parts.c, src/lib-sieve/sieve-address-parts.h, src
+	/lib-sieve/sieve-code.h, src/lib-sieve/sieve-match-types.c, src/lib-
+	sieve/sieve-match-types.h:
+	Fixed MAC OSX compile problems: forgot extern modifier at various
+	places.
+	[ab9a06342d33]
+
+2009-02-23  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve-tool/mail-raw.c:
+	Fixed issue with opening relative paths as a mail file.
+	[4d642db0b754]
+
+	* src/lib-sieve-tool/mail-raw.c:
+	Fixed tmp file name for raw storage used for sieve tools.
+	[54a07ebb8e1f]
+
+2009-02-19  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Updated TODO.
+	[7d45c1fdf9c1]
+
+	* doc/rfc/collation.rfc4790.txt, doc/rfc/i-ascii-numeric.rfc2244.txt:
+	Removed inappropriate ACAP rfc for i;ascii-numeric comparator and
+	substituted rfc4790 in stead.
+	[cebc91cd58e1]
+
+2009-02-15  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/sieve-tools/sieve-filter.c:
+	Sieve-filter: developed listing messages in a folder a little
+	further.
+	[e7dd36461c67]
+
+	* .hgignore, src/sieve-tools/Makefile.am, src/sieve-tools/sieve-
+	filter.c:
+	Started work on sieve-filter tool.
+	[85230557972e]
+
+2009-02-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/sieve-commands.h, src/lib-sieve/sieve-
+	validator.c, src/testsuite/cmd-test-message.c, src/testsuite
+	/testsuite-common.c, src/testsuite/testsuite-common.h, src/testsuite
+	/testsuite-smtp.c, src/testsuite/testsuite-smtp.h,
+	tests/extensions/enotify/mailto.svtest:
+	Testsuite: added a few final important tests for the enotify
+	extension.
+	[75b6dac1df2a]
+
+2009-02-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.1.3 for changeset 8bdff47ab3f0
+	[977e30fa18c2]
+
+	* configure.in:
+	Released v0.1.3 for Dovecot v1.2.beta1.
+	[8bdff47ab3f0] [0.1.3]
+
+2009-02-12  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Added items to the TODO list.
+	[1c401bb66e52]
+
+	* doc/man/sievec.1:
+	Minor changes to the sievec man page.
+	[c8c404ceeb47]
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-script.c, src/lib-
+	sieve/sieve-script.h:
+	Saved binary now has at most the same permissions as the script file
+	itself.
+	[3bdd01261818]
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-extensions.c:
+	Fixed bug the code generation of extensions.
+	[3eb2562e40e8]
+
+	* doc/man/sieved.1, src/sieve-tools/sieved.c:
+	Added -x parameter to sieved tool.
+	[c98dafdf1f49]
+
+2009-02-11  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-validator.c:
+	Fixed small bug in the extension validation.
+	[15dd897287d2]
+
+	* src/lib-sieve/sieve-extensions.c:
+	Imapflags: marked as depricated and disabled by default.
+	[95a9bb61d7ca]
+
+	* src/lib-sieve/sieve-validator.c:
+	Properly implemented verification of loaded extensions after last
+	require command is validated.
+	[cbb12efa1f1b]
+
+	* tests/extensions/variables/match.svtest:
+	Testsuite: added small test for ?* match values.
+	[2d132b56398a]
+
+	* NEWS:
+	Updated NEWS file for next release.
+	[a57d7b6d95a8]
+
+2009-02-08  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am, tests/extensions/vacation/message.svtest,
+	tests/extensions/vacation/references.svtest:
+	Testsuite: added message tests for the vacation extension.
+	[7a074a0ff5c0]
+
+	* src/lib-sieve/sieve-interpreter.c, src/lib-sieve/sieve-
+	interpreter.h, src/testsuite/Makefile.am, src/testsuite/cmd-test-
+	result-reset.c, src/testsuite/ext-testsuite.c, src/testsuite
+	/testsuite-common.h, src/testsuite/testsuite-result.c, src/testsuite
+	/testsuite-result.h, src/testsuite/tst-test-script-run.c,
+	tests/extensions/enotify/mailto.svtest:
+	Testsuite: added support for resetting the result.
+	[42b3ec181e64]
+
+	* tests/extensions/enotify/mailto.svtest:
+	Testsuite: added tests for enotify with multiple recipients.
+	[c84f556f3115]
+
+	* Makefile.am, TODO, src/lib-sieve/plugins/include/cmd-import.c, src
+	/lib-sieve/plugins/vacation/cmd-vacation.c, src/lib-sieve/tst-
+	size.c, src/testsuite/Makefile.am, src/testsuite/cmd-test-message.c,
+	src/testsuite/ext-testsuite.c, src/testsuite/testsuite-common.h,
+	src/testsuite/testsuite-message.c, src/testsuite/testsuite-
+	message.h, src/testsuite/testsuite-objects.c, src/testsuite
+	/testsuite-result.c, src/testsuite/testsuite-smtp.c, src/testsuite
+	/testsuite-smtp.h, src/testsuite/tst-test-result-execute.c,
+	tests/extensions/enotify/mailto.svtest:
+	Testsuite: added support for looping back outgoing SMTP messages
+	back into the test.
+	[3f857d8c403e]
+
+2009-02-07  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/cmd-redirect.c, src/lib-sieve/plugins/enotify
+	/ntfy-mailto.c, src/lib-sieve/plugins/vacation/cmd-vacation.c, src
+	/lib-sieve/sieve-address.c, src/lib-sieve/sieve-address.h:
+	Defined very basic function for address comparison.
+	[e4283ec36db2]
+
+	* src/lib-sieve/sieve-actions.c:
+	Adjusted store action to API changes in Dovecot.
+	[d2ed402f1a5f]
+
+2009-02-06  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/vacation/cmd-vacation.c, src/lib-sieve/sieve-
+	address.c, tests/extensions/vacation/execute/action.sieve:
+	Vacation: made addresses comparison case-insensitive.
+	[b315fde89b8a]
+
+2009-02-05  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README:
+	Updated documentation.
+	[cea5c68baa2e]
+
+	* src/lib-sieve/plugins/imap4flags/tag-flags.c,
+	tests/extensions/imap4flags/execute/imapflags.sieve:
+	Imap4flags: fixed dumping of \flagged flag in flags side effect.
+	[a1ad7bbd3ef7]
+
+	* Makefile.am, src/lib-sieve/plugins/imap4flags/Makefile.am, src/lib-
+	sieve/plugins/imap4flags/ext-imapflags.c, src/lib-sieve/sieve-ast.c,
+	src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-extensions.c, src
+	/lib-sieve/sieve-extensions.h, src/lib-sieve/sieve-validator.c,
+	src/testsuite/testsuite.c,
+	tests/extensions/imap4flags/errors.svtest,
+	tests/extensions/imap4flags/errors/imapflags.sieve,
+	tests/extensions/imap4flags/execute/imapflags.sieve:
+	Imap4flags: added support for obsolete imapflags extension for
+	backwards compatibility with CMUSieve.
+	[4e58445b4f87]
+
+2009-02-04  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve-validator.h:
+	Validator: added support for checking loaded extensions.
+	[ab9545a27bbf]
+
+	* src/lib-sieve/cmd-require.c, src/lib-sieve/sieve-extensions.c, src
+	/lib-sieve/sieve-extensions.h, src/lib-sieve/sieve-validator.c, src
+	/lib-sieve/sieve-validator.h:
+	Added facilities for requiring extensions and making extensions
+	mutually exclusive.
+	[37fc919d3450]
+
+	* Makefile.am, tests/extensions/imap4flags/basic.svtest,
+	tests/extensions/imap4flags/execute.svtest,
+	tests/extensions/imap4flags/execute/flags-side-effect.sieve,
+	tests/extensions/imap4flags/hasflag.svtest,
+	tests/extensions/imapflags/basic.svtest,
+	tests/extensions/imapflags/execute.svtest,
+	tests/extensions/imapflags/execute/flags-side-effect.sieve,
+	tests/extensions/imapflags/hasflag.svtest:
+	Imap4flags: gave testsuite directory proper name.
+	[f0299c1886fe]
+
+	* src/lib-sieve/plugins/imap4flags/cmd-flag.c, src/lib-
+	sieve/plugins/imap4flags/ext-imap4flags-common.c, src/lib-
+	sieve/plugins/imap4flags/ext-imap4flags-common.h, src/lib-
+	sieve/plugins/imap4flags/ext-imap4flags.c, src/lib-
+	sieve/plugins/imap4flags/tag-flags.c, src/lib-
+	sieve/plugins/imap4flags/tst-hasflag.c, src/lib-sieve/sieve-
+	extensions.c:
+	Imap4flags: properly named extension objects.
+	[581df7c170d1]
+
+	* src/lib-sieve/plugins/imap4flags/cmd-flag.c, src/lib-
+	sieve/plugins/imap4flags/ext-imap4flags-common.c, src/lib-
+	sieve/plugins/imap4flags/ext-imap4flags-common.h, src/lib-
+	sieve/plugins/imap4flags/ext-imap4flags.c, src/lib-
+	sieve/plugins/imap4flags/tag-flags.c, src/lib-
+	sieve/plugins/imap4flags/tst-hasflag.c:
+	Imap4flags: properly named functions.
+	[debaa7e5a036]
+
+	* configure.in, src/lib-sieve/Makefile.am, src/lib-
+	sieve/plugins/Makefile.am, src/lib-
+	sieve/plugins/imap4flags/Makefile.am, src/lib-
+	sieve/plugins/imap4flags/cmd-flag.c, src/lib-
+	sieve/plugins/imap4flags/ext-imap4flags-common.c, src/lib-
+	sieve/plugins/imap4flags/ext-imap4flags-common.h, src/lib-
+	sieve/plugins/imap4flags/ext-imap4flags.c, src/lib-
+	sieve/plugins/imap4flags/tag-flags.c, src/lib-
+	sieve/plugins/imap4flags/tst-hasflag.c, src/lib-
+	sieve/plugins/imapflags/Makefile.am, src/lib-sieve/plugins/imapflags
+	/cmd-flag.c, src/lib-sieve/plugins/imapflags/ext-imapflags-common.c,
+	src/lib-sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/imapflags
+	/tst-hasflag.c:
+	Imap4flags: properly named extension directory and source files.
+	[c8d2f78230f9]
+
+2009-02-03  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README:
+	Fixed README: now mentions the naming differences of the imap4flags
+	and enotify extensions compared to the old CMU Sieve plugin.
+	[f33ee1af3bdb]
+
+2009-02-02  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/cmd-redirect.c:
+	Fixed compile warning caused by missing include.
+	[c0a84cf64bbd]
+
+2009-02-01  Stephan Bosch  <stephan@rename-it.nl>
+
+	* doc/rfc/draft-ietf-sieve-notify-12.txt, doc/rfc/draft-ietf-sieve-
+	notify-mailto-10.txt, doc/rfc/notify-mailto.rfc5436.txt,
+	doc/rfc/notify.rfc5435.txt, src/lib-sieve/plugins/enotify/ext-
+	enotify.c, src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Installed RFC documents for notify extension and corresponding
+	mailto method.
+	[b11bd3479721]
+
+	* src/lib-sieve/mcht-matches.c, tests/match-types/matches.svtest:
+	Cleaned up :matches match-type code.
+	[ca2edcc58fba]
+
+	* src/lib-sieve/mcht-matches.c, tests/match-types/matches.svtest:
+	Fixed bug in the :matches match type.
+	[88cc4bf1c396]
+
+2009-01-27  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Added important TODO item.
+	[42e154b8792e]
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/rfc2822.c:
+	Changed SMTP message generation back to CRLF, because the Sieve
+	engine uses CRLF internally.
+	[082216ad12d6]
+
+	* src/lib-sieve/sieve-binary-dumper.c, src/lib-sieve/sieve-code-
+	dumper.c, src/lib-sieve/sieve-code.c:
+	Fixed use of data stack by binary dumping code.
+	[258e357cfbf7]
+
+	* src/lib-sieve/plugins/regex/mcht-regex.c:
+	Regex: fixed segfault bug occuring when regex is freed.
+	[6ed559a5f677]
+
+	* src/testsuite/tst-test-script-compile.c:
+	Testsuite: fixed warning.
+	[abc7331b2124]
+
+	* src/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-validator.c:
+	Increased various initial pool sizes.
+	[cdb4b96e70a8]
+
+2009-01-26  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-binary.c:
+	Increased initial size of binary's lazy_file pool.
+	[7caaa891d5f4]
+
+	* src/lib-sieve/rfc2822.c:
+	Fixed error in the SMTP message composition that caused mixing of
+	CRLF and LF in redirected messages.
+	[2ae233b6f5ad]
+
+2009-01-22  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Updated NEWS file.
+	[a8e587b0409e]
+
+	* NEWS:
+	Updated NEWS file.
+	[b93c8d7802a3]
+
+	* README:
+	Updated README file.
+	[171133900f9b]
+
+	* NEWS:
+	Prepared NEWS file for next release.
+	[42ef7e546072]
+
+	* INSTALL:
+	Updated documentation.
+	[32812e4f4722]
+
+	* Makefile.am, tests/extensions/regex/match-values.svtest:
+	Testsuite: added simple tests for the match values produced by the
+	:regex match.
+	[7a91f98d0be1]
+
+	* src/lib-sieve/plugins/regex/mcht-regex.c:
+	Regex: fixed bug in the match value indexes.
+	[de6db6757418]
+
+2009-01-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* doc/rfc/draft-degener-sieve-multiscript-00.txt:
+	Added multiscript draft to the doc/rfc directory.
+	[fa223cfeaa35]
+
+	* src/testsuite/Makefile.am, src/testsuite/testsuite-common.c,
+	src/testsuite/testsuite-common.h, src/testsuite/testsuite-message.c,
+	src/testsuite/testsuite-smtp.c, src/testsuite/testsuite-smtp.h,
+	src/testsuite/testsuite.c, src/testsuite/tst-test-script-run.c:
+	Testsuite: added storage of outgoing SMTP messages.
+	[3fd7e83720fb]
+
+	* src/testsuite/Makefile.am, src/testsuite/testsuite-common.c,
+	src/testsuite/testsuite-common.h, src/testsuite/testsuite-message.c,
+	src/testsuite/testsuite-message.h, src/testsuite/testsuite-
+	objects.c, src/testsuite/testsuite.c:
+	Testsuite: exported message handling to separate module.
+	[b15cfe188d87]
+
+2009-01-16  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/sieve-ext-enotify.h, src/lib-sieve/sieve-result.c, src/lib-sieve
+	/sieve-result.h:
+	Enotify: cleaned up method API.
+	[466e57aedb29]
+
+	* tests/extensions/imapflags/basic.svtest,
+	tests/extensions/imapflags/hasflag.svtest:
+	Testsuite: improved testsuite with respect to testing of setflag,
+	addflag and removeflag commands.
+	[18b4ee74fc9c]
+
+	* TODO, src/lib-sieve/plugins/imapflags/Makefile.am, src/lib-
+	sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-flag.c, src/lib-sieve/plugins/imapflags
+	/cmd-removeflag.c, src/lib-sieve/plugins/imapflags/cmd-setflag.c,
+	src/lib-sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h:
+	Imap4flags: merged setflag, addflag and removeflag implementations.
+	[38189d0d5785]
+
+	* INSTALL, src/lib-sieve/plugins/subaddress/ext-subaddress.c:
+	Added sieve_subaddress_sep setting.
+	[fac1579a1164]
+
+2009-01-11  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-address.c, tests/compile/errors.svtest,
+	tests/compile/errors/out-address.sieve:
+	Fixed bug in the outgoing mail address verification.
+	[60b3f236c3bc]
+
+	* TODO, src/lib-sieve/plugins/enotify/ntfy-mailto.c,
+	tests/extensions/enotify/execute.svtest,
+	tests/extensions/enotify/execute/duplicates.sieve:
+	Enotify/Mailto: prevented single recipient from receiving multiple
+	notifications on the same message.
+	[38b1269f8e10]
+
+	* src/testsuite/testsuite.c:
+	Testsuite: fixed segfault bugs in the error handling.
+	[31804bc166e3]
+
+2009-01-10  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README:
+	Small project status update to the README.
+	[31fb740ce85c]
+
+	* TODO, src/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/sieve-ext-enotify.h, tests/extensions/enotify/execute.svtest,
+	tests/extensions/enotify/execute/duplicates.sieve:
+	Enotify: added API for detecting and killing duplicate notification
+	recipients.
+	[975614b641aa]
+
+	* TODO, src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Multiscript: implemented sorting of script files in script
+	directories for Sieve plugin.
+	[c13464cb4fe3]
+
+	* INSTALL, README, TODO, src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Updated documentation.
+	[17a66023e259]
+
+	* TODO:
+	Reprioritized TODO.
+	[bcbae5e0e63d]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Got array_get_pool() integrated into Dovecot.
+	[3929bef582c0]
+
+	* README, TODO:
+	Updated documentation.
+	[aec958653b9f]
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Fixed segfault in lda sieve plugin.
+	[902ee7cc9588]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify/Mailto: fixed bug in the generation of the SMTP envelope
+	sender.
+	[e124dfa5388c]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: fixed various indent mishaps in ntfy-mailto.c.
+	[f958c97ec9dc]
+
+	* src/lib-sieve/sieve.c, src/lib-sieve/sieve.h, src/plugins/lda-sieve
+	/lda-sieve-plugin.c, src/sieve-tools/sieve-test.c:
+	Multiscript: added untested multiscript support to the lda sieve
+	plugin.
+	[2777abb69dd0]
+
+2009-01-09  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h:
+	Added a few accessors to the binary object for convenience.
+	[374039e9194e]
+
+	* src/testsuite/testsuite.c:
+	Testsuite: fixed warning.
+	[15bc0d5d27a5]
+
+	* src/testsuite/testsuite.c:
+	Testsuite: fixed result handling.
+	[8d63ff17d7e8]
+
+	* TODO:
+	Removed remaining references to sieve-exec.
+	[1eca558676df]
+
+2009-01-07  Stephan Bosch  <stephan@rename-it.nl>
+
+	* doc/man/sievec.1, src/lib-sieve-tool/sieve-tool.c, src/lib-sieve-
+	tool/sieve-tool.h, src/lib-sieve/sieve-script-private.h, src/lib-
+	sieve/sieve-script.c, src/lib-sieve/sieve-script.h, src/lib-
+	sieve/sieve.c, src/lib-sieve/sieve.h, src/plugins/lda-sieve/lda-
+	sieve-plugin.c, src/sieve-tools/sieve-test.c, src/sieve-
+	tools/sievec.c, src/testsuite/testsuite-script.c,
+	src/testsuite/testsuite.c:
+	Extended sievec command to allow compiling an entire directory.
+	[a56dfe862df4]
+
+2009-01-06  Stephan Bosch  <stephan@rename-it.nl>
+
+	* doc/man/sieved.1:
+	Minor revisions to the sieved man page.
+	[df54062cbf77]
+
+	* doc/man/sievec.1, src/sieve-tools/sievec.c:
+	Made outfile argument of the sievec command optional.
+	[b7ae0b1d7399]
+
+	* README:
+	Updated README.
+	[7cb784bf0c4c]
+
+	* doc/man/sieve-test.1, doc/man/sievec.1, doc/man/sieved.1, src/lib-
+	sieve/cmd-discard.c, src/lib-sieve/sieve-result.c, src/lib-sieve
+	/sieve-result.h, src/lib-sieve/sieve.c, src/sieve-tools/Makefile.am,
+	src/sieve-tools/sieve-exec.c, src/sieve-tools/sieve-test.c:
+	Merged sieve-exec tool into sieve-test.
+	[030d37107e10]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/vacation
+	/cmd-vacation.c:
+	Fixed various result error messages.
+	[02697b1b4311]
+
+	* src/lib-sieve/sieve-binary.c:
+	Fixed a theoretical security hole occuring when directory is opened
+	as a Sieve binary.
+	[d2a7caa5566f]
+
+2009-01-04  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/sieve-tools/sieve-test.c:
+	Updated TODO.
+	[2c64b5e5db89]
+
+	* src/lib-sieve/sieve-result.c, src/sieve-tools/sieve-test.c:
+	Multiscript: fixed small bug in result printing.
+	[0a5938f5e88c]
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/enotify/cmd-notify.c, src/lib-sieve/plugins/vacation
+	/cmd-vacation.c, src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-
+	actions.h, src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-
+	result.h, src/lib-sieve/sieve.c, src/lib-sieve/sieve.h, src/sieve-
+	tools/sieve-test.c:
+	Multiscript: improved handling of the keep action.
+	[5d251b577e56]
+
+	* TODO:
+	Updated TODO.
+	[511e2770304c]
+
+	* src/lib-sieve/ext-reject.c, src/lib-sieve/plugins/vacation/cmd-
+	vacation.c, src/lib-sieve/sieve-result.c, src/lib-sieve/sieve.c, src
+	/lib-sieve/sieve.h, src/sieve-tools/sieve-test.c:
+	Multiscript: implemented execution of multiple scripts for the
+	sieve-test command.
+	[d20619f44dc0]
+
+2009-01-03  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve.c, src/lib-sieve/sieve.h:
+	Multiscript: implemented API.
+	[50f5d81b9507]
+
+	* doc/man/sieve-test.1, src/lib-sieve/cmd-redirect.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/include
+	/ext-include-common.c, src/lib-sieve/sieve-actions.c, src/lib-sieve
+	/sieve-actions.h, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/sieve-interpreter.h, src/lib-sieve/sieve-result.c, src/lib-sieve
+	/sieve-result.h, src/lib-sieve/sieve-types.h, src/lib-sieve/sieve.c,
+	src/lib-sieve/sieve.h, src/plugins/lda-sieve/lda-sieve-plugin.c, src
+	/sieve-tools/sieve-exec.c, src/sieve-tools/sieve-test.c,
+	src/testsuite/testsuite-result.c, src/testsuite/testsuite-script.c,
+	src/testsuite/testsuite.c:
+	Multiscript: various changes to the interpreter to facilitate
+	multiscript support.
+	[1e54353fd486]
+
+2009-01-02  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-result.h:
+	Multiscript: added keep status evaluation to result object.
+	[70b008a20600]
+
+	* src/lib-sieve-tool/mail-raw.c, src/lib-sieve-tool/mail-raw.h, src
+	/lib-sieve-tool/sieve-tool.c, src/lib-sieve-tool/sieve-tool.h, src
+	/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-if.c, src/lib-sieve/cmd-
+	keep.c, src/lib-sieve/cmd-redirect.c, src/lib-sieve/cmd-require.c,
+	src/lib-sieve/cmd-stop.c, src/lib-sieve/cmp-i-ascii-casemap.c, src
+	/lib-sieve/cmp-i-octet.c, src/lib-sieve/ext-encoded-character.c, src
+	/lib-sieve/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/ext-reject.c, src/lib-sieve/mcht-contains.c, src/lib-sieve
+	/mcht-is.c, src/lib-sieve/mcht-matches.c, src/lib-sieve/plugins/body
+	/ext-body-common.c, src/lib-sieve/plugins/body/ext-body-common.h,
+	src/lib-sieve/plugins/body/ext-body.c, src/lib-sieve/plugins/body
+	/tst-body.c, src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-
+	cmp-i-ascii-numeric.c, src/lib-sieve/plugins/copy/ext-copy.c, src
+	/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ext-enotify-limits.h, src/lib-
+	sieve/plugins/enotify/ext-enotify.c, src/lib-sieve/plugins/enotify
+	/ntfy-mailto.c, src/lib-sieve/plugins/enotify/sieve-ext-enotify.h,
+	src/lib-sieve/plugins/enotify/tst-notify-method-capability.c, src
+	/lib-sieve/plugins/enotify/tst-valid-notify-method.c, src/lib-
+	sieve/plugins/enotify/vmodf-encodeurl.c, src/lib-
+	sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/imapflags
+	/tst-hasflag.c, src/lib-sieve/plugins/include/cmd-import.c, src/lib-
+	sieve/plugins/include/cmd-include.c, src/lib-sieve/plugins/include
+	/cmd-return.c, src/lib-sieve/plugins/include/ext-include-binary.c,
+	src/lib-sieve/plugins/include/ext-include-binary.h, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include-limits.h, src/lib-
+	sieve/plugins/include/ext-include-variables.c, src/lib-
+	sieve/plugins/include/ext-include-variables.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/plugins/regex
+	/ext-regex-common.c, src/lib-sieve/plugins/regex/ext-regex-common.h,
+	src/lib-sieve/plugins/regex/ext-regex.c, src/lib-sieve/plugins/regex
+	/mcht-regex.c, src/lib-sieve/plugins/relational/ext-relational-
+	common.c, src/lib-sieve/plugins/relational/ext-relational-common.h,
+	src/lib-sieve/plugins/relational/ext-relational.c, src/lib-
+	sieve/plugins/relational/mcht-count.c, src/lib-
+	sieve/plugins/relational/mcht-value.c, src/lib-
+	sieve/plugins/subaddress/ext-subaddress.c, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/lib-
+	sieve/plugins/vacation/ext-vacation-common.h, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-arguments.c, src/lib-sieve/plugins/variables/ext-
+	variables-arguments.h, src/lib-sieve/plugins/variables/ext-
+	variables-common.c, src/lib-sieve/plugins/variables/ext-variables-
+	common.h, src/lib-sieve/plugins/variables/ext-variables-dump.c, src
+	/lib-sieve/plugins/variables/ext-variables-dump.h, src/lib-
+	sieve/plugins/variables/ext-variables-limits.h, src/lib-
+	sieve/plugins/variables/ext-variables-modifiers.c, src/lib-
+	sieve/plugins/variables/ext-variables-modifiers.h, src/lib-
+	sieve/plugins/variables/ext-variables-name.c, src/lib-
+	sieve/plugins/variables/ext-variables-name.h, src/lib-
+	sieve/plugins/variables/ext-variables-operands.c, src/lib-
+	sieve/plugins/variables/ext-variables-operands.h, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h, src/lib-
+	sieve/plugins/variables/tst-string.c, src/lib-sieve/rfc2822.c, src
+	/lib-sieve/rfc2822.h, src/lib-sieve/sieve-actions.c, src/lib-sieve
+	/sieve-actions.h, src/lib-sieve/sieve-address-parts.c, src/lib-sieve
+	/sieve-address-parts.h, src/lib-sieve/sieve-address.c, src/lib-sieve
+	/sieve-address.h, src/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-
+	ast.h, src/lib-sieve/sieve-binary-dumper.c, src/lib-sieve/sieve-
+	binary-dumper.h, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-
+	binary.h, src/lib-sieve/sieve-code-dumper.c, src/lib-sieve/sieve-
+	code-dumper.h, src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-
+	code.h, src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-
+	commands.h, src/lib-sieve/sieve-common.h, src/lib-sieve/sieve-
+	comparators.c, src/lib-sieve/sieve-comparators.h, src/lib-sieve
+	/sieve-config.h, src/lib-sieve/sieve-dump.h, src/lib-sieve/sieve-
+	error-private.h, src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-
+	error.h, src/lib-sieve/sieve-extensions.c, src/lib-sieve/sieve-
+	extensions.h, src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-
+	generator.h, src/lib-sieve/sieve-interpreter.c, src/lib-sieve/sieve-
+	interpreter.h, src/lib-sieve/sieve-lexer.c, src/lib-sieve/sieve-
+	lexer.h, src/lib-sieve/sieve-limits.c, src/lib-sieve/sieve-limits.h,
+	src/lib-sieve/sieve-match-types.c, src/lib-sieve/sieve-match-
+	types.h, src/lib-sieve/sieve-match.c, src/lib-sieve/sieve-match.h,
+	src/lib-sieve/sieve-message.c, src/lib-sieve/sieve-message.h, src
+	/lib-sieve/sieve-objects.c, src/lib-sieve/sieve-objects.h, src/lib-
+	sieve/sieve-parser.c, src/lib-sieve/sieve-parser.h, src/lib-sieve
+	/sieve-result.c, src/lib-sieve/sieve-result.h, src/lib-sieve/sieve-
+	script-private.h, src/lib-sieve/sieve-script.c, src/lib-sieve/sieve-
+	script.h, src/lib-sieve/sieve-types.h, src/lib-sieve/sieve-
+	validator.c, src/lib-sieve/sieve-validator.h, src/lib-sieve/sieve.c,
+	src/lib-sieve/sieve.h, src/lib-sieve/tst-address.c, src/lib-sieve
+	/tst-allof.c, src/lib-sieve/tst-anyof.c, src/lib-sieve/tst-exists.c,
+	src/lib-sieve/tst-header.c, src/lib-sieve/tst-not.c, src/lib-sieve
+	/tst-size.c, src/lib-sieve/tst-truefalse.c, src/plugins/lda-sieve
+	/lda-sieve-plugin.c, src/plugins/lda-sieve/lda-sieve-plugin.h, src
+	/sieve-tools/sieve-exec.c, src/sieve-tools/sieve-test.c, src/sieve-
+	tools/sievec.c, src/sieve-tools/sieved.c, src/testsuite/cmd-test-
+	fail.c, src/testsuite/cmd-test-result-print.c, src/testsuite/cmd-
+	test-set.c, src/testsuite/cmd-test.c, src/testsuite/ext-testsuite.c,
+	src/testsuite/testsuite-arguments.c, src/testsuite/testsuite-
+	arguments.h, src/testsuite/testsuite-common.c, src/testsuite
+	/testsuite-common.h, src/testsuite/testsuite-log.c, src/testsuite
+	/testsuite-log.h, src/testsuite/testsuite-objects.c, src/testsuite
+	/testsuite-objects.h, src/testsuite/testsuite-result.c,
+	src/testsuite/testsuite-result.h, src/testsuite/testsuite-script.c,
+	src/testsuite/testsuite-script.h, src/testsuite/testsuite-
+	substitutions.c, src/testsuite/testsuite-substitutions.h,
+	src/testsuite/testsuite.c, src/testsuite/tst-test-error.c,
+	src/testsuite/tst-test-result-execute.c, src/testsuite/tst-test-
+	result.c, src/testsuite/tst-test-script-compile.c, src/testsuite
+	/tst-test-script-run.c:
+	Updated copyright messages to 2009.
+	[9e7bde020990]
+
+	* src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-result.c, src
+	/lib-sieve/sieve-result.h, src/lib-sieve/sieve.c, src/testsuite
+	/testsuite-result.c, tests/multiscript/conflicts.svtest,
+	tests/multiscript/fileinto-frop.sieve, tests/multiscript/keep.sieve:
+	Testsuite: extended multiscript testing.
+	[fd189b1545ce]
+
+	* Makefile.am, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/testsuite/Makefile.am,
+	src/testsuite/cmd-test-result-print.c, src/testsuite/ext-
+	testsuite.c, src/testsuite/testsuite-common.h, src/testsuite
+	/testsuite-log.c, src/testsuite/testsuite-result.c, src/testsuite
+	/testsuite-result.h, src/testsuite/tst-test-result-execute.c,
+	src/testsuite/tst-test-script-compile.c, src/testsuite/tst-test-
+	script-run.c, tests/multiscript/basic.svtest,
+	tests/multiscript/conflicts.svtest, tests/multiscript/fileinto-
+	inbox.sieve, tests/multiscript/notify.sieve,
+	tests/multiscript/reject-1.sieve, tests/multiscript/reject-2.sieve,
+	tests/multiscript/vacation.sieve:
+	Testsuite: added multiscript tests and required support.
+	[55a8d5467bb7]
+
+	* src/lib-sieve/plugins/enotify/cmd-notify.c:
+	Enotify: removed conflicting action flag.
+	[507b4e15de60]
+
+	* src/testsuite/testsuite-log.c, src/testsuite/testsuite-log.h,
+	src/testsuite/testsuite-script.c, src/testsuite/testsuite-script.h:
+	Testsuite: forgot to add new files.
+	[706e67f38fe1]
+
+	* src/testsuite/Makefile.am, src/testsuite/testsuite-common.c,
+	src/testsuite/testsuite-result.c, src/testsuite/tst-test-error.c,
+	tests/extensions/enotify/basic.svtest:
+	Testsuite: split off script and error handler implementations into
+	separate modules.
+	[934cd4598d45]
+
+2009-01-01  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/enotify/cmd-notify.c:
+	Fixed warning caused by previous changes.
+	[b1878ff375d3]
+
+	* src/lib-sieve/ext-reject.c, src/lib-sieve/plugins/vacation/cmd-
+	vacation.c, src/lib-sieve/sieve-result.c:
+	Multiscript: resolved inter-script action conflict situations.
+	[cf3dacb0427f]
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-
+	result.c:
+	Cleaned up action interface.
+	[9aa51ae533c0]
+
+	* TODO, src/lib-sieve/cmd-keep.c, src/lib-sieve/sieve-actions.c, src
+	/lib-sieve/sieve-result.c, src/lib-sieve/sieve-result.h,
+	src/testsuite/tst-test-result.c, tests/execute/actions.svtest,
+	tests/extensions/vacation/execute.svtest:
+	Multiscript: adjusted result object for sequential execution.
+	[091473d12b22]
+
+2008-12-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Updated TODO.
+	[61bdad87a347]
+
+2008-12-28  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/vacation/cmd-vacation.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-result.c, src/testsuite/testsuite-
+	result.c, tests/execute/actions.svtest,
+	tests/extensions/imapflags/execute.svtest,
+	tests/extensions/reject/execute.svtest,
+	tests/extensions/vacation/execute.svtest:
+	Testsuite: added basic result execution tests for various
+	extensions.
+	[a3db8c51ef35]
+
+	* src/lib-sieve/sieve-result.h, src/testsuite/Makefile.am,
+	src/testsuite/ext-testsuite.c, src/testsuite/testsuite-common.c,
+	src/testsuite/testsuite-common.h, src/testsuite/testsuite-result.c,
+	src/testsuite/testsuite-result.h, src/testsuite/tst-test-result-
+	execute.c, tests/extensions/enotify/execute.svtest:
+	Testsuite: added support for executing results.
+	[7b6167bd595c]
+
+	* src/testsuite/tst-test-compile.c, src/testsuite/tst-test-execute.c,
+	src/testsuite/tst-test-script-compile.c, src/testsuite/tst-test-
+	script-run.c:
+	Testsuite: forgot committing rename in previous commit.
+	[f8e21027c484]
+
+	* src/testsuite/Makefile.am, src/testsuite/ext-testsuite.c,
+	src/testsuite/testsuite-common.c, src/testsuite/testsuite-common.h,
+	src/testsuite/tst-test-result.c, tests/compile/compile.svtest,
+	tests/compile/errors.svtest, tests/compile/examples.svtest,
+	tests/execute/actions.svtest, tests/execute/errors.svtest,
+	tests/extensions/enotify/errors.svtest,
+	tests/extensions/enotify/execute.svtest,
+	tests/extensions/imapflags/execute.svtest,
+	tests/extensions/include/errors.svtest,
+	tests/extensions/regex/errors.svtest,
+	tests/extensions/reject/execute.svtest,
+	tests/extensions/relational/errors.svtest,
+	tests/extensions/vacation/errors.svtest,
+	tests/extensions/vacation/execute.svtest,
+	tests/extensions/variables/errors.svtest, tests/testsuite.svtest:
+	Testsuite: renamed script compile and run commands to be more
+	intuitive.
+	[f52cf8c2e033]
+
+	* src/lib-sieve/sieve-code.c, src/testsuite/Makefile.am, src/testsuite
+	/ext-testsuite.c, src/testsuite/testsuite-arguments.c, src/testsuite
+	/testsuite-arguments.h, src/testsuite/testsuite-common.h,
+	src/testsuite/testsuite-substitutions.c, src/testsuite/testsuite-
+	substitutions.h, tests/testsuite.svtest:
+	Testsuite: started implementing support for testsuite-specific
+	string substitutions.
+	[93c9cf02290f]
+
+	* src/lib-sieve/plugins/variables/ext-variables-arguments.c, src/lib-
+	sieve/sieve-ast.c, src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-
+	commands.c, src/lib-sieve/sieve-commands.h:
+	Exported variable string argument into the Sieve engine itself as
+	'catenated string' (for similar use in other extensions like the
+	testsuite).
+	[0b0b3ab3967f]
+
+	* src/lib-sieve/plugins/variables/ext-variables-arguments.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/ext-variables-operands.c, src/lib-
+	sieve/plugins/variables/ext-variables-operands.h, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-code.c,
+	src/lib-sieve/sieve-code.h:
+	Exported variable string operand into the Sieve engine itself as
+	'catenated string' (for similar use in other extensions like the
+	testsuite).
+	[75d44b76a63e]
+
+	* TODO:
+	Updated TODO.
+	[4da90917e551]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: mailto: forgot to add 'from' header to list of reserved
+	headers.
+	[504ba37c919c]
+
+	* TODO:
+	Updated TODO list.
+	[da6447787785]
+
+	* Makefile.am, TODO, configure.in, dsieve-config.h.in, src/lib-
+	sieve/Makefile.am, src/lib-sieve/plugins/Makefile.am, src/lib-sieve
+	/sieve-extensions.c:
+	Enotify: added enotify extension to default compile.
+	[1a69b463d9ad]
+
+	* TODO, src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: mailto: enforced limits on number of recipients and
+	headers.
+	[78fdf4f59ff2]
+
+	* TODO, src/lib-sieve/plugins/enotify/ntfy-mailto.c,
+	tests/extensions/enotify/errors.svtest,
+	tests/extensions/enotify/errors/uri-mailto.sieve:
+	Enotify: mailto: finished URI parsing.
+	[30a272720d99]
+
+2008-12-27  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: mailto: fixed various bugs introduced by previous
+	enthousiastic commit.
+	[bfc6b485e5bc]
+
+	* TODO, src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: mailto: added check for duplicates of unique headers in the
+	mailto URI.
+	[92b60e522c1e]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: previous change did not distinguish Cc recipients.
+	[4eded3dc6a8a]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: added check for duplicate recipients within URI.
+	[453e9f5ab425]
+
+	* TODO:
+	Updated TODO.
+	[6b666e5ef348]
+
+	* src/lib-sieve/plugins/enotify/ext-enotify-common.c:
+	Enotify: added FIXME.
+	[ee257412d8ba]
+
+	* src/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/sieve-ext-enotify.h:
+	Enotify: added runtime support for options and performed some minor
+	cleanups.
+	[08b6a2984d57]
+
+	* TODO, src/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/sieve-ext-enotify.h, tests/extensions/enotify/errors.svtest,
+	tests/extensions/enotify/errors/options.sieve:
+	Enotify: added parsing support for the :options argument.
+	[e7c9fab2e100]
+
+	* src/lib-sieve/sieve-extensions.c:
+	Fixed semantic bug in extension handling.
+	[e806506c8e7c]
+
+	* src/lib-sieve/sieve-extensions.c:
+	Fixed segfault bug in extension handling.
+	[f7666442e384]
+
+	* src/lib-sieve/ext-reject.c, src/lib-sieve/plugins/enotify/ntfy-
+	mailto.c, src/lib-sieve/plugins/vacation/cmd-vacation.c, src/lib-
+	sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h, src/lib-sieve
+	/sieve-message.c, src/lib-sieve/sieve-message.h:
+	Moved new_message_id function to sieve-message.c where it is more
+	appropriate.
+	[acf8bc97e74c]
+
+	* README, src/lib-sieve/plugins/enotify/ext-enotify.c:
+	Updated documentation.
+	[b577aab39b21]
+
+2008-12-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Updated TODO.
+	[7de9c6687512]
+
+	* Makefile.am, TODO, src/lib-sieve/plugins/enotify/ext-enotify-
+	common.c, src/lib-sieve/plugins/enotify/ext-enotify-common.h, src
+	/lib-sieve/plugins/enotify/ntfy-mailto.c, src/lib-
+	sieve/plugins/enotify/sieve-ext-enotify.h, src/lib-
+	sieve/plugins/enotify/tst-notify-method-capability.c,
+	tests/extensions/enotify/notify_method_capability.svtest,
+	tests/extensions/enotify/valid-notify-method.svtest,
+	tests/extensions/enotify/valid_notify_method.svtest:
+	Enotify: implemented notify_method_capability test.
+	[33c97930469f]
+
+	* TODO, src/lib-sieve/plugins/enotify/ext-enotify-common.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/tst-valid-notify-method.c, tests/extensions/enotify/errors.svtest,
+	tests/extensions/enotify/errors/uri-mailto.sieve,
+	tests/extensions/enotify/errors/uri.sieve,
+	tests/extensions/enotify/errors/url-mailto.sieve,
+	tests/extensions/enotify/errors/url.sieve, tests/extensions/enotify
+	/valid-notify-method.svtest:
+	Enotify: implemented the valid_notify_method test.
+	[c504a425e11d]
+
+	* src/lib-sieve/ext-encoded-character.c, src/lib-sieve/ext-envelope.c,
+	src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/ext-body.c, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/ext-cmp-i-ascii-numeric.c, src/lib-sieve/plugins/copy
+	/ext-copy.c, src/lib-sieve/plugins/enotify/ext-enotify-common.c, src
+	/lib-sieve/plugins/enotify/ext-enotify.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/plugins/regex
+	/ext-regex.c, src/lib-sieve/plugins/relational/ext-relational.c, src
+	/lib-sieve/plugins/subaddress/ext-subaddress.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-dump.c, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-
+	binary-dumper.c, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-
+	code-dumper.c, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-extensions.c, src/lib-sieve/sieve-extensions.h, src/lib-sieve
+	/sieve-generator.c, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/sieve-match-types.c, src/lib-sieve/sieve-message.c, src/lib-sieve
+	/sieve-result.c, src/lib-sieve/sieve-validator.c, src/testsuite/ext-
+	testsuite.c:
+	Simplified handling of extension ids.
+	[91a1ac721a68]
+
+	* src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-
+	numeric.c, src/lib-sieve/plugins/copy/ext-copy.c, src/lib-
+	sieve/plugins/enotify/vmodf-encodeurl.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/regex
+	/ext-regex-common.c, src/lib-sieve/plugins/relational/ext-
+	relational-common.c, src/lib-sieve/plugins/subaddress/ext-
+	subaddress.c, src/lib-sieve/plugins/variables/ext-variables-
+	modifiers.c, src/lib-sieve/sieve-address-parts.c, src/lib-sieve
+	/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-
+	common.h, src/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-
+	extensions.h, src/lib-sieve/sieve-match-types.c, src/lib-sieve
+	/sieve-objects.c, src/testsuite/testsuite-objects.c, src/testsuite
+	/testsuite-objects.h:
+	Renamed extension object registry.
+	[0d7c3b514b9d]
+
+2008-12-21  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Merged concurrent changes.
+	[6e22db2771a9]
+
+	* TODO, doc/man/sieve-test.1, doc/man/sievec.1, src/lib-sieve-tool
+	/sieve-tool.c, src/lib-sieve/sieve-extensions.c, src/lib-sieve
+	/sieve-extensions.h, src/lib-sieve/sieve.c, src/lib-sieve/sieve.h,
+	src/plugins/lda-sieve/lda-sieve-plugin.c, src/sieve-tools/sieve-
+	test.c, src/sieve-tools/sievec.c:
+	Implemented support for configuring the available extensions.
+	[fb0ba83175f5]
+
+	* src/lib-sieve/plugins/vacation/cmd-vacation.c:
+	Vacation: changed location of X-Sieve header.
+	[0760764e19ce]
+
+	* src/lib-sieve/plugins/vacation/cmd-vacation.c:
+	Vacation: last change used wrong address.
+	[481a04fbfa9c]
+
+	* src/lib-sieve/plugins/vacation/cmd-vacation.c:
+	Vacation: properly implemented use of :from address argument.
+	[51b40d48e6ea]
+
+	* src/lib-sieve/sieve-address.c:
+	Fixed accidental paste in sieve-address.c.
+	[baab6e581455]
+
+	* TODO, src/lib-sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve
+	/sieve-address.c, src/lib-sieve/sieve-address.h,
+	tests/extensions/enotify/errors.svtest,
+	tests/extensions/enotify/errors/url-mailto.sieve:
+	Enotify: added recipient verification and implemented proper To and
+	Cc header composition.
+	[05b5b209c013]
+
+	* tests/extensions/enotify/errors/from-mailto.sieve:
+	Enotify: forgot to add new file to the test suite.
+	[41cef5314a94]
+
+	* TODO, src/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/sieve-ext-enotify.h, tests/extensions/enotify/errors.svtest:
+	Enotify: implemented verification of the :from address.
+	[52ec54e6d86a]
+
+	* src/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/sieve-ext-enotify.h:
+	Enotify: made log struct name shorter.
+	[595a03fe94c5]
+
+	* src/lib-sieve/rfc2822.c:
+	Fixed compiler warning about signed char.
+	[e8f9a89974cd]
+
+	* src/lib-sieve/plugins/enotify/ext-enotify-common.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: corrected mailto URI error messages.
+	[3e4bb8701786]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: cleaned up URI error handling.
+	[543b25d99edf]
+
+	* src/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/sieve-ext-enotify.h, src/lib-sieve/sieve-actions.c, src/lib-sieve
+	/sieve-actions.h, src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-
+	error.h, src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-result.h,
+	src/lib-sieve/sieve-script.c, src/lib-sieve/sieve-script.h:
+	Enotify: shielded most of the method API from compiler internals.
+	[996e60017ae1]
+
+2008-12-20  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: added owner email to auto-submitted header.
+	[c2568b13b4c5]
+
+2008-12-19  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Updated TODO.
+	[4b85554381de]
+
+	* src/lib-sieve/sieve-lexer.c:
+	Small cosmetic changes to lexer sources.
+	[304d0952005f]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: mailto: excluded body 'header' in URI from the header field
+	body verification.
+	[675dcf5550b8]
+
+	* TODO, src/lib-sieve/plugins/enotify/ntfy-mailto.c, src/lib-
+	sieve/rfc2822.c, src/lib-sieve/rfc2822.h:
+	Enotify: mailto: implemented verification of (unstructured) header
+	field bodies and improved URI syntax checking.
+	[6993557e1579]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/lib-sieve/tst-exists.c:
+	Substituted mail_get_headers for mail_get_headers_utf8 for those
+	occasions where utf8 is of no concern.
+	[33ff0356a8d0]
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/plugins/copy/ext-copy.c,
+	src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h, src
+	/lib-sieve/sieve-result.c:
+	Improved result execution and prevented failure on store action on
+	dry run (with no specified namespace).
+	[85fbe163f73e]
+
+	* TODO, src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: avoided sending notifications on auto-submitted messages.
+	[03ba5acfb863]
+
+	* src/lib-sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-sieve/sieve-
+	extensions.c, src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-
+	validator.c:
+	Adapted to changes in the Dovecot API.
+	[e290c9a5b8d1]
+
+2008-12-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Merged concurrent changes.
+	[7c970d2e18c4]
+
+2008-12-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: mailto: added filtering of reserved headers.
+	[2dc8040cc0ca]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: changed notify message to match the latest draft
+	specification better (not yet compliant).
+	[78088c8352ee]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: now using new message composition functions.
+	[5105e03885bd]
+
+	* src/sieve-tools/sieve-exec.c:
+	Fixed message typo in sieve-exec tool.
+	[8aeef1355af5]
+
+	* src/lib-sieve/ext-reject.c, src/lib-sieve/rfc2822.c:
+	Reject: now using new message composition functions.
+	[2c8c7d6c51e0]
+
+	* configure.in:
+	Change to configure.in caused compile error.
+	[0285d0ef1b5a]
+
+	* configure.in:
+	Fixed bug in configure script that emitted Dovecot version in config
+	header in stead of Sieve version.
+	[33b8e83d57d0]
+
+	* src/lib-sieve/cmd-redirect.c:
+	Added X-Sieve header to redirected messages.
+	[073514b8b521]
+
+	* src/lib-sieve/plugins/vacation/cmd-vacation.c:
+	Vacation: now using new message composition functions.
+	[46f1c431076a]
+
+	* src/lib-sieve/rfc2822.c, src/lib-sieve/rfc2822.h:
+	Created basic internet mail message composition functionality.
+	[f6ae429a7256]
+
+	* Makefile.am, TODO, src/lib-sieve/plugins/enotify/ntfy-mailto.c, src
+	/lib-sieve/plugins/vacation/cmd-vacation.c, src/lib-sieve/rfc2822.c,
+	src/lib-sieve/rfc2822.h, tests/extensions/vacation/references.sieve,
+	tests/extensions/vacation/references.svtest:
+	Vacation: added support for properly updating references header.
+	[12399f096262]
+
+2008-12-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: implemented basic notify mailto: execution.
+	[71a3f5b90533]
+
+	* src/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/sieve-ext-enotify.h:
+	Enotify: implemented construction and printing of action object.
+	[ae144360043a]
+
+	* src/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/sieve-ext-enotify.h:
+	Enotify: implemented runtime part.
+	[84c05cf58119]
+
+2008-12-12  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: restructured mailto url parsing to use arrays for the
+	results.
+	[e02c5e441ca2]
+
+	* Makefile.am, src/lib-sieve/plugins/enotify/ntfy-mailto.c,
+	tests/extensions/enotify/errors.svtest,
+	tests/extensions/enotify/errors/url-mailto.sieve,
+	tests/extensions/enotify/errors/url.sieve:
+	Enotify: added verification of header field names in mailto url.
+	[9972da3b72b5]
+
+2008-12-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Updated TODO: listed what remains to be done for the enotify
+	extension and its mailto method.
+	[b502f54d24ea]
+
+	* doc/rfc/draft-ietf-sieve-notify-mailto-09.txt, doc/rfc/draft-ietf-
+	sieve-notify-mailto-10.txt:
+	Updated enotify:mailto draft RFC.
+	[a9992d1abeb1]
+
+2008-12-10  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/ext-reject.c:
+	Reject: improved message rejection log message.
+	[2758742b1a0f]
+
+2008-12-09  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/rfc2822.c, src/lib-sieve/rfc2822.h, src/lib-
+	sieve/sieve-commands.c, src/lib-sieve/sieve-commands.h, src/lib-
+	sieve/tst-address.c, src/lib-sieve/tst-exists.c, src/lib-sieve/tst-
+	header.c, tests/compile/warnings/invalid-headers.sieve:
+	Compiler now warns about syntactically invalid header field names.
+	[67f94b204982]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/sieve-commands.c, src/lib-
+	sieve/sieve-commands.h, src/lib-sieve/tst-truefalse.c:
+	Exported true and false commands to separate file.
+	[fae455ed3f25]
+
+2008-11-30  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-extensions.c:
+	Fixed bug in improved capability string composition.
+	[6f2f1b51ce19]
+
+	* src/lib-sieve/plugins/enotify/ext-enotify-limits.h, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: further developed URI parsing.
+	[e0f21b538123]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/rfc2822.c, src/lib-
+	sieve/rfc2822.h:
+	Added support for header verification.
+	[5661acb85286]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c,
+	tests/extensions/enotify/basic.svtest:
+	Enotify: implemented coarse mailto URI parsing.
+	[f7fba9671c6b]
+
+	* doc/rfc/draft-duerst-mailto-bis-05.txt:
+	Added new draft-bis version of mailto RFC to doc/rfc.
+	[cbecc1c67646]
+
+	* src/lib-sieve/sieve-extensions.c:
+	Activated unload handler for extensions.
+	[478f0bcdb6ff]
+
+	* src/lib-sieve/plugins/enotify/Makefile.am, src/lib-
+	sieve/plugins/enotify/cmd-notify.c, src/lib-sieve/plugins/enotify
+	/ext-enotify-common.c, src/lib-sieve/plugins/enotify/ext-enotify-
+	common.h, src/lib-sieve/plugins/enotify/ext-enotify-limits.h, src
+	/lib-sieve/plugins/enotify/ext-enotify.c, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/sieve-ext-enotify.h, tests/extensions/enotify/execute.svtest:
+	Enotify: implemented uri scheme verification.
+	[0572076ad26f]
+
+2008-11-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/ext-encoded-character.c, src/lib-sieve/ext-envelope.c,
+	src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/ext-body.c, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/ext-cmp-i-ascii-numeric.c, src/lib-sieve/plugins/copy
+	/ext-copy.c, src/lib-sieve/plugins/enotify/ext-enotify-common.c, src
+	/lib-sieve/plugins/enotify/ext-enotify.c, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/sieve-ext-enotify.h, src/lib-sieve/plugins/imapflags/ext-
+	imapflags.c, src/lib-sieve/plugins/include/ext-include.c, src/lib-
+	sieve/plugins/regex/ext-regex.c, src/lib-sieve/plugins/relational
+	/ext-relational.c, src/lib-sieve/plugins/subaddress/ext-
+	subaddress.c, src/lib-sieve/plugins/vacation/ext-vacation.c, src
+	/lib-sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-extensions.c, src/lib-sieve/sieve-extensions.h, src/lib-sieve
+	/sieve-match-types.c, src/testsuite/ext-testsuite.c:
+	Added unload method to extension object.
+	[27b8f617ddd9]
+
+2008-11-28  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Reprioritized TODO.
+	[cbe0a7182be8]
+
+2008-11-26  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.1.2 for changeset f01fe5f1e816
+	[ec695f863a30]
+
+	* .hgtags:
+	Added tag 0.1.1 for changeset e534276ecf10
+	[f01fe5f1e816] [0.1.2]
+
+	* NEWS, configure.in:
+	Released v0.1.2 for Dovecot v1.2.alpha4.
+	[3f1ca3de6312]
+
+	* src/lib-sieve/plugins/vacation/cmd-vacation.c:
+	Vacation: improved log message for discarded vacation response.
+	[346b7c072b0a]
+
+	* src/lib-sieve/sieve-result.c:
+	Fixed bug in the handling of context during result execution, which
+	resulted in broken redirect action.
+	[28e3144b79d1]
+
+2008-11-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* configure.in:
+	Released v0.1.1 for Dovecot v1.2.alpha4.
+	[e534276ecf10] [0.1.1]
+
+2008-11-24  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Updated NEWS file.
+	[4dfeda80d78d]
+
+2008-11-22  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/enotify/Makefile.am, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ext-enotify.c, src/lib-sieve/plugins/enotify
+	/ntfy-mailto.c, src/lib-sieve/sieve-address.c, src/lib-sieve/sieve-
+	address.h, src/lib-sieve/sieve-extensions.c, src/lib-sieve/sieve-
+	extensions.h, src/lib-sieve/sieve.c, src/lib-sieve/sieve.h:
+	Added registry for extension capabilities like the available notify
+	methods and adjusted the enotify extension accordingly.
+	[007bb75439a8]
+
+2008-11-21  Stephan Bosch  <stephan@rename-it.nl>
+
+	* doc/rfc/i-ascii-numeric.rfc2244.txt, src/lib-
+	sieve/plugins/comparator-i-ascii-numeric/rfc2244.txt:
+	Forgot to move RFC 2244 to proper place in doc/rfc.
+	[9605841f6f27]
+
+	* Makefile.am, doc/rfc/uri.rfc3986.txt, src/lib-sieve/plugins/enotify
+	/vmodf-encodeurl.c, tests/extensions/enotify/encodeurl.svtest:
+	Enotify: implemented :encodeurl variables modifier.
+	[68bae1330f0c]
+
+	* TODO:
+	Added TODO item.
+	[2ab9a8390108]
+
+	* src/lib-sieve-tool/mail-raw.c, src/lib-sieve-tool/sieve-tool.c, src
+	/lib-sieve/sieve-actions.c, src/sieve-tools/sieve-exec.c, src/sieve-
+	tools/sieve-test.c, src/testsuite/testsuite.c:
+	Adapted to changes in the mailbox_open() API.
+	[def28c3fc40c]
+
+2008-11-20  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am:
+	Merged concurrent changes.
+	[0cdeefe057f7]
+
+	* doc/rfc/mailto.rfc2368.txt, src/lib-
+	sieve/plugins/enotify/Makefile.am, src/lib-sieve/plugins/enotify
+	/cmd-notify.c, src/lib-sieve/plugins/enotify/ntfy-mailto.c, src/lib-
+	sieve/plugins/enotify/sieve-ext-enotify.h, src/lib-
+	sieve/plugins/enotify/vmodf-encodeurl.c:
+	Enotify: copied action implementation from old plugin.
+	[f4a1cf59f9ce]
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/plugins/lda-sieve/lda-
+	sieve-plugin.c:
+	Fixed error handling of actions that send mail.
+	[eb88535b1b04]
+
+2008-11-16  Stephan Bosch  <stephan@rename-it.nl>
+
+	* doc/rfc/draft-ietf-sieve-notify-mailto-09.txt:
+	Added notify mailto draft.
+	[c32f0e1a2ab1]
+
+	* src/lib-sieve/plugins/enotify/Makefile.am, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ext-enotify.c, src/lib-sieve/plugins/enotify
+	/vmodf-encodeurl.c, src/lib-sieve/plugins/variables/ext-variables-
+	common.c, src/lib-sieve/plugins/variables/ext-variables-common.h,
+	src/lib-sieve/plugins/variables/ext-variables-modifiers.c, src/lib-
+	sieve/plugins/variables/ext-variables-modifiers.h, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h,
+	tests/extensions/enotify/execute.svtest:
+	Enotify: finished skeleton by addin empty :encodeurl implementation.
+	[1468452b4a29]
+
+	* Makefile.am, tests/extensions/enotify/execute.svtest,
+	tests/extensions/enotify/execute/draft-rfc-ex1.sieve,
+	tests/extensions/enotify/execute/draft-rfc-ex2.sieve,
+	tests/extensions/enotify/execute/draft-rfc-ex3.sieve,
+	tests/extensions/enotify/execute/draft-rfc-ex5.sieve,
+	tests/extensions/enotify/execute/draft-rfc-ex6.sieve:
+	Testsuite: added draft RFC examples as execution tests.
+	[45464b463539]
+
+2008-11-20  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am, configure.in, src/lib-sieve/plugins/include/ext-
+	include-binary.c, src/lib-sieve/plugins/include/ext-include-
+	common.c, src/lib-sieve/plugins/include/ext-include.c, src/lib-sieve
+	/sieve-binary.c, src/lib-sieve/sieve-binary.h:
+	Enabled (optional) support for Valgrind in the testsuite and fixed a
+	few intricate bugs in the process.
+	[0d0571b7b81c]
+
+2008-11-19  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve-tool/sieve-tool.c:
+	Changed acquisition of usernames in sieve command line tools.
+	[4fcbcffe14c3]
+
+	* tests/header.svtest:
+	Testsuite: added test for header folding.
+	[bca59633ce16]
+
+	* src/lib-sieve-tool/mail-raw.c:
+	Fixed bug in mail_raw implementation: mail_namespaces_deinit() must
+	not be called explicitly for v1.2.
+	[d9a73ee95b2c]
+
+2008-11-17  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-actions.c:
+	Previous change did not compile.
+	[80aa797d9521]
+
+	* src/lib-sieve/sieve-actions.c:
+	Matched changes in Dovecot to properly handle/ignore the new mailbox
+	ACL support.
+	[0e7868a06c20]
+
+2008-11-15  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/ext-include-variables.c:
+	Merged concurrent changes.
+	[d999e9b1f138]
+
+	* src/lib-sieve/plugins/include/ext-include-variables.c:
+	Fixed small indentation error.
+	[dbef1b96761a]
+
+2008-11-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-script.c:
+	Fixed bug in handling of non-existent scripts.
+	[bb9602e98abb]
+
+	* NEWS:
+	Prepared NEWS file for next release.
+	[ce33eb8c29d3]
+
+	* INSTALL, README:
+	Slightly improved documentation.
+	[e957f2fc38ef]
+
+2008-11-15  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/ext-include-variables.c:
+	Include: fixed bug in import/export commands.
+	[49b0d4a70dab]
+
+2008-11-12  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/sieve-code.c, src
+	/lib-sieve/sieve-code.h, src/lib-sieve/sieve-validator.c:
+	Imap4flags: fixed bug in the handling of the internal variable.
+
+	Previously the final value of internal variable was for every store
+	action that didn't specify a :flags argument explicitly. This
+	results in out-of order assignment/removal of flags, e.g. also the
+	flags assigned keep actions that were executed before the
+	addflag/setflag command were modified.
+	[94ad1f1aa91b]
+
+	* TODO:
+	Updated TODO.
+	[56ddfa9b2d3b]
+
+	* README:
+	Removed man page issue from README file.
+	[b9a138e1a781]
+
+	* README:
+	Updated README.
+	[f4a59b2c82b2]
+
+	* Makefile.am, doc/man/sieve-test.1:
+	Created man page for the sieve-test command.
+	[f4c64a82078b]
+
+2008-11-11  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am, doc/man/sieved.1:
+	Created man page for the sieved command.
+	[837bc0ccab02]
+
+	* Makefile.am:
+	Enabled installation of man pages.
+	[6439050d232d]
+
+	* src/lib-sieve/Makefile.am:
+	Forgot to add new sieve-config.h to the distribution.
+	[9fa6336ed90c]
+
+	* doc/man/sievec.1:
+	Created (currently uninstalled) man page for the sievec command.
+	[95478625a6ce]
+
+	* Makefile.am:
+	Testsuite: fail with informative error if compiled against dovecot
+	headers only.
+	[4510184ed680]
+
+	* configure.in, src/Makefile.am:
+	Re-enabled support for compiling against Dovecot headers.
+	[36e00217bdd2]
+
+2008-11-10  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/enotify/Makefile.am, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ext-enotify.c, src/lib-sieve/plugins/enotify
+	/tst-notify-method-capability.c:
+	Enotify: added skeleton implementation of notify_method_capability
+	test.
+	[89259cdff750]
+
+2008-11-09  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/enotify/Makefile.am, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ext-enotify.c, src/lib-sieve/plugins/enotify
+	/tst-valid-notify-method.c, tests/extensions/enotify/basic.svtest:
+	Enotify: added skeleton implementation of valid_notify_method test.
+	[c9a597e248ab]
+
+2008-11-07  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am, src/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ext-enotify.c, src/lib-sieve/sieve-ast.c, src
+	/lib-sieve/sieve-ast.h, tests/extensions/enotify/basic.svtest:
+	Enotify: implemented skeleton for the notify command.
+	[a004b31bcc08]
+
+2008-11-02  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/sieve-extensions.c:
+	ENotify: activated empty implementation.
+	[63e099d7edf7]
+
+	* .hgignore, configure.in, dsieve-config.h.in, src/lib-
+	sieve/Makefile.am, src/lib-sieve/sieve-common.h, src/lib-sieve
+	/sieve-config.h, src/lib-sieve/sieve-types.h, src/lib-sieve/sieve.h:
+	Started using autoconf output.
+	[c5ff061ac5f4]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/cmd-keep.c, src/lib-sieve
+	/ext-fileinto.c, src/lib-sieve/sieve-actions.h:
+	Added UTF-8 to modified UTF-7 folder name conversion for
+	compatibility with IMAP.
+	[fc0395d50d04]
+
+	* .hgignore, src/sieve-tools/sieve-exec, src/sieve-tools/sieve-test,
+	src/sieve-tools/sievec, src/sieve-tools/sieved:
+	Accidentally added binaries for sieve tools.
+	[99b09b8a310a]
+
+2008-11-01  Stephan Bosch  <stephan@rename-it.nl>
+
+	* doc/rfc/draft-ietf-sieve-notify-12.txt, src/lib-
+	sieve/plugins/enotify/Makefile.am, src/lib-sieve/plugins/enotify
+	/cmd-notify.c, src/lib-sieve/plugins/enotify/ext-enotify-common.h,
+	src/lib-sieve/plugins/enotify/ext-enotify.c:
+	Enotify: built skeleton for the notify command.
+	[482517b70a32]
+
+	* README, TODO, configure.in, src/Makefile.am, src/lib-sieve-
+	tool/Makefile.am, src/lib-sieve-tool/mail-raw.c, src/lib-sieve-tool
+	/mail-raw.h, src/lib-sieve-tool/sieve-tool.c, src/lib-sieve-tool
+	/sieve-tool.h, src/lib-util/Makefile.am, src/lib-util/mail-raw.c,
+	src/lib-util/mail-raw.h, src/sieve-bin/Makefile.am, src/sieve-bin
+	/bin-common.c, src/sieve-bin/bin-common.h, src/sieve-bin/sieve-
+	exec.c, src/sieve-bin/sieve-test.c, src/sieve-bin/sievec.c, src
+	/sieve-bin/sieved.c, src/sieve-tools/Makefile.am, src/sieve-tools
+	/sieve-exec, src/sieve-tools/sieve-exec.c, src/sieve-tools/sieve-
+	test, src/sieve-tools/sieve-test.c, src/sieve-tools/sievec, src
+	/sieve-tools/sievec.c, src/sieve-tools/sieved, src/sieve-
+	tools/sieved.c, src/testsuite/Makefile.am,
+	src/testsuite/testsuite.c:
+	Removed code duplication between testsuite and commandline tools.
+	Also restructured source code of the tools.
+	[bf8ca24d25ef]
+
+2008-10-30  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/sieve-bin/Makefile.am, src/sieve-bin/namespaces.c, src/sieve-
+	bin/namespaces.h, src/sieve-bin/sieve-exec.c, src/sieve-bin/sieve-
+	test.c, src/testsuite/Makefile.am, src/testsuite/namespaces.c,
+	src/testsuite/namespaces.h, src/testsuite/testsuite-common.c,
+	src/testsuite/testsuite-objects.c, src/testsuite/testsuite.c:
+	Removed now obsolete namespaces.c/h from testsuite and commandline
+	tools.
+	[937eb9e8e043]
+
+	* src/sieve-bin/Makefile.am, src/sieve-bin/namespaces.c,
+	src/testsuite/Makefile.am, src/testsuite/namespaces.c:
+	Enabled all available mail storage types (those compiled in Dovecot)
+	for the commandline tools and the testsuite.
+	[3d96a883bda0]
+
+	* configure.in, src/Makefile.am, src/lib-util/Makefile.am, src/lib-
+	util/mail-raw.c, src/lib-util/mail-raw.h, src/sieve-bin/Makefile.am,
+	src/sieve-bin/bin-common.c, src/sieve-bin/mail-raw.c, src/sieve-bin
+	/mail-raw.h, src/sieve-bin/sieve-exec.c, src/sieve-bin/sieve-test.c,
+	src/testsuite/Makefile.am, src/testsuite/mail-raw.c, src/testsuite
+	/mail-raw.h, src/testsuite/testsuite-common.c:
+	Merged mail-raw implementations of sieve commandline tools and the
+	testsuite, thus removing duplicate code.
+	[7e82c26a38bd]
+
+	* src/lib-sieve/sieve.c, src/lib-sieve/sieve.h, src/plugins/lda-sieve
+	/lda-sieve-plugin.c, src/sieve-bin/bin-common.c:
+	Made lda plugin properly refer to the main script as 'main script'
+	and not the basename of the sieve file (which is of no interest to
+	the user for the main script).
+	[bc09d2616c36]
+
+	* src/lib-sieve/sieve-script.c, src/plugins/lda-sieve/lda-sieve-
+	plugin.c:
+	Improved logging of failed script load.
+	[32c0b5cc77af]
+
+2008-10-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-actions.c:
+	Now using folder name as specified by user in log messages in stead
+	of internal representation.
+	[5d6f65468c6d]
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Added mail_debug messages to plugin to find problems in the sieve
+	path specification more easily.
+	[91a3f25c3df5]
+
+	* TODO:
+	Added TODO item.
+	[747107b816dc]
+
+	* src/sieve-bin/sievec.c:
+	Command sievec -d always wrote to std out.
+	[e92ec8bbd16a]
+
+	* src/sieve-bin/bin-common.c, src/testsuite/testsuite.c:
+	Fixed missing mask argument in two open calls (bug found by Sergey
+	Ivanov).
+	[8dcba4f38a67]
+
+2008-10-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* configure.in, src/lib-sieve/plugins/Makefile.am, src/lib-
+	sieve/plugins/enotify/Makefile.am, src/lib-sieve/plugins/enotify
+	/ext-enotify.c:
+	Started development of enotify extension.
+	[85d6ef932c4f]
+
+2008-10-23  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.1.0 for changeset 065c12acdcc0
+	[b7d9c5e026b6]
+
+	* TODO, configure.in:
+	Released v0.1.0 for Dovecot v1.2.alpha3.
+	[065c12acdcc0] [0.1.0]
+
+	* AUTHORS, NEWS, README:
+	Minor revisions to the package documentation.
+	[9e487fec9dce]
+
+2008-10-22  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-types.h:
+	Fixed warning caused by mixup between mail_storage and
+	sieve_storage.
+	[aa3e90f621b1]
+
+	* src/lib-sieve/sieve-actions.c:
+	Improved execution of store action.
+	[2877fa93580c]
+
+2008-10-21  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-types.h,
+	src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Properly set storage_r in plugin function to prevent double errors.
+	[a679d84dff88]
+
+2008-10-20  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-result.c:
+	Prevented transaction context from becoming NULL in execution of
+	store action.
+	[2402b1499813]
+
+	* src/lib-sieve/sieve-result.c:
+	Fixed context handling bug in the result execution.
+	[a88276bff812]
+
+2008-10-19  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-validator.c, tests/compile/errors.svtest,
+	tests/compile/errors/typos.sieve:
+	Clarified errors occurring when colon is missing.
+	[3366b70ef4e3]
+
+	* src/lib-sieve/sieve-validator.c, tests/compile/errors.svtest:
+	Corrected error message.
+	[84dfe8d5a47a]
+
+	* README, src/lib-sieve/sieve-validator.c,
+	tests/compile/errors.svtest:
+	Clarified error messages for missing semicolon.
+	[b78529976e65]
+
+	* Makefile.am, src/lib-sieve/plugins/body/Makefile.am, src/lib-
+	sieve/plugins/body/body.sieve, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/Makefile.am, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/cmp-i-ascii-numeric.sieve, src/lib-
+	sieve/plugins/copy/Makefile.am, src/lib-
+	sieve/plugins/copy/copy.sieve, src/lib-
+	sieve/plugins/imapflags/Makefile.am, src/lib-
+	sieve/plugins/imapflags/imapflags-2.sieve, src/lib-
+	sieve/plugins/imapflags/imapflags-errors.sieve, src/lib-
+	sieve/plugins/imapflags/imapflags-implicit.sieve, src/lib-
+	sieve/plugins/imapflags/imapflags-variables.sieve, src/lib-
+	sieve/plugins/imapflags/imapflags.sieve, src/lib-
+	sieve/plugins/regex/Makefile.am, src/lib-
+	sieve/plugins/relational/Makefile.am, src/lib-
+	sieve/plugins/relational/relational.sieve, src/lib-
+	sieve/plugins/subaddress/Makefile.am, src/lib-
+	sieve/plugins/subaddress/subaddress.sieve, src/lib-
+	sieve/plugins/vacation/Makefile.am, src/lib-sieve/plugins/vacation
+	/vacation-errors.sieve, src/lib-
+	sieve/plugins/vacation/vacation.sieve, src/lib-
+	sieve/plugins/variables/Makefile.am, src/lib-sieve/plugins/variables
+	/variables-errors.sieve, src/lib-sieve/plugins/variables/variables-
+	match.sieve, src/lib-sieve/plugins/variables/variables-nspace.sieve,
+	src/lib-sieve/plugins/variables/variables-regex.sieve, src/lib-
+	sieve/plugins/variables/variables.sieve, src/testsuite/Makefile.am:
+	Repaired 'make dist' tarball output.
+	[28b57e7024b7]
+
+	* INSTALL, README, configure.in:
+	Revised README.
+	[dd3cdd379693]
+
+	* TODO, src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-result.h,
+	src/testsuite/Makefile.am, src/testsuite/ext-testsuite.c,
+	src/testsuite/testsuite-common.c, src/testsuite/testsuite-common.h,
+	src/testsuite/testsuite-result.c, src/testsuite/testsuite-result.h,
+	src/testsuite/tst-test-error.c, src/testsuite/tst-test-result.c,
+	tests/execute/actions.svtest, tests/execute/actions/fileinto.sieve,
+	tests/execute/actions/redirect.sieve,
+	tests/extensions/reject/execute.svtest,
+	tests/extensions/vacation/execute.svtest,
+	tests/extensions/vacation/execute/action.sieve:
+	Testsuite: added support for basic result checking.
+	[ff43885270f0]
+
+	* TODO, doc/rfc/RFC Controversy.txt, doc/rfc/RFC-questions.txt:
+	Reported RFC questions to the ietf-mta-filters mailinglist.
+	[c878efb32b9d]
+
+	* TODO, src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/regex/mcht-regex.c, src/lib-sieve/sieve-comparators.c,
+	tests/compile/errors.svtest, tests/compile/errors/unsupported.sieve:
+	Added explicit messages and tests for unsupported use of variables.
+	[6d1c5ca0d75c]
+
+2008-10-12  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Updated TODO.
+	[56dc772ca475]
+
+	* TODO, src/lib-sieve/plugins/variables/ext-variables-dump.c:
+	Fixed TODO: made sure main scope used in variables dumping is
+	unreferenced when code dumper is freed.
+	[58f57ad4f723]
+
+	* TODO:
+	Tested replacing cmusieve with sieve.
+	[3a82ec3361db]
+
+	* src/lib-sieve/sieve-binary.c:
+	Function t_str_new_const got moved to its proper place in Dovecot.
+	[7f5fc7f2e8cc]
+
+2008-10-11  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-code-dumper.c, src/lib-sieve/sieve-code-
+	dumper.h:
+	Added extension support to code dumper.
+	[59f5b7074e34]
+
+	* src/lib-sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/sieve-binary.c, src/lib-sieve/sieve-parser.c:
+	Removed/solved minor TODOs.
+	[f16ab5f94f51]
+
+	* TODO:
+	Merged concurrent changes.
+	[d061ae363863]
+
+	* TODO, src/lib-sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-binary.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/plugins/variables
+	/ext-variables-dump.c, src/lib-sieve/plugins/variables/sieve-ext-
+	variables.h:
+	Variables/Include: added support for dumping variables declared in
+	extension scopes.
+	[d514f5e3a5f4]
+
+2008-10-09  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/sieve-error.c:
+	Fixed amd64 logging segfault; turns out using same va_args in
+	multiple vprintf calls is not possible.
+	[139edcdd3820]
+
+2008-10-05  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-actions.c:
+	Added support for mailbox autocreate and autosubscribe.
+	[79da56ccfdc5]
+
+	* TODO, src/lib-sieve/cmd-keep.c, src/lib-sieve/cmd-redirect.c, src
+	/lib-sieve/plugins/include/ext-include-common.c, src/lib-sieve
+	/sieve-actions.c, src/lib-sieve/sieve-actions.h, src/lib-sieve
+	/sieve-interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-
+	sieve/sieve-result.c, src/lib-sieve/sieve-result.h, src/lib-sieve
+	/sieve-types.h, src/lib-sieve/sieve.c, src/lib-sieve/sieve.h,
+	src/plugins/lda-sieve/lda-sieve-plugin.c, src/sieve-bin/sieve-
+	exec.c, src/sieve-bin/sieve-test.c, src/testsuite/testsuite-
+	common.c, src/testsuite/testsuite.c:
+	Made plugin use tried_default_save indicator to prevent duplicate
+	error messages.
+	[f0a7278c5645]
+
+2008-10-04  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Updated TODO.
+	[0896583c34c1]
+
+2008-09-28  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/ext-variables-dump.c, src/lib-
+	sieve/plugins/variables/ext-variables-dump.h, src/lib-
+	sieve/plugins/variables/ext-variables-operands.c, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h, src/lib-sieve/sieve-
+	code-dumper.c, src/lib-sieve/sieve-code-dumper.h:
+	Variables: added identifier dump support for main scope.
+	[87841459a7ee]
+
+2008-09-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/Makefile.am, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/ext-variables-dump.c, src/lib-
+	sieve/plugins/variables/ext-variables-dump.h, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-code-
+	dumper.c, src/lib-sieve/sieve-code-dumper.h:
+	Variables: added dumptime context.
+	[7cd99ac6219f]
+
+2008-09-15  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Merged concurrent changes.
+	[f61d20c07954]
+
+2008-09-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Started NEWS file.
+	[32f5a1ed47c6]
+
+	* DESIGN, Makefile.am, doc/devel/DESIGN:
+	Moved design description to doc/devel directory.
+	[1673630bb79d]
+
+	* README, examples/elvey.sieve, examples/jerry.sieve,
+	examples/mjohnson.sieve, examples/mklose.sieve,
+	examples/relational.rfc5231.sieve, examples/rfc3028.sieve,
+	examples/sanjay.sieve, examples/sieve_examples.sieve,
+	examples/subaddress.rfc5233.sieve, examples/vacation.sieve,
+	examples/vivil.sieve, sieve/examples/elvey.sieve,
+	sieve/examples/jerry.sieve, sieve/examples/mjohnson.sieve,
+	sieve/examples/mklose.sieve,
+	sieve/examples/relational.rfc5231.sieve,
+	sieve/examples/rfc3028.sieve, sieve/examples/sanjay.sieve,
+	sieve/examples/sieve_examples.sieve,
+	sieve/examples/subaddress.rfc5233.sieve,
+	sieve/examples/vacation.sieve, sieve/examples/vivil.sieve,
+	sieve/tests/actions.sieve, sieve/tests/address-part.sieve,
+	sieve/tests/basic.sieve, sieve/tests/comparator.sieve, sieve/tests
+	/encoded-character.sieve, sieve/tests/envelope.sieve,
+	sieve/tests/extensions.sieve, sieve/tests/if.sieve, sieve/tests
+	/match-type.sieve, sieve/tests/matches.sieve,
+	sieve/tests/stop.sieve, sieve/tests/vacation.sieve,
+	tests/compile/examples.svtest:
+	Restructured Sieve example scripts.
+	[a1962f923e34]
+
+	* Makefile.am, sieve/tests/fileinto.sieve, sieve/tests/redirect.sieve,
+	tests/execute/actions.svtest, tests/execute/actions/fileinto.sieve,
+	tests/execute/actions/redirect.sieve,
+	tests/extensions/reject/execute.svtest:
+	Testsuite: added execution tests for core actions (to find
+	segfaults).
+	[a1dd8113e9d3]
+
+	* Makefile.am, sieve/tests/reject.sieve,
+	tests/extensions/reject/execute.svtest,
+	tests/extensions/reject/execute/basic.sieve:
+	Testsuite: added trivial reject action execution test.
+	[f319f06ede13]
+
+2008-09-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* sieve/errors/address-errors.sieve, sieve/errors/address-part-
+	errors.sieve, sieve/errors/encoded-character.sieve, sieve/errors
+	/envelope-errors.sieve, sieve/errors/header-errors.sieve,
+	sieve/errors/if-errors.sieve, sieve/errors/interesting.sieve,
+	sieve/errors/keep-errors.sieve, sieve/errors/out-address-
+	errors.sieve, sieve/errors/parse-errors.sieve, sieve/errors/require-
+	errors.sieve, sieve/errors/size-errors.sieve, sieve/errors/stop-
+	errors.sieve, sieve/errors/tag-errors.sieve,
+	tests/compile/errors.svtest, tests/compile/errors/out-address.sieve,
+	tests/compile/errors/tag.sieve:
+	Testsuite: added final existing error tests.
+	[08769a713018]
+
+	* README:
+	Improved README to be more readable.
+	[e6c4a1fdfb42]
+
+2008-09-12  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-error.c:
+	Removed useless PTR_OFFSET from logfile error handler
+	implementation.
+	[6f8a49489e5e]
+
+	* TODO:
+	Added pre-release TODO item.
+	[4b4ef898598d]
+
+	* TODO, src/lib-sieve/cmd-redirect.c, src/lib-sieve/cmd-require.c, src
+	/lib-sieve/ext-encoded-character.c, src/lib-sieve/ext-envelope.c,
+	src/lib-sieve/plugins/body/tst-body.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/include/cmd-import.c, src/lib-sieve/plugins/include
+	/cmd-include.c, src/lib-sieve/plugins/regex/mcht-regex.c, src/lib-
+	sieve/plugins/relational/ext-relational-common.c, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-arguments.c, src/lib-sieve/sieve-commands.h, src/lib-
+	sieve/sieve-comparators.c, src/lib-sieve/sieve-match-types.c, src
+	/lib-sieve/sieve-match-types.h, src/lib-sieve/sieve-validator.c, src
+	/lib-sieve/tst-address.c, src/lib-sieve/tst-size.c, src/testsuite
+	/testsuite-objects.c:
+	Improved argument error reporting.
+	[ad5905fa16bc]
+
+	* src/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-ast.h, src/lib-sieve
+	/sieve-commands.h, src/lib-sieve/sieve-generator.c, src/lib-sieve
+	/sieve-generator.h, src/lib-sieve/sieve-validator.c, src/lib-sieve
+	/sieve-validator.h:
+	Restructured error reporting in validator and code generator.
+	[d54dfe15ad5f]
+
+	* src/lib-sieve/plugins/vacation/cmd-vacation.c, src/lib-sieve/tst-
+	size.c, src/testsuite/tst-test-error.c:
+	Fixed new ia64 warnings.
+	[191eabe91f70]
+
+	* src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h:
+	Fixed new ia64 warnings in sieve-code.
+	[bc8e86291ec7]
+
+	* src/lib-sieve/sieve-code.h:
+	Fixed new ia64 warnings in sieve-code.
+	[f655f4d28eb2]
+
+	* src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h:
+	Fixed ia64 warnings in sieve-code.
+	[4f2b18823f75]
+
+	* src/lib-sieve/plugins/variables/ext-variables-arguments.c:
+	Variables: fixed ia64 compiler warnings.
+	[04859d48e9f6]
+
+	* src/lib-sieve/sieve-error.c:
+	Forgot to handle return value of o_stream_send in logfile error
+	hander implementation.
+	[50f6194d644e]
+
+	* src/lib-sieve/sieve-error.c:
+	Forgot O_TRUNC in logfile error handler's second logfile open()
+	call.
+	[9f7e64968d61]
+
+	* src/lib-sieve/plugins/include/cmd-import.c:
+	Include: improved trace verbosity for import command.
+	[6618ab99e32a]
+
+	* src/lib-sieve/plugins/include/cmd-import.c, src/lib-
+	sieve/plugins/include/cmd-include.c, src/lib-sieve/plugins/include
+	/ext-include-binary.c, src/lib-sieve/plugins/include/ext-include-
+	variables.c, src/lib-sieve/plugins/variables/ext-variables-common.c,
+	src/lib-sieve/plugins/variables/ext-variables-modifiers.c, src/lib-
+	sieve/plugins/variables/ext-variables-operands.c, src/lib-sieve
+	/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-
+	code-dumper.c, src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-
+	code.h, src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-
+	interpreter.c:
+	Hopefully resolved various type cast warnings surfacing on ia_64 and
+	not on i386.
+	[0e9312deb8ea]
+
+	* tests/address.svtest:
+	Testsuite: added address test case for specific strange situation.
+	[5bc7b863ba0b]
+
+	* src/lib-sieve/plugins/relational/mcht-count.c:
+	Relational: fixed portability issue in count match type (warning).
+	[910812bf8e80]
+
+2008-09-10  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README:
+	Updated documentation.
+	[11408405fac3]
+
+	* TODO, src/lib-sieve/sieve-error.c:
+	Devised simple log rotation to prevent per-user sieve processing
+	logs to grow indefinitely.
+	[9d42eeb8ce8f]
+
+2008-09-09  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Updated TODO list.
+	[a589169c1870]
+
+	* TODO, src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-envelope.c,
+	src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/mcht-is.c, src/lib-sieve/plugins/body/tst-body.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/imapflags
+	/tst-hasflag.c, src/lib-sieve/plugins/include/cmd-include.c, src
+	/lib-sieve/plugins/vacation/cmd-vacation.c, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-common.c, src/lib-sieve/plugins/variables/ext-
+	variables-modifiers.c, src/lib-sieve/plugins/variables/ext-
+	variables-operands.c, src/lib-sieve/plugins/variables/tst-string.c,
+	src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-code-
+	dumper.c, src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h,
+	src/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-match-
+	types.c, src/lib-sieve/tst-address.c, src/lib-sieve/tst-exists.c,
+	src/lib-sieve/tst-header.c, src/lib-sieve/tst-size.c, src/testsuite
+	/cmd-test-fail.c, src/testsuite/cmd-test-set.c, src/testsuite/cmd-
+	test.c, src/testsuite/testsuite-objects.c, src/testsuite/tst-test-
+	compile.c, src/testsuite/tst-test-error.c:
+	Improved byte code dumping to be more readable.
+	[758155f2aab1]
+
+	* TODO:
+	Updated TODO file.
+	[b9341f8c801e]
+
+2008-09-07  Stephan Bosch  <stephan@rename-it.nl>
+
+	* INSTALL, README, TODO:
+	Updated documentation.
+	[6628c1731333]
+
+	* TODO:
+	Removed redundant security issue listed in TODO.
+	[05599a5b010b]
+
+	* Makefile.am, TODO, src/lib-sieve/mcht-is.c, src/lib-sieve/sieve-
+	address-parts.c, tests/address.svtest:
+	Resolved handling of invalid addresses in headers for the most part.
+	[0f3e2d8877e4]
+
+	* TODO, src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-operands.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h:
+	Variables: made sure broken/malicious binary cannot allocate
+	variable storage of arbitrary size.
+	[1ce135869da6]
+
+	* src/lib-sieve/plugins/include/ext-include.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c:
+	Variables: added coding of variable scope.
+	[511ac1c1864e]
+
+	* src/lib-sieve/ext-encoded-character.c, src/lib-sieve/ext-envelope.c,
+	src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/ext-body.c, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/ext-cmp-i-ascii-numeric.c, src/lib-sieve/plugins/copy
+	/ext-copy.c, src/lib-sieve/plugins/imapflags/ext-imapflags.c, src
+	/lib-sieve/plugins/include/ext-include.c, src/lib-
+	sieve/plugins/regex/ext-regex.c, src/lib-sieve/plugins/relational
+	/ext-relational.c, src/lib-sieve/plugins/subaddress/ext-
+	subaddress.c, src/lib-sieve/plugins/vacation/ext-vacation.c, src
+	/lib-sieve/plugins/variables/ext-variables-arguments.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-code-dumper.c, src/lib-sieve
+	/sieve-comparators.c, src/lib-sieve/sieve-extensions.c, src/lib-
+	sieve/sieve-extensions.h, src/lib-sieve/sieve-interpreter.c, src
+	/lib-sieve/sieve-match-types.c, src/testsuite/ext-testsuite.c:
+	Added support for per-script extension intialization.
+	[8ce3c35e05d7]
+
+2008-09-06  Stephan Bosch  <stephan@rename-it.nl>
+
+	* INSTALL, README:
+	Reduced the severity of the warning indicating the experimental
+	nature of this implementation.
+	[ceea4bd93458]
+
+	* TODO:
+	Updated TODO.
+	[a200a842fd4c]
+
+2008-08-31  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-code-dumper.c:
+	Minor cosmetic change to code dumping.
+	[75828a2293e0]
+
+	* src/lib-sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-sieve/sieve-
+	ast.c, src/lib-sieve/sieve-binary-dumper.c, src/lib-sieve/sieve-
+	code-dumper.c, src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve.c, src/testsuite/testsuite-
+	common.c, src/testsuite/testsuite.c:
+	Added the concept of a script code header to list the extensions
+	actually used by a script (was using all extensions listed in the
+	binary).
+	[7be9b0d97e5f]
+
+	* src/lib-sieve/cmd-require.c, src/lib-sieve/sieve-ast.c, src/lib-
+	sieve/sieve-ast.h, src/lib-sieve/sieve-generator.c, src/lib-sieve
+	/sieve-generator.h, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/sieve-validator.c:
+	Revised implementation of the require command.
+	[40c588255ef4]
+
+	* Makefile.am, TODO, src/lib-sieve/plugins/vacation/cmd-vacation.c,
+	tests/extensions/vacation/execute.svtest,
+	tests/extensions/vacation/execute/no-handle.sieve:
+	Vacation: properly implemented handling of variables vs. handle
+	generation.
+	[93fb21f7bc6b]
+
+	* tests/extensions/imapflags/execute.svtest,
+	tests/extensions/imapflags/execute/flags-side-effect.sieve:
+	Forgot to add niet testsuite files.
+	[aae56b7f1a47]
+
+	* src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h:
+	Added support for runtime detection of variable strings.
+	[6e1f1dcabba9]
+
+	* TODO:
+	Updated TODO.
+	[7741fd1718b8]
+
+	* Makefile.am, TODO, src/lib-sieve/cmd-keep.c, src/lib-
+	sieve/plugins/copy/ext-copy.c, src/lib-sieve/plugins/imapflags/tag-
+	flags.c, src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-
+	generator.c, src/lib-sieve/sieve-result.c:
+	Imapflags: properly implemented handling of duplicate store actions
+	with different :flags.
+	[3ac7e031ebd0]
+
+2008-08-30  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/cmd-redirect.c:
+	Fixed assertion triggered at the end when redirect was executed
+	before.
+	[3ac9261ad66f]
+
+	* src/sieve-bin/mail-raw.c, src/sieve-bin/mail-raw.h, src/sieve-bin
+	/sieve-exec.c, src/sieve-bin/sieve-test.c:
+	Incorporated changes in deliver into the mail-raw implementation of
+	the sieve tools.
+	[938996ab0023]
+
+2008-08-26  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/plugins/imapflags/ext-imapflags-common.c:
+	Imapflags: Added FIXME.
+	[fd1281ef5eef]
+
+	* TODO, src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-redirect.c, src
+	/lib-sieve/ext-reject.c, src/lib-sieve/plugins/vacation/cmd-
+	vacation.c, src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-
+	result.c, src/lib-sieve/sieve-result.h, tests/execute/errors.svtest,
+	tests/execute/errors/actions-limit.sieve, tests/execute/errors
+	/redirect-limit.sieve:
+	Implemented policy limit on the maximum number of redirect actions
+	in a result.
+	[c8524a9a370f]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/sieve-limits.c, src/lib-
+	sieve/sieve-limits.h, src/lib-sieve/sieve-result.c,
+	tests/execute/errors.svtest, tests/execute/errors/actions-
+	limit.sieve:
+	Implemented limit on the number of actions active simultaneously.
+	[a62a86f489d0]
+
+	* src/lib-sieve/plugins/variables/ext-variables-common.c,
+	tests/extensions/include/errors/action-conflicts.sieve,
+	tests/extensions/include/errors/included/action-fileinto.sieve,
+	tests/extensions/include/errors/included/action-reject.sieve,
+	tests/extensions/include/errors/runtime.sieve:
+	Include: fixed a stupid bug triggered when variables are not used.
+	[48079cfe53f7]
+
+	* tests/extensions/include/errors.svtest:
+	Testsuite: activated runtime tests for the include extension.
+	[73aa79ec006a]
+
+	* Makefile.am, tests/extensions/vacation/errors.svtest,
+	tests/extensions/vacation/errors/conflict-reject.sieve:
+	Testsuite: added runtime error tests for vacation extension.
+	[d32c37e395ce]
+
+	* Makefile.am, tests/execute/errors.svtest, tests/execute/errors
+	/action-conflicts.sieve, tests/execute/errors/conflict-reject-
+	fileinto.sieve, tests/execute/errors/conflict-reject-keep.sieve,
+	tests/execute/errors/conflict-reject-redirect.sieve:
+	Testsuite: added simple runtime action conflict tests.
+	[6bef60271972]
+
+	* doc/rfc/draft-ietf-sieve-refuse-reject-07.txt:
+	Installed refuse-reject draft RFC in doc/rfc directory.
+	[c608ef17a086]
+
+2008-08-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* sieve/errors/action-conflicts.sieve, sieve/errors/action-
+	duplicates.sieve, src/lib-sieve/sieve-interpreter.c,
+	src/testsuite/Makefile.am, src/testsuite/ext-testsuite.c,
+	src/testsuite/testsuite-common.c, src/testsuite/testsuite-common.h,
+	src/testsuite/testsuite.c, src/testsuite/tst-test-execute.c,
+	tests/execute/errors/action-conflicts.sieve, tests/execute/errors
+	/action-duplicates.sieve:
+	Testsuite: added support for testing runtime errors.
+	[e2a304290b53]
+
+	* TODO, src/lib-sieve/plugins/vacation/cmd-vacation.c, src/lib-sieve
+	/sieve-ast.c, src/lib-sieve/sieve-ast.h:
+	Vacation: discovered and partially fixed various RFC-related issues.
+	[97e0e14d9557]
+
+	* doc/rfc/vacation.rfc5230.txt, src/lib-sieve/plugins/vacation/draft-
+	ietf-sieve-vacation-07.txt, src/lib-sieve/plugins/vacation/ext-
+	vacation.c:
+	Installed new RFC for vacation extension in doc/rfc directory.
+	[df13b70a2cb1]
+
+	* TODO:
+	Updated TODO.
+	[a256cbead058]
+
+	* TODO, src/testsuite/cmd-test-fail.c, src/testsuite/cmd-test-set.c,
+	src/testsuite/cmd-test.c, src/testsuite/ext-testsuite.c,
+	src/testsuite/mail-raw.c, src/testsuite/mail-raw.h,
+	src/testsuite/namespaces.c, src/testsuite/namespaces.h,
+	src/testsuite/testsuite-common.c, src/testsuite/testsuite-common.h,
+	src/testsuite/testsuite-objects.c, src/testsuite/testsuite-
+	objects.h, src/testsuite/testsuite.c, src/testsuite/tst-test-
+	compile.c, src/testsuite/tst-test-error.c:
+	Finished code cleanup for now.
+	[a458a0b55c11]
+
+	* src/sieve-bin/bin-common.c, src/sieve-bin/bin-common.h, src/sieve-
+	bin/mail-raw.c, src/sieve-bin/mail-raw.h, src/sieve-
+	bin/namespaces.c, src/sieve-bin/namespaces.h, src/sieve-bin/sieve-
+	exec.c, src/sieve-bin/sieve-test.c, src/sieve-bin/sievec.c, src
+	/sieve-bin/sieved.c:
+	Cleaned up Sieve tools.
+	[ae09a094452c]
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c, src/plugins/lda-sieve/lda-
+	sieve-plugin.h:
+	Cleaned up LDA Sieve plugin.
+	[ed1ca951fd92]
+
+	* src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-arguments.c, src/lib-
+	sieve/plugins/variables/ext-variables-arguments.h, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/ext-variables-limits.h, src/lib-
+	sieve/plugins/variables/ext-variables-modifiers.c, src/lib-
+	sieve/plugins/variables/ext-variables-modifiers.h, src/lib-
+	sieve/plugins/variables/ext-variables-name.c, src/lib-
+	sieve/plugins/variables/ext-variables-name.h, src/lib-
+	sieve/plugins/variables/ext-variables-operands.c, src/lib-
+	sieve/plugins/variables/ext-variables-operands.h, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h, src/lib-
+	sieve/plugins/variables/tst-string.c:
+	Cleaned up variables extension.
+	[5a4e4e269892]
+
+	* src/lib-sieve/plugins/vacation/cmd-vacation.c:
+	Vacation: removed useless duplicate_mark call.
+	[569aaef1dd00]
+
+	* src/lib-sieve/plugins/vacation/cmd-vacation.c, src/lib-
+	sieve/plugins/vacation/ext-vacation-common.h, src/lib-
+	sieve/plugins/vacation/ext-vacation.c:
+	Cleaned up vacation extension.
+	[8df7a1bc6564]
+
+2008-08-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am, sieve/examples/subaddress.rfc5233.sieve, tests/address-
+	parts/subaddress.svtest, tests/compile/examples.svtest,
+	tests/extensions/subaddress/basic.svtest,
+	tests/extensions/subaddress/rfc.svtest:
+	Testsuite: extended tests for the subaddress extension.
+	[7f440b626914]
+
+2008-08-17  Stephan Bosch  <stephan@rename-it.nl>
+
+	* doc/rfc/subaddress.rfc5233.txt, src/lib-
+	sieve/plugins/subaddress/rfc3598.txt:
+	Installed new subaddress RFC in doc/rfc directory.
+	[5cb09b134086]
+
+	* src/lib-sieve/plugins/subaddress/ext-subaddress.c:
+	Cleaned up subaddress extension.
+	[ec5e1f9fda78]
+
+	* Makefile.am, sieve/examples/relational.rfc5231.sieve, tests/compile
+	/compile-examples.svtest, tests/compile/examples.svtest,
+	tests/extensions/relational/basic.svtest,
+	tests/extensions/relational/errors.svtest,
+	tests/extensions/relational/errors/validation.sieve,
+	tests/extensions/relational/rfc.svtest, tests/match-
+	types/relational.svtest:
+	Testsuite: restructured and extended tests for the relational
+	extension.
+	[17ee47e6d698]
+
+	* doc/rfc/relational.rfc5231.txt, src/lib-
+	sieve/plugins/relational/rfc3431.txt:
+	Installed new relational RFC in doc/rfc directory.
+	[6a1838d879d9]
+
+	* src/lib-sieve/plugins/relational/ext-relational-common.c, src/lib-
+	sieve/plugins/relational/ext-relational-common.h, src/lib-
+	sieve/plugins/relational/ext-relational.c, src/lib-
+	sieve/plugins/relational/mcht-count.c, src/lib-
+	sieve/plugins/relational/mcht-value.c:
+	Cleaned up relational extension.
+	[8fa1cca640b9]
+
+	* src/lib-sieve/plugins/regex/ext-regex-common.c, src/lib-
+	sieve/plugins/regex/ext-regex-common.h, src/lib-sieve/plugins/regex
+	/ext-regex.c, src/lib-sieve/plugins/regex/mcht-regex.c:
+	Cleaned up regex extension.
+	[930e79a89723]
+
+	* src/lib-sieve/plugins/include/cmd-import.c, src/lib-
+	sieve/plugins/include/cmd-include.c, src/lib-sieve/plugins/include
+	/cmd-return.c, src/lib-sieve/plugins/include/ext-include-binary.c,
+	src/lib-sieve/plugins/include/ext-include-binary.h, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include-limits.h, src/lib-
+	sieve/plugins/include/ext-include-variables.c, src/lib-
+	sieve/plugins/include/ext-include-variables.h, src/lib-
+	sieve/plugins/include/ext-include.c:
+	Cleaned up include extension.
+	[4f58be7cfde3]
+
+	* src/lib-sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/imapflags
+	/tst-hasflag.c:
+	Cleaned up imapflags extension.
+	[1dc6e9c11f50]
+
+	* src/lib-sieve/plugins/copy/ext-copy.c:
+	Cleaned up copy extension.
+	[1ae3233e93c0]
+
+	* src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-
+	numeric.c:
+	Cleaned up comparator-i;ascii-numeric.
+	[3bc2c679843b]
+
+2008-08-16  Stephan Bosch  <stephan@rename-it.nl>
+
+	* tests/extensions/body/match-values.svtest:
+	Forgot to add test file.
+	[31efedcb72a6]
+
+	* Makefile.am:
+	Testsuite: added test for the behavior of the body test with match
+	values.
+	[76c69d75e5bd]
+
+	* src/lib-sieve/plugins/body/ext-body-common.h, src/lib-
+	sieve/plugins/body/ext-body.c, src/lib-sieve/plugins/body/tst-
+	body.c, src/lib-sieve/sieve-match-types.c:
+	Body: now disables match value processing during body test
+	evaluation as required by RFC.
+	[43ed6da2c07d]
+
+	* src/lib-sieve/mcht-contains.c, src/lib-sieve/mcht-is.c, src/lib-
+	sieve/mcht-matches.c, src/lib-sieve/sieve-result.c, src/lib-sieve
+	/sieve-result.h, src/lib-sieve/sieve-script-private.h, src/lib-sieve
+	/sieve-script.c, src/lib-sieve/sieve-script.h, src/lib-sieve/sieve-
+	types.h, src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve-
+	validator.h:
+	Finished code cleanup of the sieve library itself.
+	[7041828c5bf4]
+
+	* src/lib-sieve/sieve-common.h, src/lib-sieve/sieve-dump.h, src/lib-
+	sieve/sieve-error-private.h, src/lib-sieve/sieve-error.c, src/lib-
+	sieve/sieve-error.h, src/lib-sieve/sieve-extensions.c, src/lib-sieve
+	/sieve-extensions.h, src/lib-sieve/sieve-generator.c, src/lib-sieve
+	/sieve-generator.h, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/sieve-interpreter.h, src/lib-sieve/sieve-limits.h, src/lib-sieve
+	/sieve-message.c, src/lib-sieve/sieve-message.h, src/lib-sieve
+	/sieve-objects.c, src/lib-sieve/sieve-objects.h:
+	Broad code cleanup.
+	[ce2750c32d73]
+
+	* src/lib-sieve/cmd-stop.c:
+	Forgot to add new file for stop command.
+	[85e220b27364]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/cmd-discard.c, src/lib-
+	sieve/cmd-if.c, src/lib-sieve/cmd-keep.c, src/lib-sieve/cmd-
+	redirect.c, src/lib-sieve/cmd-require.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/include/cmd-import.c, src/lib-sieve/plugins/variables
+	/tst-string.c, src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-
+	code-dumper.c, src/lib-sieve/sieve-commands-private.h, src/lib-sieve
+	/sieve-commands.c, src/lib-sieve/sieve-commands.h, src/lib-sieve
+	/sieve-generator.c, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/sieve-validator.c, src/lib-sieve/tst-address.c, src/lib-sieve/tst-
+	allof.c, src/lib-sieve/tst-anyof.c, src/lib-sieve/tst-exists.c, src
+	/lib-sieve/tst-header.c, src/lib-sieve/tst-not.c, src/lib-sieve/tst-
+	size.c, src/testsuite/cmd-test-fail.c, src/testsuite/cmd-test-set.c,
+	src/testsuite/cmd-test.c, src/testsuite/tst-test-compile.c,
+	src/testsuite/tst-test-error.c:
+	Cleaned up commands implementation.
+	[b91b56692665]
+
+	* src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h:
+	Cleaned up sieve-code.
+	[bbee4bf32b63]
+
+	* src/lib-sieve/sieve-binary-dumper.c, src/lib-sieve/sieve-binary-
+	dumper.h:
+	Cleaned up sieve-binary-dumper.
+	[08a3dc06bce3]
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h:
+	Cleaned up sieve-binary.
+	[22672ecf40c3]
+
+	* src/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-ast.h:
+	Cleaned up sieve-ast.
+	[00363cd89a2a]
+
+	* src/lib-sieve/sieve-address.c, src/lib-sieve/sieve-address.h:
+	Cleaned up sieve-address.
+	[cb7d1b1feb8d]
+
+	* src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h:
+	Cleaned up actions implementation.
+	[af5589339bd3]
+
+	* src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-address-
+	parts.h, src/lib-sieve/sieve-comparators.c:
+	Cleaned up address part and comparator implementation.
+	[dfc2d1398889]
+
+	* sieve/errors/match-type-errors.sieve, src/lib-sieve/ext-envelope.c,
+	src/lib-sieve/plugins/body/tst-body.c, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-sieve/plugins/regex
+	/mcht-regex.c, src/lib-sieve/plugins/variables/tst-string.c, src
+	/lib-sieve/sieve-comparators.h, src/lib-sieve/sieve-match-types.c,
+	src/lib-sieve/sieve-match-types.h, src/lib-sieve/tst-address.c, src
+	/lib-sieve/tst-header.c, src/testsuite/tst-test-error.c,
+	tests/compile/errors.svtest, tests/compile/errors/match-type.sieve:
+	Cleaned up match type implementation.
+	[945375c5c915]
+
+	* TODO, src/lib-sieve/plugins/regex/mcht-regex.c:
+	Regex: improvements and bugfixes.
+	[a6cf1195a291]
+
+	* Makefile.am, src/lib-sieve/plugins/regex/regex-errors.sieve,
+	tests/extensions/regex/basic.svtest,
+	tests/extensions/regex/errors.svtest,
+	tests/extensions/regex/errors/compile.sieve, tests/match-
+	types/regex.svtest:
+	Testsuite: restructured regex tests.
+	[8e7c02d55cf3]
+
+	* Makefile.am, doc/rfc/draft-murchison-sieve-regex-07.txt, src/lib-
+	sieve/plugins/regex/draft-murchison-sieve-regex-07.txt, src/lib-
+	sieve/plugins/regex/mcht-regex.c, src/lib-
+	sieve/plugins/regex/regex.sieve, src/lib-sieve/sieve-match-types.c,
+	tests/extensions/variables/regex.svtest, tests/match-
+	types/regex.svtest:
+	Regex: fixed a few minor bugs.
+	[560db263607a]
+
+2008-08-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/sieve-bin/mail-raw.c, src/sieve-bin/mail-raw.h, src/sieve-
+	bin/namespaces.c, src/sieve-bin/namespaces.h, src/sieve-bin/sieve-
+	exec.c, src/sieve-bin/sieve-test.c, src/testsuite/mail-raw.c,
+	src/testsuite/mail-raw.h, src/testsuite/namespaces.c,
+	src/testsuite/namespaces.h, src/testsuite/testsuite-common.c,
+	src/testsuite/testsuite-common.h, src/testsuite/testsuite.c:
+	Compile fix for changes in Dovecot.
+	[aa1a94658613]
+
+2008-08-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/plugins/include/cmd-import.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/variables/ext-variables-common.c,
+	tests/extensions/include/errors/runtime.sieve:
+	Include: implemented runtime checking of export/import.
+	[cbd74d26eff4]
+
+	* src/lib-sieve/plugins/include/cmd-import.c, src/lib-
+	sieve/plugins/include/cmd-include.c, src/lib-sieve/plugins/include
+	/ext-include-binary.c, src/lib-sieve/plugins/include/ext-include-
+	common.h, src/lib-sieve/plugins/include/ext-include-variables.c, src
+	/lib-sieve/plugins/include/ext-include-variables.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/sieve-ast.c, src
+	/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-validator.c,
+	tests/extensions/include/variables.svtest:
+	Include: transformed import and export to actual code operations for
+	runtime checking.
+	[d8002c76aabb]
+
+	* src/lib-sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h:
+	Variables: added functionality to obtain variable identifier from
+	storage using linked scope.
+	[504a89d17b2d]
+
+	* src/lib-sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-common.c, src/lib-sieve/plugins/variables/ext-
+	variables-operands.c, src/lib-sieve/plugins/variables/sieve-ext-
+	variables.h:
+	Variables: invalid variable indexes now trigger interpretation to
+	fail with EXEC_BIN_CORRUPT.
+	[7a03042a70ea]
+
+2008-08-12  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-binary.h, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c:
+	Include: variable indexes are now verified to the global variable
+	scope, meaning that a corrupt binary cannot allocate arbitrary
+	global variables anymore.
+	[d8b16b132509]
+
+	* src/lib-sieve/ext-encoded-character.c, src/lib-sieve/ext-envelope.c,
+	src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/ext-body.c, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/ext-cmp-i-ascii-numeric.c, src/lib-sieve/plugins/copy
+	/ext-copy.c, src/lib-sieve/plugins/imapflags/ext-imapflags.c, src
+	/lib-sieve/plugins/include/ext-include.c, src/lib-
+	sieve/plugins/regex/ext-regex.c, src/lib-sieve/plugins/relational
+	/ext-relational.c, src/lib-sieve/plugins/subaddress/ext-
+	subaddress.c, src/lib-sieve/plugins/vacation/ext-vacation.c, src
+	/lib-sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-extensions.c, src/lib-sieve/sieve-extensions.h, src/lib-sieve
+	/sieve-match-types.c, src/testsuite/ext-testsuite.c:
+	Removed obsoleted runtime_load() extension event.
+	[6f0b6cbd33c6]
+
+	* src/lib-sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-operands.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-sieve
+	/sieve-match-types.c:
+	Added run() event to the interpreter_extension object.
+	[878c2ad37f27]
+
+	* TODO:
+	Cleaned up TODO file.
+	[8ca8af945cec]
+
+	* TODO, doc/rfc/RFC Controversy.txt, src/lib-sieve/plugins/imapflags
+	/ext-imapflags-common.c, src/lib-sieve/plugins/include/ext-include-
+	variables.c, src/lib-sieve/plugins/variables/Makefile.am, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-arguments.c, src/lib-sieve/plugins/variables/ext-
+	variables-common.c, src/lib-sieve/plugins/variables/ext-variables-
+	limits.h, src/lib-sieve/plugins/variables/ext-variables-name.c, src
+	/lib-sieve/plugins/variables/ext-variables-operands.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h,
+	tests/extensions/variables/basic.svtest,
+	tests/extensions/variables/errors.svtest,
+	tests/extensions/variables/errors/limits.sieve:
+	Variables: implemented limits on number of variables in a scope, the
+	length of variable names, size of variable values and the number of
+	accesible match values.
+	[f23512858a52]
+
+	* TODO, src/lib-sieve/mcht-matches.c, src/lib-
+	sieve/plugins/include/Makefile.am, src/lib-sieve/plugins/regex/mcht-
+	regex.c, src/lib-sieve/sieve-limits.h, src/lib-sieve/sieve-match-
+	types.c:
+	Limited number of accepted match values
+	[31520dab90b8]
+
+	* src/lib-sieve/plugins/include/ext-include-limits.h:
+	Include: forgot to add new file to the repository.
+	[32e7a10e0c4e]
+
+	* TODO:
+	Merged concurrent changes.
+	[9a691e80df72]
+
+	* TODO, src/lib-sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-binary.h, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h:
+	Include: limited the number of included scripts.
+	[f01020cfcebb]
+
+	* src/lib-sieve/sieve-script.c, src/lib-sieve/sieve-script.h, src/lib-
+	sieve/sieve.c, src/lib-sieve/sieve.h, src/plugins/lda-sieve/lda-
+	sieve-plugin.c, src/sieve-bin/bin-common.c:
+	LDA-Plugin: prevented plugin from polluting the logfiles when the
+	script does not exist.
+	[5d70ae722bca]
+
+2008-08-11  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/cmd-include.c,
+	tests/extensions/include/errors.svtest,
+	tests/extensions/include/errors/generic.sieve:
+	Include: used wrong messaging function in previous commit.
+	[177bf38926ca]
+
+	* src/lib-sieve/plugins/include/cmd-include.c:
+	Include: prohibited use of '/' in scriptnames.
+	[88105cf833da]
+
+2008-08-10  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, tests/extensions/body/basic.svtest:
+	Body: discovered various issues (listed in disabled tests).
+	[66543e00dfba]
+
+	* src/lib-sieve/sieve-message.c, src/lib-sieve/sieve-message.h,
+	src/testsuite/cmd-test-set.c, src/testsuite/testsuite-common.c,
+	src/testsuite/testsuite-common.h, src/testsuite/testsuite-objects.c,
+	src/testsuite/testsuite-objects.h,
+	tests/extensions/body/basic.svtest:
+	Body: added test regarding empty bodies and fixed testsuite to flush
+	the message context when the message is changed.
+	[c6c5a7eb8e6e]
+
+	* src/lib-sieve/plugins/body/tst-body.c,
+	tests/extensions/body/basic.svtest:
+	Body: fixed default comparator and added testsuite test to prevent
+	this in the future.
+	[83bd74561800]
+
+	* Makefile.am, src/lib-sieve/plugins/body/ext-body-common.c, src/lib-
+	sieve/plugins/body/tst-body.c, tests/extensions/body/basic.svtest:
+	Body: fixed bug in the :raw transform, added much comment to the
+	body extraction code and added a first simple test to the testsuite.
+	[3153995e2bc7]
+
+	* src/lib-sieve/sieve-lexer.c, src/testsuite/mail-raw.c:
+	Made the lexer conform to the new Sieve RFC.
+	[0fae7796f624]
+
+	* doc/rfc/body.rfc5173.txt, src/lib-sieve/plugins/body/draft-ietf-
+	sieve-body-07.txt, src/lib-sieve/plugins/body/ext-body.c:
+	Installed RFC for the body extension in the doc/rfc directory.
+	[42dc34bb2dc2]
+
+	* TODO, src/lib-sieve/cmd-redirect.c, src/lib-sieve/cmd-require.c, src
+	/lib-sieve/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/ext-reject.c, src/lib-sieve/plugins/imapflags/ext-imapflags-
+	common.c, src/lib-sieve/plugins/imapflags/tag-flags.c, src/lib-
+	sieve/plugins/include/cmd-include.c, src/lib-sieve/plugins/include
+	/ext-include-common.c, src/lib-sieve/plugins/relational/ext-
+	relational-common.c, src/lib-sieve/plugins/vacation/cmd-vacation.c,
+	src/lib-sieve/plugins/variables/ext-variables-arguments.c, src/lib-
+	sieve/sieve-actions.c, src/lib-sieve/sieve-binary.c, src/lib-sieve
+	/sieve-comparators.c, src/lib-sieve/sieve-validator.c, src/lib-sieve
+	/sieve-validator.h, src/lib-sieve/tst-address.c:
+	Made sure error messages do not print large erroneous values.
+	[ea459c2b87c0]
+
+	* TODO, src/lib-sieve/sieve-parser.c, tests/compile/errors.svtest,
+	tests/compile/errors/parser.sieve:
+	Limited the depth of the AST and added tests to verify that it is
+	resolved gracefully.
+	[aa4d3069f079]
+
+2008-08-09  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-limits.h, src/lib-sieve/sieve-parser.c,
+	tests/compile/errors.svtest, tests/compile/errors/parser.sieve:
+	Limited number of command arguments.
+	[9a2fc3c9675d]
+
+	* src/lib-sieve/sieve-lexer.c:
+	Made lexer use the (i_*) ctype.h functions.
+	[51d06f8b3339]
+
+	* src/lib-sieve/sieve-lexer.c, src/lib-sieve/sieve-limits.h,
+	tests/compile/errors.svtest, tests/compile/errors/lexer.sieve:
+	Limited the length of identifiers.
+	[aaca552f0561]
+
+	* TODO, src/lib-sieve/Makefile.am, src/lib-sieve/cmd-redirect.c, src
+	/lib-sieve/sieve-address.c, src/lib-sieve/sieve-ast.c, src/lib-sieve
+	/sieve-ast.h, src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-
+	common.h, src/lib-sieve/sieve-lexer.c, src/lib-sieve/sieve-limits.h,
+	src/lib-sieve/sieve-parser.c, tests/compile/errors.svtest,
+	tests/compile/errors/lexer.sieve:
+	Enforced limits on string length and handled the finite nature of
+	integers for number parsing and the construction of the AST.
+	[317c332b2623]
+
+2008-08-06  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-variables.c:
+	Include: fixed bug in global variables referencing the main script.
+	[b1c1779b1d4b]
+
+2008-08-05  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-binary.h, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include-variables.c, src/lib-
+	sieve/plugins/include/ext-include-variables.h,
+	tests/extensions/include/variables.svtest:
+	Include: symbol table for global variables now also includes
+	locations for the first import/export of each known variable.
+	[ba3785f991b9]
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-binary.h, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h:
+	Include: included scripts are now referenced by an include_id in
+	stead of the binary block id.
+	[b67c51062eba]
+
+	* src/lib-sieve/sieve-interpreter.c, src/lib-sieve/sieve-validator.c:
+	Forgot to implement free() event for validator and interpreter
+	extensions.
+	[e1f834c53a3d]
+
+	* src/lib-sieve/plugins/include/cmd-import.c, src/lib-
+	sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-binary.h, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include-variables.c, src/lib-
+	sieve/plugins/include/ext-include-variables.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/plugins/variables
+	/ext-variables-common.c, src/lib-sieve/plugins/variables/sieve-ext-
+	variables.h, src/lib-sieve/sieve-binary-dumper.c, src/lib-sieve
+	/sieve-binary-dumper.h, src/lib-sieve/sieve-extensions.h, src/lib-
+	sieve/sieve-generator.c, src/testsuite/ext-testsuite.c,
+	tests/extensions/include/errors.svtest,
+	tests/extensions/include/errors/import-runtime.sieve,
+	tests/extensions/include/errors/variables.sieve:
+	Include: added symbol table to the binary for global variables.
+	[d9518ecfeb23]
+
+	* README, TODO:
+	Updated documentation.
+	[54897b07b2da]
+
+2008-08-03  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Minor TODO file revisions.
+	[472b4c6dde9e]
+
+	* Makefile.am, tests/match-types/regex.svtest:
+	Testsuite: added match values test for the :regex match
+	[35384a182b33]
+
+	* TODO, src/lib-sieve/mcht-matches.c, src/lib-sieve/plugins/include
+	/ext-include-common.c, src/lib-sieve/plugins/regex/mcht-regex.c, src
+	/lib-sieve/sieve-match-types.c, src/lib-sieve/sieve-match-types.h,
+	tests/extensions/variables/match.svtest, tests/match-
+	types/matches.svtest:
+	Fixed replacing match values only when a test succeeds.
+	[dd371558d0fb]
+
+	* src/lib-sieve/sieve-interpreter.c, src/lib-sieve/sieve-
+	interpreter.h, src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve-
+	validator.h:
+	Upgraded validator and interpreter extension support to provide
+	destruction notifications.
+	[0ec7042e1ce5]
+
+2008-08-02  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Include: found one issue.
+	[37f5ac342261]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/testsuite
+	/testsuite-common.c, src/testsuite/testsuite.c,
+	tests/extensions/include/errors.svtest,
+	tests/extensions/include/errors/circular-1.sieve,
+	tests/extensions/include/errors/circular-2.sieve,
+	tests/extensions/include/errors/circular-3.sieve,
+	tests/extensions/include/errors/included/circular-one.sieve,
+	tests/extensions/include/errors/included/circular-three-2.sieve,
+	tests/extensions/include/errors/included/circular-three-3.sieve,
+	tests/extensions/include/errors/included/circular-three.sieve,
+	tests/extensions/include/errors/included/circular-two-2.sieve,
+	tests/extensions/include/errors/included/circular-two.sieve,
+	tests/extensions/include/included/variables-included1.sieve,
+	tests/extensions/include/included/variables-included2.sieve,
+	tests/extensions/include/included/variables-included3.sieve,
+	tests/extensions/include/variables-included1.sieve,
+	tests/extensions/include/variables-included2.sieve,
+	tests/extensions/include/variables-included3.sieve:
+	Testsuite: added circular include tests.
+	[bfa2fb869c31]
+
+	* doc/rfc/draft-daboo-sieve-include-05.txt, src/lib-
+	sieve/plugins/include/Makefile.am, src/lib-sieve/plugins/include
+	/draft-daboo-sieve-include-05.txt, src/lib-sieve/plugins/include
+	/include-error.sieve, src/lib-sieve/plugins/include/include-
+	variables.sieve, src/lib-sieve/plugins/include/include-
+	variables1.sieve, src/lib-sieve/plugins/include/include-
+	variables2.sieve, src/lib-sieve/plugins/include/include-
+	variables3.sieve, src/lib-sieve/plugins/include/include.sieve, src
+	/lib-sieve/plugins/include/included1.sieve, src/lib-
+	sieve/plugins/include/included2.sieve, src/lib-
+	sieve/plugins/include/included3.sieve,
+	tests/extensions/include/errors.svtest,
+	tests/extensions/include/errors/generic.sieve:
+	Include: cleaned up source directory.
+	[525f4e7bd2ce]
+
+	* Makefile.am, src/lib-sieve/plugins/include/include-variables-
+	error.sieve, src/lib-sieve/plugins/include/include-variables-
+	error2.sieve, tests/extensions/include/errors.svtest,
+	tests/extensions/include/errors/variables-inactive.sieve,
+	tests/extensions/include/errors/variables.sieve:
+	Testsuite: added compile error tests for the include extension.
+	[7efaba3fb362]
+
+	* src/lib-sieve/plugins/copy/rfc3894.txt:
+	Copy: forgot to remove RFC from old location.
+	[4cd77c6931ad]
+
+	* doc/rfc/copy.rfc3894.txt:
+	Copy: moved RFC to doc/rfc directory.
+	[04dd13d1e194]
+
+	* doc/rfc/imap4flags.rfc5232.txt, src/lib-sieve/plugins/imapflags
+	/draft-ietf-sieve-imapflags-05.txt, src/lib-sieve/plugins/imapflags
+	/ext-imapflags.c:
+	Imapflags: updated specification to RFC 5232.
+	[f1f8c50c2d7e]
+
+	* TODO:
+	Imapflags: found one new issue.
+	[9f896bff4250]
+
+	* Makefile.am, src/lib-sieve/plugins/imapflags/ext-imapflags-common.c,
+	src/lib-sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-
+	sieve/plugins/variables/ext-variables-arguments.c, src/lib-sieve
+	/sieve-generator.c, tests/extensions/imapflags/hasflag.svtest,
+	tests/extensions/imapflags/rfc.svtest:
+	Imapflags: accidentally omitted support for multiple variables in
+	the hasflag test.
+	[b6602e8dd433]
+
+	* TODO, tests/extensions/variables/errors.svtest,
+	tests/extensions/variables/errors/set.sieve,
+	tests/extensions/variables/string.svtest:
+	Testsuite: added new tests for the variables extension.
+	[ff3d19af6da3]
+
+	* src/lib-sieve/sieve-lexer.c, src/lib-sieve/sieve-validator.c,
+	tests/compile/trivial.sieve,
+	tests/extensions/variables/errors.svtest:
+	Fixed various case-sensitivily-related issues.
+	[8d140a08e7d8]
+
+	* Makefile.am, src/lib-sieve/plugins/variables/ext-variables-
+	arguments.c, tests/extensions/variables/errors.svtest,
+	tests/extensions/variables/errors/namespace.sieve,
+	tests/extensions/variables/errors/set.sieve:
+	Variables: fixed various error handling issues.
+	[eb93d4e65fce]
+
+	* src/lib-sieve/sieve-address.c:
+	Fixed a warning.
+	[5e651fda205f]
+
+2008-08-01  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am, src/lib-sieve/Makefile.am, src/lib-
+	sieve/plugins/variables/Makefile.am, src/lib-sieve/plugins/variables
+	/ext-variables.c:
+	Fixed 'make dist' to produce a working tarball.
+	[39a595dbbde4]
+
+	* src/lib-sieve/mcht-matches.c, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/ext-cmp-i-ascii-numeric.c, tests/match-
+	types/contains.svtest, tests/match-types/is.svtest, tests/match-
+	types/matches.svtest, tests/match-types/relational.svtest:
+	Testsuite: added test regarding matching the empty string and fixed
+	an issue in the i;ascii-numeric comparator.
+	[4817eca9348a]
+
+	* Makefile.am, TODO, src/lib-sieve/mcht-contains.c, src/lib-sieve
+	/mcht-is.c, src/lib-sieve/mcht-matches.c, src/lib-
+	sieve/plugins/regex/mcht-regex.c, src/lib-sieve/plugins/relational
+	/mcht-count.c, src/lib-sieve/plugins/relational/mcht-value.c, src
+	/lib-sieve/plugins/variables/tst-string.c, src/lib-sieve/sieve-
+	match-types.h, src/lib-sieve/sieve-match.c,
+	tests/extensions/variables/string.svtest:
+	Variables: fixed :count issue for the string test.
+	[fc0444f14dd1]
+
+	* TODO, tests/extensions/variables/basic.svtest,
+	tests/extensions/variables/modifiers.svtest,
+	tests/extensions/variables/string.svtest:
+	Testsuite: added more tests for the variables extension and found
+	one issue.
+	[cd218e005c1e]
+
+	* Makefile.am, src/lib-sieve/ext-envelope.c, src/lib-sieve/tst-
+	address.c, src/lib-sieve/tst-header.c,
+	tests/extensions/variables/basic.svtest,
+	tests/extensions/variables/match.svtest,
+	tests/extensions/variables/modifiers.svtest, tests/match-
+	types/contains.svtest:
+	Testsuite: added RFC compliance tests for the variables extension
+	and fixed use of wrong default comparator.
+	[2246d563ad2d]
+
+	* src/lib-sieve/ext-encoded-character.c, src/lib-
+	sieve/plugins/variables/ext-variables-arguments.c, src/lib-sieve
+	/sieve-validator.c, tests/extensions/variables/quoting.svtest:
+	Fixed bug in the order of default argument processing. Variable
+	strings were evaluated befor constant strings, which is wrong.
+	[6fa43c9bac62]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/sieve-address.c,
+	tests/extensions/envelope.svtest:
+	Envelope: added more test and fixed source route parsing.
+	[568d3af73d04]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/sieve-address.c,
+	tests/extensions/envelope.svtest:
+	Envelope: fixed one bug in the path parsing (printfs active).
+	[fbae4e8724ad]
+
+2008-07-31  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, doc/rfc/RFC Controversy.txt, src/lib-sieve/ext-envelope.c, src
+	/lib-sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/subaddress/ext-subaddress.c, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-address-parts.h, src/lib-sieve
+	/sieve-address.c, src/lib-sieve/sieve-address.h, src/lib-sieve
+	/sieve-common.h, tests/extensions/envelope.svtest,
+	tests/testsuite.svtest:
+	Envelope: working towards proper RFC compliance of forward/return-
+	path parsing.
+	[0d6138082c33]
+
+2008-07-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/ext-variables-arguments.c,
+	tests/extensions/variables/basic.svtest:
+	Variables: fixed RFC compliance issue regarding failing validation
+	on unknown namespaces.
+	[336904483e84]
+
+	* src/lib-sieve/plugins/variables/ext-variables-arguments.c,
+	tests/extensions/variables/basic.svtest:
+	Variables: fixed bug in variables substitution (RFC example failed
+	during testing).
+	[ccbfb44d427c]
+
+	* src/lib-sieve/plugins/variables/ext-variables-common.c,
+	tests/extensions/variables/basic.svtest:
+	Variables: fixed very significant bug in the variable scope
+	implementation.
+	[225f7cfd99c0]
+
+	* src/lib-sieve/sieve-binary.h:
+	Removed superfluous include.
+	[29e9b491cadf]
+
+	* tests/extensions/variables/basic.svtest:
+	Testsuite: cleaned up basic varibles test case.
+	[b8ac459bccec]
+
+	* Makefile.am, configure.in, src/testsuite/Makefile.am,
+	src/testsuite/tests/address-parts/subaddress.svtest,
+	src/testsuite/tests/comparators/core.svtest,
+	src/testsuite/tests/compile/compile-examples.svtest,
+	src/testsuite/tests/compile/compile.svtest,
+	src/testsuite/tests/compile/errors.svtest,
+	src/testsuite/tests/compile/errors/address-part.sieve,
+	src/testsuite/tests/compile/errors/address.sieve,
+	src/testsuite/tests/compile/errors/encoded-character.sieve,
+	src/testsuite/tests/compile/errors/envelope.sieve,
+	src/testsuite/tests/compile/errors/header.sieve,
+	src/testsuite/tests/compile/errors/if.sieve,
+	src/testsuite/tests/compile/errors/keep.sieve,
+	src/testsuite/tests/compile/errors/require.sieve,
+	src/testsuite/tests/compile/errors/size.sieve,
+	src/testsuite/tests/compile/errors/stop.sieve,
+	src/testsuite/tests/compile/redirect.sieve,
+	src/testsuite/tests/compile/trivial.sieve, src/testsuite/tests
+	/control-structures.svtest, src/testsuite/tests/exists.svtest,
+	src/testsuite/tests/extensions/encoded-character.svtest,
+	src/testsuite/tests/extensions/envelope.svtest,
+	src/testsuite/tests/extensions/imapflags/basic.svtest,
+	src/testsuite/tests/extensions/imapflags/rfc.svtest,
+	src/testsuite/tests/extensions/include/variables-included1.sieve,
+	src/testsuite/tests/extensions/include/variables-included2.sieve,
+	src/testsuite/tests/extensions/include/variables-included3.sieve,
+	src/testsuite/tests/extensions/include/variables.svtest,
+	src/testsuite/tests/extensions/variables/basic.svtest,
+	src/testsuite/tests/extensions/variables/match.svtest,
+	src/testsuite/tests/header.svtest, src/testsuite/tests/lexer.svtest,
+	src/testsuite/tests/match-types/contains.svtest, src/testsuite/tests
+	/match-types/is.svtest, src/testsuite/tests/match-
+	types/matches.svtest, src/testsuite/tests/match-
+	types/relational.svtest, src/testsuite/tests/testsuite.svtest, tests
+	/address-parts/subaddress.svtest, tests/comparators/core.svtest,
+	tests/compile/compile-examples.svtest, tests/compile/compile.svtest,
+	tests/compile/errors.svtest, tests/compile/errors/address-
+	part.sieve, tests/compile/errors/address.sieve, tests/compile/errors
+	/encoded-character.sieve, tests/compile/errors/envelope.sieve,
+	tests/compile/errors/header.sieve, tests/compile/errors/if.sieve,
+	tests/compile/errors/keep.sieve, tests/compile/errors/require.sieve,
+	tests/compile/errors/size.sieve, tests/compile/errors/stop.sieve,
+	tests/compile/redirect.sieve, tests/compile/trivial.sieve, tests
+	/control-structures.svtest, tests/exists.svtest, tests/extensions
+	/encoded-character.svtest, tests/extensions/envelope.svtest,
+	tests/extensions/imapflags/basic.svtest,
+	tests/extensions/imapflags/rfc.svtest, tests/extensions/include
+	/variables-included1.sieve, tests/extensions/include/variables-
+	included2.sieve, tests/extensions/include/variables-included3.sieve,
+	tests/extensions/include/variables.svtest,
+	tests/extensions/variables/basic.svtest,
+	tests/extensions/variables/match.svtest, tests/header.svtest,
+	tests/lexer.svtest, tests/match-types/contains.svtest, tests/match-
+	types/is.svtest, tests/match-types/matches.svtest, tests/match-
+	types/relational.svtest, tests/testsuite.svtest:
+	Testsuite: moved tests directory to the root of the package.
+	[bbd0d8bab632]
+
+	* doc/rfc/variables.rfc5229.txt, src/lib-
+	sieve/plugins/variables/rfc5229.txt:
+	Installed variables rfc in the doc/rfc directory.
+	[785a600fb225]
+
+	* TODO, src/lib-sieve/ext-encoded-character.c,
+	src/testsuite/tests/compile/errors/encoded-character.sieve,
+	src/testsuite/tests/extensions/encoded-character.svtest:
+	Encoded-character: resolved error reporting issue, added some syntax
+	error tests and fixed some parsing bugs in the process.
+	[9dd5079adbbe]
+
+	* TODO, src/lib-sieve/ext-encoded-character.c,
+	src/testsuite/tests/compile/errors.svtest,
+	src/testsuite/tests/compile/errors/address-part.sieve,
+	src/testsuite/tests/compile/errors/encoded-character.sieve,
+	src/testsuite/tests/compile/errors/envelope.sieve,
+	src/testsuite/tests/compile/errors/keep.sieve,
+	src/testsuite/tests/compile/errors/size.sieve,
+	src/testsuite/tests/compile/errors/stop.sieve, src/testsuite/tests
+	/control-structures.svtest:
+	Testsuite: added compile error testcases and discovered one new
+	issue.
+	[1bf8cc2f7f10]
+
+	* TODO:
+	Reprioritized TODO file.
+	[1342d7920181]
+
+	* TODO, src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h:
+	Variables: resolved issues in the scope implementation.
+	[a3bcc26814b1]
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include-variables.c, src/lib-
+	sieve/plugins/include/ext-include-variables.h, src/lib-sieve/sieve-
+	ast.c, src/lib-sieve/sieve-ast.h:
+	Added proper extension support to AST object.
+	[031f0a483697]
+
+2008-07-28  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-error.h, src/lib-
+	sieve/sieve-validator.c, src/testsuite/tests/compile/errors.svtest,
+	src/testsuite/tests/compile/errors/address.sieve,
+	src/testsuite/tests/compile/errors/header.sieve,
+	src/testsuite/tests/compile/errors/if.sieve,
+	src/testsuite/tests/compile/errors/require.sieve, src/testsuite
+	/testsuite-common.c:
+	Testsuite: added a few more compile error test cases.
+	[658fa458abd4]
+
+	* src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-error.h,
+	src/testsuite/Makefile.am,
+	src/testsuite/tests/compile/errors.svtest,
+	src/testsuite/tests/compile/errors/header.sieve,
+	src/testsuite/tests/errors.svtest, src/testsuite/tests/header-
+	errors.sieve, src/testsuite/testsuite-common.c, src/testsuite
+	/testsuite-common.h, src/testsuite/testsuite.c, src/testsuite/tst-
+	test-compile.c, src/testsuite/tst-test-error.c:
+	Testsuite: completed support for error validation and added one test
+	case.
+	[b7ae709ef86e]
+
+	* src/testsuite/Makefile.am, src/testsuite/cmd-test-fail.c,
+	src/testsuite/cmd-test-set.c, src/testsuite/ext-testsuite.c,
+	src/testsuite/tests/errors.svtest, src/testsuite/tests/header-
+	errors.sieve, src/testsuite/testsuite-common.h, src/testsuite/tst-
+	test-compile.c, src/testsuite/tst-test-error.c:
+	Testsuite: started support for error validation.
+	[bef773d65f77]
+
+	* TODO, src/testsuite/Makefile.am, src/testsuite/tests/match-
+	types/contains.svtest, src/testsuite/tests/match-types/is.svtest:
+	Testsuite: marginally improved match-type tests.
+	[444696f0d147]
+
+	* src/testsuite/Makefile.am:
+	Added variables testcase to the testsuite.
+	[2030448d3cd4]
+
+	* src/lib-sieve/mcht-matches.c, src/lib-sieve/sieve-match-types.c, src
+	/lib-sieve/sieve-match-types.h,
+	src/testsuite/tests/extensions/variables/match.svtest,
+	src/testsuite/tests/lexer.svtest, src/testsuite/tests/match-
+	types/matches.svtest:
+	Fixed bugs in the :matches match type.
+	[6305d80a9f22]
+
+	* src/lib-sieve/ext-encoded-character.c, src/testsuite/Makefile.am,
+	src/testsuite/tests/extensions/encoded-character.svtest:
+	Encoded-character: fixed a few bugs to properly match the examples
+	provided in the RFC.
+	[a320882164ec]
+
+2008-07-27  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/tst-header.c:
+	Added stripping of right white space from header content.
+	[9a21206c0260]
+
+	* TODO:
+	Updated TODO
+	[8ec5db20d93b]
+
+	* src/testsuite/tests/extensions/envelope.svtest:
+	Envelope: forgot to add new test case.
+	[ce3a837f69f0]
+
+	* TODO, src/lib-sieve/ext-envelope.c, src/testsuite/Makefile.am:
+	Envelope: <> return path now always matches as the empty string,
+	regardless of the specified address part.
+	[270b07d72782]
+
+	* TODO:
+	Minor TODO file change.
+	[9ba44410e26e]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/tst-address.c:
+	Forgot to adjust comment.
+	[3560a09d215a]
+
+	* doc/rfc/RFC Controversy.txt:
+	Updated documentation.
+	[20da4decbf18]
+
+	* TODO, doc/rfc/RFC Controversy.txt, sieve/errors/envelope-
+	errors.sieve, sieve/examples/elvey.sieve, src/lib-sieve/ext-
+	envelope.c, src/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-ast.h,
+	src/lib-sieve/tst-address.c:
+	Envelope: added compile-time envelope-part verification.
+	[9a5d8cd44c16]
+
+	* doc/rfc/RFC Controversy.txt:
+	Added RFC controversy file to log all matters that require
+	clarification from RFC editors.
+	[eaa9516bda0a]
+
+	* TODO:
+	Restricted allowable headers for the address test.
+	[b7212151acde]
+
+	* TODO, sieve/errors/address-errors.sieve, src/lib-sieve/tst-
+	address.c, src/testsuite/tests/extensions/imapflags/rfc.svtest:
+	Imapflags: forgot to add testcase file.
+	[afe2b84e7719]
+
+	* src/lib-sieve/sieve-match.c:
+	Disallowed extraction of key elements from key strings for match
+	types for with that would not make sense.
+	[ba9fe4253d74]
+
+	* TODO, src/lib-sieve/plugins/imapflags/ext-imapflags-common.c, src
+	/lib-sieve/plugins/imapflags/tag-flags.c, src/lib-
+	sieve/plugins/relational/mcht-count.c, src/testsuite/Makefile.am,
+	src/testsuite/tests/extensions/imapflags/basic.svtest:
+	Imapflags: resolved problem of hasflags encountering duplicate flags
+	in flag lists contained in a variable.
+	[df6023e12048]
+
+	* TODO, src/lib-sieve/ext-envelope.c, src/lib-sieve/mcht-contains.c,
+	src/lib-sieve/mcht-is.c, src/lib-sieve/mcht-matches.c, src/lib-
+	sieve/plugins/body/tst-body.c, src/lib-sieve/plugins/imapflags/tst-
+	hasflag.c, src/lib-sieve/plugins/regex/mcht-regex.c, src/lib-
+	sieve/plugins/relational/mcht-count.c, src/lib-
+	sieve/plugins/relational/mcht-value.c, src/lib-
+	sieve/plugins/variables/tst-string.c, src/lib-sieve/sieve-match-
+	types.h, src/lib-sieve/sieve-match.c, src/lib-sieve/sieve-match.h,
+	src/lib-sieve/tst-address.c, src/lib-sieve/tst-header.c,
+	src/testsuite/Makefile.am,
+	src/testsuite/tests/extensions/imapflags/basic.svtest:
+	Imapflags: resolved string representation issue in hasflag.
+	[9261c0d19ce3]
+
+	* TODO, src/lib-sieve/plugins/body/tst-body.c, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-
+	sieve/plugins/variables/tst-string.c, src/lib-sieve/sieve-match.c,
+	src/lib-sieve/sieve-match.h, src/lib-sieve/tst-header.c,
+	src/testsuite/tests/extensions/imapflags/basic.svtest:
+	Resolved code duplication among commands that use comparators and
+	match-types and found problems in the imapflags extension in the
+	process.
+	[662b8d662c89]
+
+2008-07-26  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	LDA-Sieve plugin: forgot to save the new binary when encountered a
+	corrupt one.
+	[d42d299f470b]
+
+	* TODO, src/lib-sieve/cmd-keep.c, src/lib-sieve/cmd-redirect.c, src
+	/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-sieve
+	/sieve-actions.c, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-
+	binary.h, src/lib-sieve/sieve-code-dumper.c, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-interpreter.h:
+	Improved the handling corrupt binaries further for the action
+	commands.
+	[fd1d663f3b2c]
+
+2008-07-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/Makefile.am, src/lib-sieve/ext-envelope.c, src
+	/lib-sieve/mcht-contains.c, src/lib-sieve/mcht-is.c, src/lib-sieve
+	/mcht-matches.c, src/lib-sieve/plugins/body/tst-body.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-sieve/plugins/regex
+	/mcht-regex.c, src/lib-sieve/plugins/relational/ext-relational-
+	common.h, src/lib-sieve/plugins/relational/mcht-count.c, src/lib-
+	sieve/plugins/relational/mcht-value.c, src/lib-
+	sieve/plugins/variables/tst-string.c, src/lib-sieve/sieve-address-
+	parts.c, src/lib-sieve/sieve-address-parts.h, src/lib-sieve/sieve-
+	common.h, src/lib-sieve/sieve-match-types.c, src/lib-sieve/sieve-
+	match-types.h, src/lib-sieve/sieve-match.c, src/lib-sieve/sieve-
+	match.h, src/lib-sieve/tst-address.c, src/lib-sieve/tst-header.c,
+	src/sieve-bin/sieve-test.c, src/testsuite/Makefile.am,
+	src/testsuite/tests/control-structures.svtest, src/testsuite/tests
+	/match-types/relational.svtest, src/testsuite/testsuite-common.c,
+	src/testsuite/testsuite-common.h, src/testsuite/testsuite.c:
+	Significantly improved handling of old/corrupt binaries and revised
+	matching implementation in the process.
+	[07f6bc2fe04b]
+
+	* src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-
+	numeric.c:
+	Fixed extremely stupid bug in the i;ascii-numeric comparator.
+	[f7df94b061ec]
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-interpreter.c,
+	src/plugins/lda-sieve/lda-sieve-plugin.c, src/sieve-bin/sieve-
+	exec.c, src/sieve-bin/sieve-test.c:
+	Implemented graceful handling of corrupt binaries by the sieve lda
+	plugin.
+	[c300bab057a2]
+
+	* configure.in:
+	Properly configured package name.
+	[dfe8a1ecad3c]
+
+	* TODO, src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-keep.c, src
+	/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-envelope.c, src/lib-
+	sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/tst-body.c, src/lib-sieve/plugins/imapflags/cmd-
+	addflag.c, src/lib-sieve/plugins/imapflags/cmd-removeflag.c, src
+	/lib-sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-sieve/plugins/include
+	/cmd-include.c, src/lib-sieve/plugins/include/cmd-return.c, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/tst-string.c, src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-
+	code.h, src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-sieve
+	/sieve-result.c, src/lib-sieve/sieve-result.h, src/lib-sieve/sieve-
+	types.h, src/lib-sieve/tst-address.c, src/lib-sieve/tst-exists.c,
+	src/lib-sieve/tst-header.c, src/lib-sieve/tst-size.c, src/sieve-bin
+	/sieve-exec.c, src/testsuite/cmd-test-fail.c, src/testsuite/cmd-
+	test-set.c, src/testsuite/cmd-test.c, src/testsuite/tst-test-
+	compile.c:
+	Working towards improving the handling of currupt binaries: defined
+	multiple exit codes for execution functions and defined trace macro
+	for reporting binary corruptions.
+	[10c30a4bd44a]
+
+	* TODO, src/testsuite/tests/extensions/include/variables-
+	included1.sieve, src/testsuite/tests/extensions/include/variables-
+	included2.sieve, src/testsuite/tests/extensions/include/variables-
+	included3.sieve,
+	src/testsuite/tests/extensions/include/variables.svtest:
+	Testsuite: forgot to add test cases for include extension.
+	[e3542907a783]
+
+	* TODO, src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/variables/ext-variables-operands.c, src/lib-sieve
+	/sieve-script.c, src/lib-sieve/sieve-script.h,
+	src/testsuite/Makefile.am, src/testsuite/testsuite.c:
+	Fixed code emission for extension-defined variables and removed
+	hardcoded paths from include extension.
+	[c3dfcab426ca]
+
+	* TODO:
+	Added future TODO item.
+	[defad0db1bb4]
+
+	* TODO, src/lib-sieve/sieve-interpreter.h:
+	Updated TODO and removed spurious FIXME.
+	[477722eeaf09]
+
+	* README, src/testsuite/ext-testsuite.c:
+	Updated documentation.
+	[89e50989541a]
+
+	* .hgignore, src/lib-sieve/sieve-script.c, src/lib-sieve/sieve-
+	script.h, src/testsuite/Makefile.am, src/testsuite/cmd-test-fail.c,
+	src/testsuite/cmd-test-set.c, src/testsuite/cmd-test.c,
+	src/testsuite/ext-testsuite.c, src/testsuite/tests/compile/compile-
+	examples.svtest, src/testsuite/tests/compile/compile.svtest,
+	src/testsuite/tests/compile/redirect.sieve,
+	src/testsuite/tests/compile/trivial.sieve, src/testsuite/testsuite-
+	common.h, src/testsuite/tst-test-compile.c:
+	Testsuite: added test_compile command to test compilation of
+	scripts.
+	[e6846fc1dc11]
+
+2008-07-24  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, sieve/errors/out-address-errors.sieve, src/lib-sieve/sieve-
+	address.c, src/lib-sieve/sieve-binary.c:
+	Revised Sieve address validation functionality.
+	[10abb0055a23]
+
+	* README, TODO, configure.in, src/lib-sieve/sieve-binary.c:
+	Started using new str_new_const() function.
+	[3fc4deedc23b]
+
+	* TODO, src/lib-sieve/cmd-redirect.c, src/lib-sieve/plugins/imapflags
+	/cmd-addflag.c, src/lib-sieve/plugins/imapflags/cmd-removeflag.c,
+	src/lib-sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/imapflags-errors.sieve, src/lib-
+	sieve/plugins/imapflags/imapflags.sieve, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/imapflags
+	/tst-hasflag.c, src/lib-sieve/sieve-commands.h, src/lib-sieve/sieve-
+	result.c, src/lib-sieve/sieve-result.h:
+	Imapflags: improved handling of invalid flags.
+	[4d45ccdd880b]
+
+	* TODO, src/lib-sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-sieve/sieve-
+	ast.c, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-
+	validator.c:
+	Significantly improved pool allocation by checking --enable-debug
+	warnings from dovecot.
+	[4a5f60764e5f]
+
+	* src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-validator.c:
+	Removed all legacy use of array_create().
+	[f4bb043dc649]
+
+	* src/lib-sieve/sieve-lexer.c:
+	Lexer: fixed repetitive string alloation problem.
+	[14dd750dfeb8]
+
+2008-07-23  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-binary.c:
+	Fixed bug introduced by previous change.
+	[e4db63d3e106]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/plugins/variables/cmd-
+	set.c, src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-address-
+	parts.c, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h,
+	src/lib-sieve/sieve-code-dumper.c, src/lib-sieve/sieve-code.c, src
+	/lib-sieve/sieve-common.h, src/lib-sieve/sieve-comparators.c, src
+	/lib-sieve/sieve-extensions-private.h, src/lib-sieve/sieve-
+	extensions.c, src/lib-sieve/sieve-match-types.c, src/testsuite
+	/testsuite-common.c, src/testsuite/testsuite-objects.c:
+	Reworked operand and operation binary coding functions.
+	[a8f9c4a6c502]
+
+	* src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-if.c, src/lib-sieve
+	/cmd-keep.c, src/lib-sieve/cmd-redirect.c, src/lib-sieve/cmd-
+	require.c, src/lib-sieve/ext-envelope.c, src/lib-sieve/ext-
+	fileinto.c, src/lib-sieve/ext-reject.c, src/lib-sieve/plugins/body
+	/ext-body-common.c, src/lib-sieve/plugins/body/tst-body.c, src/lib-
+	sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-numeric.c,
+	src/lib-sieve/plugins/copy/ext-copy.c, src/lib-
+	sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/imapflags
+	/tst-hasflag.c, src/lib-sieve/plugins/include/cmd-include.c, src
+	/lib-sieve/plugins/include/cmd-return.c, src/lib-
+	sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-variables.c, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/plugins/regex
+	/ext-regex.c, src/lib-sieve/plugins/relational/ext-relational.c, src
+	/lib-sieve/plugins/subaddress/ext-subaddress.c, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-common.c, src/lib-sieve/plugins/variables/ext-
+	variables-common.h, src/lib-sieve/plugins/variables/ext-variables-
+	modifiers.c, src/lib-sieve/plugins/variables/ext-variables-
+	modifiers.h, src/lib-sieve/plugins/variables/ext-variables-
+	operands.c, src/lib-sieve/plugins/variables/sieve-ext-variables.h,
+	src/lib-sieve/plugins/variables/tst-string.c, src/lib-sieve/sieve-
+	actions.h, src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-
+	address-parts.h, src/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-
+	ast.h, src/lib-sieve/sieve-binary-dumper.c, src/lib-sieve/sieve-
+	binary.c, src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-code.c,
+	src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-commands.c, src/lib-
+	sieve/sieve-comparators.c, src/lib-sieve/sieve-comparators.h, src
+	/lib-sieve/sieve-extensions-private.h, src/lib-sieve/sieve-
+	extensions.c, src/lib-sieve/sieve-extensions.h, src/lib-sieve/sieve-
+	generator.c, src/lib-sieve/sieve-generator.h, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-sieve
+	/sieve-match-types.c, src/lib-sieve/sieve-match-types.h, src/lib-
+	sieve/sieve-message.c, src/lib-sieve/sieve-message.h, src/lib-sieve
+	/sieve-objects.c, src/lib-sieve/sieve-objects.h, src/lib-sieve
+	/sieve-result.c, src/lib-sieve/sieve-result.h, src/lib-sieve/sieve-
+	validator.c, src/lib-sieve/sieve-validator.h, src/lib-sieve/tst-
+	address.c, src/lib-sieve/tst-allof.c, src/lib-sieve/tst-anyof.c, src
+	/lib-sieve/tst-exists.c, src/lib-sieve/tst-header.c, src/lib-sieve
+	/tst-size.c, src/testsuite/cmd-test-fail.c, src/testsuite/cmd-test-
+	set.c, src/testsuite/cmd-test.c, src/testsuite/testsuite-common.c,
+	src/testsuite/testsuite-objects.c, src/testsuite/testsuite-
+	objects.h:
+	Fully substituted the use of extension ids with the use of the
+	extension object itself.
+	[0da758d61cad]
+
+	* src/lib-sieve/ext-encoded-character.c, src/lib-sieve/ext-envelope.c,
+	src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/ext-body.c, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/ext-cmp-i-ascii-numeric.c, src/lib-sieve/plugins/copy
+	/ext-copy.c, src/lib-sieve/plugins/imapflags/ext-imapflags.c, src
+	/lib-sieve/plugins/include/ext-include.c, src/lib-
+	sieve/plugins/regex/ext-regex.c, src/lib-sieve/plugins/relational
+	/ext-relational.c, src/lib-sieve/plugins/subaddress/ext-
+	subaddress.c, src/lib-sieve/plugins/vacation/ext-vacation.c, src
+	/lib-sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-
+	comparators.c, src/lib-sieve/sieve-extensions.c, src/lib-sieve
+	/sieve-extensions.h, src/lib-sieve/sieve-match-types.c, src/lib-
+	sieve/sieve-validator.c, src/testsuite/ext-testsuite.c:
+	Made initially assigned extension id available directly from the
+	const extension object itself.
+	[3e237d753a2a]
+
+	* TODO, src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-error.h:
+	Reworked previous change into three elegant macros.
+	[416c6954b998]
+
+2008-07-22  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/sieve-binary.c, src/lib-sieve/sieve-error.c, src/lib-sieve
+	/sieve-error.h, src/lib-sieve/sieve-extensions.c, src/lib-sieve
+	/sieve-script.c, src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Made utility functions for neatly handing system errors, warnings
+	and notices.
+	[8a116201d954]
+
+	* src/lib-sieve/tst-allof.c, src/lib-sieve/tst-anyof.c,
+	src/testsuite/tests/control-structures.svtest:
+	Testsuite: added tests for use of allof/anyof with a single test and
+	optimized code generation.
+	[971a8a94e8ab]
+
+	* TODO, src/testsuite/tests/header.svtest, src/testsuite/tests/match-
+	types/contains.svtest:
+	Testsuite: added test case for the header test and found one issue.
+	[447d40a17ea0]
+
+	* src/lib-sieve/sieve-lexer.c, src/testsuite/Makefile.am,
+	src/testsuite/tests/lexer.svtest:
+	Testsuite: added lexer string scan comparison test and fixed lexer
+	bug in the process.
+	[1bab36c85b54]
+
+2008-07-21  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/testsuite/tests/control-structures.svtest:
+	Testsuite: added some control structure tests involving nesting.
+	[46a2df6cafe4]
+
+	* TODO, src/lib-sieve/tst-exists.c, src/testsuite/Makefile.am,
+	src/testsuite/tests/exists.svtest, src/testsuite/testsuite-
+	objects.c:
+	Testsuite: added tests for 'exists' test and fixed a semantic error
+	in the 'exists' test.
+	[ce5660cb5dbf]
+
+	* TODO, src/lib-sieve/ext-envelope.c, src/lib-sieve/sieve-address-
+	parts.c, src/testsuite/tests/testsuite.svtest, src/testsuite
+	/testsuite-objects.c:
+	Testsuite: tested handling of teststuite envelope environment and
+	fixed bugs in the envelope test in the process.
+	[ff0f9c67a106]
+
+	* src/testsuite/Makefile.am, src/testsuite/tests/address-
+	parts/subaddress.svtest, src/testsuite/testsuite-common.c:
+	Testsuite: added test case for subadress extension.
+	[21061d5f3422]
+
+	* Makefile.am, TODO, configure.in, src/Makefile.am,
+	src/testsuite/Makefile.am, src/testsuite/tests/testsuite.svtest,
+	src/testsuite/testsuite-common.c, src/testsuite/testsuite-common.h,
+	src/testsuite/testsuite.c:
+	Coupled testsuite to 'make test'.
+	[36ab72963cd1]
+
+	* sieve/tests/encoded-character.sieve, src/lib-sieve/cmd-if.c, src
+	/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-encoded-character.c,
+	src/lib-sieve/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/ext-reject.c, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/tst-address.c, src/lib-sieve/tst-allof.c, src/lib-sieve/tst-
+	anyof.c, src/lib-sieve/tst-exists.c, src/lib-sieve/tst-header.c, src
+	/lib-sieve/tst-not.c, src/lib-sieve/tst-size.c:
+	Cleaned up test and core extension implementations.
+	[5df6769ad854]
+
+	* src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-if.c, src/lib-sieve
+	/cmd-keep.c, src/lib-sieve/cmd-redirect.c, src/lib-sieve/cmd-
+	require.c:
+	Cleaned up command implementations.
+	[837769563332]
+
+	* src/lib-sieve/sieve-script-private.h, src/lib-sieve/sieve-script.c:
+	Fixed handling of script files that are in fact symbolic links.
+	[fd9003533d28]
+
+	* src/lib-sieve/sieve-binary.c:
+	Fixed bug in binary created without a corresponding script object.
+	[9560bfd8e2e5]
+
+	* TODO, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-error.c, src
+	/lib-sieve/sieve-error.h, src/lib-sieve/sieve-script.c:
+	Reversed stat() and open() on two occasions to make retrieved stat
+	information guaranteed to be valid for the opened file and added
+	error handling for various close() system calls.
+	[b04c29c4ac90]
+
+	* TODO:
+	Updated TODO list.
+	[bab521877ded]
+
+	* src/lib-sieve/plugins/regex/ext-regex.c, src/lib-sieve/plugins/regex
+	/mcht-regex.c, src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-modifiers.c, src/lib-
+	sieve/plugins/variables/ext-variables-name.c, src/lib-
+	sieve/plugins/variables/ext-variables-name.h, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-
+	actions.c:
+	Removed various unnecessary includes of <ctype.h> and replaced yey
+	another toupper() with its i_* equivalent.
+	[2e1963c29390]
+
+	* src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-
+	numeric.c, src/lib-sieve/plugins/variables/ext-variables-name.c:
+	Removed direct use of isdigit, isalpha and isalnum and replaced
+	these with their dovecot i_* equivalents to prevent problems on some
+	systems.
+	[732c5001ccb5]
+
+	* TODO:
+	Updated TODO.
+	[47c0a9d219b6]
+
+	* src/lib-sieve/plugins/variables/Makefile.am, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-common.c, src/lib-sieve/plugins/variables/ext-
+	variables-common.h, src/lib-sieve/plugins/variables/ext-variables-
+	modifiers.c, src/lib-sieve/plugins/variables/ext-variables-
+	modifiers.h, src/lib-sieve/plugins/variables/ext-variables.c, src
+	/lib-sieve/plugins/variables/sieve-ext-variables.h, src/lib-
+	sieve/plugins/variables/variables-match.sieve,
+	src/testsuite/tests/extensions/variables/basic.svtest:
+	Variables: made set modifiers descendants of the sieve object too.
+	[6c31299662d8]
+
+2008-07-20  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-objects.c,
+	src/testsuite/testsuite-common.c, src/testsuite/testsuite-common.h,
+	src/testsuite/testsuite-objects.c, src/testsuite/testsuite-
+	objects.h:
+	Testsuite: made testsuite objects a descendant from sieve objects.
+	[12a346d25711]
+
+	* TODO, src/lib-sieve/plugins/regex/ext-regex.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-
+	comparators.c, src/lib-sieve/sieve-match-types.c, src/lib-sieve
+	/sieve-validator.c, src/lib-sieve/sieve-validator.h:
+	Removed remaining code duplication among comparators, match types
+	and address parts.
+	[1654a241fa56]
+
+	* TODO:
+	Updated TODO list.
+	[8292d75ce253]
+
+	* src/lib-sieve/plugins/copy/ext-copy.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/sieve-actions.c,
+	src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-address-parts.h,
+	src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h, src/lib-
+	sieve/sieve-comparators.h, src/lib-sieve/sieve-match-types.h, src
+	/lib-sieve/sieve-objects.c, src/lib-sieve/sieve-objects.h:
+	Made side effects sieve objects too.
+	[81b6c6a65f86]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/cmp-i-ascii-casemap.c, src
+	/lib-sieve/cmp-i-octet.c, src/lib-sieve/mcht-contains.c, src/lib-
+	sieve/mcht-is.c, src/lib-sieve/mcht-matches.c, src/lib-
+	sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-numeric.c,
+	src/lib-sieve/plugins/regex/ext-regex-common.c, src/lib-
+	sieve/plugins/regex/mcht-regex.c, src/lib-sieve/plugins/relational
+	/ext-relational-common.c, src/lib-sieve/plugins/relational/mcht-
+	count.c, src/lib-sieve/plugins/relational/mcht-value.c, src/lib-
+	sieve/plugins/subaddress/ext-subaddress.c, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-address-parts.h, src/lib-sieve
+	/sieve-common.h, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-comparators.h, src/lib-sieve/sieve-match-types.c, src/lib-
+	sieve/sieve-match-types.h, src/lib-sieve/sieve-objects.c, src/lib-
+	sieve/sieve-objects.h:
+	Introduced the concept of a sieve object to merge the coding of
+	comparators, match types, address parts and other objects that might
+	need to be represented in byte code (removes lots of code
+	duplication).
+	[344eaae8693c]
+
+2008-07-19  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/cmp-i-octet.c, src/lib-sieve/mcht-contains.c,
+	src/lib-sieve/mcht-is.c, src/lib-sieve/mcht-matches.c, src/lib-
+	sieve/plugins/regex/Makefile.am, src/lib-sieve/plugins/regex/ext-
+	regex-common.c, src/lib-sieve/plugins/regex/ext-regex-common.h, src
+	/lib-sieve/plugins/regex/ext-regex.c, src/lib-sieve/plugins/regex
+	/mcht-regex.c, src/lib-sieve/plugins/relational/ext-relational-
+	common.c, src/lib-sieve/plugins/relational/ext-relational-common.h,
+	src/lib-sieve/plugins/relational/ext-relational.c, src/lib-
+	sieve/plugins/relational/mcht-count.c, src/lib-
+	sieve/plugins/relational/mcht-value.c, src/lib-sieve/sieve-
+	comparators.c, src/lib-sieve/sieve-comparators.h, src/lib-sieve
+	/sieve-match-types.c, src/lib-sieve/sieve-match-types.h:
+	Revised extension support for match-types.
+	[a6bf1b1c8a2b]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/cmp-i-ascii-casemap.c, src
+	/lib-sieve/cmp-i-octet.c, src/lib-sieve/sieve-comparators.c, src
+	/lib-sieve/sieve-comparators.h:
+	Cleaned up comparator implementation.
+	[8976941d215c]
+
+	* TODO, src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i
+	-ascii-numeric.c, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-comparators.h, src/testsuite/tests/comparators/core.svtest:
+	Revised extension support for comparators.
+	[29676b9e16c2]
+
+2008-07-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-comparators.c:
+	Fixed stupid bug in the match-type context validation.
+	[e67e5024a970]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/sieve-ast.c, src/lib-sieve
+	/sieve-ast.h, src/lib-sieve/sieve-common.h, src/lib-sieve/sieve-
+	error.c, src/lib-sieve/sieve-error.h, src/lib-sieve/sieve-lexer.c,
+	src/lib-sieve/sieve-parser.c, src/lib-sieve/sieve-result.c, src/lib-
+	sieve/sieve-script-private.h, src/lib-sieve/sieve-script.c, src/lib-
+	sieve/sieve-types.h, src/lib-sieve/sieve.h:
+	Made error reporting cleaner by avoiding the scriptname of the main
+	script and indicating that the printed numbers are in fact source
+	code lines.
+	[2c5ae7a67d28]
+
+	* src/lib-sieve/sieve-validator.h:
+	Fixed warnings caused by remaining spurious inline definitions in
+	sieve-validator.h
+	[bfc24ba04381]
+
+2008-07-17  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-lexer.c, src/lib-sieve/sieve-lexer.h, src/lib-
+	sieve/sieve-parser.c, src/lib-sieve/sieve-parser.h, src/lib-
+	sieve/sieve.c, src/lib-sieve/sieve.h, src/plugins/lda-sieve/lda-
+	sieve-plugin.c:
+	Code cleanup: parser, lexer, lda-plugin and main interface.
+	[d5ca488d55b7]
+
+	* TODO:
+	Updated TODO.
+	[c44e8d20b130]
+
+2008-07-16  Stephan Bosch  <stephan@rename-it.nl>
+
+	* INSTALL:
+	Update INSTALL file.
+	[c0acf033f79d]
+
+	* README, TODO:
+	Updated documentation.
+	[3f2415b96676]
+
+	* TODO, src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-keep.c, src
+	/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/ext-reject.c, src/lib-sieve/plugins/vacation/cmd-vacation.c,
+	src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h, src
+	/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-interpreter.c, src
+	/lib-sieve/sieve-interpreter.h, src/lib-sieve/sieve-result.c, src
+	/lib-sieve/sieve-result.h:
+	Made runtime errors for action conflicts more user-friendly by
+	adding sourcecode line numbers.
+	[5dfc5676bd6f]
+
+	* src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-if.c, src/lib-sieve
+	/cmd-keep.c, src/lib-sieve/cmd-redirect.c, src/lib-sieve/cmd-
+	require.c, src/lib-sieve/ext-envelope.c, src/lib-sieve/ext-
+	fileinto.c, src/lib-sieve/ext-reject.c, src/lib-sieve/plugins/body
+	/tst-body.c, src/lib-sieve/plugins/copy/ext-copy.c, src/lib-
+	sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/imapflags
+	/tst-hasflag.c, src/lib-sieve/plugins/include/cmd-include.c, src
+	/lib-sieve/plugins/include/cmd-return.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-arguments.c, src/lib-sieve/plugins/variables/tst-
+	string.c, src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-
+	actions.h, src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-
+	code.c, src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-commands.c,
+	src/lib-sieve/sieve-commands.h, src/lib-sieve/sieve-common.h, src
+	/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-generator.c, src
+	/lib-sieve/sieve-generator.h, src/lib-sieve/sieve-match-types.c, src
+	/lib-sieve/sieve-result.c, src/lib-sieve/sieve-result.h, src/lib-
+	sieve/tst-address.c, src/lib-sieve/tst-allof.c, src/lib-sieve/tst-
+	anyof.c, src/lib-sieve/tst-exists.c, src/lib-sieve/tst-header.c, src
+	/lib-sieve/tst-not.c, src/lib-sieve/tst-size.c, src/testsuite/cmd-
+	test-fail.c, src/testsuite/cmd-test-set.c, src/testsuite/cmd-test.c,
+	src/testsuite/testsuite-objects.c:
+	Cleaned up generator code and added emission of source line
+	positions for all actions.
+	[d60e232af73e]
+
+2008-07-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, sieve/tests/stop.sieve, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/lib-sieve/sieve-parser.c:
+	Resolved various small issues.
+	[dd844326cd20]
+
+	* TODO, src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/sieve-interpreter.c, src/lib-sieve/sieve-interpreter.h, src
+	/lib-sieve/sieve.c, src/lib-sieve/sieve.h, src/plugins/lda-sieve
+	/lda-sieve-plugin.c, src/sieve-bin/sieve-exec.c, src/sieve-bin
+	/sieve-test.c, src/testsuite/testsuite.c:
+	Removed last significant printf()s from library code.
+	[663bb4cf98d8]
+
+	* sieve/tests/actions.sieve, src/lib-sieve/cmd-redirect.c, src/lib-
+	sieve/ext-encoded-character.c, src/lib-sieve/plugins/copy/ext-
+	copy.c, src/lib-sieve/plugins/vacation/cmd-vacation.c, src/lib-sieve
+	/sieve-address.c, src/lib-sieve/sieve-address.h, src/lib-sieve
+	/sieve-ast.c, src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-
+	result.c:
+	Added address normalization to prevent redirect action duplicates.
+	[41e894bd5adb]
+
+	* src/lib-sieve/sieve-actions.c:
+	Made "INBOX" folder name case-insensitive.
+	[ad20dac29faf]
+
+	* TODO, src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-redirect.c, src
+	/lib-sieve/ext-reject.c, src/lib-sieve/plugins/copy/ext-copy.c, src
+	/lib-sieve/plugins/imapflags/imapflags-implicit.sieve, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/vacation
+	/cmd-vacation.c, src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-
+	actions.h, src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-common.h,
+	src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-result.h, src/lib-
+	sieve/sieve-validator.c, src/lib-sieve/sieve.c, src/lib-
+	sieve/sieve.h, src/sieve-bin/sieve-test.c,
+	src/testsuite/testsuite.c:
+	Built result print functions thus removing various printf()s.
+	[ab0569f04717]
+
+	* TODO, src/lib-sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-variables.c, src/lib-
+	sieve/plugins/variables/ext-variables-arguments.c, src/lib-sieve
+	/sieve-interpreter.c, src/lib-sieve/sieve-lexer.c, src/lib-sieve
+	/sieve-result.c, src/sieve-bin/sieve-exec.c:
+	Removed various printf()s.
+	[8b83101ed51a]
+
+	* README, TODO, src/lib-sieve/plugins/imapflags/ext-imapflags.c, src
+	/lib-sieve/plugins/imapflags/imapflags.sieve, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/sieve-result.c:
+	Implemented support for side-effects to implicit keep and finished
+	the imapflags extension.
+	[c0b959cfdf01]
+
+	* src/lib-sieve/ext-encoded-character.c, src/lib-sieve/ext-envelope.c,
+	src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/ext-body.c, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/ext-cmp-i-ascii-numeric.c, src/lib-sieve/plugins/copy
+	/ext-copy.c, src/lib-sieve/plugins/imapflags/ext-imapflags.c, src
+	/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/plugins/regex
+	/ext-regex.c, src/lib-sieve/plugins/relational/ext-relational.c, src
+	/lib-sieve/plugins/subaddress/ext-subaddress.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-
+	comparators.c, src/lib-sieve/sieve-extensions.c, src/lib-sieve
+	/sieve-extensions.h, src/lib-sieve/sieve-interpreter.c, src/lib-
+	sieve/sieve-match-types.c, src/testsuite/ext-testsuite.c:
+	Previous change in extension interface for implicit side effect
+	support broke include extension.
+	[4cb32478d80d]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/cmd-discard.c, src/lib-
+	sieve/cmd-redirect.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/ext-body-common.c, src/lib-sieve/plugins/copy
+	/ext-copy.c, src/lib-sieve/plugins/imapflags/ext-imapflags-common.c,
+	src/lib-sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/include
+	/ext-include-common.c, src/lib-sieve/plugins/include/ext-include-
+	common.h, src/lib-sieve/plugins/include/ext-include.c, src/lib-
+	sieve/plugins/include/include.sieve, src/lib-sieve/plugins/vacation
+	/cmd-vacation.c, src/lib-sieve/plugins/variables/ext-variables.c,
+	src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h, src
+	/lib-sieve/sieve-common.h, src/lib-sieve/sieve-extensions.c, src
+	/lib-sieve/sieve-extensions.h, src/lib-sieve/sieve-interpreter.c,
+	src/lib-sieve/sieve-interpreter.h, src/lib-sieve/sieve-message.c,
+	src/lib-sieve/sieve-message.h, src/lib-sieve/sieve-result.c, src
+	/lib-sieve/sieve-result.h:
+	Added support for implicit side effects and adjusted imapflags
+	extension accordingly.
+	[f55d47d1daee]
+
+2008-07-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/plugins/imapflags/tag-flags.c, src/lib-sieve
+	/sieve-actions.c, src/lib-sieve/sieve-actions.h:
+	Imapflags: flags are stored for explicit actions.
+	[9fa69efd67d1]
+
+2008-07-12  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c:
+	Imapflags: cleaned up some debug messages and fixed triggered
+	assertion.
+	[ebdd1e5333ca]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/ext-reject.c:
+	Forgot a few trace macros.
+	[4f32214d959c]
+
+	* TODO:
+	Updated TODO list.
+	[9d16b8207a91]
+
+	* src/lib-sieve/sieve-actions.c:
+	Fixed typos in some error messages.
+	[584e2516320d]
+
+	* sieve/errors/out-address-errors.sieve, src/lib-sieve/Makefile.am,
+	src/lib-sieve/cmd-redirect.c, src/lib-sieve/plugins/vacation/cmd-
+	vacation.c, src/lib-sieve/sieve-address.c, src/lib-sieve/sieve-
+	address.h, src/lib-sieve/sieve-validator-address.c, src/lib-sieve
+	/sieve-validator.h:
+	Improved address validation significantly.
+	[3d2a4f000814]
+
+	* src/testsuite/tests/control-structures.svtest, src/testsuite/tests
+	/match-types/contains.svtest:
+	Added two simple test cases.
+	[8354f6045c96]
+
+	* src/lib-sieve/sieve-commands.c:
+	Forgot trace macro for the stop command.
+	[2affc8a239aa]
+
+	* TODO:
+	Removed llist TODO item, turns out to be less mergeable than
+	initially thought.
+	[e324d382f62b]
+
+2008-06-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/testsuite/tests/match-types/matches.svtest:
+	Testsuite: extended :matches tests.
+	[3cc1f848aa72]
+
+	* src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-keep.c, src/lib-sieve
+	/cmd-redirect.c, src/lib-sieve/plugins/body/tst-body.c, src/lib-
+	sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-sieve/plugins/include
+	/cmd-include.c, src/lib-sieve/plugins/include/cmd-return.c, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/tst-string.c, src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-sieve/tst-
+	address.c, src/lib-sieve/tst-exists.c, src/lib-sieve/tst-header.c,
+	src/lib-sieve/tst-size.c, src/testsuite/cmd-test-fail.c,
+	src/testsuite/cmd-test-set.c, src/testsuite/cmd-test.c,
+	src/testsuite/ext-testsuite.c, src/testsuite/tests/match-
+	types/matches.svtest, src/testsuite/testsuite-common.c,
+	src/testsuite/testsuite-common.h, src/testsuite/testsuite.c:
+	Introduced trace macro for runtime tracing and improved testsuite
+	implementation.
+	[d4206ad35724]
+
+	* src/lib-sieve/mcht-matches.c, src/testsuite/mail-raw.c,
+	src/testsuite/tests/match-types/matches.svtest:
+	Testsuite: fixed CRLF bug in reading a script-specified mail
+	message.
+	[65bedbabab62]
+
+	* sieve/tests/matches.sieve, src/lib-sieve/mcht-matches.c, src/lib-
+	sieve/tst-header.c, src/testsuite/tests/match-types/matches.svtest:
+	Fixed bugs in :matches implementation.
+	[ded9f063bb3b]
+
+2008-06-28  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-generator.c, src/testsuite/tests/match-
+	types/matches.svtest, src/testsuite/tests/testsuite.sieve,
+	src/testsuite/tests/testsuite.svtest:
+	Added testcase to the testsuite.
+	[901e88d94ef2]
+
+	* README, src/lib-sieve/ext-encoded-character.c, src/lib-sieve/ext-
+	envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-
+	reject.c, src/lib-sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/plugins/variables
+	/ext-variables.c:
+	Updated documentation.
+	[fe8d65b77b9d]
+
+	* TODO:
+	Updated TODO.
+	[e591cfdaaab9]
+
+	* TODO, src/lib-sieve/sieve-error-private.h, src/lib-sieve/sieve-
+	error.c, src/lib-sieve/sieve-error.h, src/lib-sieve/sieve-parser.c,
+	src/lib-sieve/sieve-validator.c, src/plugins/lda-sieve/lda-sieve-
+	plugin.c, src/sieve-bin/bin-common.c, src/sieve-bin/sieve-exec.c,
+	src/sieve-bin/sieve-test.c, src/testsuite/testsuite.c:
+	Added support for limits on the maximum number of errors collected
+	during compilation.
+	[16066e307609]
+
+	* README, TODO:
+	Updated documentation.
+	[4282b0a65c30]
+
+	* sieve/errors/out-address-errors.sieve, src/lib-sieve/Makefile.am,
+	src/lib-sieve/cmd-redirect.c, src/lib-sieve/plugins/vacation/cmd-
+	vacation.c, src/lib-sieve/sieve-address.c, src/lib-sieve/sieve-
+	commands.h, src/lib-sieve/sieve-validator-address.c, src/lib-sieve
+	/sieve-validator.h:
+	Added compile-time address validation.
+	[d977d476923d]
+
+	* doc/rfc/imail.rfc2822.txt:
+	Added IMAIL rfc.
+	[252d826d42e3]
+
+	* doc/rfc/draft-ietf-sieve-3028bis-13.txt, doc/rfc/rfc3028.txt,
+	doc/rfc/rfc3629.txt, doc/rfc/sieve.rfc5228.txt,
+	doc/rfc/utf-8.rfc3629.txt:
+	Updated doc/rfc directory.
+	[c045f8d8aaf8]
+
+	* README, TODO:
+	Updated documentation.
+	[85aee022d63b]
+
+	* src/lib-sieve/ext-fileinto.c, src/lib-sieve/plugins/imapflags/tag-
+	flags.c, src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-
+	binary.c, src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-code-
+	dumper.c, src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-
+	commands.h, src/lib-sieve/sieve-extensions-private.h:
+	Imapflags: finished for implicit flag attachment to fileinto and
+	keep commands.
+	[b9d8f9649bde]
+
+2008-06-17  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/ext-encoded-character.c, src/lib-
+	sieve/plugins/body/tst-body.c, src/lib-sieve/plugins/copy/ext-
+	copy.c, src/lib-sieve/plugins/imapflags/ext-imapflags-common.c, src
+	/lib-sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/include
+	/cmd-include.c, src/lib-sieve/plugins/vacation/cmd-vacation.c, src
+	/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-arguments.c, src/lib-sieve
+	/sieve-address-parts.c, src/lib-sieve/sieve-ast.c, src/lib-sieve
+	/sieve-ast.h, src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-
+	commands.h, src/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-
+	match-types.c, src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve-
+	validator.h, src/lib-sieve/tst-size.c, src/testsuite/testsuite-
+	objects.c:
+	Added the concept of persistent tags and implemented imapflags
+	extension for bare keep and fileinto commands (intermittent commit,
+	not working properly yet).
+	[b941171d7557]
+
+2008-06-04  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/imapflags-variables.sieve, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h:
+	Imapflags: added execution support for variables.
+	[3115627a9c60]
+
+	* src/lib-sieve/plugins/imapflags/Makefile.am, src/lib-
+	sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/imapflags-variables.sieve, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-arguments.c, src/lib-sieve/plugins/variables/ext-
+	variables-arguments.h, src/lib-sieve/plugins/variables/ext-
+	variables-operands.c, src/lib-sieve/plugins/variables/ext-variables-
+	operands.h, src/lib-sieve/plugins/variables/sieve-ext-variables.h,
+	src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h:
+	Imapflags: added validation and code support for variables.
+	[eebce2c24704]
+
+2008-06-03  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/plugins/vacation/vacation.sieve, src/lib-sieve
+	/sieve-validator.c:
+	Fixed bug in duplicate argument detection.
+	[9a8045ad9897]
+
+	* src/lib-sieve/plugins/vacation/Makefile.am, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/lib-
+	sieve/plugins/vacation/ext-vacation-common.h, src/lib-
+	sieve/plugins/vacation/ext-vacation.c:
+	Vacation: exported command implementation to separate file.
+	[c0d69bd47692]
+
+	* src/lib-sieve/sieve-binary.c, src/sieve-bin/sieved.c:
+	Fixed bug in sieved.
+	[0cf9a6ab85d6]
+
+	* INSTALL, README, configure.in, src/sieve-bin/Makefile.am:
+	Minor compile and documentation changes.
+	[5d55a9fb061d]
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Made lda sieve plugin save and load binaries.
+	[98a4a28d48d3]
+
+	* src/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-ast.h, src/lib-sieve
+	/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-
+	code.c, src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-commands.c,
+	src/lib-sieve/sieve-commands.h, src/lib-sieve/sieve-comparators.c,
+	src/lib-sieve/sieve-comparators.h, src/lib-sieve/sieve-generator.c,
+	src/lib-sieve/sieve-generator.h, src/lib-sieve/sieve-interpreter.c,
+	src/lib-sieve/sieve-interpreter.h, src/lib-sieve/sieve-lexer.c, src
+	/lib-sieve/sieve-lexer.h, src/lib-sieve/sieve-result.c, src/lib-
+	sieve/sieve-result.h, src/lib-sieve/sieve-script.c, src/lib-sieve
+	/sieve-script.h, src/lib-sieve/sieve-validator.c, src/lib-sieve
+	/sieve-validator.h, src/lib-sieve/sieve.c, src/lib-sieve/sieve.h,
+	src/sieve-bin/sievec.c, src/testsuite/cmd-test.c, src/testsuite
+	/testsuite-common.c:
+	Resolved all outstanding warnings.
+	[61acd01fe9df]
+
+	* DESIGN, INSTALL, Makefile.am, README, TODO, src/lib-
+	sieve/Makefile.am, src/lib-sieve/plugins/body/Makefile.am, src/lib-
+	sieve/plugins/comparator-i-ascii-numeric/Makefile.am, src/lib-
+	sieve/plugins/copy/Makefile.am, src/lib-
+	sieve/plugins/imapflags/Makefile.am, src/lib-sieve/plugins/imapflags
+	/ext-imapflags-common.c, src/lib-sieve/plugins/include/Makefile.am,
+	src/lib-sieve/plugins/regex/Makefile.am, src/lib-
+	sieve/plugins/relational/Makefile.am, src/lib-
+	sieve/plugins/subaddress/Makefile.am, src/lib-
+	sieve/plugins/vacation/Makefile.am, src/lib-
+	sieve/plugins/variables/Makefile.am:
+	Updated documentation and fixed 'make dist'.
+	[65c7b117ff36]
+
+2008-05-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-generator.h,
+	src/testsuite/Makefile.am, src/testsuite/cmd-test-fail.c,
+	src/testsuite/cmd-test.c, src/testsuite/ext-testsuite.c,
+	src/testsuite/tests/testsuite.sieve, src/testsuite/testsuite-
+	common.c, src/testsuite/testsuite-common.h:
+	Testsuite: added test_fail command.
+	[063d37ff4c79]
+
+	* src/lib-sieve/cmd-if.c, src/lib-sieve/sieve-generator.c, src/lib-
+	sieve/sieve-generator.h, src/lib-sieve/tst-allof.c, src/lib-sieve
+	/tst-anyof.c, src/testsuite/Makefile.am, src/testsuite/cmd-test-
+	set.c, src/testsuite/cmd-test.c, src/testsuite/ext-testsuite.c,
+	src/testsuite/tests/testsuite.sieve, src/testsuite/testsuite-
+	common.h, src/testsuite/testsuite-objects.c:
+	Testsuite: added 'test' command to group sieve statements into a
+	test.
+	[3cc05036846c]
+
+2008-05-27  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/testsuite/cmd-test-set.c, src/testsuite/ext-testsuite.c,
+	src/testsuite/tests/testsuite.sieve, src/testsuite/testsuite-
+	common.c, src/testsuite/testsuite-common.h, src/testsuite/testsuite-
+	objects.c, src/testsuite/testsuite-objects.h:
+	Testsuite: added support for test object members.
+	[62f783ff9f22]
+
+2008-05-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/testsuite/Makefile.am, src/testsuite/cmd-test-set.c,
+	src/testsuite/testsuite-common.c, src/testsuite/testsuite-common.h,
+	src/testsuite/testsuite-objects.c, src/testsuite/testsuite-
+	objects.h:
+	Testsuite: exported testsuit object interface to separate files.
+	[e26637dce509]
+
+	* src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-extensions-
+	private.h, src/testsuite/Makefile.am, src/testsuite/cmd-test-
+	message.c, src/testsuite/cmd-test-set.c, src/testsuite/ext-
+	testsuite.c, src/testsuite/tests/testsuite.sieve, src/testsuite
+	/testsuite-common.c, src/testsuite/testsuite-common.h:
+	Testsuite: implemented testsuite object interface.
+	[3e39d288a27f]
+
+2008-05-21  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README, src/lib-sieve/plugins/vacation/vacation-errors.sieve:
+	vacation: added TODO regarding duplicate tagged arguments to the
+	vacation command.
+	[62ced79fac8a]
+
+	* .hgignore, src/testsuite/testsuite:
+	testsuite: removed spurious binary from repository.
+	[058401bf5f8a]
+
+	* configure.in, src/testsuite/Makefile.am, src/testsuite/cmd-test-
+	message.c, src/testsuite/mail-raw.c,
+	src/testsuite/tests/testsuite.sieve, src/testsuite/testsuite,
+	src/testsuite/testsuite-common.c, src/testsuite/testsuite-common.h,
+	src/testsuite/testsuite.c:
+	Testsuite: setting message content works.
+	[93b3a300c389]
+
+	* src/lib-sieve/sieve-binary-dumper.c, src/lib-sieve/sieve-code-
+	dumper.c, src/lib-sieve/sieve-extensions-private.h, src/lib-sieve
+	/sieve-extensions.c, src/testsuite/cmd-test-message.c, src/testsuite
+	/ext-testsuite.c, src/testsuite/testsuite,
+	src/testsuite/testsuite.c:
+	Fixed execution of initial testsuite implementation.
+	[c1455741740d]
+
+2008-05-20  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/ext-encoded-character.c, src/lib-sieve/ext-envelope.c,
+	src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/ext-body.c, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/ext-cmp-i-ascii-numeric.c, src/lib-sieve/plugins/copy
+	/ext-copy.c, src/lib-sieve/plugins/imapflags/ext-imapflags.c, src
+	/lib-sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-binary.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/plugins/regex
+	/ext-regex.c, src/lib-sieve/plugins/relational/ext-relational.c, src
+	/lib-sieve/plugins/subaddress/ext-subaddress.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-
+	binary-dumper.c, src/lib-sieve/sieve-binary-dumper.h, src/lib-sieve
+	/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-
+	code-dumper.c, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-extensions.h, src/lib-sieve/sieve-match-types.c,
+	src/testsuite/testsuite:
+	Properly implemented dumping a binary including a list of required
+	extensions and support for extension-specific output.
+	[49041cf55a5c]
+
+2008-05-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgignore, src/Makefile.am, src/lib-sieve/Makefile.am, src/lib-sieve
+	/ext-reject.c, src/lib-sieve/plugins/body/ext-body.c, src/lib-
+	sieve/plugins/body/tst-body.c, src/lib-sieve/plugins/imapflags/ext-
+	imapflags-common.c, src/lib-sieve/plugins/imapflags/imapflags.sieve,
+	src/lib-sieve/plugins/imapflags/tag-flags.c, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-sieve/plugins/include
+	/cmd-include.c, src/lib-sieve/plugins/vacation/ext-vacation.c, src
+	/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-arguments.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-operands.c, src/lib-
+	sieve/plugins/variables/tst-string.c, src/lib-sieve/sieve-actions.c,
+	src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-binary-
+	dumper.c, src/lib-sieve/sieve-binary-dumper.h, src/lib-sieve/sieve-
+	binary.c, src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-code-
+	dumper.c, src/lib-sieve/sieve-code-dumper.h, src/lib-sieve/sieve-
+	code.c, src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-common.h,
+	src/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-dump.h, src
+	/lib-sieve/sieve-extensions-private.h, src/lib-sieve/sieve-match-
+	types.c, src/lib-sieve/sieve-result.c, src/lib-sieve/sieve.c, src
+	/lib-sieve/tst-header.c, src/testsuite/Makefile.am, src/testsuite
+	/cmd-test-message.c, src/testsuite/ext-testsuite.c, src/testsuite
+	/mail-raw.c, src/testsuite/mail-raw.h, src/testsuite/namespaces.c,
+	src/testsuite/namespaces.h, src/testsuite/tests/testsuite.sieve,
+	src/testsuite/testsuite, src/testsuite/testsuite-common.h,
+	src/testsuite/testsuite.c:
+	RECOVERED FROM INCONSISTENCY: developed testsuite and binary dumping
+	and fixed various small issues.
+	[5173404351c7]
+
+2008-04-06  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README:
+	Updated documentation.
+	[e80c85bfd227]
+
+	* src/lib-sieve/plugins/include/Makefile.am, src/lib-
+	sieve/plugins/include/cmd-export.c, src/lib-sieve/plugins/include
+	/cmd-import.c, src/lib-sieve/plugins/include/ext-include-common.c,
+	src/lib-sieve/plugins/include/ext-include-variables.c, src/lib-
+	sieve/plugins/include/ext-include-variables.h, src/lib-
+	sieve/plugins/include/include-variables.sieve, src/lib-
+	sieve/plugins/include/include-variables1.sieve, src/lib-
+	sieve/plugins/include/include-variables2.sieve, src/lib-
+	sieve/plugins/include/include-variables3.sieve, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-common.c, src/lib-sieve/plugins/variables/ext-
+	variables-common.h, src/lib-sieve/plugins/variables/ext-variables-
+	operands.c, src/lib-sieve/plugins/variables/ext-variables.c, src
+	/lib-sieve/plugins/variables/sieve-ext-variables.h:
+	Include: merged import and export commands into a single
+	implementation and implemented global variable storage.
+	[2071bd319715]
+
+	* README, src/lib-sieve/plugins/variables/Makefile.am, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-operands.c, src/lib-
+	sieve/plugins/variables/ext-variables-operands.h, src/lib-
+	sieve/plugins/variables/ext-variables.c:
+	Variables: exported new operand definitions to separate file.
+	[1515291be1fe]
+
+2008-04-05  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/Makefile.am, src/lib-
+	sieve/plugins/variables/ext-variables-arguments.c, src/lib-
+	sieve/plugins/variables/ext-variables-arguments.h, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/ext-variables.c:
+	Variables: exported new argument definitions to separate file.
+	[889cea0db5b6]
+
+	* src/lib-sieve/plugins/include/cmd-export.c, src/lib-
+	sieve/plugins/include/cmd-import.c, src/lib-sieve/plugins/include
+	/ext-include-common.c, src/lib-sieve/plugins/include/ext-include-
+	variables.c, src/lib-sieve/plugins/include/ext-include-variables.h:
+	Include: implemented global variable scope.
+	[5cce69ab4eb4]
+
+2008-04-03  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README, src/sieve-bin/sieve-test.c:
+	Added -c option to sieve-test to force compile.
+	[5c2eeabbafbe]
+
+2008-03-24  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README, src/lib-sieve/plugins/include/ext-include.c, src/lib-
+	sieve/plugins/variables/ext-variables.c:
+	Updated documentation.
+	[157a94a31c54]
+
+	* src/lib-sieve/plugins/include/Makefile.am, src/lib-
+	sieve/plugins/include/cmd-export.c, src/lib-sieve/plugins/include
+	/cmd-import.c, src/lib-sieve/plugins/include/ext-include-binary.h,
+	src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include-variables.c, src/lib-
+	sieve/plugins/include/ext-include-variables.h, src/lib-
+	sieve/plugins/include/include-variables1.sieve, src/lib-
+	sieve/plugins/include/include-variables2.sieve:
+	Include: moved variables support to separate file.
+	[9a997c6e97d0]
+
+	* src/lib-sieve/plugins/include/Makefile.am, src/lib-
+	sieve/plugins/include/cmd-export.c, src/lib-sieve/plugins/include
+	/ext-include-binary.c, src/lib-sieve/plugins/include/ext-include-
+	binary.h, src/lib-sieve/plugins/include/ext-include-common.c, src
+	/lib-sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c:
+	Include: moved implementation of binary extension to separate file.
+	[29877e0201ea]
+
+	* src/lib-sieve/plugins/include/cmd-export.c, src/lib-
+	sieve/plugins/include/cmd-import.c, src/lib-sieve/plugins/include
+	/ext-include-common.c, src/lib-sieve/plugins/include/ext-include-
+	common.h, src/lib-sieve/plugins/include/ext-include.c, src/lib-
+	sieve/plugins/include/include-variables-error2.sieve, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h, src/lib-sieve/sieve-
+	ast.c, src/lib-sieve/sieve-ast.h:
+	Include: added AST context and now export context detectects export
+	of imported variables.
+	[7e2750e9e64b]
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/include-error.sieve, src/lib-sieve/sieve-
+	ast.c, src/lib-sieve/sieve-ast.h:
+	Include: moved script existance validation back to validation stage.
+	[f179c5640bed]
+
+	* src/lib-sieve/plugins/include/Makefile.am, src/lib-
+	sieve/plugins/include/cmd-export.c, src/lib-sieve/plugins/include
+	/cmd-import.c, src/lib-sieve/plugins/include/include-variables-
+	error.sieve, src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h:
+	Include: made import and export commands check whether the variables
+	extension is active.
+	[b1e85659979f]
+
+2008-03-23  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/Makefile.am, src/lib-
+	sieve/plugins/include/cmd-export.c, src/lib-sieve/plugins/include
+	/cmd-import.c, src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/plugins/include
+	/include-variables.sieve, src/lib-sieve/plugins/include/include-
+	variables1.sieve, src/lib-sieve/plugins/include/include-
+	variables2.sieve, src/lib-sieve/sieve-generator.c, src/lib-sieve
+	/sieve-script.c:
+	Include: added skeleton import and export commands.
+	[c3f48302b86a]
+
+	* README:
+	Updated TODO.
+	[404001bc4009]
+
+	* src/lib-sieve/plugins/regex/mcht-regex.c, src/lib-
+	sieve/plugins/variables/Makefile.am, src/lib-sieve/plugins/variables
+	/variables-regex.sieve, src/lib-sieve/sieve-match-types.c, src/lib-
+	sieve/sieve-match-types.h:
+	Regex: added match values support.
+	[5dfb64a0f93b]
+
+	* src/lib-sieve/plugins/relational/Makefile.am, src/lib-
+	sieve/plugins/relational/ext-relational-common.c, src/lib-
+	sieve/plugins/relational/ext-relational-common.h, src/lib-
+	sieve/plugins/relational/ext-relational.c, src/lib-
+	sieve/plugins/relational/mcht-count.c, src/lib-
+	sieve/plugins/relational/mcht-value.c:
+	Relational: split match-type implementation into separate file.
+	[c3887aa30660]
+
+	* src/lib-sieve/plugins/regex/Makefile.am, src/lib-sieve/plugins/regex
+	/ext-regex-common.h, src/lib-sieve/plugins/regex/ext-regex.c, src
+	/lib-sieve/plugins/regex/mcht-regex.c:
+	Regex: split match type implementation into separate file.
+	[6de0ef9ce851]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/mcht-contains.c, src/lib-
+	sieve/mcht-is.c, src/lib-sieve/mcht-matches.c, src/lib-
+	sieve/plugins/body/ext-body-common.c, src/lib-sieve/sieve-match-
+	types.c, src/lib-sieve/sieve-match-types.h:
+	Exported match type implementations to separate files.
+	[9c87314c8c6e]
+
+2008-03-22  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/variables-match.sieve, src/lib-sieve
+	/sieve-match-types.c:
+	Finished :matches function for now, but it can still be improved and
+	it needs more testing.
+	[dce3ebd372de]
+
+2008-03-09  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/variables-match.sieve, src/lib-sieve
+	/sieve-match-types.c, src/lib-sieve/sieve-match-types.h:
+	Revised :matches function, but did finish.
+	[361d7952dcc3]
+
+2008-03-08  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/variables-match.sieve, src/lib-sieve
+	/sieve-match-types.c:
+	Variables: fixed bug in match value indexing.
+	[eb6b7af13024]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/plugins/body/tst-body.c,
+	src/lib-sieve/plugins/imapflags/tst-hasflag.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-
+	sieve/plugins/variables/tst-string.c, src/lib-
+	sieve/plugins/variables/variables-match.sieve, src/lib-sieve/sieve-
+	match-types.c, src/lib-sieve/sieve-match-types.h, src/lib-sieve/tst-
+	address.c, src/lib-sieve/tst-header.c:
+	Variables: First work towards match value support.
+	[39ae5f637374]
+
+2008-02-28  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README, src/lib-sieve/plugins/variables/ext-variables.c:
+	Updated documentation.
+	[b01fae741c62]
+
+	* src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/variables-errors.sieve:
+	Variables: added variable name parsing to the set command and added
+	error handling.
+	[636f16de84ad]
+
+	* src/lib-sieve/plugins/variables/Makefile.am, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-name.c, src/lib-
+	sieve/plugins/variables/ext-variables-name.h, src/lib-
+	sieve/plugins/variables/variables-nspace.sieve:
+	Variables: exported namespace+variable parsing to separate file.
+	[1eb6468cbb57]
+
+	* src/lib-sieve/plugins/variables/ext-variables-common.c:
+	Variables: exported namespace+variable parsing to separate function.
+	[324762d634a0]
+
+	* README:
+	Updated documentation.
+	[2d7d8b3882d6]
+
+2008-02-27  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/plugins/variables/ext-
+	variables-common.c:
+	Variables: added parsing support for namespaces.
+	[be3b8bac2c3b]
+
+	* src/lib-sieve/plugins/variables/tst-string.c:
+	Variables: fixed string test.
+	[6b07d2c2aecf]
+
+2008-02-26  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Expand ~ to home in sieve path.
+	[5a26dbbd6b04]
+
+2008-02-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-binary.c:
+	Fixed indent in sieve-banary.c
+	[b3ad65e8017e]
+
+	* src/lib-sieve/sieve-script.c:
+	Simplified needlessly complex assignment.
+	[71baeea1b4c2]
+
+	* README:
+	Added TODO item.
+	[5e891151c11d]
+
+	* src/lib-sieve/plugins/regex/ext-regex.c, src/lib-sieve/sieve-
+	comparators.c:
+	Avoid direct to_lower() invocations; replaced by i_tolower().
+	[4a4da0b36b73]
+
+	* README:
+	Updated documentation.
+	[23fddcb3bff4]
+
+	* src/lib-sieve/plugins/regex/ext-regex.c, src/lib-sieve/sieve-code.c,
+	src/lib-sieve/sieve-match-types.c:
+	Changed various p_new(pool_datastack_create(),) invocations to
+	t_new()
+	[4a350bcb98fb]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-
+	sieve/plugins/variables/variables.sieve:
+	Envelope: changed p_array_init(,pool_datastack_create(),) into
+	t_array_init(,)
+	[d2659865968c]
+
+	* README:
+	Updated documentation.
+	[8854635f2819]
+
+2008-02-23  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/variables.sieve, src/lib-sieve/sieve-code.c:
+	Variables: fixed bug in string-list containing variables.
+	[bda964bee9f5]
+
+	* src/lib-sieve/plugins/regex/ext-regex.c, src/lib-
+	sieve/plugins/variables/tst-string.c, src/lib-
+	sieve/plugins/variables/variables.sieve, src/lib-sieve/sieve-
+	commands.c:
+	Fixed bugs in string substitution support and the regex extension.
+	[2c93a6f1f120]
+
+	* src/lib-sieve/plugins/variables/draft-ietf-sieve-variables-08.txt,
+	src/lib-sieve/plugins/variables/ext-variables.c, src/lib-
+	sieve/plugins/variables/rfc5229.txt:
+	Variables: updated included specification to new RFC 5229.
+	[970977365e61]
+
+	* README:
+	Updated documentation.
+	[8223da28978b]
+
+	* src/lib-sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/variables.sieve:
+	Variables: made variable identifiers case insensitive.
+	[22ba1d548f77]
+
+2008-02-22  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/variables-errors.sieve:
+	Variables: added check for equal precedence and added comment.
+	[78ac4b9fd4b7]
+
+	* src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/variables.sieve:
+	Variables: activated 'quotewildcard' set modifier and fixed a bug.
+	[f5cc923c0cf8]
+
+	* src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/variables.sieve:
+	Variables: activated 'length' set modifier.
+	[571ff4050c4e]
+
+	* src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/variables.sieve:
+	Variables: activated support for set command modifiers.
+	[9c3840cc68f6]
+
+	* src/lib-sieve/plugins/body/ext-body-common.c:
+	Adjusted body extension to compile with dovecot past 1.1.beta16
+	(message parser changes)
+	[854549e5e6d9]
+
+2008-02-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* AUTHORS:
+	Added notice about the omission CMU code to the AUTHORS file.
+	[e10b34c008dd]
+
+	* .hgignore, configure.in:
+	Assigned proper package version and name.
+	[19fa7bfb0623]
+
+	* .hgignore, COPYING:
+	Removed duplicate licence.
+	[be7aad6c814d]
+
+	* Makefile.am:
+	Added maintainermode functions to Makefile.am
+	[fdf2ea8d11d3]
+
+2008-02-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/ext-encoded-character.c, src/lib-sieve/plugins/body
+	/ext-body-common.c, src/lib-sieve/sieve-address-parts.c, src/lib-
+	sieve/sieve-ast.c, src/lib-sieve/sieve-binary.c, src/lib-sieve
+	/sieve-commands.c, src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-
+	error.h, src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-lexer.c, src/lib-sieve/sieve-
+	parser.c, src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve.c,
+	src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Incorporated changes in dovecot-1.1
+	[c8c67641d0dc]
+
+2008-02-11  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/variables.sieve:
+	Variables: set modifiers are now sorted.
+	[5ceb8e6709ef]
+
+2008-02-10  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h:
+	Added code support for set modifiers.
+	[edba29e3d158]
+
+2008-01-06  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-envelope.c, src/lib-
+	sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/tst-body.c, src/lib-sieve/plugins/imapflags/ext-
+	imapflags-common.c, src/lib-sieve/plugins/imapflags/tst-hasflag.c,
+	src/lib-sieve/plugins/vacation/ext-vacation.c, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-common.c, src/lib-sieve/plugins/variables/tst-
+	string.c, src/lib-sieve/plugins/variables/variables.sieve, src/lib-
+	sieve/sieve-validator.c, src/lib-sieve/tst-address.c, src/lib-sieve
+	/tst-exists.c, src/lib-sieve/tst-header.c, src/lib-sieve/tst-size.c:
+	Fixed bugs in validation error handling and fixed bugs in dynamic
+	argument support.
+	[207f7dea843e]
+
+2008-01-05  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-
+	sieve/plugins/variables/variables.sieve, src/lib-sieve/sieve-ast.c,
+	src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-validator.c:
+	First successful variable substitutions.
+	[beaacb4d8406]
+
+	* Merged concurrent changes.
+	[8e8f0012b6c1]
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-envelope.c, src/lib-
+	sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/tst-body.c, src/lib-sieve/plugins/imapflags/cmd-
+	addflag.c, src/lib-sieve/plugins/imapflags/cmd-removeflag.c, src
+	/lib-sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/imapflags
+	/tst-hasflag.c, src/lib-sieve/plugins/vacation/ext-vacation.c, src
+	/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h, src/lib-
+	sieve/plugins/variables/tst-string.c, src/lib-sieve/sieve-actions.c,
+	src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-address-parts.c,
+	src/lib-sieve/sieve-address-parts.h, src/lib-sieve/sieve-code.c, src
+	/lib-sieve/sieve-code.h, src/lib-sieve/sieve-comparators.c, src/lib-
+	sieve/sieve-comparators.h, src/lib-sieve/sieve-interpreter.c, src
+	/lib-sieve/sieve-match-types.c, src/lib-sieve/sieve-match-types.h,
+	src/lib-sieve/tst-address.c, src/lib-sieve/tst-exists.c, src/lib-
+	sieve/tst-header.c, src/lib-sieve/tst-size.c:
+	Changed operand read API to get access to the runtime environment
+	inside the read functions.
+	[be351797c032]
+
+2008-01-04  Stephan Bosch  <stephan@rename-it.nl>
+
+	* sieve/errors/interesting.sieve, src/lib-sieve/sieve-parser.c:
+	Minor fix in the error reporting of the sieve parser.
+	[d403335a9351]
+
+	* src/lib-sieve/sieve-extensions.c, src/lib-sieve/sieve-extensions.h,
+	src/lib-sieve/sieve.c:
+	Implemented dynamic sieve_get_capabilities() for proper MANAGESIEVE
+	support.
+	[5ecaa79ab879]
+
+	* src/lib-sieve/sieve.c, src/lib-sieve/sieve.h:
+	Published compiler API using script objects instead of paths.
+	[16d8c8b63bcc]
+
+	* src/lib-sieve/sieve-validator.c:
+	Fixed segfault occuring when command did not exist.
+	[31182d66d254]
+
+	* src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-script.c:
+	Small changes: removed T_FRAME and improved an error message.
+	[dac13553f2fa]
+
+2008-01-03  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/plugins/include/ext-
+	include-common.c, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-
+	error-private.h, src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-
+	error.h, src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-lexer.c, src/lib-sieve/sieve-
+	parser.c, src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-script-
+	private.h, src/lib-sieve/sieve-script.c, src/lib-sieve/sieve-
+	script.h, src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve.c,
+	src/lib-sieve/sieve.h, src/plugins/lda-sieve/lda-sieve-plugin.c, src
+	/sieve-bin/bin-common.c, src/sieve-bin/sieve-exec.c, src/sieve-bin
+	/sieve-test.c:
+	Implemented required features for use with MANAGESIEVE service.
+	[41d479d33f26]
+
+	* src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-error.h:
+	Added strbuf error handler.
+	[57118bf13efc]
+
+2007-12-30  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-
+	code.c, src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-
+	comparators.c, src/lib-sieve/sieve-match-types.c:
+	Added variable operand to the variables extension.
+	[cd89ce24b255]
+
+	* src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-address-parts.c,
+	src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h, src/lib-
+	sieve/sieve-comparators.c, src/lib-sieve/sieve-extensions.h, src
+	/lib-sieve/sieve-match-types.c:
+	Added support for adding new types operands to the engine.
+	[6f5eadd0e4c8]
+
+	* src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h:
+	Defined variable argument for the variables extension.
+	[b0552c08b279]
+
+2007-12-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-generator.c, src
+	/lib-sieve/sieve-generator.h, src/lib-sieve/sieve-validator.c, src
+	/lib-sieve/sieve-validator.h:
+	Changed validation and generation of string list argument to fully
+	support the new string list encoding.
+	[f65dd8431ae8]
+
+	* src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-binary.c, src
+	/lib-sieve/sieve-code.c:
+	Changed encoding of stringlist. Now it contains string operands in
+	stead of bare strings.
+	[7bac41b7e6c1]
+
+	* src/lib-sieve/sieve-extensions-private.h:
+	Removed obsolete code.
+	[9aeb0333b0d7]
+
+	* sieve/tests/address-part.sieve, src/lib-sieve/ext-encoded-
+	character.c, src/lib-sieve/ext-envelope.c, src/lib-sieve/ext-
+	fileinto.c, src/lib-sieve/ext-reject.c, src/lib-sieve/plugins/body
+	/ext-body.c, src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-
+	cmp-i-ascii-numeric.c, src/lib-sieve/plugins/copy/ext-copy.c, src
+	/lib-sieve/plugins/imapflags/tag-flags.c, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/plugins/regex
+	/ext-regex.c, src/lib-sieve/plugins/relational/ext-relational.c, src
+	/lib-sieve/plugins/subaddress/ext-subaddress.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-
+	code.c, src/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-
+	comparators.h, src/lib-sieve/sieve-extensions-private.h, src/lib-
+	sieve/sieve-extensions.h, src/lib-sieve/sieve-generator.c, src/lib-
+	sieve/sieve-match-types.c, src/lib-sieve/sieve-validator.c:
+	Removed much code duplication between extensions that provide
+	support for further extension.
+	[3009bde82cd7]
+
+2007-12-27  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-
+	numeric.c, src/lib-sieve/plugins/regex/ext-regex.c, src/lib-
+	sieve/plugins/relational/ext-relational.c, src/lib-
+	sieve/plugins/subaddress/ext-subaddress.c, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-address-parts.h, src/lib-sieve
+	/sieve-code.c, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-comparators.h, src/lib-sieve/sieve-extensions-private.h, src
+	/lib-sieve/sieve-match-types.c, src/lib-sieve/sieve-match-types.h:
+	Further migrated implementation of extensions to new extension
+	architecture.
+	[4ac0b9e8635c]
+
+	* src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-if.c, src/lib-sieve
+	/cmd-keep.c, src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-
+	encoded-character.c, src/lib-sieve/ext-envelope.c, src/lib-sieve
+	/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/ext-body.c, src/lib-sieve/plugins/body/tst-
+	body.c, src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i
+	-ascii-numeric.c, src/lib-sieve/plugins/copy/copy.sieve, src/lib-
+	sieve/plugins/copy/ext-copy.c, src/lib-sieve/plugins/imapflags/cmd-
+	addflag.c, src/lib-sieve/plugins/imapflags/cmd-removeflag.c, src
+	/lib-sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/imapflags
+	/tst-hasflag.c, src/lib-sieve/plugins/include/cmd-include.c, src
+	/lib-sieve/plugins/include/cmd-return.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/plugins/regex
+	/ext-regex.c, src/lib-sieve/plugins/relational/ext-relational.c, src
+	/lib-sieve/plugins/subaddress/ext-subaddress.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-common.h, src/lib-sieve/plugins/variables/ext-
+	variables.c, src/lib-sieve/plugins/variables/tst-string.c, src/lib-
+	sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h, src/lib-sieve
+	/sieve-address-parts.c, src/lib-sieve/sieve-binary.c, src/lib-sieve
+	/sieve-binary.h, src/lib-sieve/sieve-code-dumper.c, src/lib-sieve
+	/sieve-code-dumper.h, src/lib-sieve/sieve-code.c, src/lib-sieve
+	/sieve-code.h, src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-
+	common.h, src/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-
+	extensions-private.h, src/lib-sieve/sieve-extensions.c, src/lib-
+	sieve/sieve-extensions.h, src/lib-sieve/sieve-generator.c, src/lib-
+	sieve/sieve-generator.h, src/lib-sieve/sieve-interpreter.c, src/lib-
+	sieve/sieve-match-types.c, src/lib-sieve/sieve-validator.c, src/lib-
+	sieve/sieve.c, src/lib-sieve/tst-address.c, src/lib-sieve/tst-
+	allof.c, src/lib-sieve/tst-anyof.c, src/lib-sieve/tst-exists.c, src
+	/lib-sieve/tst-header.c, src/lib-sieve/tst-size.c:
+	Major changes in the extensions support.
+	[8b74028295fd]
+
+2007-12-26  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-address-
+	parts.h, src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-commands.c,
+	src/lib-sieve/sieve-commands.h, src/lib-sieve/sieve-comparators.c,
+	src/lib-sieve/sieve-comparators.h, src/lib-sieve/sieve-match-
+	types.c, src/lib-sieve/sieve-match-types.h, src/lib-sieve/sieve-
+	validator.c, src/lib-sieve/sieve-validator.h:
+	Changed implementation of command context handling and instanced
+	tags to avoid duplicate lookups.
+	[74d12bfed7c8]
+
+	* src/lib-sieve/plugins/variables/Makefile.am, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-common.c, src/lib-sieve/plugins/variables/ext-
+	variables-common.h, src/lib-sieve/plugins/variables/ext-variables.c,
+	src/lib-sieve/plugins/variables/tst-string.c, src/lib-
+	sieve/plugins/variables/variables.sieve:
+	Further developed the variables extension.
+	[492938049fc1]
+
+2007-12-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README, configure.in, src/lib-sieve/Makefile.am, src/lib-
+	sieve/plugins/Makefile.am, src/lib-
+	sieve/plugins/variables/Makefile.am, src/lib-sieve/plugins/variables
+	/draft-ietf-sieve-variables-08.txt, src/lib-sieve/plugins/variables
+	/ext-variables.c, src/lib-sieve/plugins/variables/variables.sieve,
+	src/lib-sieve/sieve-extensions.c:
+	Started skeleton implementation of variables extension.
+	[cac5b0cdb8e6]
+
+	* sieve/tests/encoded-character.sieve, src/lib-sieve/ext-encoded-
+	character.c:
+	Fixed non-standard behavior for the encoded-character extension.
+	[6900d4693821]
+
+	* README, sieve/errors/encoded-character.sieve, sieve/tests/encoded-
+	character.sieve, src/lib-sieve/ext-encoded-character.c, src/lib-
+	sieve/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/sieve-bin
+	/mail-raw.c:
+	Finished encoded-character extension.
+	[dd6a814d5350]
+
+	* doc/rfc/rfc3629.txt:
+	Added UTF-8 rfc to doc/rfc directory.
+	[772db2c40fd1]
+
+	* sieve/tests/encoded-character.sieve, src/lib-sieve/ext-encoded-
+	character.c, src/lib-sieve/sieve-validator.c:
+	Built a little more extensive tests for the encoded-character
+	extension.
+	[f6cba45b3299]
+
+2007-12-24  Stephan Bosch  <stephan@rename-it.nl>
+
+	* sieve/tests/encoded-character.sieve, src/lib-sieve/cmd-redirect.c,
+	src/lib-sieve/ext-encoded-character.c, src/lib-sieve/ext-envelope.c,
+	src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/tst-body.c, src/lib-sieve/plugins/imapflags/ext-
+	imapflags-common.c, src/lib-sieve/plugins/imapflags/tst-hasflag.c,
+	src/lib-sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-
+	ast.h, src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve-
+	validator.h, src/lib-sieve/tst-address.c, src/lib-sieve/tst-
+	exists.c, src/lib-sieve/tst-header.c, src/lib-sieve/tst-size.c:
+	Encoded character extension basicly works, but no unicode support is
+	implemented.
+	[0c62d3501b83]
+
+2007-12-19  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-keep.c, src/lib-sieve
+	/cmd-redirect.c, src/lib-sieve/cmd-require.c, src/lib-sieve/ext-
+	encoded-character.c, src/lib-sieve/ext-envelope.c, src/lib-sieve
+	/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/tst-body.c, src/lib-sieve/plugins/imapflags/cmd-
+	addflag.c, src/lib-sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/imapflags
+	/tst-hasflag.c, src/lib-sieve/plugins/include/cmd-return.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-address-
+	parts.c, src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-code-
+	dumper.c, src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-
+	commands.h, src/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-
+	comparators.h, src/lib-sieve/sieve-generator.h, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-parser.h, src/lib-sieve/sieve-
+	validator.c, src/lib-sieve/sieve-validator.h, src/lib-sieve/tst-
+	address.c, src/lib-sieve/tst-allof.c, src/lib-sieve/tst-anyof.c, src
+	/lib-sieve/tst-exists.c, src/lib-sieve/tst-header.c, src/lib-sieve
+	/tst-not.c, src/lib-sieve/tst-size.c:
+	Implemented support for overriding default argument implementations
+	of number, string and string-list.
+	[811636f212aa]
+
+2007-12-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* doc/rfc/draft-ietf-sieve-3028bis-13.txt, doc/rfc/rfc3028.txt:
+	Added sieve rfc and new sieve 3028bis to the doc/rfc directory.
+	[cf0d3511810b]
+
+	* doc/rfc:
+	Removed erroneous rfc file from new doc dir.
+	[50462444b677]
+
+	* doc/rfc, sieve/tests/encoded-character.sieve, src/lib-sieve/ext-
+	encoded-character.c:
+	Forgot to add new files.
+	[ec01147fbf36]
+
+	* README:
+	Updated documentation.
+	[d870f0bb6228]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/sieve-extensions.c:
+	Started skeleton for the encoded-character extension.
+	[915854a9a6e7]
+
+	* README:
+	Updated TODO list.
+	[c4f08e56f98f]
+
+	* README, src/lib-sieve/plugins/body/ext-body.c:
+	Updated documentation.
+	[7853b0fd8c2f]
+
+	* src/lib-sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c:
+	Changed imapflags extension to use the message context instead of
+	the interpreter context.
+	[73f99ee08abb]
+
+	* src/lib-sieve/plugins/body/ext-body-common.c:
+	Changed body extension to use the message context instead of the
+	interpreter context.
+	[c769d7261264]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-sieve
+	/sieve-interpreter.c, src/lib-sieve/sieve-interpreter.h:
+	Introduced message context to give extensions the ability to
+	associate context data with the currently processed message.
+	[08a085d3c1b9]
+
+	* README, src/lib-sieve/plugins/body/ext-body.c:
+	Updated documentation.
+	[d47f4b7439d2]
+
+	* src/lib-sieve/plugins/body/body.sieve, src/lib-sieve/plugins/body
+	/ext-body-common.c, src/lib-sieve/plugins/body/tst-body.c:
+	Fixed minor bug in the body extension.
+	[c8ea2fb589cc]
+
+	* AUTHORS, src/lib-sieve/plugins/body/Makefile.am, src/lib-
+	sieve/plugins/body/body.sieve, src/lib-sieve/plugins/body/ext-body-
+	common.c, src/lib-sieve/plugins/body/ext-body-common.h, src/lib-
+	sieve/plugins/body/ext-body.c, src/lib-sieve/plugins/body/tst-
+	body.c, src/lib-sieve/plugins/imapflags/tst-hasflag.c, src/lib-sieve
+	/sieve-address-parts.c, src/lib-sieve/sieve-match-types.c, src/lib-
+	sieve/sieve-match-types.h, src/lib-sieve/tst-header.c:
+	Implemented evaluation for the body test introduced by the body
+	extension.
+	[7dc23ed0c79f]
+
+	* src/lib-sieve/plugins/body/ext-body.c, src/lib-sieve/sieve-
+	extensions.c, src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-
+	generator.h:
+	Implemented validation and code generation for body extension.
+	[24a83b8759f7]
+
+	* README, configure.in, src/lib-sieve/Makefile.am, src/lib-
+	sieve/plugins/Makefile.am, src/lib-sieve/plugins/body/Makefile.am,
+	src/lib-sieve/plugins/body/draft-ietf-sieve-body-07.txt, src/lib-
+	sieve/plugins/body/ext-body.c:
+	Started skeleton for the body extension.
+	[87141cd62e03]
+
+	* README, src/lib-sieve/plugins/include/ext-include.c:
+	Updated documentation.
+	[ebdc3d4b1ebb]
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/cmd-return.c, src/lib-sieve/plugins/include
+	/ext-include-common.c, src/lib-sieve/plugins/include/ext-include-
+	common.h, src/lib-sieve/plugins/include/included2.sieve, src/lib-
+	sieve/sieve-binary.c:
+	Implemented return command for include extension.
+	[2ecc3c3f89cf]
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/sieve-binary.c,
+	src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-error.c:
+	Basic include functionality seems to be working and if source
+	scripts are changed the binary is always recompiled.
+	[4d87cc13eb79]
+
+2007-12-16  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/sieve-binary.c,
+	src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-script.c, src/lib-
+	sieve/sieve-script.h, src/lib-sieve/sieve.c:
+	Working towards proper dependency handling for sieve binaries.
+	[7055341a175d]
+
+	* src/lib-sieve/sieve-binary.c:
+	Added support for lazy binary load.
+	[443f611ba331]
+
+2007-12-15  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-sieve/sieve-
+	binary.c:
+	Added internal support for different methods of loading a binary.
+	[06efb6d54463]
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/sieve-binary.c,
+	src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve.c, src/sieve-
+	bin/sieved.c:
+	Working towards complete binary support for the include extension.
+	[1f60d0e233a2]
+
+2007-12-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README:
+	Updated documentation.
+	[cd70b1e8764f]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/included2.sieve, src/lib-sieve/sieve-binary.c,
+	src/lib-sieve/sieve-interpreter.c:
+	Fixed bug regarding stop command in combination with include
+	extension.
+	[84c480ec5cd3]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c:
+	Simplified the include loop a little.
+	[e930ac1deb4e]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/include.sieve, src/lib-
+	sieve/plugins/include/included2.sieve, src/lib-sieve/sieve-binary.c,
+	src/lib-sieve/sieve-binary.h:
+	Implemented mostly untested deep-level include execution support.
+	[c88db860a282]
+
+2007-12-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-
+	sieve/sieve.c:
+	First successful (single level) execution of four consecutive
+	includes.
+	[5f1564b65675]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-sieve
+	/sieve-commands.c, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/sieve-interpreter.h:
+	Added support for interrupting an interpreter and continuing
+	execution later.
+	[1af35588edfc]
+
+	* src/lib-sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/include/cmd-include.c, src/lib-sieve/plugins/include
+	/ext-include-common.c, src/lib-sieve/plugins/include/ext-include-
+	common.h, src/lib-sieve/plugins/include/ext-include.c:
+	Include extension now generates include opcode. Not executable yet
+	though.
+	[ac8496b3d19c]
+
+	* src/lib-sieve/sieve-binary.c:
+	Implemented the binary_free event for binary extensions. Script
+	references in the include extension are now properly released.
+	[d0a0bbdaf6b0]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/sieve-binary.c,
+	src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-common.h:
+	Fixed behavior of binary object with respect to pre-loaded
+	extensons. Broke it with last change.
+	[ce0e32e63adc]
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-
+	sieve/sieve-extensions.c, src/lib-sieve/sieve-extensions.h:
+	Changed binary object's extension linkage for extending the binary
+	itself.
+	[5633827bd892]
+
+2007-12-11  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/sieve-script.c,
+	src/lib-sieve/sieve-script.h:
+	Doubly included scripts are no longer compiled and included multiple
+	times.
+	[64ffbd9afaaa]
+
+	* src/lib-sieve/plugins/include/included1.sieve, src/lib-sieve/sieve-
+	binary.c:
+	Forgot to set the number of blocks in the binary header.
+	[69967868a8cc]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/included1.sieve:
+	Re-established circular include detection for include extension.
+	[e8867e044d2c]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/included1.sieve, src/lib-sieve/sieve-binary.c,
+	src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-generator.h,
+	src/lib-sieve/sieve.c:
+	Further developed the include extension to compile included scripts
+	in additional blocks of the binary.
+	[6d0b5b112f00]
+
+2007-12-10  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-
+	sieve/sieve-generator.c, src/lib-sieve/sieve-generator.h, src/lib-
+	sieve/sieve.c:
+	Further developed the binary format: binary can now contain multiple
+	blocks with arbitrary data.
+	[958ac41805fc]
+
+	* README:
+	Updated documentation: Changed priorities in TODO list.
+	[c27f92353192]
+
+	* README:
+	Updated documentation.
+	[b1b5f7d6ff6c]
+
+2007-12-09  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-
+	sieve/plugins/include/included1.sieve, src/lib-sieve/sieve-ast.c,
+	src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-binary.c, src/lib-
+	sieve/sieve-binary.h, src/lib-sieve/sieve-commands.h, src/lib-sieve
+	/sieve-error.h, src/lib-sieve/sieve-generator.c, src/lib-sieve
+	/sieve-generator.h, src/lib-sieve/sieve-script.c, src/lib-sieve
+	/sieve-validator.c, src/lib-sieve/sieve-validator.h, src/lib-
+	sieve/sieve.c, src/sieve-bin/sieved.c:
+	Moved actual include operation from validator to generator stage.
+	[c49356652255]
+
+	* .hgignore, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-
+	script.c, src/lib-sieve/sieve-script.h, src/lib-sieve/sieve.c, src
+	/lib-sieve/sieve.h, src/sieve-bin/bin-common.c, src/sieve-bin/bin-
+	common.h, src/sieve-bin/sieve-exec.c, src/sieve-bin/sieve-test.c,
+	src/sieve-bin/sievec.c:
+	Sieve executables now work with binaries too.
+	[8e7a1b3c0ad9]
+
+	* .hgignore, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-
+	binary.h, src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-
+	extensions.c, src/lib-sieve/sieve-extensions.h, src/lib-sieve/sieve-
+	generator.c, src/lib-sieve/sieve-script.c, src/sieve-
+	bin/Makefile.am, src/sieve-bin/sievec.c, src/sieve-bin/sieved.c:
+	Made a basic implementation of saving binaries to disk.
+	[60a7a53897cf]
+
+2007-12-08  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/include.sieve, src/lib-
+	sieve/plugins/include/included2.sieve, src/lib-sieve/sieve-ast.c,
+	src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-parser.c, src/lib-
+	sieve/sieve.c:
+	Cleaned up ast implementation a little.
+	[82fb78a39773]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/included2.sieve, src/lib-
+	sieve/plugins/include/included3.sieve, src/lib-sieve/sieve.c:
+	Prevented more scripts from being included when errors have occured.
+	[fade5794fecf]
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/included3.sieve, src/lib-sieve/sieve-lexer.c,
+	src/lib-sieve/sieve-script.c, src/lib-sieve/sieve-script.h, src/lib-
+	sieve/sieve.c:
+	Properly implemented circular include detection for the include
+	extension.
+	[d3b8e1347bb5]
+
+	* src/lib-sieve/Makefile.am, src/lib-
+	sieve/plugins/include/Makefile.am, src/lib-sieve/plugins/include
+	/cmd-include.c, src/lib-sieve/plugins/include/ext-include-common.c,
+	src/lib-sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-
+	sieve/plugins/include/include.sieve, src/lib-
+	sieve/plugins/include/included1.sieve, src/lib-
+	sieve/plugins/include/included2.sieve, src/lib-
+	sieve/plugins/include/included3.sieve, src/lib-sieve/sieve-ast.c,
+	src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-commands.h, src/lib-
+	sieve/sieve-common.h, src/lib-sieve/sieve-error.c, src/lib-sieve
+	/sieve-error.h, src/lib-sieve/sieve-lexer.c, src/lib-sieve/sieve-
+	lexer.h, src/lib-sieve/sieve-parser.c, src/lib-sieve/sieve-parser.h,
+	src/lib-sieve/sieve-script.c, src/lib-sieve/sieve-script.h, src/lib-
+	sieve/sieve-validator.c, src/lib-sieve/sieve-validator.h, src/lib-
+	sieve/sieve.c, src/lib-sieve/sieve.h:
+	First defined an encapsulating script object and implemented part of
+	the include extension.
+	[20278c7b7254]
+
+2007-12-07  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README, configure.in, src/lib-sieve/Makefile.am, src/lib-
+	sieve/plugins/Makefile.am, src/lib-
+	sieve/plugins/include/Makefile.am, src/lib-sieve/plugins/include
+	/cmd-include.c, src/lib-sieve/plugins/include/cmd-return.c, src/lib-
+	sieve/plugins/include/draft-daboo-sieve-include-05.txt, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-
+	sieve/plugins/include/include.sieve, src/lib-sieve/sieve-
+	extensions.c:
+	Started skeleton implementation for the include extension.
+	[fae946e07bd2]
+
+	* README, src/lib-sieve/plugins/vacation/ext-vacation.c:
+	Updated documentation.
+	[3ffe74253949]
+
+2007-12-06  Stephan Bosch  <stephan@rename-it.nl>
+
+	* sieve/tests/vacation.sieve, src/lib-sieve/plugins/vacation/ext-
+	vacation.c:
+	Added :addresses support to the vacation extension.
+	[22045e56dec8]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/plugins/imapflags/cmd-
+	addflag.c, src/lib-sieve/plugins/imapflags/cmd-removeflag.c, src
+	/lib-sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/sieve-code.c, src
+	/lib-sieve/sieve-code.h, src/lib-sieve/tst-address.c, src/lib-sieve
+	/tst-exists.c, src/lib-sieve/tst-header.c:
+	Added support for reading an entire stringlist into memory. Also
+	fixed various identical bugs in stringlist-related error handling.
+	[a2ae74cddb58]
+
+	* README:
+	Added two TODO items.
+	[5b3f80ba5fa5]
+
+	* README, src/lib-sieve/plugins/vacation/ext-vacation.c:
+	Tiny update to documentation and removed a compiler warning.
+	[57bef612b360]
+
+	* src/lib-sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-
+	generator.c:
+	Added :mime support to vacation extension.
+	[e0170e8422a7]
+
+	* src/lib-sieve/cmd-keep.c, src/lib-sieve/cmd-redirect.c, src/lib-
+	sieve/ext-reject.c, src/lib-sieve/plugins/vacation/ext-vacation.c,
+	src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h, src
+	/lib-sieve/sieve-interpreter.c, src/lib-sieve/sieve-interpreter.h,
+	src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-result.h, src/lib-
+	sieve/sieve.c, src/lib-sieve/sieve.h, src/plugins/lda-sieve/lda-
+	sieve-plugin.c, src/sieve-bin/sieve-exec.c, src/sieve-bin/sieve-
+	test.c:
+	Renamed mail_environment to script_env.
+	[357df85b1c14]
+
+	* README, src/lib-sieve/cmd-redirect.c:
+	Added mail-loop detection to the redirect action.
+	[5208c9de6da9]
+
+	* src/lib-sieve/sieve-interpreter.c, src/lib-sieve/sieve-
+	interpreter.h, src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-
+	result.h, src/lib-sieve/sieve.c, src/lib-sieve/sieve.h, src/plugins
+	/lda-sieve/lda-sieve-plugin.c, src/sieve-bin/sieve-exec.c:
+	Changed execution error handling a little.
+	[9bedd7aaed60]
+
+	* src/lib-sieve/ext-reject.c, src/lib-sieve/sieve-address-parts.c, src
+	/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-commands.c, src/lib-
+	sieve/sieve-error.c, src/lib-sieve/sieve-error.h, src/lib-sieve
+	/sieve-generator.c, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/sieve-lexer.c, src/lib-sieve/sieve-parser.c, src/lib-sieve/sieve-
+	validator.c:
+	Adopted code to use Dovecot's new T_FRAME* macros.
+	[7d056b0525a8]
+
+	* src/lib-sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-
+	code-dumper.h, src/lib-sieve/sieve-error.h, src/lib-sieve/sieve-
+	interpreter.h, src/lib-sieve/sieve-lexer.c, src/lib-sieve/sieve-
+	parser.c, src/lib-sieve/sieve-result.h, src/lib-sieve/sieve-
+	validator.h:
+	Added proper ATTR_FORMAT to all functions that accept a string
+	format and fixed one bug in the process.
+	[ed5bbe4892fe]
+
+	* README:
+	Further updated documentation and cleaned up the README file.
+	[34dd6d80f884]
+
+	* INSTALL, README:
+	Updated documentation. We are gettin closer to a first release.
+	[ba0d6c952726]
+
+	* src/lib-sieve/ext-fileinto.c, src/lib-sieve/sieve-interpreter.c, src
+	/lib-sieve/sieve-result.c, src/sieve-bin/bin-common.c, src/sieve-bin
+	/sieve-exec.c:
+	Implemented implicit keep to execute when not canceled or when the
+	preceeding action execution fails.
+	[83139c099737]
+
+2007-12-05  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-interpreter.c:
+	Fixed minor bugs in the error reporting.
+	[3cf617a5c19b]
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Fixed tiny bug in the error reporting in the lda-sieve plugin.
+	[dd6d34c328e0]
+
+	* src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-error.h, src/lib-
+	sieve/sieve-interpreter.c, src/lib-sieve/sieve-interpreter.h, src
+	/lib-sieve/sieve-result.c, src/lib-sieve/sieve-result.h, src/lib-
+	sieve/sieve.c, src/lib-sieve/sieve.h, src/plugins/lda-sieve/lda-
+	sieve-plugin.c, src/sieve-bin/sieve-exec.c, src/sieve-bin/sieve-
+	test.c:
+	Further developed the error handling.
+	[b440e2ecb968]
+
+2007-12-04  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Added a little more error logging to the lda-sieve plugin.
+	[22100a6b83a0]
+
+	* src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-error.h,
+	src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Implemented logfile error handler and assigned it to the lda-sieve
+	plugin.
+	[1dd0d188e90d]
+
+2007-12-03  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-ast.h, src/lib-sieve
+	/sieve-error.c, src/lib-sieve/sieve-error.h, src/lib-sieve/sieve-
+	lexer.c, src/lib-sieve/sieve-lexer.h, src/lib-sieve/sieve-parser.c,
+	src/lib-sieve/sieve-parser.h, src/lib-sieve/sieve-validator.c, src
+	/lib-sieve/sieve.c, src/lib-sieve/sieve.h, src/plugins/lda-sieve
+	/lda-sieve-plugin.c, src/sieve-bin/bin-common.c, src/sieve-
+	bin/sievec.c:
+	Further developed error handling.
+	[38b7c79a1bc9]
+
+2007-12-02  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Forgot to initialize sieve library in lda-sieve plugin. It has now
+	successfully delivered its first message.
+	[0bb383b96a44]
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c, src/plugins/lda-sieve/lda-
+	sieve-plugin.h:
+	Fixed misnamed module entry points for the lda-sieve plugin.
+	[b8b366a08231]
+
+	* configure.in, src/Makefile.am, src/lib-sieve/sieve.c, src/lib-
+	sieve/sieve.h, src/plugins/lda-sieve/Makefile.am, src/plugins/lda-
+	sieve/lda-sieve-plugin.c, src/plugins/lda-sieve/lda-sieve-plugin.h,
+	src/sieve-bin/bin-common.c:
+	Included sieve plugin into the build process.
+	[0eee6014369f]
+
+	* README, src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c,
+	src/lib-sieve/plugins/vacation/ext-vacation.c, src/lib-
+	sieve/sieve.c, src/lib-sieve/sieve.h, src/plugins/lda-sieve/lda-
+	sieve-plugin.c, src/sieve-bin/sievec.c:
+	Documentation updates.
+	[f48f95ebfcad]
+
+	* src/lib-sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-code-dumper.c, src/lib-sieve/sieve-
+	error.c, src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve.c, src
+	/lib-sieve/sieve.h, src/sieve-bin/bin-common.c, src/sieve-bin/bin-
+	common.h, src/sieve-bin/sieve-exec.c, src/sieve-bin/sieve-test.c,
+	src/sieve-bin/sievec.c:
+	Implemented sieve test binaries further. They now have proper
+	command line arguments.
+	[c1e500086b9c]
+
+	* src/sieve-bin/Makefile.am, src/sieve-bin/bin-common.c, src/sieve-bin
+	/bin-common.h, src/sieve-bin/sieve-exec.c, src/sieve-bin/sieve-
+	test.c, src/sieve-bin/sievec.c:
+	Updated and cleaned-up the sieve test binaries.
+	[9ed2f2979c35]
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-envelope.c, src/lib-
+	sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/copy/ext-copy.c, src/lib-sieve/plugins/imapflags/ext-
+	imapflags-common.c, src/lib-sieve/plugins/imapflags/tag-flags.c, src
+	/lib-sieve/plugins/imapflags/tst-hasflag.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-code-dumper.c, src/lib-sieve
+	/sieve-code-dumper.h, src/lib-sieve/sieve-code.c, src/lib-sieve
+	/sieve-comparators.c, src/lib-sieve/sieve-interpreter.c, src/lib-
+	sieve/sieve-match-types.c, src/lib-sieve/sieve.c, src/lib-
+	sieve/sieve.h, src/lib-sieve/tst-address.c, src/lib-sieve/tst-
+	exists.c, src/lib-sieve/tst-header.c, src/lib-sieve/tst-size.c, src
+	/sieve-bin/sieve-exec.c, src/sieve-bin/sieve-test.c, src/sieve-
+	bin/sievec.c:
+	Properly implemented the code dumper. Dumps are now printed in a
+	stream. The individual opcode and operand implementations no longer
+	use printf()s.
+	[b68f9e45a6bd]
+
+	* src/lib-sieve/sieve-code-dumper.c, src/lib-sieve/sieve-code-
+	dumper.h:
+	Forgot to add new files.
+	[3a75f9a2a4ac]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/cmd-redirect.c, src/lib-
+	sieve/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-sieve
+	/ext-reject.c, src/lib-sieve/plugins/copy/ext-copy.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/imapflags
+	/tst-hasflag.c, src/lib-sieve/plugins/vacation/ext-vacation.c, src
+	/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-address-parts.c, src
+	/lib-sieve/sieve-address-parts.h, src/lib-sieve/sieve-code.c, src
+	/lib-sieve/sieve-code.h, src/lib-sieve/sieve-common.h, src/lib-sieve
+	/sieve-comparators.c, src/lib-sieve/sieve-comparators.h, src/lib-
+	sieve/sieve-generator.c, src/lib-sieve/sieve-interpreter.c, src/lib-
+	sieve/sieve-interpreter.h, src/lib-sieve/sieve-match-types.c, src
+	/lib-sieve/sieve-match-types.h, src/lib-sieve/sieve.c, src/lib-sieve
+	/tst-address.c, src/lib-sieve/tst-exists.c, src/lib-sieve/tst-
+	header.c, src/lib-sieve/tst-size.c:
+	Exported sieve-code-dumper from sieve-interpreter containing all
+	code dumping related implementation. Now to remove all printfs....
+	[ca3bfa6b2284]
+
+2007-12-01  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h:
+	Fixed bug in handling optional operands to opcodes that have no
+	mandatory operands (0 is no longer a valid opcode)
+	[77e421643cc2]
+
+	* sieve/errors/action-conflicts.sieve, sieve/errors/action-
+	duplicates.sieve, src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-
+	keep.c, src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-fileinto.c,
+	src/lib-sieve/ext-reject.c, src/lib-sieve/plugins/vacation/ext-
+	vacation.c, src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-
+	actions.h, src/lib-sieve/sieve-commands-private.h, src/lib-sieve
+	/sieve-interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-
+	sieve/sieve-result.c, src/lib-sieve/sieve-result.h:
+	Added conflict and duplicate checking to vacation and reject
+	actions.
+	[c33bb67f8b09]
+
+	* sieve/tests/vacation.sieve, src/lib-sieve/cmd-redirect.c, src/lib-
+	sieve/ext-reject.c, src/lib-sieve/plugins/vacation/ext-vacation.c,
+	src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h, src
+	/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve.h, src/sieve-
+	bin/sieve-exec.c, src/sieve-bin/sieve-test.c:
+	Implemented actions reject and vacation.
+	[d34c2fe9ac63]
+
+	* src/lib-sieve/ext-envelope.c:
+	Fixed minor bug in envelope extension.
+	[e39957361fed]
+
+2007-11-30  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/imapflags.sieve, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/sieve-actions.c,
+	src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-result.c, src
+	/lib-sieve/sieve-result.h, src/lib-sieve/sieve-validator.c:
+	Further developed imapflags extension and added proper logging
+	functions to the result object.
+	[bc668e541c89]
+
+2007-11-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/copy/ext-copy.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/sieve-actions.h,
+	src/lib-sieve/sieve-interpreter.c:
+	The :flags tag introduced by the imapflags extension now attaches
+	side-effects to the appropriate action commands.
+	[b3f4220296e2]
+
+	* README, src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-keep.c, src
+	/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/plugins/copy/ext-copy.c, src/lib-sieve/sieve-actions.c, src
+	/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-result.c:
+	Properly implemented handling of the implicit keep flag and fully
+	implemented the copy extension.
+	[24896ebd3e8d]
+
+	* src/lib-sieve/cmd-keep.c, src/lib-sieve/cmd-redirect.c, src/lib-
+	sieve/ext-fileinto.c, src/lib-sieve/plugins/copy/ext-copy.c, src
+	/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h, src/lib-
+	sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-sieve
+	/sieve-code.c, src/lib-sieve/sieve-common.h, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-sieve
+	/sieve-result.c, src/lib-sieve/sieve-result.h:
+	Added basic execution support to copy extension. Not completely
+	functional yet.
+	[8ad6e3739a65]
+
+	* src/lib-sieve/plugins/copy/ext-copy.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-
+	code.c:
+	Added support for reading side effect operands.
+	[04e8fa76e983]
+
+	* src/lib-sieve/plugins/copy/ext-copy.c:
+	Added registration of side-effect extension into binary.
+	[98c1c9798c08]
+
+	* src/lib-sieve/plugins/copy/ext-copy.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-actions.h:
+	Defined side-effect object for the copy extension.
+	[f22e0d5b9788]
+
+	* src/lib-sieve/plugins/imapflags/tst-hasflag.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-address-
+	parts.c, src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h, src
+	/lib-sieve/sieve-generator.c, src/lib-sieve/tst-header.c:
+	Incorporated the signedness of the id_code in the optional_read
+	functions as well
+	[2923c10f41b9]
+
+2007-11-28  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/copy/ext-copy.c, src/lib-sieve/sieve-address-
+	parts.c, src/lib-sieve/sieve-address-parts.h, src/lib-sieve/sieve-
+	binary.c, src/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-
+	comparators.h, src/lib-sieve/sieve-extensions.c, src/lib-sieve
+	/sieve-match-types.c, src/lib-sieve/sieve-match-types.h, src/lib-
+	sieve/sieve-validator.c, src/lib-sieve/sieve-validator.h, src/lib-
+	sieve/tst-size.c:
+	Changed id_code for optional operands to signed and fixed a
+	ext_my_id-related error in the vacation and copy extensions.
+	[38a9854e21ca]
+
+	* src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h, src
+	/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-code.c, src/lib-sieve
+	/sieve-code.h, src/lib-sieve/sieve-extensions.c:
+	Added operand emission support for action side effects.
+	[8b9ba3e6a631]
+
+	* src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h, src
+	/lib-sieve/sieve-extensions.c, src/lib-sieve/sieve-extensions.h:
+	Created pre-loaded action side effects 'extension'.
+	[37a2969e9787]
+
+	* src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-binary.c,
+	src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-comparators.c, src
+	/lib-sieve/sieve-match-types.c:
+	Removed part of the code duplication between address-part, match-
+	type and comparator implementations.
+	[34b4be8738f2]
+
+	* src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-common.h, src
+	/lib-sieve/sieve-result.c, src/lib-sieve/sieve-result.h:
+	Added untested support for side effects to result object.
+	[ec22e9a0a06d]
+
+2007-11-27  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/copy/ext-copy.c, src/lib-
+	sieve/plugins/imapflags/Makefile.am, src/lib-sieve/plugins/imapflags
+	/ext-imapflags.c, src/lib-sieve/plugins/imapflags/imapflags.sieve,
+	src/lib-sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-result.c:
+	Added :flags tag to the imapflags extension and fixed bug in the
+	result execution.
+	[e4ccc420bbc8]
+
+	* README:
+	Updated documentation.
+	[0b63e817f6b6]
+
+	* src/lib-sieve/plugins/copy/copy.sieve, src/lib-sieve/plugins/copy
+	/ext-copy.c, src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve-
+	validator.h:
+	Added support for externally adding tags to (possibly not yet
+	registered) command. The copy extension now adds such a tag to
+	fileinto and redirect.
+	[9ad768a6d2b9]
+
+	* configure.in, src/lib-sieve/Makefile.am, src/lib-
+	sieve/plugins/Makefile.am, src/lib-sieve/plugins/copy/Makefile.am,
+	src/lib-sieve/plugins/copy/ext-copy.c, src/lib-
+	sieve/plugins/copy/rfc3894.txt, src/lib-sieve/sieve-extensions.c,
+	src/sieve-bin/sieve-exec.c:
+	Added skeleton for the copy extension.
+	[f4d0e3674a8c]
+
+	* sieve/tests/actions.sieve, src/lib-sieve/sieve-actions.c:
+	Minor changes
+	[da31c25af3df]
+
+	* sieve/tests/actions.sieve, src/lib-sieve/sieve-actions.c, src/sieve-
+	bin/sieve-exec.c:
+	Store action seems to work properly now.
+	[eec88e2b625d]
+
+	* sieve/tests/actions.sieve, src/lib-sieve/sieve-actions.c, src/lib-
+	sieve/sieve-actions.h, src/lib-sieve/sieve-result.c, src/lib-
+	sieve/sieve.h, src/sieve-bin/Makefile.am, src/sieve-bin/mail-raw.c,
+	src/sieve-bin/mail-raw.h, src/sieve-bin/namespaces.c, src/sieve-
+	bin/namespaces.h, src/sieve-bin/sieve-exec.c, src/sieve-bin/sieve-
+	test.c:
+	Almost finished implementing the store action. But, I still get
+	strange errors when the mail transaction commits. Mail is stored
+	though.
+	[246c88fea246]
+
+	* src/lib-sieve/cmd-keep.c, src/lib-sieve/cmd-redirect.c, src/lib-
+	sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h, src/lib-sieve
+	/sieve-result.c:
+	Turned action execution into a transaction.
+	[d9a51d8e6d16]
+
+	* README, src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-keep.c, src
+	/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/sieve-result.c, src/lib-sieve/sieve-result.h:
+	Added (not yet active) handling of implicit keep and adjusted
+	commands accordingly.
+	[d8eaf00dd960]
+
+	* README:
+	Added TODO item.
+	[2e2cbe36ac1d]
+
+2007-11-26  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/cmd-keep.c, src/lib-sieve/sieve.c, src/lib-
+	sieve/sieve.h, src/sieve-bin/sieve-exec.c, src/sieve-bin/sieve-
+	test.c:
+	Added inbox location to mail environment and made keep command use
+	it to generate its store action.
+	[1fabb5b3de8f]
+
+	* README, src/lib-sieve/ext-fileinto.c:
+	Updated documentation.
+	[b77f5ae48116]
+
+	* sieve/tests/actions.sieve, src/lib-sieve/Makefile.am, src/lib-sieve
+	/cmd-discard.c, src/lib-sieve/cmd-keep.c, src/lib-sieve/cmd-
+	redirect.c, src/lib-sieve/ext-fileinto.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-
+	common.h, src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-
+	result.h:
+	Fileinto command now produces a store action which is now produced
+	by the keep command as well.
+	[b59ff97b1b4b]
+
+	* sieve/tests/actions.sieve, src/lib-sieve/cmd-discard.c, src/lib-
+	sieve/cmd-keep.c:
+	Made discard command add discard action to the result.
+	[d00c1ecbe750]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/cmd-discard.c, src/lib-
+	sieve/cmd-keep.c, src/lib-sieve/sieve-commands.c:
+	Exported discard command to its own separate file.
+	[8bedc7e9f17e]
+
+	* src/lib-sieve/cmd-keep.c, src/lib-sieve/cmd-redirect.c, src/lib-
+	sieve/sieve-result.c, src/lib-sieve/sieve-result.h:
+	Added support for detecting action conflicts.
+	[37fcab36395a]
+
+	* README:
+	Updated documentation.
+	[eb3c1925ac1f]
+
+	* sieve/tests/redirect.sieve, src/lib-sieve/cmd-keep.c, src/lib-sieve
+	/cmd-redirect.c, src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-
+	result.h:
+	Added support for avoiding duplicate actions in the sieve result.
+	[7fa2aeb9a269]
+
+	* src/lib-sieve/cmd-keep.c, src/lib-sieve/cmd-redirect.c:
+	Made keep command add keep action to the result.
+	[b4ac2186369d]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/cmd-keep.c, src/lib-sieve
+	/sieve-commands-private.h, src/lib-sieve/sieve-commands.c:
+	Exported keep command to its own separate file.
+	[a061b79e6eb1]
+
+2007-11-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/sieve-bin/bin-common.c, src/sieve-bin/sieve-exec.c, src/sieve-
+	bin/sieve-test.c:
+	Minor changes to the executables.
+	[1c349f5cf532]
+
+	* README, src/lib-sieve/sieve-interpreter.c, src/sieve-bin/sieve-
+	exec.c, src/sieve-bin/sieve-test.c:
+	Added mail-file parameter to the sieve-test and sieve-exec binaries.
+	[38ff5f7794ad]
+
+	* .hgignore, sieve/tests/redirect.sieve, src/lib-sieve/sieve-binary.c,
+	src/lib-sieve/sieve-interpreter.c, src/lib-sieve/sieve-result.c, src
+	/lib-sieve/sieve.c, src/lib-sieve/sieve.h, src/sieve-
+	bin/Makefile.am, src/sieve-bin/bin-common.c, src/sieve-bin/bin-
+	common.h, src/sieve-bin/mail-raw.c, src/sieve-bin/mail-raw.h, src
+	/sieve-bin/sieve-exec.c, src/sieve-bin/sieve-test.c, src/sieve-
+	bin/sieve_test.c, src/sieve-bin/sievec.c:
+	Cleaned up implementation of sieve test binaries and added sieve-
+	exec
+	[ab2fd12a0195]
+
+	* src/lib-sieve/sieve-match-types.c:
+	Removed spurious debug message.
+	[5b53dd17b678]
+
+2007-11-24  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/sieve-interpreter.c, src
+	/lib-sieve/sieve-interpreter.h, src/lib-sieve/sieve-result.c, src
+	/lib-sieve/sieve-result.h, src/lib-sieve/sieve.c, src/lib-
+	sieve/sieve.h, src/sieve-bin/Makefile.am, src/sieve-
+	bin/sieve_test.c:
+	Added first action execution support. Redirect is the first command
+	to actually work.
+	[3ea3f400caa9]
+
+	* README:
+	Added TODO item.
+	[312bfe51f644]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/ext-cmp-i-ascii-numeric.c, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-sieve/plugins/regex
+	/ext-regex.c, src/lib-sieve/plugins/relational/ext-relational.c, src
+	/lib-sieve/plugins/relational/relational.sieve, src/lib-
+	sieve/plugins/subaddress/ext-subaddress.c, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-address-parts.h, src/lib-sieve
+	/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-
+	comparators.c, src/lib-sieve/sieve-comparators.h, src/lib-sieve
+	/sieve-match-types.c, src/lib-sieve/sieve-match-types.h, src/lib-
+	sieve/tst-address.c, src/lib-sieve/tst-header.c:
+	Moved address-part, match-type and comparator code registries from
+	interpreter to binary where they belong.
+	[17fe832ec983]
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-
+	sieve/sieve-interpreter.c:
+	Added extension context storage support to the sieve binary.
+	[bf61316d9b84]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/ext-reject.c, src/lib-sieve/plugins/comparator-i-ascii-numeric
+	/ext-cmp-i-ascii-numeric.c, src/lib-sieve/plugins/imapflags/ext-
+	imapflags.c, src/lib-sieve/plugins/regex/ext-regex.c, src/lib-
+	sieve/plugins/relational/ext-relational.c, src/lib-
+	sieve/plugins/subaddress/ext-subaddress.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-address-
+	parts.c, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h,
+	src/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-extensions.c,
+	src/lib-sieve/sieve-extensions.h, src/lib-sieve/sieve-interpreter.c,
+	src/lib-sieve/sieve-match-types.c:
+	Added binary_load event to the sieve extensions.
+	[abc3d97f3cfe]
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-envelope.c, src/lib-
+	sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-address-
+	parts.c, src/lib-sieve/sieve-address-parts.h, src/lib-sieve/sieve-
+	binary.c, src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h,
+	src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-common.h, src
+	/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-comparators.h,
+	src/lib-sieve/sieve-interpreter.c, src/lib-sieve/sieve-
+	interpreter.h, src/lib-sieve/sieve-match-types.c, src/lib-sieve
+	/sieve-match-types.h, src/lib-sieve/sieve-result.c, src/lib-sieve
+	/sieve-result.h, src/lib-sieve/sieve.c, src/lib-sieve/tst-address.c,
+	src/lib-sieve/tst-exists.c, src/lib-sieve/tst-header.c, src/lib-
+	sieve/tst-size.c:
+	Grouped runtime parameters into a single runtime environment and
+	started implementation of result composition/execution.
+	[7c800bfa74cc]
+
+	* src/lib-sieve/sieve-interpreter.c:
+	Changed interpreter in the event of an unimplemented opcode.
+	[91fd90402931]
+
+	* README, src/lib-sieve/plugins/imapflags/ext-imapflags.c:
+	Updated documentation.
+	[9dd4fe921d74]
+
+	* src/lib-sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/imapflags-2.sieve, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c:
+	Implemented hasflag command interpretation for the imapflags
+	extension.
+	[30917ef6965c]
+
+2007-11-23  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/imapflags-2.sieve, src/lib-
+	sieve/plugins/imapflags/imapflags.sieve, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-
+	sieve/plugins/relational/ext-relational.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-ast.c,
+	src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-comparators.c, src
+	/lib-sieve/tst-size.c:
+	Added actual flag management to the imapflags extension. Addflag,
+	removeflag and setflag now do what they should do.
+	[610b5f638c33]
+
+	* README, src/lib-sieve/cmd-if.c, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/ext-cmp-i-ascii-numeric.c, src/lib-
+	sieve/plugins/relational/relational.sieve, src/lib-sieve/tst-
+	allof.c, src/lib-sieve/tst-anyof.c:
+	Finished i;ascii-numeric comparator and fixed a segfault bug in the
+	process.
+	[8cd504cc2e3a]
+
+	* README, src/lib-sieve/plugins/imapflags/Makefile.am, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/imapflags-errors.sieve, src/lib-
+	sieve/plugins/imapflags/imapflags.sieve, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-sieve/tst-header.c:
+	Added hasflag test to the imapflags extension.
+	[cc5f85570a9a]
+
+	* src/lib-sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/imapflags.sieve, src/lib-sieve/sieve-code.c,
+	src/lib-sieve/sieve-code.h:
+	Implemented code generation and interpretation for the commands
+	introduced by the imapflags extension.
+	[f0c34dee6ae7]
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-envelope.c, src/lib-
+	sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-numeric.c,
+	src/lib-sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-sieve/plugins/regex
+	/ext-regex.c, src/lib-sieve/plugins/relational/ext-relational.c, src
+	/lib-sieve/plugins/subaddress/ext-subaddress.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-address-
+	parts.c, src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h, src
+	/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-comparators.c, src
+	/lib-sieve/sieve-extensions.c, src/lib-sieve/sieve-extensions.h, src
+	/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-generator.h, src
+	/lib-sieve/sieve-interpreter.c, src/lib-sieve/sieve-match-types.c,
+	src/lib-sieve/tst-address.c, src/lib-sieve/tst-exists.c, src/lib-
+	sieve/tst-header.c, src/lib-sieve/tst-size.c:
+	Upgraded opcode extension support to handle more than one opcode per
+	extension.
+	[2a2d82471e77]
+
+2007-11-22  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/imapflags.sieve:
+	imapflags: Added (dummy) check for the existance of the variables
+	extension.
+	[9d97ea5c52c6]
+
+	* src/lib-sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/imapflags-errors.sieve, src/lib-sieve/sieve-
+	validator.c:
+	Implemented validation for the commands introduced by the imapflags
+	extension.
+	[82e86518dfc9]
+
+	* src/lib-sieve/plugins/imapflags/Makefile.am, src/lib-
+	sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/imapflags.sieve, src/lib-sieve/sieve-
+	commands.h, src/lib-sieve/sieve-extensions.c, src/lib-sieve/sieve-
+	validator.c:
+	Created skeletons for the commands introduced by the imapflags
+	extension.
+	[c0471778290f]
+
+	* configure.in, src/lib-sieve/Makefile.am, src/lib-
+	sieve/plugins/Makefile.am, src/lib-
+	sieve/plugins/imapflags/Makefile.am, src/lib-sieve/plugins/imapflags
+	/draft-ietf-sieve-imapflags-05.txt, src/lib-sieve/plugins/imapflags
+	/ext-imapflags.c:
+	Started skeleton for the imapflags extension.
+	[6ea6b7699606]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/plugins/Makefile.am, src
+	/lib-sieve/plugins/comparator-i-ascii-numeric/Makefile.am, src/lib-
+	sieve/plugins/regex/Makefile.am, src/lib-
+	sieve/plugins/relational/Makefile.am, src/lib-
+	sieve/plugins/subaddress/Makefile.am, src/lib-
+	sieve/plugins/vacation/Makefile.am, src/sieve-bin/Makefile.am:
+	Cleaned up make process and included the 'plugins' into the main
+	sieve library archive.
+	[b669519df1b5]
+
+	* README, src/lib-sieve/sieve-commands.c:
+	Updated documentation.
+	[ab270d1accc1]
+
+	* sieve/examples/vivil.sieve, sieve/tests/stop.sieve, src/lib-sieve
+	/cmd-if.c, src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-
+	commands.h, src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-
+	generator.h:
+	Removed unecessary jump after commands like stop.
+	[a487f6447efa]
+
+	* sieve/tests/matches.sieve, src/lib-sieve/sieve-match-types.c:
+	Debugged :matches match type and no more bugs are currently known.
+	[acdcd1d8f031]
+
+	* sieve/tests/matches.sieve, src/lib-sieve/plugins/comparator-i-ascii-
+	numeric/ext-cmp-i-ascii-numeric.c, src/lib-sieve/sieve-
+	comparators.c, src/lib-sieve/sieve-comparators.h, src/lib-sieve
+	/sieve-match-types.c:
+	Made first buggy implementation of :matches match type.
+	[d3756743700b]
+
+2007-11-21  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README:
+	Updated documentation with respect to extensions.
+	[cd8b13651e87]
+
+	* sieve/tests/reject.sieve, src/lib-sieve/ext-reject.c:
+	Added dummy execution support to reject extension.
+	[29620589f088]
+
+	* README, src/lib-sieve/plugins/vacation/ext-vacation.c:
+	Updated documentation.
+	[3dcfafbef34d]
+
+	* sieve/tests/vacation.sieve, src/lib-sieve/plugins/vacation/ext-
+	vacation.c, src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve-
+	validator.h:
+	Implemented dummy execution for vacation extension.
+	[ef682330f822]
+
+	* src/lib-sieve/ext-envelope.c:
+	Resolved compiler warning in envelope extension.
+	[7e2d6e8893dc]
+
+	* sieve/tests/redirect.sieve:
+	Added test script for redirect command.
+	[30ec001eaee2]
+
+	* src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-interpreter.c, src
+	/lib-sieve/sieve-interpreter.h:
+	Properly implemented stop command and associated opcode.
+	[cb2ac2578b83]
+
+	* src/sieve-bin/sieve_test.c:
+	Added status message to sieve_test to indicate successful script
+	run.
+	[64e0b6403468]
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/sieve-code.c, src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-
+	interpreter.h:
+	Created dummy interpretation support for the redirect command.
+	[382920e5c5ae]
+
+	* sieve/tests/fileinto.sieve, src/lib-sieve/ext-fileinto.c:
+	Created dummy interpretation support for the fileinto extension.
+	[c410f5746af3]
+
+	* src/lib-sieve/ext-envelope.c:
+	Removed debug lines in envelope extension.
+	[0d144c5c6726]
+
+	* src/lib-sieve/ext-envelope.c:
+	Made ext_envelope_get_fields cleaner.
+	[962e5ed2a7b0]
+
+	* README, src/lib-sieve/ext-envelope.c:
+	Updated documentation.
+	[c05059b64271]
+
+	* sieve/tests/envelope.sieve, src/lib-sieve/ext-envelope.c, src/lib-
+	sieve/sieve-address-parts.c, src/lib-sieve/sieve-address-parts.h,
+	src/lib-sieve/sieve.h, src/lib-sieve/tst-address.c, src/sieve-
+	bin/sieve_test.c:
+	Made basic execution implementation of the envelope extension.
+	[6bf04ad6e814]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/sieve-common.h, src/lib-
+	sieve/sieve-interpreter.c, src/lib-sieve/sieve-interpreter.h, src
+	/lib-sieve/sieve.c, src/lib-sieve/sieve.h, src/lib-sieve/tst-
+	address.c, src/lib-sieve/tst-exists.c, src/lib-sieve/tst-header.c,
+	src/lib-sieve/tst-size.c, src/sieve-bin/sieve_test.c:
+	Added envelope data to the interpreter environment.
+	[b9cf89b005f2]
+
+	* README, src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i
+	-ascii-numeric.c, src/lib-sieve/plugins/regex/ext-regex.c, src/lib-
+	sieve/plugins/relational/ext-relational.c, src/lib-
+	sieve/plugins/relational/relational.sieve, src/lib-sieve/sieve-
+	match-types.c, src/lib-sieve/sieve-match-types.h, src/lib-sieve/tst-
+	address.c, src/lib-sieve/tst-header.c:
+	Completed implementation of the relational extension.
+	[7dd971306703]
+
+	* src/lib-sieve/plugins/regex/ext-regex.c, src/lib-
+	sieve/plugins/regex/regex.sieve, src/lib-sieve/plugins/relational
+	/ext-relational.c, src/lib-sieve/sieve-match-types.c, src/lib-sieve
+	/sieve-match-types.h:
+	Improved match handling and started implementing the interpretation
+	of the relational match type.
+	[158169910d95]
+
+2007-11-20  Stephan Bosch  <stephan@rename-it.nl>
+
+	* sieve/errors/match-type-errors.sieve, sieve/tests/match-type.sieve,
+	src/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-
+	comparators.h, src/lib-sieve/sieve-match-types.c:
+	Implemented context validation for :contains match type.
+	[6f1dcac24c57]
+
+	* README, src/lib-sieve/plugins/regex/ext-regex.c:
+	Updated documentation with respect to regex externsion and match-
+	type support.
+	[37fd899b7dca]
+
+	* src/lib-sieve/sieve-match-types.c:
+	Last commit broke execution of match types other than
+	:regex...fixed.
+	[f9e2b975f5eb]
+
+	* src/lib-sieve/plugins/regex/ext-regex.c, src/lib-
+	sieve/plugins/regex/regex.sieve, src/lib-sieve/plugins/relational
+	/ext-relational.c, src/lib-sieve/sieve-address-parts.c, src/lib-
+	sieve/sieve-address-parts.h, src/lib-sieve/sieve-common.h, src/lib-
+	sieve/sieve-match-types.c, src/lib-sieve/sieve-match-types.h, src
+	/lib-sieve/tst-address.c, src/lib-sieve/tst-header.c:
+	Implemented regex match execution.
+	[114ec23016dd]
+
+	* sieve/examples/sanjay.sieve:
+	Fixed missing require in sanjay.sieve example
+	[81baf031527e]
+
+	* src/lib-sieve/plugins/regex/ext-regex.c:
+	Forgot to handle stringlists in :regex validation.
+	[4e082129513a]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/plugins/regex/ext-
+	regex.c, src/lib-sieve/plugins/regex/regex-errors.sieve, src/lib-
+	sieve/sieve-match-types.c, src/lib-sieve/sieve-match-types.h, src
+	/lib-sieve/tst-address.c, src/lib-sieve/tst-header.c:
+	Implemented :regex match validation.
+	[fefebffac65f]
+
+	* sieve/errors/address-part-errors.sieve,
+	sieve/errors/interesting.sieve, sieve/errors/match-type-
+	errors.sieve, src/lib-sieve/sieve-address-parts.c, src/lib-sieve
+	/sieve-ast.h, src/lib-sieve/sieve-match-types.c, src/lib-sieve
+	/sieve-validator.c:
+	Implemented detection of duplicate optional arguments.
+	[9add85be3ddd]
+
+	* src/lib-sieve/plugins/regex/ext-regex.c, src/lib-sieve/plugins/regex
+	/regex-errors.sieve, src/lib-sieve/sieve-commands.h, src/lib-sieve
+	/sieve-comparators.c, src/lib-sieve/sieve-comparators.h, src/lib-
+	sieve/sieve-validator.c:
+	Made regex match complaint about comparators other than i;octet or i
+	;ascii-casemap
+	[ebf35c004764]
+
+	* src/lib-sieve/plugins/regex/ext-regex.c, src/lib-
+	sieve/plugins/relational/ext-relational.c, src/lib-sieve/sieve-
+	match-types.c, src/lib-sieve/sieve-match-types.h:
+	Added support for match-type argument context validation.
+	[9db6e7335e9e]
+
+	* src/lib-sieve/sieve-validator.c:
+	Added support for argument context validation.
+	[7dcaf16bcf7d]
+
+	* src/lib-sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-commands.c, src/lib-sieve
+	/sieve-commands.h, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-match-types.c, src/lib-sieve/sieve-validator.c, src/lib-sieve
+	/tst-size.c:
+	Added validat_context method to command arguments for the to-be-
+	implemented argument context validation.
+	[754320bac6bb]
+
+	* src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-commands.c,
+	src/lib-sieve/sieve-commands.h, src/lib-sieve/sieve-comparators.c,
+	src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-match-types.c:
+	Changed argument generator function prototype to assign
+	responsibility of advancing to the next argument to the generator
+	itself.
+	[6ba97a809b25]
+
+	* src/lib-sieve/sieve-commands.c:
+	Removed i_unreached() at inappropriate location.
+	[80a6ca8aa099]
+
+	* src/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-ast.h, src/lib-sieve
+	/sieve-commands.c, src/lib-sieve/sieve-commands.h, src/lib-sieve
+	/sieve-validator.c:
+	Removed code duplication in validator: merged command and test
+	validation in one function.
+	[55047d9405c9]
+
+	* src/lib-sieve/sieve-validator.c:
+	Fixed bug in the command validation.
+	[0f7c34ca82a9]
+
+	* src/lib-sieve/cmd-if.c, src/lib-sieve/cmd-require.c, src/lib-sieve
+	/sieve-commands.h:
+	Improved validation of command placement for if and require
+	commands.
+	[7666f12ccc2a]
+
+	* src/lib-sieve/cmd-if.c, src/lib-sieve/cmd-redirect.c, src/lib-sieve
+	/cmd-require.c, src/lib-sieve/ext-envelope.c, src/lib-sieve/ext-
+	fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-commands-
+	private.h, src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-
+	commands.h, src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve-
+	validator.h, src/lib-sieve/tst-address.c, src/lib-sieve/tst-allof.c,
+	src/lib-sieve/tst-anyof.c, src/lib-sieve/tst-exists.c, src/lib-sieve
+	/tst-header.c, src/lib-sieve/tst-not.c, src/lib-sieve/tst-size.c:
+	Changed validator's command syntax validation such that command
+	implementations don't have to call the argument, test and block
+	validation functions explicitly.
+	[e43df7ab9749]
+
+2007-11-19  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/cmd-if.c, src/lib-sieve/cmd-redirect.c, src/lib-sieve
+	/cmd-require.c, src/lib-sieve/ext-envelope.c, src/lib-sieve/ext-
+	fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-ast.h,
+	src/lib-sieve/sieve-commands.h, src/lib-sieve/sieve-validator.c, src
+	/lib-sieve/sieve-validator.h, src/lib-sieve/tst-address.c, src/lib-
+	sieve/tst-allof.c, src/lib-sieve/tst-anyof.c, src/lib-sieve/tst-
+	exists.c, src/lib-sieve/tst-header.c, src/lib-sieve/tst-not.c, src
+	/lib-sieve/tst-size.c:
+	Changed argument validation to record the first positional argument
+	into the command context by default. Also furter improved
+	validator's error handling.
+	[d357da9effa4]
+
+	* sieve/errors/address-errors.sieve, sieve/errors/header-errors.sieve,
+	src/lib-sieve/cmd-redirect.c, src/lib-sieve/cmd-require.c, src/lib-
+	sieve/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-sieve
+	/ext-reject.c, src/lib-sieve/plugins/subaddress/subaddress.sieve,
+	src/lib-sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-
+	ast.c, src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-common.h, src
+	/lib-sieve/sieve-validator.c, src/lib-sieve/sieve-validator.h, src
+	/lib-sieve/tst-address.c, src/lib-sieve/tst-exists.c, src/lib-sieve
+	/tst-header.c, src/lib-sieve/tst-size.c:
+	Revised positional argument checking and fixed the validator's error
+	handling.
+	[31ade1ddf884]
+
+	* src/lib-sieve/sieve-match-types.c:
+	Prevent unimplemented match type from causing a segfault.
+	[614e7a053e31]
+
+	* src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-
+	numeric.c, src/lib-sieve/plugins/regex/ext-regex.c, src/lib-
+	sieve/plugins/relational/ext-relational.c, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-address-parts.h, src/lib-sieve
+	/sieve-common.h, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-comparators.h, src/lib-sieve/sieve-interpreter.c, src/lib-
+	sieve/sieve-interpreter.h, src/lib-sieve/sieve-match-types.c, src
+	/lib-sieve/sieve-match-types.h, src/lib-sieve/tst-address.c, src
+	/lib-sieve/tst-header.c:
+	Implemented match type execution and activated match types :is and
+	:contains.
+	[44f7b3f89e34]
+
+2007-11-17  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README, src/lib-sieve/plugins/regex/ext-regex.c, src/lib-
+	sieve/plugins/relational/ext-relational.c:
+	Minor updates to the documentation.
+	[033d7cb3a8dd]
+
+	* src/lib-sieve/plugins/relational/ext-relational.c, src/lib-
+	sieve/plugins/relational/relational.sieve, src/lib-sieve/sieve-
+	match-types.c, src/lib-sieve/sieve-match-types.h:
+	Fixed code generation for relational extension.
+	[9aedfec64626]
+
+	* src/lib-sieve/plugins/regex/ext-regex.c, src/lib-
+	sieve/plugins/relational/ext-relational.c, src/lib-sieve/sieve-
+	match-types.c, src/lib-sieve/sieve-match-types.h:
+	Implemented support for additional parameters to match-types and
+	implemented validation for the relational extension.
+	[c49afa847933]
+
+	* configure.in, sieve/tests/match-type.sieve, src/lib-
+	sieve/plugins/Makefile.am, src/lib-sieve/plugins/regex/Makefile.am,
+	src/lib-sieve/plugins/regex/draft-murchison-sieve-regex-07.txt, src
+	/lib-sieve/plugins/regex/ext-regex.c, src/lib-
+	sieve/plugins/regex/regex.sieve, src/lib-
+	sieve/plugins/relational/Makefile.am, src/lib-
+	sieve/plugins/relational/ext-relational.c, src/lib-
+	sieve/plugins/relational/relational.sieve, src/lib-
+	sieve/plugins/relational/rfc3431.txt, src/lib-sieve/sieve-
+	extensions.c, src/sieve-bin/Makefile.am:
+	Created skeletons for regex and relational extensions. These are to
+	be developed simultaneously with the match-type support in general.
+	[f3db84e346eb]
+
+	* README, sieve/tests/match-type.sieve, src/lib-sieve/Makefile.am, src
+	/lib-sieve/ext-envelope.c, src/lib-sieve/sieve-address-parts.c, src
+	/lib-sieve/sieve-code.c, src/lib-sieve/sieve-comparators.c, src/lib-
+	sieve/sieve-extensions.c, src/lib-sieve/sieve-extensions.h, src/lib-
+	sieve/sieve-interpreter.c, src/lib-sieve/sieve-match-types.c, src
+	/lib-sieve/sieve-match-types.h, src/lib-sieve/sieve-validator.c, src
+	/lib-sieve/tst-address.c, src/lib-sieve/tst-header.c:
+	Started implementation of match-type support and fixed compilation
+	error.
+	[b352686b0063]
+
+	* README, src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i
+	-ascii-numeric.c, src/lib-sieve/plugins/vacation/ext-vacation.c, src
+	/lib-sieve/sieve-comparators.c:
+	Updated README and a few minor cosmetic changes to the code.
+	[8eddb5ec9ddb]
+
+	* configure.in, src/lib-sieve/ext-envelope.c, src/lib-
+	sieve/plugins/Makefile.am, src/lib-sieve/plugins/comparator-i-ascii-
+	numeric/Makefile.am, src/lib-sieve/plugins/comparator-i-ascii-
+	numeric/cmp-i-ascii-numeric.sieve, src/lib-
+	sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-numeric.c,
+	src/lib-sieve/plugins/comparator-i-ascii-numeric/rfc2244.txt, src
+	/lib-sieve/plugins/subaddress/ext-subaddress.c, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-address-parts.h, src/lib-sieve
+	/sieve-common.h, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-comparators.h, src/lib-sieve/sieve-extensions.c, src/lib-
+	sieve/tst-address.c, src/lib-sieve/tst-header.c, src/sieve-
+	bin/Makefile.am:
+	Implemented comparator-i;ascii-numeric extension and activated
+	comparator extension support.
+	[01386a471dc7]
+
+	* src/lib-sieve/sieve-extensions.c:
+	Added dummy extensions for core comparators.
+	[ae2e6fd6f94e]
+
+	* sieve/tests/extensions.sieve, src/lib-sieve/cmd-require.c, src/lib-
+	sieve/sieve-address-parts.c:
+	A few small cosmetic changes in addr-part code and generic extension
+	support.
+	[7b9f9e71030e]
+
+2007-11-16  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/subaddress/ext-subaddress.c, src/lib-
+	sieve/plugins/subaddress/subaddress.sieve, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-common.h:
+	Finished implementation of subaddress extension.
+	[05c4031e501e]
+
+	* configure.in, src/lib-sieve/ext-envelope.c, src/lib-
+	sieve/plugins/Makefile.am, src/lib-
+	sieve/plugins/subaddress/Makefile.am, src/lib-
+	sieve/plugins/subaddress/ext-subaddress.c, src/lib-
+	sieve/plugins/subaddress/rfc3598.txt, src/lib-
+	sieve/plugins/subaddress/subaddress.sieve, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-address-
+	parts.c, src/lib-sieve/sieve-address-parts.h, src/lib-sieve/sieve-
+	ast.h, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h,
+	src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-commands.h, src
+	/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-extensions.c,
+	src/lib-sieve/sieve-extensions.h, src/lib-sieve/sieve-interpreter.c,
+	src/lib-sieve/sieve-validator.c, src/lib-sieve/tst-address.c, src
+	/lib-sieve/tst-size.c, src/sieve-bin/Makefile.am:
+	Implemented support for the subaddress extension and fixed extension
+	support to work properly.
+	[4e9f385adc07]
+
+2007-11-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* sieve/tests/address-part.sieve, src/lib-sieve/sieve-address-parts.c,
+	src/lib-sieve/sieve-address-parts.h, src/lib-sieve/tst-address.c:
+	Implemented address part execution support.
+	[af5ea3cdd396]
+
+2007-11-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* sieve/tests/address-part.sieve, src/lib-sieve/ext-envelope.c, src
+	/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-address-
+	parts.h, src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h, src
+	/lib-sieve/sieve-validator.c, src/lib-sieve/tst-address.c:
+	Activated address-part code generation support.
+	[60ab1abd0d01]
+
+	* src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-ast.h, src
+	/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-code.c, src/lib-sieve
+	/sieve-code.h, src/lib-sieve/sieve-commands-private.h, src/lib-sieve
+	/sieve-commands.c, src/lib-sieve/sieve-common.h, src/lib-sieve
+	/sieve-comparators.c, src/lib-sieve/sieve-error.c, src/lib-sieve
+	/sieve-error.h, src/lib-sieve/sieve-extensions.c, src/lib-sieve
+	/sieve-generator.h, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/sieve-interpreter.h, src/lib-sieve/sieve-lexer.c, src/lib-sieve
+	/sieve-lexer.h, src/lib-sieve/sieve-parser.c, src/lib-sieve/sieve-
+	parser.h, src/lib-sieve/sieve-validator.h:
+	Lots of cosmetic changes
+	[19366331bc99]
+
+	* INSTALL, README:
+	Added a little documentation to the README file.
+	[2fd76028ca9b]
+
+	* src/lib-sieve/sieve-validator.c:
+	Removed unused static pre-declaration from validator.
+	[f745b4988763]
+
+	* sieve/tests/comparator.sieve, src/lib-sieve/Makefile.am, src/lib-
+	sieve/cmd-require.c, src/lib-sieve/ext-envelope.c, src/lib-sieve
+	/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-address-
+	parts.c, src/lib-sieve/sieve-address-parts.h, src/lib-sieve/sieve-
+	binary.c, src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-code.c,
+	src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-comparators.c, src
+	/lib-sieve/sieve-comparators.h, src/lib-sieve/sieve-extensions.c,
+	src/lib-sieve/sieve-extensions.h, src/lib-sieve/sieve-generator.c,
+	src/lib-sieve/sieve-generator.h, src/lib-sieve/sieve-interpreter.c,
+	src/lib-sieve/sieve-interpreter.h, src/lib-sieve/sieve-validator.c,
+	src/lib-sieve/sieve-validator.h, src/lib-sieve/sieve.c, src/lib-
+	sieve/sieve.h, src/lib-sieve/tst-address.c, src/lib-sieve/tst-
+	header.c, src/sieve-bin/sieve_test.c, src/sieve-bin/sievec.c:
+	Rewrote large parts of the extension support and added partial
+	address-part implementation.
+	[bbbf416d458c]
+
+2007-11-11  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/sieve-bin/Makefile.am, src/sieve-bin/sieve_test.c:
+	Upgraded sieve_test to 1.1.beta8
+	[beaeb564662c]
+
+	* src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-common.h, src
+	/lib-sieve/sieve-interpreter.c, src/lib-sieve/sieve-interpreter.h,
+	src/lib-sieve/tst-address.c, src/lib-sieve/tst-header.c:
+	Enabled comparator execution support.
+	[5b4103b61afd]
+
+	* sieve/tests/comparator.sieve, src/lib-sieve/ext-envelope.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-ast.c,
+	src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-code.c, src/lib-sieve
+	/sieve-code.h, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-comparators.h, src/lib-sieve/sieve-generator.c, src/lib-sieve
+	/sieve-validator.c, src/lib-sieve/sieve-validator.h, src/lib-sieve
+	/tst-address.c, src/lib-sieve/tst-header.c, src/lib-sieve/tst-
+	size.c:
+	Added support for optional operators to the byte code
+	implementation.
+	[9355ea520e77]
+
+2007-11-09  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/ext-reject.c, src/lib-sieve/plugins/vacation/ext-vacation.c,
+	src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-
+	sieve/sieve-code.c, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-comparators.h, src/lib-sieve/sieve-extensions.h, src/lib-
+	sieve/sieve-interpreter.c, src/lib-sieve/sieve-interpreter.h:
+	Started implementation of comparator execution support.
+	[a3e2d0467235]
+
+2007-11-08  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h:
+	Changed string-list single-string handling for coded list.
+	[494b84c7dab4]
+
+	* src/lib-sieve/cmd-if.c, src/lib-sieve/ext-envelope.c, src/lib-sieve
+	/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-binary.c,
+	src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-code.c, src/lib-
+	sieve/sieve-code.h, src/lib-sieve/sieve-commands.c, src/lib-sieve
+	/sieve-common.h, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-extensions.h, src/lib-sieve/sieve-generator.c, src/lib-sieve
+	/sieve-generator.h, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/sieve-interpreter.h, src/lib-sieve/tst-address.c, src/lib-sieve
+	/tst-allof.c, src/lib-sieve/tst-anyof.c, src/lib-sieve/tst-exists.c,
+	src/lib-sieve/tst-header.c, src/lib-sieve/tst-size.c:
+	Properly implemented opcode and operand handing and moved code to
+	more appropriate units.
+	[6d30cd3270b4]
+
+2007-11-01  Stephan Bosch  <stephan@rename-it.nl>
+
+	* sieve/examples/sieve_examples.sieve, sieve/examples/stephan.sieve,
+	sieve/examples/unparsed-elvey.sieve, src/lib-sieve/sieve-code.h:
+	A few minor changes
+	[8eb67ba19a03]
+
+	* sieve/examples/elvey.sieve, sieve/examples/jerry.sieve,
+	sieve/examples/mjohnson.sieve, sieve/examples/mklose.sieve,
+	sieve/examples/sanjay.sieve, sieve/examples/vivil.sieve:
+	Added sieve example and documented the others with author and the
+	url where I found them.
+	[36b747fc5a42]
+
+2007-10-27  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-
+	sieve/sieve-comparators.c, src/lib-sieve/sieve-interpreter.c, src
+	/lib-sieve/sieve-interpreter.h:
+	Moved literall access functions from interpreter to binary.
+	[df004c3d4967]
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-code.c, src/lib-
+	sieve/sieve-comparators.c, src/lib-sieve/sieve-comparators.h, src
+	/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-generator.h:
+	Implemented comparator support towards code generation,
+	interpretation is not possible yet.
+	[c4eb303c242c]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/ext-reject.c, src/lib-sieve/plugins/vacation/ext-vacation.c,
+	src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-code.c, src/lib-
+	sieve/sieve-code.h, src/lib-sieve/sieve-commands.c, src/lib-sieve
+	/sieve-commands.h, src/lib-sieve/sieve-generator.c, src/lib-sieve
+	/sieve-generator.h, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/sieve-validator.c, src/lib-sieve/sieve-validator.h, src/lib-sieve
+	/tst-address.c, src/lib-sieve/tst-exists.c, src/lib-sieve/tst-
+	header.c, src/lib-sieve/tst-size.c:
+	Changed argument to operand processing to be much more flexible.
+	[b07f5129b239]
+
+2007-10-26  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-
+	sieve/sieve-generator.c, src/lib-sieve/sieve-generator.h:
+	Moved literal emission functions from generator to binary source.
+	[8d9c3aa76abf]
+
+	* sieve/tests/comparator.sieve, src/lib-sieve/Makefile.am, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-ast.c,
+	src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-code.c, src/lib-sieve
+	/sieve-code.h, src/lib-sieve/sieve-commands.h, src/lib-sieve/sieve-
+	common.h, src/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-
+	comparators.h, src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-
+	generator.h, src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve-
+	validator.h, src/lib-sieve/tst-size.c:
+	First steps towards implementing code generation and interpretation
+	for proper comperators.
+	[8f8c18edbd39]
+
+	* src/lib-sieve/tst-exists.c:
+	Extremely minor cosmetic change.
+	[8b215ab7e80f]
+
+	* src/lib-sieve/plugins/Makefile, src/lib-sieve/plugins/Makefile.in:
+	Removed files with intermittent compilation results from the
+	repository (oops)
+	[3c56353ce681]
+
+	* sieve/tests/basic.sieve, src/lib-sieve/sieve-generator.c, src/lib-
+	sieve/tst-exists.c, src/lib-sieve/tst-header.c:
+	Made header and exists tests executable.
+	[38b4e757271d]
+
+2007-10-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* sieve/tests/basic.sieve, src/lib-sieve/sieve-binary.c, src/lib-sieve
+	/sieve-code.c, src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-sieve
+	/sieve-lexer.c, src/lib-sieve/sieve.c, src/lib-sieve/sieve.h, src
+	/lib-sieve/tst-address.c, src/lib-sieve/tst-size.c, src/sieve-
+	bin/Makefile.am, src/sieve-bin/sieve_test.c, src/sieve-bin/sievec.c:
+	Made address and size tests executable and fixed minor bug regarding
+	the lexer.
+	[931a0b442f19]
+
+	* .hgignore, src/lib-sieve/Makefile.am, src/lib-sieve/sieve-ast.c, src
+	/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-generator.h, src
+	/lib-sieve/sieve-parser.c, src/lib-sieve/sieve-parser.h, src/lib-
+	sieve/sieve-validator.c, src/lib-sieve/sieve-validator.h, src/lib-
+	sieve/sieve.c, src/lib-sieve/sieve.h, src/sieve-bin/Makefile, src
+	/sieve-bin/Makefile.am, src/sieve-bin/Makefile.in, src/sieve-
+	bin/sieve_test.c, src/sieve-bin/sievec, src/sieve-bin/sievec.c, src
+	/sieve-bin/sievec.o:
+	Created libsieve interface and started the sieve_test binary.
+	[8d922df3dd5c]
+
+2007-10-24  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/cmd-if.c, src/lib-sieve/ext-fileinto.c, src/lib-sieve
+	/ext-reject.c, src/lib-sieve/plugins/Makefile, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-ast.c,
+	src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-code.c, src/lib-
+	sieve/sieve-commands.c, src/lib-sieve/sieve-generator.c, src/lib-
+	sieve/sieve-generator.h, src/lib-sieve/sieve-interpreter.c, src/lib-
+	sieve/sieve-lexer.c, src/lib-sieve/sieve-parser.c, src/lib-sieve
+	/sieve-result.c, src/lib-sieve/sieve-validator.c, src/lib-sieve/tst-
+	address.c, src/lib-sieve/tst-size.c, src/sieve-bin/Makefile, src
+	/sieve-bin/Makefile.am, src/sieve-bin/Makefile.in, src/sieve-
+	bin/sievec, src/sieve-bin/sievec.o:
+	Upgraded from dovecot-1.0 to dovecot-1.1 (array changes and various
+	_unref differences)
+	[f36e62f9baf9]
+
+	* configure.in, sieve/errors/address-errors.sieve, sieve/errors
+	/header-errors.sieve, sieve/errors/if-errors.sieve,
+	sieve/errors/interesting.sieve, sieve/errors/keep-errors.sieve,
+	sieve/errors/parse-errors.sieve, sieve/errors/require-errors.sieve,
+	sieve/errors/size-errors.sieve, sieve/errors/stop-errors.sieve,
+	sieve/errors/tag-errors.sieve, sieve/examples/elvey.sieve,
+	sieve/examples/mjohnson.sieve, sieve/examples/mklose.sieve,
+	sieve/examples/rfc3028.sieve, sieve/examples/sanjay.sieve,
+	sieve/examples/sieve_examples.sieve, sieve/examples/stephan.sieve,
+	sieve/examples/unparsed-elvey.sieve, sieve/examples/vacation.sieve,
+	sieve/examples/vivil.sieve, sieve/tests/basic.sieve,
+	sieve/tests/extensions.sieve, sieve/tests/if.sieve, src/Makefile.am,
+	src/lib-sieve/Makefile.am, src/lib-sieve/scripts/errors/address-
+	errors.sieve, src/lib-sieve/scripts/errors/header-errors.sieve, src
+	/lib-sieve/scripts/errors/if-errors.sieve, src/lib-
+	sieve/scripts/errors/interesting.sieve, src/lib-sieve/scripts/errors
+	/keep-errors.sieve, src/lib-sieve/scripts/errors/parse-errors.sieve,
+	src/lib-sieve/scripts/errors/require-errors.sieve, src/lib-
+	sieve/scripts/errors/size-errors.sieve, src/lib-sieve/scripts/errors
+	/stop-errors.sieve, src/lib-sieve/scripts/errors/tag-errors.sieve,
+	src/lib-sieve/scripts/examples/elvey.sieve, src/lib-
+	sieve/scripts/examples/mjohnson.sieve, src/lib-
+	sieve/scripts/examples/mklose.sieve, src/lib-
+	sieve/scripts/examples/rfc3028.sieve, src/lib-
+	sieve/scripts/examples/sanjay.sieve, src/lib-
+	sieve/scripts/examples/sieve_examples.sieve, src/lib-
+	sieve/scripts/examples/stephan.sieve, src/lib-sieve/scripts/examples
+	/unparsed-elvey.sieve, src/lib-
+	sieve/scripts/examples/vacation.sieve, src/lib-
+	sieve/scripts/examples/vivil.sieve, src/lib-
+	sieve/scripts/tests/extensions.sieve, src/lib-
+	sieve/scripts/tests/if.sieve, src/lib-sieve/sieve-code.c, src/lib-
+	sieve/sieve-code.h, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/sieve-interpreter.h, src/lib-sieve/sieve-result.c, src/lib-
+	sieve/sievec.c, src/lib-sieve/tst-address.c, src/lib-sieve/tst-
+	exists.c, src/lib-sieve/tst-header.c, src/lib-sieve/tst-size.c, src
+	/sieve-bin/Makefile, src/sieve-bin/Makefile.am, src/sieve-
+	bin/Makefile.in, src/sieve-bin/sievec, src/sieve-bin/sievec.c, src
+	/sieve-bin/sievec.o:
+	Exported sievec binary to separate directory called sieve-bin.
+	[f3dd838d3893]
+
+2007-10-23  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/cmd-if.c, src/lib-sieve
+	/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-
+	reject.c, src/lib-sieve/plugins/vacation/Makefile.am, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-binary.c,
+	src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-code.c, src/lib-
+	sieve/sieve-code.h, src/lib-sieve/sieve-commands.c, src/lib-sieve
+	/sieve-common.h, src/lib-sieve/sieve-extensions.h, src/lib-sieve
+	/sieve-generator.c, src/lib-sieve/sieve-generator.h, src/lib-sieve
+	/sieve-interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-
+	sieve/sieve-result.c, src/lib-sieve/sieve-result.h, src/lib-sieve
+	/tst-address.c, src/lib-sieve/tst-allof.c, src/lib-sieve/tst-
+	anyof.c, src/lib-sieve/tst-exists.c, src/lib-sieve/tst-header.c, src
+	/lib-sieve/tst-size.c:
+	Started first support for actual execution of sieve script.
+	[7d3b717d834d]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/sieve-interpreter.h, src/plugins/Makefile.am, src/plugins/lda-
+	sieve/Makefile.am, src/plugins/lda-sieve/lda-sieve-plugin.c,
+	src/plugins/lda-sieve/lda-sieve-plugin.h:
+	* Minor changes to the extension implementation
+	* Started the lda plugin source
+	[5252fd9fd951]
+
+2007-10-22  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-address.c:
+	Changed (currently unused) sieve-address.c to use dovecot rfc822
+	parser.
+	[d32cc88f0ecf]
+
+	* src/lib-sieve/plugins/vacation/draft-ietf-sieve-vacation-07.txt:
+	Added draft RFC for vacation extension.
+	[4f6590dd1d7e]
+
+	* configure.in, src/lib-sieve/Makefile.am, src/lib-sieve/ext-
+	envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-
+	reject.c, src/lib-sieve/plugins/Makefile, src/lib-
+	sieve/plugins/Makefile.am, src/lib-sieve/plugins/Makefile.in, src
+	/lib-sieve/plugins/comparator-i;ascii-numeric.c, src/lib-
+	sieve/plugins/copy.c, src/lib-sieve/plugins/vacation/Makefile.am,
+	src/lib-sieve/plugins/vacation/ext-vacation.c, src/lib-
+	sieve/plugins/vacation/vacation.sieve, src/lib-
+	sieve/scripts/tests/extensions.sieve, src/lib-sieve/sieve-
+	extensions.c:
+	* Further developed the extension support
+	* Added plugins as static libraries (for now)
+	[2b26d303f3d1]
+
+	* src/lib-sieve/scripts/tests/extensions.sieve, src/lib-
+	sieve/scripts/tests/reject.sieve:
+	Renamed reject.sieve to extensions.sieve for generic extensions
+	testing.
+	[3993600b2e1f]
+
+	* src/lib-sieve/cmd-require.c, src/lib-sieve/ext-fileinto.c:
+	* Added generation support to the fileinto extension.
+	* Fixed a bug in the require command generation.
+	[4f38530232e6]
+
+	* .hgignore, src/lib-sieve/Makefile.am, src/lib-sieve/cmd-require.c,
+	src/lib-sieve/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/ext-reject.c, src/lib-sieve/scripts/tests/reject.sieve, src
+	/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-binary.c, src/lib-sieve
+	/sieve-binary.h, src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-
+	extensions.c, src/lib-sieve/sieve-extensions.h, src/lib-sieve/sieve-
+	generator.c, src/lib-sieve/sieve-generator.h, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-sieve
+	/sieve-validator.c, src/lib-sieve/sieve-validator.h, src/lib-
+	sieve/sievec.c:
+	Added basic extension support to generator and interpreter.
+	[2f78fc8c9919]
+
+2007-10-21  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/cmd-if.c, src/lib-sieve/ext-reject.c, src/lib-sieve
+	/sieve-code.c, src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-
+	commands-private.h, src/lib-sieve/sieve-commands.c, src/lib-sieve
+	/sieve-extensions.h, src/lib-sieve/sieve-generator.c, src/lib-sieve
+	/sieve-generator.h, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/tst-address.c, src/lib-sieve/tst-allof.c, src/lib-sieve/tst-
+	anyof.c, src/lib-sieve/tst-exists.c, src/lib-sieve/tst-header.c, src
+	/lib-sieve/tst-size.c:
+	Initial commit didn't compile because it was comitted in the middle
+	of a new feature.
+	[b50c7ada434a]
+
+	* autogen.sh:
+	Added autogen.sh from the dovecot project (removed doc/wiki code)
+	[10ed2a377ea0]
+
+2007-10-21  stephan  <stephan@flappie>
+
+	* .hgignore, libsieve-config.h.in:
+	Added -config files to the hgignore and removed them from the
+	repository
+	[ddac82bec3c3]
+
+	* .hgignore, AUTHORS, COPYING.LGPL, INSTALL, Makefile.am, NEWS,
+	README, configure.in, libsieve-config.h.in, src/Makefile.am, src
+	/lib-sieve/Makefile.am, src/lib-sieve/cmd-if.c, src/lib-sieve/cmd-
+	redirect.c, src/lib-sieve/cmd-require.c, src/lib-sieve/ext-
+	envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-
+	reject.c, src/lib-sieve/plugins/comparator-i;ascii-numeric.c, src
+	/lib-sieve/plugins/copy.c, src/lib-sieve/scripts/errors/address-
+	errors.sieve, src/lib-sieve/scripts/errors/header-errors.sieve, src
+	/lib-sieve/scripts/errors/if-errors.sieve, src/lib-
+	sieve/scripts/errors/interesting.sieve, src/lib-sieve/scripts/errors
+	/keep-errors.sieve, src/lib-sieve/scripts/errors/parse-errors.sieve,
+	src/lib-sieve/scripts/errors/require-errors.sieve, src/lib-
+	sieve/scripts/errors/size-errors.sieve, src/lib-sieve/scripts/errors
+	/stop-errors.sieve, src/lib-sieve/scripts/errors/tag-errors.sieve,
+	src/lib-sieve/scripts/examples/elvey.sieve, src/lib-
+	sieve/scripts/examples/mjohnson.sieve, src/lib-
+	sieve/scripts/examples/mklose.sieve, src/lib-
+	sieve/scripts/examples/rfc3028.sieve, src/lib-
+	sieve/scripts/examples/sanjay.sieve, src/lib-
+	sieve/scripts/examples/sieve_examples.sieve, src/lib-
+	sieve/scripts/examples/stephan.sieve, src/lib-sieve/scripts/examples
+	/unparsed-elvey.sieve, src/lib-
+	sieve/scripts/examples/vacation.sieve, src/lib-
+	sieve/scripts/examples/vivil.sieve, src/lib-
+	sieve/scripts/tests/if.sieve, src/lib-sieve/sieve-address.c, src
+	/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-ast.h, src/lib-sieve
+	/sieve-code.c, src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-
+	commands-private.h, src/lib-sieve/sieve-commands.c, src/lib-sieve
+	/sieve-commands.h, src/lib-sieve/sieve-common.h, src/lib-sieve
+	/sieve-error.c, src/lib-sieve/sieve-error.h, src/lib-sieve/sieve-
+	extensions.c, src/lib-sieve/sieve-extensions.h, src/lib-sieve/sieve-
+	generator.c, src/lib-sieve/sieve-generator.h, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-sieve
+	/sieve-lexer.c, src/lib-sieve/sieve-lexer.h, src/lib-sieve/sieve-
+	parser.c, src/lib-sieve/sieve-parser.h, src/lib-sieve/sieve-
+	validator.c, src/lib-sieve/sieve-validator.h, src/lib-
+	sieve/sievec.c, src/lib-sieve/tst-address.c, src/lib-sieve/tst-
+	allof.c, src/lib-sieve/tst-anyof.c, src/lib-sieve/tst-exists.c, src
+	/lib-sieve/tst-header.c, src/lib-sieve/tst-not.c, src/lib-sieve/tst-
+	size.c, stamp.h.in:
+	First entered libsieve into new Hg repository
+	[d31c1c993bcf]
+
diff -urN dovecot-1.2.4/dovecot-libsieve/config.rpath dovecot-1.2.4.debian/dovecot-libsieve/config.rpath
--- dovecot-1.2.4/dovecot-libsieve/config.rpath	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/config.rpath	2009-08-21 00:55:29.000000000 +0200
@@ -0,0 +1,666 @@
+#! /bin/sh
+# Output a system dependent set of variables, describing how to set the
+# run time search path of shared libraries in an executable.
+#
+#   Copyright 1996-2007 Free Software Foundation, Inc.
+#   Taken from GNU libtool, 2001
+#   Originally by Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996
+#
+#   This file is free software; the Free Software Foundation gives
+#   unlimited permission to copy and/or distribute it, with or without
+#   modifications, as long as this notice is preserved.
+#
+# The first argument passed to this file is the canonical host specification,
+#    CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
+# or
+#    CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
+# The environment variables CC, GCC, LDFLAGS, LD, with_gnu_ld
+# should be set by the caller.
+#
+# The set of defined variables is at the end of this script.
+
+# Known limitations:
+# - On IRIX 6.5 with CC="cc", the run time search patch must not be longer
+#   than 256 bytes, otherwise the compiler driver will dump core. The only
+#   known workaround is to choose shorter directory names for the build
+#   directory and/or the installation directory.
+
+# All known linkers require a `.a' archive for static linking (except MSVC,
+# which needs '.lib').
+libext=a
+shrext=.so
+
+host="$1"
+host_cpu=`echo "$host" | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+host_vendor=`echo "$host" | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+host_os=`echo "$host" | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+# Code taken from libtool.m4's _LT_CC_BASENAME.
+
+for cc_temp in $CC""; do
+  case $cc_temp in
+    compile | *[\\/]compile | ccache | *[\\/]ccache ) ;;
+    distcc | *[\\/]distcc | purify | *[\\/]purify ) ;;
+    \-*) ;;
+    *) break;;
+  esac
+done
+cc_basename=`echo "$cc_temp" | sed -e 's%^.*/%%'`
+
+# Code taken from libtool.m4's AC_LIBTOOL_PROG_COMPILER_PIC.
+
+wl=
+if test "$GCC" = yes; then
+  wl='-Wl,'
+else
+  case "$host_os" in
+    aix*)
+      wl='-Wl,'
+      ;;
+    darwin*)
+      case $cc_basename in
+        xlc*)
+          wl='-Wl,'
+          ;;
+      esac
+      ;;
+    mingw* | cygwin* | pw32* | os2*)
+      ;;
+    hpux9* | hpux10* | hpux11*)
+      wl='-Wl,'
+      ;;
+    irix5* | irix6* | nonstopux*)
+      wl='-Wl,'
+      ;;
+    newsos6)
+      ;;
+    linux* | k*bsd*-gnu)
+      case $cc_basename in
+        icc* | ecc*)
+          wl='-Wl,'
+          ;;
+        pgcc | pgf77 | pgf90)
+          wl='-Wl,'
+          ;;
+        ccc*)
+          wl='-Wl,'
+          ;;
+        como)
+          wl='-lopt='
+          ;;
+        *)
+          case `$CC -V 2>&1 | sed 5q` in
+            *Sun\ C*)
+              wl='-Wl,'
+              ;;
+          esac
+          ;;
+      esac
+      ;;
+    osf3* | osf4* | osf5*)
+      wl='-Wl,'
+      ;;
+    rdos*)
+      ;;
+    solaris*)
+      wl='-Wl,'
+      ;;
+    sunos4*)
+      wl='-Qoption ld '
+      ;;
+    sysv4 | sysv4.2uw2* | sysv4.3*)
+      wl='-Wl,'
+      ;;
+    sysv4*MP*)
+      ;;
+    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
+      wl='-Wl,'
+      ;;
+    unicos*)
+      wl='-Wl,'
+      ;;
+    uts4*)
+      ;;
+  esac
+fi
+
+# Code taken from libtool.m4's AC_LIBTOOL_PROG_LD_SHLIBS.
+
+hardcode_libdir_flag_spec=
+hardcode_libdir_separator=
+hardcode_direct=no
+hardcode_minus_L=no
+
+case "$host_os" in
+  cygwin* | mingw* | pw32*)
+    # FIXME: the MSVC++ port hasn't been tested in a loooong time
+    # When not using gcc, we currently assume that we are using
+    # Microsoft Visual C++.
+    if test "$GCC" != yes; then
+      with_gnu_ld=no
+    fi
+    ;;
+  interix*)
+    # we just hope/assume this is gcc and not c89 (= MSVC++)
+    with_gnu_ld=yes
+    ;;
+  openbsd*)
+    with_gnu_ld=no
+    ;;
+esac
+
+ld_shlibs=yes
+if test "$with_gnu_ld" = yes; then
+  # Set some defaults for GNU ld with shared library support. These
+  # are reset later if shared libraries are not supported. Putting them
+  # here allows them to be overridden if necessary.
+  # Unlike libtool, we use -rpath here, not --rpath, since the documented
+  # option of GNU ld is called -rpath, not --rpath.
+  hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+  case "$host_os" in
+    aix3* | aix4* | aix5*)
+      # On AIX/PPC, the GNU linker is very broken
+      if test "$host_cpu" != ia64; then
+        ld_shlibs=no
+      fi
+      ;;
+    amigaos*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_minus_L=yes
+      # Samuel A. Falvo II <kc5tja@dolphin.openprojects.net> reports
+      # that the semantics of dynamic libraries on AmigaOS, at least up
+      # to version 4, is to share data among multiple programs linked
+      # with the same dynamic library.  Since this doesn't match the
+      # behavior of shared libraries on other platforms, we cannot use
+      # them.
+      ld_shlibs=no
+      ;;
+    beos*)
+      if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+        :
+      else
+        ld_shlibs=no
+      fi
+      ;;
+    cygwin* | mingw* | pw32*)
+      # hardcode_libdir_flag_spec is actually meaningless, as there is
+      # no search path for DLLs.
+      hardcode_libdir_flag_spec='-L$libdir'
+      if $LD --help 2>&1 | grep 'auto-import' > /dev/null; then
+        :
+      else
+        ld_shlibs=no
+      fi
+      ;;
+    interix[3-9]*)
+      hardcode_direct=no
+      hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+      ;;
+    gnu* | linux* | k*bsd*-gnu)
+      if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+        :
+      else
+        ld_shlibs=no
+      fi
+      ;;
+    netbsd*)
+      ;;
+    solaris*)
+      if $LD -v 2>&1 | grep 'BFD 2\.8' > /dev/null; then
+        ld_shlibs=no
+      elif $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+        :
+      else
+        ld_shlibs=no
+      fi
+      ;;
+    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)
+      case `$LD -v 2>&1` in
+        *\ [01].* | *\ 2.[0-9].* | *\ 2.1[0-5].*)
+          ld_shlibs=no
+          ;;
+        *)
+          if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+            hardcode_libdir_flag_spec='`test -z "$SCOABSPATH" && echo ${wl}-rpath,$libdir`'
+          else
+            ld_shlibs=no
+          fi
+          ;;
+      esac
+      ;;
+    sunos4*)
+      hardcode_direct=yes
+      ;;
+    *)
+      if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+        :
+      else
+        ld_shlibs=no
+      fi
+      ;;
+  esac
+  if test "$ld_shlibs" = no; then
+    hardcode_libdir_flag_spec=
+  fi
+else
+  case "$host_os" in
+    aix3*)
+      # Note: this linker hardcodes the directories in LIBPATH if there
+      # are no directories specified by -L.
+      hardcode_minus_L=yes
+      if test "$GCC" = yes; then
+        # Neither direct hardcoding nor static linking is supported with a
+        # broken collect2.
+        hardcode_direct=unsupported
+      fi
+      ;;
+    aix4* | aix5*)
+      if test "$host_cpu" = ia64; then
+        # On IA64, the linker does run time linking by default, so we don't
+        # have to do anything special.
+        aix_use_runtimelinking=no
+      else
+        aix_use_runtimelinking=no
+        # Test if we are trying to use run time linking or normal
+        # AIX style linking. If -brtl is somewhere in LDFLAGS, we
+        # need to do runtime linking.
+        case $host_os in aix4.[23]|aix4.[23].*|aix5*)
+          for ld_flag in $LDFLAGS; do
+            if (test $ld_flag = "-brtl" || test $ld_flag = "-Wl,-brtl"); then
+              aix_use_runtimelinking=yes
+              break
+            fi
+          done
+          ;;
+        esac
+      fi
+      hardcode_direct=yes
+      hardcode_libdir_separator=':'
+      if test "$GCC" = yes; then
+        case $host_os in aix4.[012]|aix4.[012].*)
+          collect2name=`${CC} -print-prog-name=collect2`
+          if test -f "$collect2name" && \
+            strings "$collect2name" | grep resolve_lib_name >/dev/null
+          then
+            # We have reworked collect2
+            :
+          else
+            # We have old collect2
+            hardcode_direct=unsupported
+            hardcode_minus_L=yes
+            hardcode_libdir_flag_spec='-L$libdir'
+            hardcode_libdir_separator=
+          fi
+          ;;
+        esac
+      fi
+      # Begin _LT_AC_SYS_LIBPATH_AIX.
+      echo 'int main () { return 0; }' > conftest.c
+      ${CC} ${LDFLAGS} conftest.c -o conftest
+      aix_libpath=`dump -H conftest 2>/dev/null | sed -n -e '/Import File Strings/,/^$/ { /^0/ { s/^0  *\(.*\)$/\1/; p; }
+}'`
+      if test -z "$aix_libpath"; then
+        aix_libpath=`dump -HX64 conftest 2>/dev/null | sed -n -e '/Import File Strings/,/^$/ { /^0/ { s/^0  *\(.*\)$/\1/; p; }
+}'`
+      fi
+      if test -z "$aix_libpath"; then
+        aix_libpath="/usr/lib:/lib"
+      fi
+      rm -f conftest.c conftest
+      # End _LT_AC_SYS_LIBPATH_AIX.
+      if test "$aix_use_runtimelinking" = yes; then
+        hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
+      else
+        if test "$host_cpu" = ia64; then
+          hardcode_libdir_flag_spec='${wl}-R $libdir:/usr/lib:/lib'
+        else
+          hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
+        fi
+      fi
+      ;;
+    amigaos*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_minus_L=yes
+      # see comment about different semantics on the GNU ld section
+      ld_shlibs=no
+      ;;
+    bsdi[45]*)
+      ;;
+    cygwin* | mingw* | pw32*)
+      # When not using gcc, we currently assume that we are using
+      # Microsoft Visual C++.
+      # hardcode_libdir_flag_spec is actually meaningless, as there is
+      # no search path for DLLs.
+      hardcode_libdir_flag_spec=' '
+      libext=lib
+      ;;
+    darwin* | rhapsody*)
+      hardcode_direct=no
+      if test "$GCC" = yes ; then
+        :
+      else
+        case $cc_basename in
+          xlc*)
+            ;;
+          *)
+            ld_shlibs=no
+            ;;
+        esac
+      fi
+      ;;
+    dgux*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      ;;
+    freebsd1*)
+      ld_shlibs=no
+      ;;
+    freebsd2.2*)
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      ;;
+    freebsd2*)
+      hardcode_direct=yes
+      hardcode_minus_L=yes
+      ;;
+    freebsd* | dragonfly*)
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      ;;
+    hpux9*)
+      hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+      hardcode_libdir_separator=:
+      hardcode_direct=yes
+      # hardcode_minus_L: Not really in the search PATH,
+      # but as the default location of the library.
+      hardcode_minus_L=yes
+      ;;
+    hpux10*)
+      if test "$with_gnu_ld" = no; then
+        hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+        hardcode_libdir_separator=:
+        hardcode_direct=yes
+        # hardcode_minus_L: Not really in the search PATH,
+        # but as the default location of the library.
+        hardcode_minus_L=yes
+      fi
+      ;;
+    hpux11*)
+      if test "$with_gnu_ld" = no; then
+        hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+        hardcode_libdir_separator=:
+        case $host_cpu in
+          hppa*64*|ia64*)
+            hardcode_direct=no
+            ;;
+          *)
+            hardcode_direct=yes
+            # hardcode_minus_L: Not really in the search PATH,
+            # but as the default location of the library.
+            hardcode_minus_L=yes
+            ;;
+        esac
+      fi
+      ;;
+    irix5* | irix6* | nonstopux*)
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      ;;
+    netbsd*)
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      ;;
+    newsos6)
+      hardcode_direct=yes
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      ;;
+    openbsd*)
+      if test -f /usr/libexec/ld.so; then
+        hardcode_direct=yes
+        if test -z "`echo __ELF__ | $CC -E - | grep __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+          hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+        else
+          case "$host_os" in
+            openbsd[01].* | openbsd2.[0-7] | openbsd2.[0-7].*)
+              hardcode_libdir_flag_spec='-R$libdir'
+              ;;
+            *)
+              hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+              ;;
+          esac
+        fi
+      else
+        ld_shlibs=no
+      fi
+      ;;
+    os2*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_minus_L=yes
+      ;;
+    osf3*)
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      ;;
+    osf4* | osf5*)
+      if test "$GCC" = yes; then
+        hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      else
+        # Both cc and cxx compiler support -rpath directly
+        hardcode_libdir_flag_spec='-rpath $libdir'
+      fi
+      hardcode_libdir_separator=:
+      ;;
+    solaris*)
+      hardcode_libdir_flag_spec='-R$libdir'
+      ;;
+    sunos4*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_direct=yes
+      hardcode_minus_L=yes
+      ;;
+    sysv4)
+      case $host_vendor in
+        sni)
+          hardcode_direct=yes # is this really true???
+          ;;
+        siemens)
+          hardcode_direct=no
+          ;;
+        motorola)
+          hardcode_direct=no #Motorola manual says yes, but my tests say they lie
+          ;;
+      esac
+      ;;
+    sysv4.3*)
+      ;;
+    sysv4*MP*)
+      if test -d /usr/nec; then
+        ld_shlibs=yes
+      fi
+      ;;
+    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[01].[10]* | unixware7* | sco3.2v5.0.[024]*)
+      ;;
+    sysv5* | sco3.2v5* | sco5v6*)
+      hardcode_libdir_flag_spec='`test -z "$SCOABSPATH" && echo ${wl}-R,$libdir`'
+      hardcode_libdir_separator=':'
+      ;;
+    uts4*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      ;;
+    *)
+      ld_shlibs=no
+      ;;
+  esac
+fi
+
+# Check dynamic linker characteristics
+# Code taken from libtool.m4's AC_LIBTOOL_SYS_DYNAMIC_LINKER.
+# Unlike libtool.m4, here we don't care about _all_ names of the library, but
+# only about the one the linker finds when passed -lNAME. This is the last
+# element of library_names_spec in libtool.m4, or possibly two of them if the
+# linker has special search rules.
+library_names_spec=      # the last element of library_names_spec in libtool.m4
+libname_spec='lib$name'
+case "$host_os" in
+  aix3*)
+    library_names_spec='$libname.a'
+    ;;
+  aix4* | aix5*)
+    library_names_spec='$libname$shrext'
+    ;;
+  amigaos*)
+    library_names_spec='$libname.a'
+    ;;
+  beos*)
+    library_names_spec='$libname$shrext'
+    ;;
+  bsdi[45]*)
+    library_names_spec='$libname$shrext'
+    ;;
+  cygwin* | mingw* | pw32*)
+    shrext=.dll
+    library_names_spec='$libname.dll.a $libname.lib'
+    ;;
+  darwin* | rhapsody*)
+    shrext=.dylib
+    library_names_spec='$libname$shrext'
+    ;;
+  dgux*)
+    library_names_spec='$libname$shrext'
+    ;;
+  freebsd1*)
+    ;;
+  freebsd* | dragonfly*)
+    case "$host_os" in
+      freebsd[123]*)
+        library_names_spec='$libname$shrext$versuffix' ;;
+      *)
+        library_names_spec='$libname$shrext' ;;
+    esac
+    ;;
+  gnu*)
+    library_names_spec='$libname$shrext'
+    ;;
+  hpux9* | hpux10* | hpux11*)
+    case $host_cpu in
+      ia64*)
+        shrext=.so
+        ;;
+      hppa*64*)
+        shrext=.sl
+        ;;
+      *)
+        shrext=.sl
+        ;;
+    esac
+    library_names_spec='$libname$shrext'
+    ;;
+  interix[3-9]*)
+    library_names_spec='$libname$shrext'
+    ;;
+  irix5* | irix6* | nonstopux*)
+    library_names_spec='$libname$shrext'
+    case "$host_os" in
+      irix5* | nonstopux*)
+        libsuff= shlibsuff=
+        ;;
+      *)
+        case $LD in
+          *-32|*"-32 "|*-melf32bsmip|*"-melf32bsmip ") libsuff= shlibsuff= ;;
+          *-n32|*"-n32 "|*-melf32bmipn32|*"-melf32bmipn32 ") libsuff=32 shlibsuff=N32 ;;
+          *-64|*"-64 "|*-melf64bmip|*"-melf64bmip ") libsuff=64 shlibsuff=64 ;;
+          *) libsuff= shlibsuff= ;;
+        esac
+        ;;
+    esac
+    ;;
+  linux*oldld* | linux*aout* | linux*coff*)
+    ;;
+  linux* | k*bsd*-gnu)
+    library_names_spec='$libname$shrext'
+    ;;
+  knetbsd*-gnu)
+    library_names_spec='$libname$shrext'
+    ;;
+  netbsd*)
+    library_names_spec='$libname$shrext'
+    ;;
+  newsos6)
+    library_names_spec='$libname$shrext'
+    ;;
+  nto-qnx*)
+    library_names_spec='$libname$shrext'
+    ;;
+  openbsd*)
+    library_names_spec='$libname$shrext$versuffix'
+    ;;
+  os2*)
+    libname_spec='$name'
+    shrext=.dll
+    library_names_spec='$libname.a'
+    ;;
+  osf3* | osf4* | osf5*)
+    library_names_spec='$libname$shrext'
+    ;;
+  rdos*)
+    ;;
+  solaris*)
+    library_names_spec='$libname$shrext'
+    ;;
+  sunos4*)
+    library_names_spec='$libname$shrext$versuffix'
+    ;;
+  sysv4 | sysv4.3*)
+    library_names_spec='$libname$shrext'
+    ;;
+  sysv4*MP*)
+    library_names_spec='$libname$shrext'
+    ;;
+  sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
+    library_names_spec='$libname$shrext'
+    ;;
+  uts4*)
+    library_names_spec='$libname$shrext'
+    ;;
+esac
+
+sed_quote_subst='s/\(["`$\\]\)/\\\1/g'
+escaped_wl=`echo "X$wl" | sed -e 's/^X//' -e "$sed_quote_subst"`
+shlibext=`echo "$shrext" | sed -e 's,^\.,,'`
+escaped_libname_spec=`echo "X$libname_spec" | sed -e 's/^X//' -e "$sed_quote_subst"`
+escaped_library_names_spec=`echo "X$library_names_spec" | sed -e 's/^X//' -e "$sed_quote_subst"`
+escaped_hardcode_libdir_flag_spec=`echo "X$hardcode_libdir_flag_spec" | sed -e 's/^X//' -e "$sed_quote_subst"`
+
+LC_ALL=C sed -e 's/^\([a-zA-Z0-9_]*\)=/acl_cv_\1=/' <<EOF
+
+# How to pass a linker flag through the compiler.
+wl="$escaped_wl"
+
+# Static library suffix (normally "a").
+libext="$libext"
+
+# Shared library suffix (normally "so").
+shlibext="$shlibext"
+
+# Format of library name prefix.
+libname_spec="$escaped_libname_spec"
+
+# Library names that the linker finds when passed -lNAME.
+library_names_spec="$escaped_library_names_spec"
+
+# Flag to hardcode \$libdir into a binary during linking.
+# This must work even if \$libdir does not exist.
+hardcode_libdir_flag_spec="$escaped_hardcode_libdir_flag_spec"
+
+# Whether we need a single -rpath flag with a separated argument.
+hardcode_libdir_separator="$hardcode_libdir_separator"
+
+# Set to yes if using DIR/libNAME.so during linking hardcodes DIR into the
+# resulting binary.
+hardcode_direct="$hardcode_direct"
+
+# Set to yes if using the -LDIR flag during linking hardcodes DIR into the
+# resulting binary.
+hardcode_minus_L="$hardcode_minus_L"
+
+EOF
diff -urN dovecot-1.2.4/dovecot-libsieve/configure.in dovecot-1.2.4.debian/dovecot-libsieve/configure.in
--- dovecot-1.2.4/dovecot-libsieve/configure.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/configure.in	2009-08-21 00:55:05.000000000 +0200
@@ -0,0 +1,128 @@
+AC_INIT([Dovecot Sieve], [0.1.12], [dovecot@dovecot.org], [dovecot-1.2-sieve])
+AC_CONFIG_SRCDIR([src])
+
+# Autoheader is not needed and does more harm than good for this package. However, it is 
+# tightly integrated in autoconf/automake and therefore it is difficult not to use it. As 
+# a workaround we give autoheader a dummy config header to chew on and we handle the 
+# real config header ourselves.
+AC_CONFIG_HEADERS([dummy-config.h dsieve-config.h])
+
+AC_DEFINE_UNQUOTED(SIEVE_NAME, "$PACKAGE_NAME", 
+	[Define to the full name of this Sieve implementation.])
+AC_DEFINE_UNQUOTED(SIEVE_VERSION, "$PACKAGE_VERSION", 
+	[Define to the version of this Sieve implementation.])
+
+AM_INIT_AUTOMAKE([no-define foreign])
+
+AM_MAINTAINER_MODE
+
+AC_PROG_CC
+AC_PROG_CPP
+AC_PROG_LIBTOOL
+
+AC_ARG_WITH(dovecot,
+[AC_HELP_STRING([--with-dovecot=DIR], [Dovecot base directory [../dovecot]])],
+	dovecotdir="$withval",
+	dovecotdir=../dovecot
+)
+old=`pwd`
+cd $dovecotdir
+dovecotdir=`pwd`
+cd $old
+AC_SUBST(dovecotdir)
+
+if ! test -f "$dovecotdir/dovecot-config"; then
+  echo
+  echo "dovecot-config not found from $dovecotdir, use --with-dovecot=PATH"
+  echo "to give path to compiled Dovecot sources or to a directory with the"
+  echo "installed dovecot-config file."
+  AC_MSG_ERROR([dovecot-config not found])
+fi
+
+if test -d "$dovecotdir/src"; then
+  # compiling against sources
+  have_dovecot_libs=yes
+else
+  # compiling against installed headers
+  echo "WARNING: Cannot build Sieve commandline tools without the compiled"
+  echo "         Dovecot sources. Compiling against headers will only build"
+  echo "         the Sieve plugin." 
+  have_dovecot_libs=no
+fi
+AM_CONDITIONAL(HAVE_DOVECOT_LIBS, test "$have_dovecot_libs" = "yes")
+
+# Extensions under development
+#
+
+AC_ARG_WITH(unfinished-features,
+[AC_HELP_STRING([--with-unfinished-features], 
+	[Build unfinished new features/extensions [default=no]])],
+        if test x$withval = xno || test x$withval = xauto; then
+                want_unfinished_features=$withval
+        else
+                want_unfinished_features=yes
+        fi,
+        want_unfinished_features=no)
+AM_CONDITIONAL(BUILD_UNFINISHED, test "$want_unfinished_features" = "yes")
+
+if test "$want_unfinished_features" = "yes"; then
+	AC_DEFINE(HAVE_SIEVE_UNFINISHED,,
+		[Define to build Sieve unfinished features/extensions.])
+fi
+
+#
+#
+
+AC_ARG_ENABLE(valgrind,
+[AC_HELP_STRING([--enable-valgrind], [Enable Valgrind memory leak checks in testsuite [default=no]])],
+    if test x$enableval = xno || test x$enableval = xauto; then
+        want_valgrind=$enableval
+    else
+        want_valgrind=yes
+    fi,
+    want_valgrind=no)
+AM_CONDITIONAL(TESTSUITE_VALGRIND, test "$want_valgrind" = "yes")
+
+dnl replace relative ../ paths in the file with full paths
+eval `cat $dovecotdir/dovecot-config|sed 's,\$(top_builddir)/,$dovecotdir/,g'`
+
+if test $have_dovecot_libs = yes; then
+  dovecot_incdir="$dovecotdir"
+fi
+
+AC_SUBST(STORAGE_LIBS)
+AC_SUBST(LIBICONV)
+AC_SUBST(RAND_LIBS)
+AC_SUBST(MODULE_LIBS)
+AC_SUBST(dovecot_incdir)
+AC_SUBST(moduledir)
+
+AC_CONFIG_FILES([
+Makefile
+src/Makefile
+src/lib-sieve/Makefile
+src/lib-sieve/plugins/Makefile
+src/lib-sieve/plugins/vacation/Makefile
+src/lib-sieve/plugins/subaddress/Makefile
+src/lib-sieve/plugins/comparator-i-ascii-numeric/Makefile
+src/lib-sieve/plugins/relational/Makefile
+src/lib-sieve/plugins/regex/Makefile
+src/lib-sieve/plugins/imap4flags/Makefile
+src/lib-sieve/plugins/copy/Makefile
+src/lib-sieve/plugins/include/Makefile
+src/lib-sieve/plugins/body/Makefile
+src/lib-sieve/plugins/variables/Makefile
+src/lib-sieve/plugins/enotify/Makefile
+src/lib-sieve/plugins/notify/Makefile
+src/lib-sieve/plugins/environment/Makefile
+src/lib-sieve/plugins/mailbox/Makefile
+src/lib-sieve/plugins/date/Makefile
+src/lib-sieve-tool/Makefile
+src/plugins/Makefile
+src/plugins/lda-sieve/Makefile
+src/sieve-tools/Makefile
+src/sieve-tools/debug/Makefile
+src/testsuite/Makefile
+stamp.h])
+
+AC_OUTPUT
diff -urN dovecot-1.2.4/dovecot-libsieve/COPYING dovecot-1.2.4.debian/dovecot-libsieve/COPYING
--- dovecot-1.2.4/dovecot-libsieve/COPYING	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/COPYING	2008-07-18 12:11:28.000000000 +0200
@@ -0,0 +1,4 @@
+See AUTHORS file for list of copyright holders.
+
+Everything is licenced under LGPLv2.1 (see COPYING.LGPL) unless otherwise 
+mentioned at the beginning of the file.
diff -urN dovecot-1.2.4/dovecot-libsieve/COPYING.LGPL dovecot-1.2.4.debian/dovecot-libsieve/COPYING.LGPL
--- dovecot-1.2.4/dovecot-libsieve/COPYING.LGPL	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/COPYING.LGPL	2008-07-18 12:11:28.000000000 +0200
@@ -0,0 +1,510 @@
+
+                  GNU LESSER GENERAL PUBLIC LICENSE
+                       Version 2.1, February 1999
+
+ Copyright (C) 1991, 1999 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+[This is the first released version of the Lesser GPL.  It also counts
+ as the successor of the GNU Library Public License, version 2, hence
+ the version number 2.1.]
+
+                            Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+Licenses are intended to guarantee your freedom to share and change
+free software--to make sure the software is free for all its users.
+
+  This license, the Lesser General Public License, applies to some
+specially designated software packages--typically libraries--of the
+Free Software Foundation and other authors who decide to use it.  You
+can use it too, but we suggest you first think carefully about whether
+this license or the ordinary General Public License is the better
+strategy to use in any particular case, based on the explanations
+below.
+
+  When we speak of free software, we are referring to freedom of use,
+not price.  Our General Public Licenses are designed to make sure that
+you have the freedom to distribute copies of free software (and charge
+for this service if you wish); that you receive source code or can get
+it if you want it; that you can change the software and use pieces of
+it in new free programs; and that you are informed that you can do
+these things.
+
+  To protect your rights, we need to make restrictions that forbid
+distributors to deny you these rights or to ask you to surrender these
+rights.  These restrictions translate to certain responsibilities for
+you if you distribute copies of the library or if you modify it.
+
+  For example, if you distribute copies of the library, whether gratis
+or for a fee, you must give the recipients all the rights that we gave
+you.  You must make sure that they, too, receive or can get the source
+code.  If you link other code with the library, you must provide
+complete object files to the recipients, so that they can relink them
+with the library after making changes to the library and recompiling
+it.  And you must show them these terms so they know their rights.
+
+  We protect your rights with a two-step method: (1) we copyright the
+library, and (2) we offer you this license, which gives you legal
+permission to copy, distribute and/or modify the library.
+
+  To protect each distributor, we want to make it very clear that
+there is no warranty for the free library.  Also, if the library is
+modified by someone else and passed on, the recipients should know
+that what they have is not the original version, so that the original
+author's reputation will not be affected by problems that might be
+introduced by others.
+^L
+  Finally, software patents pose a constant threat to the existence of
+any free program.  We wish to make sure that a company cannot
+effectively restrict the users of a free program by obtaining a
+restrictive license from a patent holder.  Therefore, we insist that
+any patent license obtained for a version of the library must be
+consistent with the full freedom of use specified in this license.
+
+  Most GNU software, including some libraries, is covered by the
+ordinary GNU General Public License.  This license, the GNU Lesser
+General Public License, applies to certain designated libraries, and
+is quite different from the ordinary General Public License.  We use
+this license for certain libraries in order to permit linking those
+libraries into non-free programs.
+
+  When a program is linked with a library, whether statically or using
+a shared library, the combination of the two is legally speaking a
+combined work, a derivative of the original library.  The ordinary
+General Public License therefore permits such linking only if the
+entire combination fits its criteria of freedom.  The Lesser General
+Public License permits more lax criteria for linking other code with
+the library.
+
+  We call this license the "Lesser" General Public License because it
+does Less to protect the user's freedom than the ordinary General
+Public License.  It also provides other free software developers Less
+of an advantage over competing non-free programs.  These disadvantages
+are the reason we use the ordinary General Public License for many
+libraries.  However, the Lesser license provides advantages in certain
+special circumstances.
+
+  For example, on rare occasions, there may be a special need to
+encourage the widest possible use of a certain library, so that it
+becomes a de-facto standard.  To achieve this, non-free programs must
+be allowed to use the library.  A more frequent case is that a free
+library does the same job as widely used non-free libraries.  In this
+case, there is little to gain by limiting the free library to free
+software only, so we use the Lesser General Public License.
+
+  In other cases, permission to use a particular library in non-free
+programs enables a greater number of people to use a large body of
+free software.  For example, permission to use the GNU C Library in
+non-free programs enables many more people to use the whole GNU
+operating system, as well as its variant, the GNU/Linux operating
+system.
+
+  Although the Lesser General Public License is Less protective of the
+users' freedom, it does ensure that the user of a program that is
+linked with the Library has the freedom and the wherewithal to run
+that program using a modified version of the Library.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.  Pay close attention to the difference between a
+"work based on the library" and a "work that uses the library".  The
+former contains code derived from the library, whereas the latter must
+be combined with the library in order to run.
+^L
+                  GNU LESSER GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License Agreement applies to any software library or other
+program which contains a notice placed by the copyright holder or
+other authorized party saying it may be distributed under the terms of
+this Lesser General Public License (also called "this License").
+Each licensee is addressed as "you".
+
+  A "library" means a collection of software functions and/or data
+prepared so as to be conveniently linked with application programs
+(which use some of those functions and data) to form executables.
+
+  The "Library", below, refers to any such software library or work
+which has been distributed under these terms.  A "work based on the
+Library" means either the Library or any derivative work under
+copyright law: that is to say, a work containing the Library or a
+portion of it, either verbatim or with modifications and/or translated
+straightforwardly into another language.  (Hereinafter, translation is
+included without limitation in the term "modification".)
+
+  "Source code" for a work means the preferred form of the work for
+making modifications to it.  For a library, complete source code means
+all the source code for all modules it contains, plus any associated
+interface definition files, plus the scripts used to control
+compilation and installation of the library.
+
+  Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running a program using the Library is not restricted, and output from
+such a program is covered only if its contents constitute a work based
+on the Library (independent of the use of the Library in a tool for
+writing it).  Whether that is true depends on what the Library does
+and what the program that uses the Library does.
+
+  1. You may copy and distribute verbatim copies of the Library's
+complete source code as you receive it, in any medium, provided that
+you conspicuously and appropriately publish on each copy an
+appropriate copyright notice and disclaimer of warranty; keep intact
+all the notices that refer to this License and to the absence of any
+warranty; and distribute a copy of this License along with the
+Library.
+
+  You may charge a fee for the physical act of transferring a copy,
+and you may at your option offer warranty protection in exchange for a
+fee.
+
+  2. You may modify your copy or copies of the Library or any portion
+of it, thus forming a work based on the Library, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) The modified work must itself be a software library.
+
+    b) You must cause the files modified to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    c) You must cause the whole of the work to be licensed at no
+    charge to all third parties under the terms of this License.
+
+    d) If a facility in the modified Library refers to a function or a
+    table of data to be supplied by an application program that uses
+    the facility, other than as an argument passed when the facility
+    is invoked, then you must make a good faith effort to ensure that,
+    in the event an application does not supply such function or
+    table, the facility still operates, and performs whatever part of
+    its purpose remains meaningful.
+
+    (For example, a function in a library to compute square roots has
+    a purpose that is entirely well-defined independent of the
+    application.  Therefore, Subsection 2d requires that any
+    application-supplied function or table used by this function must
+    be optional: if the application does not supply it, the square
+    root function must still compute square roots.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Library,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Library, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote
+it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Library.
+
+In addition, mere aggregation of another work not based on the Library
+with the Library (or with a work based on the Library) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may opt to apply the terms of the ordinary GNU General Public
+License instead of this License to a given copy of the Library.  To do
+this, you must alter all the notices that refer to this License, so
+that they refer to the ordinary GNU General Public License, version 2,
+instead of to this License.  (If a newer version than version 2 of the
+ordinary GNU General Public License has appeared, then you can specify
+that version instead if you wish.)  Do not make any other change in
+these notices.
+^L
+  Once this change is made in a given copy, it is irreversible for
+that copy, so the ordinary GNU General Public License applies to all
+subsequent copies and derivative works made from that copy.
+
+  This option is useful when you wish to copy part of the code of
+the Library into a program that is not a library.
+
+  4. You may copy and distribute the Library (or a portion or
+derivative of it, under Section 2) in object code or executable form
+under the terms of Sections 1 and 2 above provided that you accompany
+it with the complete corresponding machine-readable source code, which
+must be distributed under the terms of Sections 1 and 2 above on a
+medium customarily used for software interchange.
+
+  If distribution of object code is made by offering access to copy
+from a designated place, then offering equivalent access to copy the
+source code from the same place satisfies the requirement to
+distribute the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  5. A program that contains no derivative of any portion of the
+Library, but is designed to work with the Library by being compiled or
+linked with it, is called a "work that uses the Library".  Such a
+work, in isolation, is not a derivative work of the Library, and
+therefore falls outside the scope of this License.
+
+  However, linking a "work that uses the Library" with the Library
+creates an executable that is a derivative of the Library (because it
+contains portions of the Library), rather than a "work that uses the
+library".  The executable is therefore covered by this License.
+Section 6 states terms for distribution of such executables.
+
+  When a "work that uses the Library" uses material from a header file
+that is part of the Library, the object code for the work may be a
+derivative work of the Library even though the source code is not.
+Whether this is true is especially significant if the work can be
+linked without the Library, or if the work is itself a library.  The
+threshold for this to be true is not precisely defined by law.
+
+  If such an object file uses only numerical parameters, data
+structure layouts and accessors, and small macros and small inline
+functions (ten lines or less in length), then the use of the object
+file is unrestricted, regardless of whether it is legally a derivative
+work.  (Executables containing this object code plus portions of the
+Library will still fall under Section 6.)
+
+  Otherwise, if the work is a derivative of the Library, you may
+distribute the object code for the work under the terms of Section 6.
+Any executables containing that work also fall under Section 6,
+whether or not they are linked directly with the Library itself.
+^L
+  6. As an exception to the Sections above, you may also combine or
+link a "work that uses the Library" with the Library to produce a
+work containing portions of the Library, and distribute that work
+under terms of your choice, provided that the terms permit
+modification of the work for the customer's own use and reverse
+engineering for debugging such modifications.
+
+  You must give prominent notice with each copy of the work that the
+Library is used in it and that the Library and its use are covered by
+this License.  You must supply a copy of this License.  If the work
+during execution displays copyright notices, you must include the
+copyright notice for the Library among them, as well as a reference
+directing the user to the copy of this License.  Also, you must do one
+of these things:
+
+    a) Accompany the work with the complete corresponding
+    machine-readable source code for the Library including whatever
+    changes were used in the work (which must be distributed under
+    Sections 1 and 2 above); and, if the work is an executable linked
+    with the Library, with the complete machine-readable "work that
+    uses the Library", as object code and/or source code, so that the
+    user can modify the Library and then relink to produce a modified
+    executable containing the modified Library.  (It is understood
+    that the user who changes the contents of definitions files in the
+    Library will not necessarily be able to recompile the application
+    to use the modified definitions.)
+
+    b) Use a suitable shared library mechanism for linking with the
+    Library.  A suitable mechanism is one that (1) uses at run time a
+    copy of the library already present on the user's computer system,
+    rather than copying library functions into the executable, and (2)
+    will operate properly with a modified version of the library, if
+    the user installs one, as long as the modified version is
+    interface-compatible with the version that the work was made with.
+
+    c) Accompany the work with a written offer, valid for at least
+    three years, to give the same user the materials specified in
+    Subsection 6a, above, for a charge no more than the cost of
+    performing this distribution.
+
+    d) If distribution of the work is made by offering access to copy
+    from a designated place, offer equivalent access to copy the above
+    specified materials from the same place.
+
+    e) Verify that the user has already received a copy of these
+    materials or that you have already sent this user a copy.
+
+  For an executable, the required form of the "work that uses the
+Library" must include any data and utility programs needed for
+reproducing the executable from it.  However, as a special exception,
+the materials to be distributed need not include anything that is
+normally distributed (in either source or binary form) with the major
+components (compiler, kernel, and so on) of the operating system on
+which the executable runs, unless that component itself accompanies
+the executable.
+
+  It may happen that this requirement contradicts the license
+restrictions of other proprietary libraries that do not normally
+accompany the operating system.  Such a contradiction means you cannot
+use both them and the Library together in an executable that you
+distribute.
+^L
+  7. You may place library facilities that are a work based on the
+Library side-by-side in a single library together with other library
+facilities not covered by this License, and distribute such a combined
+library, provided that the separate distribution of the work based on
+the Library and of the other library facilities is otherwise
+permitted, and provided that you do these two things:
+
+    a) Accompany the combined library with a copy of the same work
+    based on the Library, uncombined with any other library
+    facilities.  This must be distributed under the terms of the
+    Sections above.
+
+    b) Give prominent notice with the combined library of the fact
+    that part of it is a work based on the Library, and explaining
+    where to find the accompanying uncombined form of the same work.
+
+  8. You may not copy, modify, sublicense, link with, or distribute
+the Library except as expressly provided under this License.  Any
+attempt otherwise to copy, modify, sublicense, link with, or
+distribute the Library is void, and will automatically terminate your
+rights under this License.  However, parties who have received copies,
+or rights, from you under this License will not have their licenses
+terminated so long as such parties remain in full compliance.
+
+  9. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Library or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Library (or any work based on the
+Library), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Library or works based on it.
+
+  10. Each time you redistribute the Library (or any work based on the
+Library), the recipient automatically receives a license from the
+original licensor to copy, distribute, link with or modify the Library
+subject to these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties with
+this License.
+^L
+  11. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Library at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Library by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Library.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply, and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  12. If the distribution and/or use of the Library is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Library under this License
+may add an explicit geographical distribution limitation excluding those
+countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  13. The Free Software Foundation may publish revised and/or new
+versions of the Lesser General Public License from time to time.
+Such new versions will be similar in spirit to the present version,
+but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Library
+specifies a version number of this License which applies to it and
+"any later version", you have the option of following the terms and
+conditions either of that version or of any later version published by
+the Free Software Foundation.  If the Library does not specify a
+license version number, you may choose any version ever published by
+the Free Software Foundation.
+^L
+  14. If you wish to incorporate parts of the Library into other free
+programs whose distribution conditions are incompatible with these,
+write to the author to ask for permission.  For software which is
+copyrighted by the Free Software Foundation, write to the Free
+Software Foundation; we sometimes make exceptions for this.  Our
+decision will be guided by the two goals of preserving the free status
+of all derivatives of our free software and of promoting the sharing
+and reuse of software generally.
+
+                            NO WARRANTY
+
+  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
+WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
+EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
+KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
+THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
+WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
+AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
+FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
+CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
+LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
+FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
+SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGES.
+
+                     END OF TERMS AND CONDITIONS
+^L
+           How to Apply These Terms to Your New Libraries
+
+  If you develop a new library, and you want it to be of the greatest
+possible use to the public, we recommend making it free software that
+everyone can redistribute and change.  You can do so by permitting
+redistribution under these terms (or, alternatively, under the terms
+of the ordinary General Public License).
+
+  To apply these terms, attach the following notices to the library.
+It is safest to attach them to the start of each source file to most
+effectively convey the exclusion of warranty; and each file should
+have at least the "copyright" line and a pointer to where the full
+notice is found.
+
+
+    <one line to give the library's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
+
+Also add information on how to contact you by electronic and paper mail.
+
+You should also get your employer (if you work as a programmer) or
+your school, if any, to sign a "copyright disclaimer" for the library,
+if necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the
+  library `Frob' (a library for tweaking knobs) written by James
+  Random Hacker.
+
+  <signature of Ty Coon>, 1 April 1990
+  Ty Coon, President of Vice
+
+That's all there is to it!
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/depcomp dovecot-1.2.4.debian/dovecot-libsieve/depcomp
--- dovecot-1.2.4/dovecot-libsieve/depcomp	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/depcomp	2008-07-18 12:31:10.000000000 +0200
@@ -0,0 +1,589 @@
+#! /bin/sh
+# depcomp - compile a program generating dependencies as side-effects
+
+scriptversion=2007-03-29.01
+
+# Copyright (C) 1999, 2000, 2003, 2004, 2005, 2006, 2007 Free Software
+# Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+# 02110-1301, USA.
+
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+# Originally written by Alexandre Oliva <oliva@dcc.unicamp.br>.
+
+case $1 in
+  '')
+     echo "$0: No command.  Try \`$0 --help' for more information." 1>&2
+     exit 1;
+     ;;
+  -h | --h*)
+    cat <<\EOF
+Usage: depcomp [--help] [--version] PROGRAM [ARGS]
+
+Run PROGRAMS ARGS to compile a file, generating dependencies
+as side-effects.
+
+Environment variables:
+  depmode     Dependency tracking mode.
+  source      Source file read by `PROGRAMS ARGS'.
+  object      Object file output by `PROGRAMS ARGS'.
+  DEPDIR      directory where to store dependencies.
+  depfile     Dependency file to output.
+  tmpdepfile  Temporary file to use when outputing dependencies.
+  libtool     Whether libtool is used (yes/no).
+
+Report bugs to <bug-automake@gnu.org>.
+EOF
+    exit $?
+    ;;
+  -v | --v*)
+    echo "depcomp $scriptversion"
+    exit $?
+    ;;
+esac
+
+if test -z "$depmode" || test -z "$source" || test -z "$object"; then
+  echo "depcomp: Variables source, object and depmode must be set" 1>&2
+  exit 1
+fi
+
+# Dependencies for sub/bar.o or sub/bar.obj go into sub/.deps/bar.Po.
+depfile=${depfile-`echo "$object" |
+  sed 's|[^\\/]*$|'${DEPDIR-.deps}'/&|;s|\.\([^.]*\)$|.P\1|;s|Pobj$|Po|'`}
+tmpdepfile=${tmpdepfile-`echo "$depfile" | sed 's/\.\([^.]*\)$/.T\1/'`}
+
+rm -f "$tmpdepfile"
+
+# Some modes work just like other modes, but use different flags.  We
+# parameterize here, but still list the modes in the big case below,
+# to make depend.m4 easier to write.  Note that we *cannot* use a case
+# here, because this file can only contain one case statement.
+if test "$depmode" = hp; then
+  # HP compiler uses -M and no extra arg.
+  gccflag=-M
+  depmode=gcc
+fi
+
+if test "$depmode" = dashXmstdout; then
+   # This is just like dashmstdout with a different argument.
+   dashmflag=-xM
+   depmode=dashmstdout
+fi
+
+case "$depmode" in
+gcc3)
+## gcc 3 implements dependency tracking that does exactly what
+## we want.  Yay!  Note: for some reason libtool 1.4 doesn't like
+## it if -MD -MP comes after the -MF stuff.  Hmm.
+## Unfortunately, FreeBSD c89 acceptance of flags depends upon
+## the command line argument order; so add the flags where they
+## appear in depend2.am.  Note that the slowdown incurred here
+## affects only configure: in makefiles, %FASTDEP% shortcuts this.
+  for arg
+  do
+    case $arg in
+    -c) set fnord "$@" -MT "$object" -MD -MP -MF "$tmpdepfile" "$arg" ;;
+    *)  set fnord "$@" "$arg" ;;
+    esac
+    shift # fnord
+    shift # $arg
+  done
+  "$@"
+  stat=$?
+  if test $stat -eq 0; then :
+  else
+    rm -f "$tmpdepfile"
+    exit $stat
+  fi
+  mv "$tmpdepfile" "$depfile"
+  ;;
+
+gcc)
+## There are various ways to get dependency output from gcc.  Here's
+## why we pick this rather obscure method:
+## - Don't want to use -MD because we'd like the dependencies to end
+##   up in a subdir.  Having to rename by hand is ugly.
+##   (We might end up doing this anyway to support other compilers.)
+## - The DEPENDENCIES_OUTPUT environment variable makes gcc act like
+##   -MM, not -M (despite what the docs say).
+## - Using -M directly means running the compiler twice (even worse
+##   than renaming).
+  if test -z "$gccflag"; then
+    gccflag=-MD,
+  fi
+  "$@" -Wp,"$gccflag$tmpdepfile"
+  stat=$?
+  if test $stat -eq 0; then :
+  else
+    rm -f "$tmpdepfile"
+    exit $stat
+  fi
+  rm -f "$depfile"
+  echo "$object : \\" > "$depfile"
+  alpha=ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
+## The second -e expression handles DOS-style file names with drive letters.
+  sed -e 's/^[^:]*: / /' \
+      -e 's/^['$alpha']:\/[^:]*: / /' < "$tmpdepfile" >> "$depfile"
+## This next piece of magic avoids the `deleted header file' problem.
+## The problem is that when a header file which appears in a .P file
+## is deleted, the dependency causes make to die (because there is
+## typically no way to rebuild the header).  We avoid this by adding
+## dummy dependencies for each header file.  Too bad gcc doesn't do
+## this for us directly.
+  tr ' ' '
+' < "$tmpdepfile" |
+## Some versions of gcc put a space before the `:'.  On the theory
+## that the space means something, we add a space to the output as
+## well.
+## Some versions of the HPUX 10.20 sed can't process this invocation
+## correctly.  Breaking it into two sed invocations is a workaround.
+    sed -e 's/^\\$//' -e '/^$/d' -e '/:$/d' | sed -e 's/$/ :/' >> "$depfile"
+  rm -f "$tmpdepfile"
+  ;;
+
+hp)
+  # This case exists only to let depend.m4 do its work.  It works by
+  # looking at the text of this script.  This case will never be run,
+  # since it is checked for above.
+  exit 1
+  ;;
+
+sgi)
+  if test "$libtool" = yes; then
+    "$@" "-Wp,-MDupdate,$tmpdepfile"
+  else
+    "$@" -MDupdate "$tmpdepfile"
+  fi
+  stat=$?
+  if test $stat -eq 0; then :
+  else
+    rm -f "$tmpdepfile"
+    exit $stat
+  fi
+  rm -f "$depfile"
+
+  if test -f "$tmpdepfile"; then  # yes, the sourcefile depend on other files
+    echo "$object : \\" > "$depfile"
+
+    # Clip off the initial element (the dependent).  Don't try to be
+    # clever and replace this with sed code, as IRIX sed won't handle
+    # lines with more than a fixed number of characters (4096 in
+    # IRIX 6.2 sed, 8192 in IRIX 6.5).  We also remove comment lines;
+    # the IRIX cc adds comments like `#:fec' to the end of the
+    # dependency line.
+    tr ' ' '
+' < "$tmpdepfile" \
+    | sed -e 's/^.*\.o://' -e 's/#.*$//' -e '/^$/ d' | \
+    tr '
+' ' ' >> $depfile
+    echo >> $depfile
+
+    # The second pass generates a dummy entry for each header file.
+    tr ' ' '
+' < "$tmpdepfile" \
+   | sed -e 's/^.*\.o://' -e 's/#.*$//' -e '/^$/ d' -e 's/$/:/' \
+   >> $depfile
+  else
+    # The sourcefile does not contain any dependencies, so just
+    # store a dummy comment line, to avoid errors with the Makefile
+    # "include basename.Plo" scheme.
+    echo "#dummy" > "$depfile"
+  fi
+  rm -f "$tmpdepfile"
+  ;;
+
+aix)
+  # The C for AIX Compiler uses -M and outputs the dependencies
+  # in a .u file.  In older versions, this file always lives in the
+  # current directory.  Also, the AIX compiler puts `$object:' at the
+  # start of each line; $object doesn't have directory information.
+  # Version 6 uses the directory in both cases.
+  dir=`echo "$object" | sed -e 's|/[^/]*$|/|'`
+  test "x$dir" = "x$object" && dir=
+  base=`echo "$object" | sed -e 's|^.*/||' -e 's/\.o$//' -e 's/\.lo$//'`
+  if test "$libtool" = yes; then
+    tmpdepfile1=$dir$base.u
+    tmpdepfile2=$base.u
+    tmpdepfile3=$dir.libs/$base.u
+    "$@" -Wc,-M
+  else
+    tmpdepfile1=$dir$base.u
+    tmpdepfile2=$dir$base.u
+    tmpdepfile3=$dir$base.u
+    "$@" -M
+  fi
+  stat=$?
+
+  if test $stat -eq 0; then :
+  else
+    rm -f "$tmpdepfile1" "$tmpdepfile2" "$tmpdepfile3"
+    exit $stat
+  fi
+
+  for tmpdepfile in "$tmpdepfile1" "$tmpdepfile2" "$tmpdepfile3"
+  do
+    test -f "$tmpdepfile" && break
+  done
+  if test -f "$tmpdepfile"; then
+    # Each line is of the form `foo.o: dependent.h'.
+    # Do two passes, one to just change these to
+    # `$object: dependent.h' and one to simply `dependent.h:'.
+    sed -e "s,^.*\.[a-z]*:,$object:," < "$tmpdepfile" > "$depfile"
+    # That's a tab and a space in the [].
+    sed -e 's,^.*\.[a-z]*:[	 ]*,,' -e 's,$,:,' < "$tmpdepfile" >> "$depfile"
+  else
+    # The sourcefile does not contain any dependencies, so just
+    # store a dummy comment line, to avoid errors with the Makefile
+    # "include basename.Plo" scheme.
+    echo "#dummy" > "$depfile"
+  fi
+  rm -f "$tmpdepfile"
+  ;;
+
+icc)
+  # Intel's C compiler understands `-MD -MF file'.  However on
+  #    icc -MD -MF foo.d -c -o sub/foo.o sub/foo.c
+  # ICC 7.0 will fill foo.d with something like
+  #    foo.o: sub/foo.c
+  #    foo.o: sub/foo.h
+  # which is wrong.  We want:
+  #    sub/foo.o: sub/foo.c
+  #    sub/foo.o: sub/foo.h
+  #    sub/foo.c:
+  #    sub/foo.h:
+  # ICC 7.1 will output
+  #    foo.o: sub/foo.c sub/foo.h
+  # and will wrap long lines using \ :
+  #    foo.o: sub/foo.c ... \
+  #     sub/foo.h ... \
+  #     ...
+
+  "$@" -MD -MF "$tmpdepfile"
+  stat=$?
+  if test $stat -eq 0; then :
+  else
+    rm -f "$tmpdepfile"
+    exit $stat
+  fi
+  rm -f "$depfile"
+  # Each line is of the form `foo.o: dependent.h',
+  # or `foo.o: dep1.h dep2.h \', or ` dep3.h dep4.h \'.
+  # Do two passes, one to just change these to
+  # `$object: dependent.h' and one to simply `dependent.h:'.
+  sed "s,^[^:]*:,$object :," < "$tmpdepfile" > "$depfile"
+  # Some versions of the HPUX 10.20 sed can't process this invocation
+  # correctly.  Breaking it into two sed invocations is a workaround.
+  sed 's,^[^:]*: \(.*\)$,\1,;s/^\\$//;/^$/d;/:$/d' < "$tmpdepfile" |
+    sed -e 's/$/ :/' >> "$depfile"
+  rm -f "$tmpdepfile"
+  ;;
+
+hp2)
+  # The "hp" stanza above does not work with aCC (C++) and HP's ia64
+  # compilers, which have integrated preprocessors.  The correct option
+  # to use with these is +Maked; it writes dependencies to a file named
+  # 'foo.d', which lands next to the object file, wherever that
+  # happens to be.
+  # Much of this is similar to the tru64 case; see comments there.
+  dir=`echo "$object" | sed -e 's|/[^/]*$|/|'`
+  test "x$dir" = "x$object" && dir=
+  base=`echo "$object" | sed -e 's|^.*/||' -e 's/\.o$//' -e 's/\.lo$//'`
+  if test "$libtool" = yes; then
+    tmpdepfile1=$dir$base.d
+    tmpdepfile2=$dir.libs/$base.d
+    "$@" -Wc,+Maked
+  else
+    tmpdepfile1=$dir$base.d
+    tmpdepfile2=$dir$base.d
+    "$@" +Maked
+  fi
+  stat=$?
+  if test $stat -eq 0; then :
+  else
+     rm -f "$tmpdepfile1" "$tmpdepfile2"
+     exit $stat
+  fi
+
+  for tmpdepfile in "$tmpdepfile1" "$tmpdepfile2"
+  do
+    test -f "$tmpdepfile" && break
+  done
+  if test -f "$tmpdepfile"; then
+    sed -e "s,^.*\.[a-z]*:,$object:," "$tmpdepfile" > "$depfile"
+    # Add `dependent.h:' lines.
+    sed -ne '2,${; s/^ *//; s/ \\*$//; s/$/:/; p;}' "$tmpdepfile" >> "$depfile"
+  else
+    echo "#dummy" > "$depfile"
+  fi
+  rm -f "$tmpdepfile" "$tmpdepfile2"
+  ;;
+
+tru64)
+   # The Tru64 compiler uses -MD to generate dependencies as a side
+   # effect.  `cc -MD -o foo.o ...' puts the dependencies into `foo.o.d'.
+   # At least on Alpha/Redhat 6.1, Compaq CCC V6.2-504 seems to put
+   # dependencies in `foo.d' instead, so we check for that too.
+   # Subdirectories are respected.
+   dir=`echo "$object" | sed -e 's|/[^/]*$|/|'`
+   test "x$dir" = "x$object" && dir=
+   base=`echo "$object" | sed -e 's|^.*/||' -e 's/\.o$//' -e 's/\.lo$//'`
+
+   if test "$libtool" = yes; then
+      # With Tru64 cc, shared objects can also be used to make a
+      # static library.  This mechanism is used in libtool 1.4 series to
+      # handle both shared and static libraries in a single compilation.
+      # With libtool 1.4, dependencies were output in $dir.libs/$base.lo.d.
+      #
+      # With libtool 1.5 this exception was removed, and libtool now
+      # generates 2 separate objects for the 2 libraries.  These two
+      # compilations output dependencies in $dir.libs/$base.o.d and
+      # in $dir$base.o.d.  We have to check for both files, because
+      # one of the two compilations can be disabled.  We should prefer
+      # $dir$base.o.d over $dir.libs/$base.o.d because the latter is
+      # automatically cleaned when .libs/ is deleted, while ignoring
+      # the former would cause a distcleancheck panic.
+      tmpdepfile1=$dir.libs/$base.lo.d   # libtool 1.4
+      tmpdepfile2=$dir$base.o.d          # libtool 1.5
+      tmpdepfile3=$dir.libs/$base.o.d    # libtool 1.5
+      tmpdepfile4=$dir.libs/$base.d      # Compaq CCC V6.2-504
+      "$@" -Wc,-MD
+   else
+      tmpdepfile1=$dir$base.o.d
+      tmpdepfile2=$dir$base.d
+      tmpdepfile3=$dir$base.d
+      tmpdepfile4=$dir$base.d
+      "$@" -MD
+   fi
+
+   stat=$?
+   if test $stat -eq 0; then :
+   else
+      rm -f "$tmpdepfile1" "$tmpdepfile2" "$tmpdepfile3" "$tmpdepfile4"
+      exit $stat
+   fi
+
+   for tmpdepfile in "$tmpdepfile1" "$tmpdepfile2" "$tmpdepfile3" "$tmpdepfile4"
+   do
+     test -f "$tmpdepfile" && break
+   done
+   if test -f "$tmpdepfile"; then
+      sed -e "s,^.*\.[a-z]*:,$object:," < "$tmpdepfile" > "$depfile"
+      # That's a tab and a space in the [].
+      sed -e 's,^.*\.[a-z]*:[	 ]*,,' -e 's,$,:,' < "$tmpdepfile" >> "$depfile"
+   else
+      echo "#dummy" > "$depfile"
+   fi
+   rm -f "$tmpdepfile"
+   ;;
+
+#nosideeffect)
+  # This comment above is used by automake to tell side-effect
+  # dependency tracking mechanisms from slower ones.
+
+dashmstdout)
+  # Important note: in order to support this mode, a compiler *must*
+  # always write the preprocessed file to stdout, regardless of -o.
+  "$@" || exit $?
+
+  # Remove the call to Libtool.
+  if test "$libtool" = yes; then
+    while test $1 != '--mode=compile'; do
+      shift
+    done
+    shift
+  fi
+
+  # Remove `-o $object'.
+  IFS=" "
+  for arg
+  do
+    case $arg in
+    -o)
+      shift
+      ;;
+    $object)
+      shift
+      ;;
+    *)
+      set fnord "$@" "$arg"
+      shift # fnord
+      shift # $arg
+      ;;
+    esac
+  done
+
+  test -z "$dashmflag" && dashmflag=-M
+  # Require at least two characters before searching for `:'
+  # in the target name.  This is to cope with DOS-style filenames:
+  # a dependency such as `c:/foo/bar' could be seen as target `c' otherwise.
+  "$@" $dashmflag |
+    sed 's:^[  ]*[^: ][^:][^:]*\:[    ]*:'"$object"'\: :' > "$tmpdepfile"
+  rm -f "$depfile"
+  cat < "$tmpdepfile" > "$depfile"
+  tr ' ' '
+' < "$tmpdepfile" | \
+## Some versions of the HPUX 10.20 sed can't process this invocation
+## correctly.  Breaking it into two sed invocations is a workaround.
+    sed -e 's/^\\$//' -e '/^$/d' -e '/:$/d' | sed -e 's/$/ :/' >> "$depfile"
+  rm -f "$tmpdepfile"
+  ;;
+
+dashXmstdout)
+  # This case only exists to satisfy depend.m4.  It is never actually
+  # run, as this mode is specially recognized in the preamble.
+  exit 1
+  ;;
+
+makedepend)
+  "$@" || exit $?
+  # Remove any Libtool call
+  if test "$libtool" = yes; then
+    while test $1 != '--mode=compile'; do
+      shift
+    done
+    shift
+  fi
+  # X makedepend
+  shift
+  cleared=no
+  for arg in "$@"; do
+    case $cleared in
+    no)
+      set ""; shift
+      cleared=yes ;;
+    esac
+    case "$arg" in
+    -D*|-I*)
+      set fnord "$@" "$arg"; shift ;;
+    # Strip any option that makedepend may not understand.  Remove
+    # the object too, otherwise makedepend will parse it as a source file.
+    -*|$object)
+      ;;
+    *)
+      set fnord "$@" "$arg"; shift ;;
+    esac
+  done
+  obj_suffix="`echo $object | sed 's/^.*\././'`"
+  touch "$tmpdepfile"
+  ${MAKEDEPEND-makedepend} -o"$obj_suffix" -f"$tmpdepfile" "$@"
+  rm -f "$depfile"
+  cat < "$tmpdepfile" > "$depfile"
+  sed '1,2d' "$tmpdepfile" | tr ' ' '
+' | \
+## Some versions of the HPUX 10.20 sed can't process this invocation
+## correctly.  Breaking it into two sed invocations is a workaround.
+    sed -e 's/^\\$//' -e '/^$/d' -e '/:$/d' | sed -e 's/$/ :/' >> "$depfile"
+  rm -f "$tmpdepfile" "$tmpdepfile".bak
+  ;;
+
+cpp)
+  # Important note: in order to support this mode, a compiler *must*
+  # always write the preprocessed file to stdout.
+  "$@" || exit $?
+
+  # Remove the call to Libtool.
+  if test "$libtool" = yes; then
+    while test $1 != '--mode=compile'; do
+      shift
+    done
+    shift
+  fi
+
+  # Remove `-o $object'.
+  IFS=" "
+  for arg
+  do
+    case $arg in
+    -o)
+      shift
+      ;;
+    $object)
+      shift
+      ;;
+    *)
+      set fnord "$@" "$arg"
+      shift # fnord
+      shift # $arg
+      ;;
+    esac
+  done
+
+  "$@" -E |
+    sed -n -e '/^# [0-9][0-9]* "\([^"]*\)".*/ s:: \1 \\:p' \
+       -e '/^#line [0-9][0-9]* "\([^"]*\)".*/ s:: \1 \\:p' |
+    sed '$ s: \\$::' > "$tmpdepfile"
+  rm -f "$depfile"
+  echo "$object : \\" > "$depfile"
+  cat < "$tmpdepfile" >> "$depfile"
+  sed < "$tmpdepfile" '/^$/d;s/^ //;s/ \\$//;s/$/ :/' >> "$depfile"
+  rm -f "$tmpdepfile"
+  ;;
+
+msvisualcpp)
+  # Important note: in order to support this mode, a compiler *must*
+  # always write the preprocessed file to stdout, regardless of -o,
+  # because we must use -o when running libtool.
+  "$@" || exit $?
+  IFS=" "
+  for arg
+  do
+    case "$arg" in
+    "-Gm"|"/Gm"|"-Gi"|"/Gi"|"-ZI"|"/ZI")
+	set fnord "$@"
+	shift
+	shift
+	;;
+    *)
+	set fnord "$@" "$arg"
+	shift
+	shift
+	;;
+    esac
+  done
+  "$@" -E |
+  sed -n '/^#line [0-9][0-9]* "\([^"]*\)"/ s::echo "`cygpath -u \\"\1\\"`":p' | sort | uniq > "$tmpdepfile"
+  rm -f "$depfile"
+  echo "$object : \\" > "$depfile"
+  . "$tmpdepfile" | sed 's% %\\ %g' | sed -n '/^\(.*\)$/ s::	\1 \\:p' >> "$depfile"
+  echo "	" >> "$depfile"
+  . "$tmpdepfile" | sed 's% %\\ %g' | sed -n '/^\(.*\)$/ s::\1\::p' >> "$depfile"
+  rm -f "$tmpdepfile"
+  ;;
+
+none)
+  exec "$@"
+  ;;
+
+*)
+  echo "Unknown depmode $depmode" 1>&2
+  exit 1
+  ;;
+esac
+
+exit 0
+
+# Local Variables:
+# mode: shell-script
+# sh-indentation: 2
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "scriptversion="
+# time-stamp-format: "%:y-%02m-%02d.%02H"
+# time-stamp-end: "$"
+# End:
diff -urN dovecot-1.2.4/dovecot-libsieve/doc/devel/DESIGN dovecot-1.2.4.debian/dovecot-libsieve/doc/devel/DESIGN
--- dovecot-1.2.4/dovecot-libsieve/doc/devel/DESIGN	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/doc/devel/DESIGN	2008-10-04 10:41:25.000000000 +0200
@@ -0,0 +1,45 @@
+The compiler consists of the following stages:
+
+PARSER: sieve-parser.c, sieve-lexer.c
+  Parses the scriptfile and produces an abstract syntax tree for it 
+  (sieve-ast.c). 
+
+VALIDATOR: sieve-validator.c
+  Performs contextual analysis on the ast produced by the parser. This checks 
+  for the validity of commands, tests and arguments. Also, the ast is decorated 
+  with any context data acquired during the process. This context is used by the 
+  last compiler stage. 
+
+GENERATOR: sieve-generator.c
+  This last compiler stage uses a visitor pattern to wander through the ast and 
+  produces sieve byte code (sieve-binary.c).
+
+The resulting (in-memory) binary can be fed to the interpreter for execution:
+
+INTERPRETER: sieve-interpreter.c 
+  The interpreter executes the byte code and produces a sieve_result object. 
+  This result is no more than just a collection of actions to be performed. 
+  During execution, action commands add actions to the result. Duplates and 
+  conflicts between actions are handled in this execution phase.
+
+RESULT: sieve-result.c sieve-actions.c
+  When the result is to be executed, it needs no further checking, as the 
+  validity of the result was verified during interpretation already. The 
+  result's actions are executed in a transaction-like atomic manner. If one of 
+  the actions fails, the whole transaction is rolled back meaning that either 
+  everything succeeds or everything fails. This is only possible to some extent:
+  transmitted responses can of course not be rolled back. However, these are 
+  executed in the commit phase, meaning that they will only be performed if all
+  other actions were successful.
+  
+Debugging:
+
+BINARY-DUMPER: sieve-code-dumper.c sieve-binary-dumper.c
+  A loaded binary can be dumped to a stream in human-readable form using the 
+  binary-dumper. The binary-dumper displays information on all the blocks that
+  the binary consists off. Program code blocks are dumped using the code-dumper.
+  It's implementation is similar to the interpreter, with the exception that it 
+  performs no actions and just sequentially wanders through the byte code 
+  printing instructions along the way. The term human-readable is a bit optimistic 
+  though; currently, the presented data looks like an assembly language. 
+
diff -urN dovecot-1.2.4/dovecot-libsieve/doc/man/sievec.1 dovecot-1.2.4.debian/dovecot-libsieve/doc/man/sievec.1
--- dovecot-1.2.4/dovecot-libsieve/doc/man/sievec.1	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/doc/man/sievec.1	2009-08-01 13:28:30.000000000 +0200
@@ -0,0 +1,72 @@
+.TH "SIEVEC" "1" "4 July 2009"
+.SH NAME
+sievec \- Sieve script compiler for the Dovecot secure IMAP server
+.SH SYNOPSIS
+sievec [\fB-d\fR] [\fB-x\fR "\fIextension extension ...\fR"] \fIscript-file\fR [\fIout-file\fR]
+.SH DESCRIPTION
+.PP
+The \fBsievec\fP command is part of the Sieve implementation for the Dovecot secure 
+IMAP server. Sieve (RFC 5228) is a simple and highly extensible language for filtering 
+e-mail messages. It can be implemented for any type of mail access protocol, mail 
+architecture and operating system. The language cannot execute external programs and in 
+its basic form it does not provide the means to cause infinite loops, making it suitable 
+for running securely on mail servers where mail users have no permission run arbitrary programs.
+.PP
+Using the \fBsievec\fP command, Sieve scripts can be compiled into a binary representation. 
+The resulting binary can be used directly to process e-mail messages during the delivery process. 
+The delivery of mail messages and therefore also the execution of Sieve scripts is  
+performed by Dovecot's local delivery agent (LDA) called \fBdeliver\fP. Usually, it is not 
+necessary to compile the Sieve script manually using \fBsievec\fP, because \fBdeliver\fP will do 
+this automatically if the binary is missing. However, in some cases \fBdeliver\fP does not have 
+permission to write the compiled binary to disk, forcing it to recompile the script every time it 
+is executed. Using the \fBsievec\fP tool, this can be performed manually by an authorized user to 
+increase performance.
+.PP
+The \fBsievec\fP command accepts two arguments: the \fIscript-file\fP argument specifies the 
+script to be compiled and the \fIout-file\fR argument specifies where the (binary) output is to
+be written. This Sieve implementation reconizes files with a \fB.sieve\fP extension as Sieve 
+scripts and corresponding files with a \fB.svbin\fP extension as the associated compiled binary. 
+This means for example that Dovecot's deliver process will look for a binary file 'dovecot.svbin' 
+when it needs to execute 'dovecot.sieve'. Such filename is chosen automatically for the binary output
+when the out-file argument is missing.
+.PP
+If the \fIscript-file\fP  argument is a directory, all files in that directory with a \fI.sieve\fP 
+extension are compiled into a corresponding \fI.svbin\fP binary file. The compilation is not halted 
+upon errors; it attempts to compile as many scripts in the directory as possible. Note that the 
+\fB-d\fP option and the \fIout-file\fP argument are not allowed when the \fIscript-file\fP argument 
+is a directory.
+.PP
+The \fBsievec\fP command is also useful to verify Sieve scripts before using. Additionally, with 
+the \fB-d\fP option it can output a textual (and thus human-readable) dump of the generated Sieve
+code to the specified file. The output is then identical to what the \fBsieved\fP(1) command produces
+for a stored binary file. This output is mainly useful to find bugs in the compiler that yield corrupt 
+binaries.
+.SH OPTIONS
+.TP 
+\fB-d\fP 
+Don't write the binary to \fIout-file\fP, but write a textual dump of the binary in 
+stead. In this context, the \fIout-file\fP value '-' has special meaning: it causes the the textual 
+dump to be written to \fBstdout\fP. The \fIout-file\fP argument may also be omitted, which has 
+the same effect as '-'. The output is identical to what the \fBsieved\fP(1) command produces for 
+a compiled Sieve binary file. Note that this option is not allowed when the \fIout-file\fP argument
+is a directory.
+.TP
+\fB-x\fP "\fIextension extension ...\fP"
+Set the available extensions. The parameter is a space-separated list of the active extensions. By
+prepending the extension identifiers with \fB+\fP or \fB-\fP, extensions can be included or excluded 
+relative to the default set of extensions. If no extensions have a \fB+\fP or \fB-\fP prefix, only 
+those extensions that are explicitly listed will be enabled. Unknown extensions are ignored 
+and a warning is produced. By default, all supported extensions are available, except for deprecated 
+extensions or those that are still under development. 
+
+For example \fB-x\fP "+imapflags -enotify" will enable the deprecated imapflags extension along with all 
+extensions that are available by default, except for the enotify extension. 
+.SH AUTHOR
+.PP
+The Sieve implementation for Dovecot was written by Stephan Bosch <stephan@rename-it.nl>.
+.PP
+Dovecot was written by Timo Sirainen <tss@iki.fi>.
+.SH "SEE ALSO"
+.BR sieved (1),
+.BR sieve-test (1)
+
diff -urN dovecot-1.2.4/dovecot-libsieve/doc/man/sieved.1 dovecot-1.2.4.debian/dovecot-libsieve/doc/man/sieved.1
--- dovecot-1.2.4/dovecot-libsieve/doc/man/sieved.1	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/doc/man/sieved.1	2009-08-01 13:28:47.000000000 +0200
@@ -0,0 +1,55 @@
+.TH "SIEVED" "1" "4 July 2009"
+.SH NAME
+sieved \- Sieve script binary dump tool for the Dovecot secure IMAP server
+.SH SYNOPSIS
+sieved [\fB-x\fR "\fIextension extension ...\fR"] \fIsieve-binary\fR [\fIout-file\fR]
+.br
+.SH DESCRIPTION
+.PP
+The \fBsieved\fP command is part of the Sieve implementation for the Dovecot secure 
+IMAP server. Sieve (RFC 5228) is a simple and highly extensible language for filtering 
+e-mail messages. It can be implemented for any type of mail access protocol, mail 
+architecture and operating system. The language cannot execute external programs and in 
+its basic form it does not provide the means to cause infinite loops, making it suitable 
+for running securely on mail servers where mail users have no permission run arbitrary programs.
+.PP
+Using the \fBsieved\fP command, Sieve binaries, which are produced for instance by
+\fBsievec\fP(1), can be transformed into a human-readable textual representation. This can 
+provide valuable insight in how the Sieve script is executed. This is also particularly useful 
+to view corrupt binaries that can result from bugs in the Sieve implementation. This tool is 
+intended mainly for development purposes, so normally system administrators and users will not 
+need to use this tool.
+.PP
+The \fIsieve-binary\fR argument specifies the Sieve binary file that needs to be dumped. The
+optional \fIout-file\fR argument specifies where the output must be written. If omitted, the
+output is written to \fBstdout\fR.
+.PP
+The format of the output is not explained here in detail, but it should be relatively easy
+to understand. The Sieve binaries comprise a set of data blocks, each of which can contain
+arbitrary data. For the base language implementation two blocks are used: the first containing
+a specification of all required language extensions and the second containing the main Sieve
+program. Compiled Sieve programs are represented as flat byte code and therefore the dump of
+the main program is a disassembly listing of the interpreter operations. Extensions can define 
+new operations and use additional blocks. Therefore, the output of \fBsieved\fP depends greatly
+on the language extensions used when compiling the binary. 
+.SH OPTIONS
+.TP
+\fB-x\fP "\fIextension extension ...\fP"
+Set the available extensions. The parameter is a space-separated list of the active extensions. By
+prepending the extension identifiers with \fB+\fP or \fB-\fP, extensions can be included or excluded
+relative to the default set of extensions. If no extensions have a \fB+\fP or \fB-\fP prefix, only 
+those extensions that are explicitly listed will be enabled. Unknown extensions are ignored and a 
+warning is produced. By default, all supported extensions are available, except for deprecated
+extensions or those that are still under development.
+
+For example \fB-x\fP "+imapflags -enotify" will enable the deprecated imapflags extension along with all
+extensions that are available by default, except for the enotify extension.
+.SH AUTHOR
+.PP
+The Sieve implementation for Dovecot was written by Stephan Bosch <stephan@rename-it.nl>.
+.PP
+Dovecot was written by Timo Sirainen <tss@iki.fi>.
+.SH "SEE ALSO"
+.BR sievec (1),
+.BR sieve-test (1)
+
diff -urN dovecot-1.2.4/dovecot-libsieve/doc/man/sieve-filter.1 dovecot-1.2.4.debian/dovecot-libsieve/doc/man/sieve-filter.1
--- dovecot-1.2.4/dovecot-libsieve/doc/man/sieve-filter.1	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/doc/man/sieve-filter.1	2009-08-08 14:57:37.000000000 +0200
@@ -0,0 +1,151 @@
+.TH "SIEVE-FILTER" "1" "5 August 2009"
+.SH NAME
+sieve-filter \- Sieve mailbox filter tool for the Dovecot secure IMAP server
+.PP
+\fBWARNING: \fRThis tool is not finished and should \fB*NOT*\fR be used, unless you feel like testing newly developed
+features! The behavior described in this manual page represents the design and not necessarily what the tool currently implements.
+
+.SH SYNOPSIS
+sieve-filter [\fIoptions\fR] \fIscript-file\fR \fIsource-location\fR \fIsource-mailbox\fR [\fIinbox-namespace\fR [\fInamespace\fR ...]]
+.TP
+\fInamepace\fR = [prefix=]location[;option=value,option=value,...]
+.TP
+[FIXME: what would be the easiest way to specify a filter operation without always needing to
+delve into the complexity of namespaces]
+
+.SH DESCRIPTION
+.PP
+The \fBsieve-filter\fP command is part of the Sieve implementation for the Dovecot secure 
+IMAP server. Sieve (RFC 5228) is a simple and highly extensible language for filtering 
+e-mail messages. It can be implemented for any type of mail access protocol, mail 
+architecture and operating system. The language cannot execute external programs and in 
+its basic form it does not provide the means to cause infinite loops, making it suitable 
+for running securely on mail servers where mail users have no permission run arbitrary programs.
+.PP
+The Sieve language was originally meant for filtering messages upon delivery. However, there are
+occasions when it is desirable to filter messages that are already stored in a mailbox, for
+instance when a bug in a Sieve script caused many messages to be delivered incorrectly.
+Using the sieve-filter tool it is possible to apply a Sieve script on all messages in a particular
+mailbox, making it possible to delete messages, to store them in a different folder and to change
+the assigned IMAP flags and keywords. Attempts to send messages to the outside world are ignored by default
+for obvious reasons, but, using the proper command line options, it is possible to capture outgoing
+mail as well. 
+.PP
+The command has three mandatory arguments: the \fIscript-file\fP argument, which specifies the path of the
+Sieve script, the \fIsource-location\fP argument, which specifies the mail storage of the source mailbox 
+(e.g. `maildir:~/Maildir'), and the \fIsource-mailbox\fP argument, which specifies the name of the source 
+mailbox within the specified mail storage (e.g. `INBOX.Spam'). 
+.PP
+This tool does not (yet) use Dovecot's configuration file to obtain information on namespaces and the
+location of mailboxes. Therefore, any used namespaces need to be specified on the command line. These
+specifications directly follow the \fIsource-mailbox\fP parameter. The first specified namespace will
+be the INBOX namespace.
+.PP
+If no namespaces are defined on the commandline, the source-location is used as the default mail store
+where the INBOX is located. This means that the keep action could operate on the folder the message
+originates from. In this case the message remains untouched and it is not duplicated, but IMAP flags and
+keywords can be evaluated and changed with the imap4flags extension . If namespaces are defined explicitly, 
+the source location is available as a namespace with prefix `#src/'. 
+.PP
+If no options are specified, the sieve-filter command runs in a simulation mode in which it only 
+prints what would be performed, without actually doing anything. Use the \fB-e\fP option to activate
+true script execution. Also, the source mailbox is opened read-only by default, so that the source mailbox
+remains unchanged. Use the \fB-W\fP to allow changes in the source mailbox. 
+
+.SH CAUTION
+Although this is a very useful tool, it can also be very destructive when used improperly. A small 
+bug in your Sieve script in combination with the wrong command line options could cause it to 
+discard (many) more e-mails than it was supposed to. Therefore, users are advised to read this manual
+carefully and to use the simulation mode first to check what the script will do. 
+.PP
+\fBMAKING A BACKUP IS IMPERATIVE FOR ANY IMPORTANT MAIL!\fP
+.PP
+By default, it will open the source mailbox in a read-only mode, such that it will not delete any of your
+e-mails. However, it can still litter other mailboxes with spurious copies of your e-mails if your
+Sieve script decides to do so.
+
+.SH OPTIONS
+.TP 
+\fB-D\fP \fIsource-action\fP
+By default, the sieve-filter command does not delete the messages from the source mailbox. This means that
+a copy operation is executed by default and the source mailbox is not altered. The \fIsource-action\fP
+parameter of the \fB-D\fP option can take four different values:
+.RS 7
+.TP 
+\fBkeep\fP (default)
+Keep messages in source folder. If \fB-W\fR is specified and the source mailbox is the destination of
+a keep or fileinto action, flags can be changed by the Sieve script. Messages are never duplicated in the
+source mailbox.
+.TP 
+\fBflag\fP
+Flag messages as \\DELETED.
+.TP 
+\fBmove\fP [\fIfolder\fP]
+Move messages to the indicated \fIfolder\fP.
+.TP 
+\fBexpunge\fP
+Expunge messages, meaning that these are removed irreversibly when the tool finishes filtering.
+.PP
+Note that values other than `keep' have no effect, unless the \fB-W\fP option is specified as well.
+.RE
+.TP
+\fB-e\fP
+Turns on execution mode. By default, the sieve-filter command runs in simulation mode in which it 
+changes nothing, meaning that no mailbox is altered in any way and no actions are performed. It only
+prints what would be done. Using this option the sieve-filter command becomes active and performs the 
+requested actions.
+.TP
+\fB-f\fP \fIenvelope-sender\fP
+The envelope sender or return path. This is what Sieve's envelope test will compare to when the 
+"from" envelope part is requested. Also, this is where response messages are sent to. 
+.TP
+\fB-m\fP \fIdefault-mailbox\fP
+The mailbox within the default namespace where the keep action stores the message. This is "INBOX"
+by default.
+.TP
+\fB-Q\fP \fImail-command\fP
+Send outgoing e-mail through the specified program. By default, the sieve-filter command ignores 
+Sieve actions such as redirect, reject, vacation and notify, but using this option outgoing messages
+can be fed to the \fBstdin\fP of an external shell command. This option has no effect in simulation
+mode, Unless you really know what you are doing, \fBDO NOT USE THIS TO FEED MAIL TO SENDMAIL!\f.
+.TP
+\fB-r\fP \fIrecipient-address\fP
+The envelope recipient address. This is what Sieve's envelope test will compare to when the "to"
+envelope part is requested. Some tests and actions will also use this as the owner's e-mail address.
+.TP
+\fB-S\fP \fIscript-file\fP
+Specify additional scripts to be executed before the main script. Multiple \fB-s\fP arguments are
+allowed and the specified scripts are executed sequentially in the order specified at the command
+line.
+.TP
+\fB-W\fP
+Enables write access to the source mailbox. This allows deleting the messages from the source mailbox
+and changing the assigned IMAP flags and keywords. 
+.TP
+\fB-x\fP "\fIextension extension ...\fP"
+Set the available extensions. The parameter is a space-separated list of the active extensions. By
+prepending the extension identifiers with \fB+\fP or \fB-\fP, extensions can be included or excluded
+relative to the default set of extensions. If no extensions have a \fB+\fP or \fB-\fP prefix, only 
+those extensions that are explicitly listed will be enabled. Unknown extensions are ignored and a 
+warning is produced. By default, all supported extensions are available, except for deprecated extensions 
+or those that are still under development.
+
+For example \fB-x\fP "+imapflags -enotify" will enable the deprecated imapflags extension along with all
+extensions that are available by default, except for the enotify extension.
+
+.SH EXAMPLES
+
+.TP
+[...]
+
+.SH AUTHOR
+.PP
+The Sieve implementation for Dovecot was written by Stephan Bosch <stephan@rename-it.nl>.
+.PP
+Dovecot was written by Timo Sirainen <tss@iki.fi>.
+
+.SH "SEE ALSO"
+.BR sievec (1),
+.BR sieved (1),
+.BR sieve-test (1)
+
diff -urN dovecot-1.2.4/dovecot-libsieve/doc/man/sieve-test.1 dovecot-1.2.4.debian/dovecot-libsieve/doc/man/sieve-test.1
--- dovecot-1.2.4/dovecot-libsieve/doc/man/sieve-test.1	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/doc/man/sieve-test.1	2009-08-01 13:31:49.000000000 +0200
@@ -0,0 +1,130 @@
+.TH "SIEVE-TEST" "1" "4 July 2009"
+.SH NAME
+sieve-test \- Sieve script tester for the Dovecot secure IMAP server
+.SH SYNOPSIS
+sieve-test
+[\fB-c\fR] 
+[\fB-d\fR \fIdump-file\fR]
+[\fB-e\fR]
+[\fB-f\fR \fIenvelope-sender\fR]
+[\fB-l\fR \fImail-location\fR]
+[\fB-m\fR \fIdefault-mailbox\fR]
+[\fB-r\fR \fIrecipient-address\fR]
+[\fB-s\fR \fIscript-file\fR]
+[\fB-t\fR]
+[\fB-x\fR "\fIextension extension ...\fR"]
+\fIscript-file\fR \fImail-file\fR
+.SH DESCRIPTION
+.PP
+The \fBsieve-test\fP command is part of the Sieve implementation for the Dovecot secure 
+IMAP server. Sieve (RFC 5228) is a simple and highly extensible language for filtering 
+e-mail messages. It can be implemented for any type of mail access protocol, mail 
+architecture and operating system. The language cannot execute external programs and in 
+its basic form it does not provide the means to cause infinite loops, making it suitable 
+for running securely on mail servers where mail users have no permission run arbitrary programs.
+.PP
+Using the \fBsieve-test\fP command, the execution of Sieve scripts can be tested. This evaluates
+the script for the provided message, yielding a set of Sieve actions. Unless the \fB-e\fP option is 
+specified, it does not actually execute these actions, meaning that it does not store or forward the 
+message anywere. In stead, it prints a detailed list of what actions would normally take place. 
+Note that, even when \fB-e\fP is specified, no messages are ever transmitted to remote SMTP 
+recipients. The outgoing messages are printed to \fBstdout\fP in stead. 
+.PP
+This is a very useful tool to debug the execution of Sieve scripts. It can be used to verify
+newly installed scripts for the intended behaviour and it can provide more detailed information
+about script execution problems that are reported by the Sieve plugin.
+.PP
+The command has two mandatory arguments: the \fIscript-file\fP argument, which specifies the
+script to (compile and) execute, and the \fImail-file\fP argument, which specifies the file 
+containing the e-mail message to filter. 
+
+Note that this tool looks for a pre-compiled binary file with a \fI.svbin\fP extension and 
+with basename and path identical to the specified script. Use the \fB-c\fP option to disable this
+behavior by forcing the script to be compiled into a new binary.  
+.SH OPTIONS
+.TP 
+\fB-c\fP
+Force compilation. By default, the compiled binary is stored on disk. When this binary is found
+during the next execution of \fBsieve-test\fP and its modification time is more recent than the
+script file, it is used and the script is not compiled again. This option forces the script to be
+compiled, thus ignoring any present binary. Refer to \fBsievec\fP(1) for more information about 
+Sieve compilation.
+.TP
+\fB-d\fP \fIdump-file\fP
+Causes a dump of the generated code to be written to the specified file. This is identical to the
+dump produced by \fBsieved\fR(1). Using '-' as filename causes the dump to be written to \fBstdout\fP.
+.TP
+\fB-e\fP
+Turns on true execution of the set of actions that results from running the script. In combination
+with the \fB-l\fP parameter, the actual delivery of messages can be tested. Note that this will
+not transmit any messages to remote SMTP recipients. Such actions only print the outgoing message
+to \fBstdout\fP.
+.TP
+\fB-f\fP \fIenvelope-sender\fP
+The envelope sender or return path. This is what Sieve's envelope test will compare to when the 
+"from" envelope part is requested. Also, this is where response messages are sent to. 
+.TP
+\fB-l\fP \fImail-location\fP
+The location of the user's mail store. The syntax of this option's \fImail-location\fP parameter 
+is identical to what is used for the mail_location setting in the Dovecot config file. This 
+parameter is typically used in combination with \fB-e\fP to test the actual delivery of messages. 
+If \fB-l\fP is omitted when \fB-e\fP is specified, mail store actions like fileinto and keep are 
+skipped.
+.TP
+\fB-m\fP \fIdefault-mailbox\fP
+The mailbox where the keep action stores the message. This is "INBOX" by default.
+.TP
+\fB-r\fP \fIrecipient-address\fP
+The envelope recipient address. This is what Sieve's envelope test will compare to when the "to"
+envelope part is requested. Some tests and actions will also use this as the owner's e-mail address.
+.TP
+\fB-s\fP \fIscript-file\fP
+Specify additional scripts to be executed before the main script. Multiple \fB-s\fP arguments are
+allowed and the specified scripts are executed sequentially in the order specified at the command
+line.
+.TP
+\fB-t\fP
+Enable simple trace debugging; prints all encountered byte code instructions to \fBstdout\fP. This is
+currently only intelligible for developers.
+.TP
+\fB-x\fP "\fIextension extension ...\fP"
+Set the available extensions. The parameter is a space-separated list of the active extensions. By
+prepending the extension identifiers with \fB+\fP or \fB-\fP, extensions can be included or excluded
+relative to the default set of extensions. If no extensions have a \fB+\fP or \fB-\fP prefix, only 
+those extensions that are explicitly listed will be enabled. Unknown extensions are ignored and a 
+warning is produced. By default, all supported extensions are available, except for deprecated extensions 
+or those that are still under development.
+
+For example \fB-x\fP "+imapflags -enotify" will enable the deprecated imapflags extension along with all
+extensions that are available by default, except for the enotify extension.
+.SH DEBUG SUPPORT
+.PP
+To improve script debugging, the Sieve command line tools such as \fBsieve-test\fP support a custom
+Sieve language extension called 'vnd.dovecot.debug'. It adds the \fBdebug_print\fP command that allows
+printing debug messages to \fBstdout\fP. 
+.PP
+Example:
+.PP
+require "vnd.dovecot.debug";
+.PP
+if header :contains "subject" "hello" {
+.PP
+  debug_print "Subject header contains hello!";
+.PP
+}
+.PP
+Other tools like \fBsievec\fP and \fBsieved\fP also recognize the vnd.dovecot.debug extension. In contrast,
+the actual Sieve plugin for the Dovecot LDA does not allow the use of the debug extension. So, keep in mind that 
+scripts and compiled binaries that refer to de debug extension will fail to be run by the Sieve plugin itself.
+.PP
+Note that it is not necessary to enable nor possible to disable the availability of the debug extension with 
+the \fB-x\fP option.
+.SH AUTHOR
+.PP
+The Sieve implementation for Dovecot was written by Stephan Bosch <stephan@rename-it.nl>.
+.PP
+Dovecot was written by Timo Sirainen <tss@iki.fi>.
+.SH "SEE ALSO"
+.BR sievec (1),
+.BR sieved (1)
+
diff -urN dovecot-1.2.4/dovecot-libsieve/doc/rfc/body.rfc5173.txt dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/body.rfc5173.txt
--- dovecot-1.2.4/dovecot-libsieve/doc/rfc/body.rfc5173.txt	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/body.rfc5173.txt	2008-08-10 20:30:25.000000000 +0200
@@ -0,0 +1,563 @@
+
+
+
+
+
+
+Network Working Group                                         J. Degener
+Request for Comments: 5173                                   P. Guenther
+Updates: 5229                                             Sendmail, Inc.
+Category: Standards Track                                     April 2008
+
+
+
+                 Sieve Email Filtering: Body Extension
+
+Status of This Memo
+
+   This document specifies an Internet standards track protocol for the
+   Internet community, and requests discussion and suggestions for
+   improvements.  Please refer to the current edition of the "Internet
+   Official Protocol Standards" (STD 1) for the standardization state
+   and status of this protocol.  Distribution of this memo is unlimited.
+
+Abstract
+
+   This document defines a new command for the "Sieve" email filtering
+   language that tests for the occurrence of one or more strings in the
+   body of an email message.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Degener & Guenther          Standards Track                     [Page 1]
+
+RFC 5173         Sieve Email Filtering: Body Extension        April 2008
+
+
+1.  Introduction
+
+   The "body" test checks for the occurrence of one or more strings in
+   the body of an email message.  Such a test was initially discussed
+   for the [SIEVE] base document, but was subsequently removed because
+   it was thought to be too costly to implement.
+
+   Nevertheless, several server vendors have implemented some form of
+   the "body" test.
+
+   This document reintroduces the "body" test as an extension, and
+   specifies its syntax and semantics.
+
+2.  Conventions Used in This Document
+
+   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
+   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
+   document are to be interpreted as described in [KEYWORDS].
+
+   Conventions for notations are as in [SIEVE] Section 1.1, including
+   the use of the "Usage:" label for the definition of text and tagged
+   argument syntax.
+
+   The rules for interpreting the grammar are defined in [SIEVE] and
+   inherited by this specification.  In particular, readers of this
+   document are reminded that according to [SIEVE] Sections 2.6.2 and
+   2.6.3, optional arguments such as COMPARATOR and MATCH-TYPE can
+   appear in any order.
+
+3.  Capability Identifier
+
+   The capability string associated with the extension defined in this
+   document is "body".
+
+4.  Test body
+
+   Usage: "body" [COMPARATOR] [MATCH-TYPE] [BODY-TRANSFORM]
+                <key-list: string-list>
+
+   The body test matches content in the body of an email message, that
+   is, anything following the first empty line after the header.  (The
+   empty line itself, if present, is not considered to be part of the
+   body.)
+
+   The COMPARATOR and MATCH-TYPE keyword parameters are defined in
+   [SIEVE].  As specified in Sections 2.7.1 and 2.7.3 of [SIEVE], the
+   default COMPARATOR is "i;ascii-casemap" and the default MATCH-TYPE is
+   ":is".
+
+
+
+Degener & Guenther          Standards Track                     [Page 2]
+
+RFC 5173         Sieve Email Filtering: Body Extension        April 2008
+
+
+   The BODY-TRANSFORM is a keyword parameter that governs how a set of
+   strings to be matched against are extracted from the body of the
+   message.  If a message consists of a header only, not followed by an
+   empty line, then that set is empty and all "body" tests return false,
+   including those that test for an empty string.  (This is similar to
+   how the "header" test always fails when the named header fields
+   aren't present.)  Otherwise, the transform must be followed as
+   defined below in Section 5.
+
+   Note that the transformations defined here do *not* match against
+   each line of the message independently, so the strings will usually
+   contain CRLFs.  How these can be matched is governed by the
+   comparator and match-type.  For example, with the default comparator
+   of "i;ascii-casemap", they can be included literally in the key
+   strings, or be matched with the "*" or "?" wildcards of the :matches
+   match-type, or be skipped with :contains.
+
+5.  Body Transform
+
+   Prior to matching content in a message body, "transformations" can be
+   applied that filter and decode certain parts of the body.  These
+   transformations are selected by a "BODY-TRANSFORM" keyword parameter.
+
+   Usage: ":raw"
+        / ":content" <content-types: string-list>
+        / ":text"
+
+   The default transformation is :text.
+
+5.1.  Body Transform ":raw"
+
+   The ":raw" transform matches against the entire undecoded body of a
+   message as a single item.
+
+   If the specified body-transform is ":raw", the [MIME] structure of
+   the body is irrelevant.  The implementation MUST NOT remove any
+   transfer encoding from the message, MUST NOT refuse to filter
+   messages with syntactic errors (unless the environment it is part of
+   rejects them outright), and MUST treat multipart boundaries or the
+   MIME headers of enclosed body parts as part of the content being
+   matched against, instead of MIME structures to interpret.
+
+
+
+
+
+
+
+
+
+
+Degener & Guenther          Standards Track                     [Page 3]
+
+RFC 5173         Sieve Email Filtering: Body Extension        April 2008
+
+
+   Example:
+
+        require "body";
+
+        # This will match a message containing the literal text
+        # "MAKE MONEY FAST" in body parts (ignoring any
+        # content-transfer-encodings) or MIME headers other than
+        # the outermost RFC 2822 header.
+
+        if body :raw :contains "MAKE MONEY FAST" {
+                discard;
+        }
+
+5.2.  Body Transform ":content"
+
+   If the body transform is ":content", the MIME parts that have the
+   specified content types are matched against independently.
+
+   If an individual content type begins or ends with a '/' (slash) or
+   contains multiple slashes, then it matches no content types.
+   Otherwise, if it contains a slash, then it specifies a full
+   <type>/<subtype> pair, and matches only that specific content type.
+   If it is the empty string, all MIME content types are matched.
+   Otherwise, it specifies a <type> only, and any subtype of that type
+   matches it.
+
+   The search for MIME parts matching the :content specification is
+   recursive and automatically descends into multipart and
+   message/rfc822 MIME parts.  All MIME parts with matching types are
+   searched for the key strings.  The test returns true if any
+   combination of a searched MIME part and key-list argument match.
+
+   If the :content specification matches a multipart MIME part, only the
+   prologue and epilogue sections of the part will be searched for the
+   key strings, treating the entire prologue and the entire epilogue as
+   separate strings; the contents of nested parts are only searched if
+   their respective types match the :content specification.
+
+   If the :content specification matches a message/rfc822 MIME part,
+   only the header of the nested message will be searched for the key
+   strings, treating the header as a single string; the contents of the
+   nested message body parts are only searched if their content type
+   matches the :content specification.
+
+   For other MIME types, the entire part will be searched as a single
+   string.
+
+
+
+
+
+Degener & Guenther          Standards Track                     [Page 4]
+
+RFC 5173         Sieve Email Filtering: Body Extension        April 2008
+
+
+   (Matches against container types with an empty match string can be
+   useful as tests for the existence of such parts.)
+
+   Example:
+
+        From: Whomever
+        To: Someone
+        Date: Whenever
+        Subject: whatever
+        Content-Type: multipart/mixed; boundary=outer
+
+     &  This is a multi-part message in MIME format.
+     &
+        --outer
+        Content-Type: multipart/alternative; boundary=inner
+
+     &  This is a nested multi-part message in MIME format.
+     &
+        --inner
+        Content-Type: text/plain; charset="us-ascii"
+
+     $  Hello
+     $
+        --inner
+        Content-Type: text/html; charset="us-ascii"
+
+     %  <html><body>Hello</body></html>
+     %
+        --inner--
+     &
+     &  This is the end of the inner MIME multipart.
+     &
+        --outer
+        Content-Type: message/rfc822
+
+     !  From: Someone Else
+     !  Subject: hello request
+
+     $  Please say Hello
+     $
+        --outer--
+     &
+     &  This is the end of the outer MIME multipart.
+
+
+
+
+
+
+
+
+Degener & Guenther          Standards Track                     [Page 5]
+
+RFC 5173         Sieve Email Filtering: Body Extension        April 2008
+
+
+   In the above example, the '&', '$', '%', and '!' characters at the
+   start of a line are used to illustrate what portions of the example
+   message are used in tests:
+
+   - the lines starting with '&' are the ones that are tested when a
+     'body :content "multipart" :contains "MIME"' test is executed.
+
+   - the lines starting with '$' are the ones that are tested when a
+     'body :content "text/plain" :contains "Hello"' test is executed.
+
+   - the lines starting with '%' are the ones that are tested when a
+     'body :content "text/html" :contains "Hello"' test is executed.
+
+   - the lines starting with '$' or '%' are the ones that are tested
+     when a 'body :content "text" :contains "Hello"' test is executed.
+
+   - the lines starting with '!' are the ones that are tested when a
+     'body :content "message/rfc822" :contains "Hello"' test is
+     executed.
+
+   Comparisons are performed on octets.  Implementations decode the
+   content-transfer-encoding and convert text to [UTF-8] as input to the
+   comparator.  MIME parts that cannot be decoded and converted MAY be
+   treated as plain US-ASCII, omitted, or processed according to local
+   conventions.  A NUL octet (character zero) SHOULD NOT cause early
+   termination of the content being compared against.  Implementations
+   MUST support the "quoted-printable", "base64", "7bit", "8bit", and
+   "binary" content transfer encodings.  Implementations MUST be capable
+   of converting to UTF-8 the US-ASCII, ISO-8859-1, and the US-ASCII
+   subset of ISO-8859-* character sets.
+
+   Each matched part is matched against independently: search
+   expressions MUST NOT match across MIME part boundaries.  MIME headers
+   of the containing part MUST NOT be included in the data.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Degener & Guenther          Standards Track                     [Page 6]
+
+RFC 5173         Sieve Email Filtering: Body Extension        April 2008
+
+
+   Example:
+
+        require ["body", "fileinto"];
+
+        # Save any message with any text MIME part that contains the
+        # words "missile" or "coordinates" in the "secrets" folder.
+
+        if body :content "text" :contains ["missile", "coordinates"] {
+                fileinto "secrets";
+        }
+
+        # Save any message with an audio/mp3 MIME part in
+        # the "jukebox" folder.
+
+        if body :content "audio/mp3" :contains "" {
+                fileinto "jukebox";
+        }
+
+5.3.  Body Transform ":text"
+
+   The ":text" body transform matches against the results of an
+   implementation's best effort at extracting UTF-8 encoded text from a
+   message.
+
+   It is unspecified whether this transformation results in a single
+   string or multiple strings being matched against.  All the text
+   extracted from a given non-container MIME part MUST be in the same
+   string.
+
+   In simple implementations, :text MAY be treated the same as :content
+   "text".
+
+   Sophisticated implementations MAY strip mark-up from the text prior
+   to matching, and MAY convert media types other than text to text
+   prior to matching.
+
+   (For example, they may be able to convert proprietary text editor
+   formats to text or apply optical character recognition algorithms to
+   image data.)
+
+   Example:
+        require ["body", "fileinto"];
+
+        # Save messages mentioning the project schedule in the
+        # project/schedule folder.
+        if body :text :contains "project schedule" {
+                fileinto "project/schedule";
+        }
+
+
+
+Degener & Guenther          Standards Track                     [Page 7]
+
+RFC 5173         Sieve Email Filtering: Body Extension        April 2008
+
+
+6.  Interaction with Other Sieve Extensions
+
+   Any extension that extends the grammar for the COMPARATOR or MATCH-
+   TYPE nonterminals will also affect the implementation of "body".
+
+   Wildcard expressions used with "body" are exempt from the side
+   effects described in [VARIABLES].  That is, they MUST NOT set match
+   variables (${1}, ${2}...) to the input values corresponding to
+   wildcard sequences in the matched pattern.  However, if the extension
+   is present, variable references in the key strings or content type
+   strings are evaluated as described in this document.
+
+7.  IANA Considerations
+
+   The following template specifies the IANA registration of the Sieve
+   extension specified in this document:
+
+   To: iana@iana.org
+   Subject: Registration of new Sieve extension
+
+   Capability name: body
+   Description:     Provides a test for matching against the
+                    body of the message being processed
+   RFC number:      RFC 5173
+   Contact Address: The Sieve discussion list
+                    <ietf-mta-filters@imc.org>
+
+8.  Security Considerations
+
+   The system MUST be sized and restricted in such a manner that even
+   malicious use of body matching does not deny service to other users
+   of the host system.
+
+   Filters relying on string matches in the raw body of an email message
+   may be more general than intended.  Text matches are no replacement
+   for a spam, virus, or other security related filtering system.
+
+9.  Acknowledgments
+
+   This document has been revised in part based on comments and
+   discussions that took place on and off the SIEVE mailing list.
+   Thanks to Cyrus Daboo, Ned Freed, Bob Johannessen, Simon Josefsson,
+   Mark E. Mallett, Chris Markle, Alexey Melnikov, Ken Murchison, Greg
+   Shapiro, Tim Showalter, Nigel Swinson, Dowson Tong, and Christian
+   Vogt for reviews and suggestions.
+
+
+
+
+
+
+Degener & Guenther          Standards Track                     [Page 8]
+
+RFC 5173         Sieve Email Filtering: Body Extension        April 2008
+
+
+10.  References
+
+10.1.  Normative References
+
+   [KEYWORDS]   Bradner, S., "Key words for use in RFCs to Indicate
+                Requirement Levels", BCP 14, RFC 2119, March 1997.
+
+   [MIME]       Freed, N. and N. Borenstein, "Multipurpose Internet Mail
+                Extensions (MIME) Part One: Format of Internet Message
+                Bodies", RFC 2045, November 1996.
+
+   [SIEVE]      Guenther, P., Ed., and T. Showalter, Ed., "Sieve: An
+                Email Filtering Language", RFC 5228, January 2008.
+
+   [UTF-8]      Yergeau, F., "UTF-8, a transformation format of ISO
+                10646", STD 63, RFC 3629, November 2003.
+
+10.2.  Informative References
+
+   [VARIABLES]  Homme, K., "Sieve Email Filtering: Variables Extension",
+                RFC 5229, January 2008.
+
+Authors' Addresses
+
+   Jutta Degener
+   5245 College Ave, Suite #127
+   Oakland, CA 94618
+
+   EMail: jutta@pobox.com
+
+
+   Philip Guenther
+   Sendmail, Inc.
+   6425 Christie Ave, 4th Floor
+   Emeryville, CA 94608
+
+   EMail: guenther@sendmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Degener & Guenther          Standards Track                     [Page 9]
+
+RFC 5173         Sieve Email Filtering: Body Extension        April 2008
+
+
+Full Copyright Statement
+
+   Copyright (C) The IETF Trust (2008).
+
+   This document is subject to the rights, licenses and restrictions
+   contained in BCP 78, and except as set forth therein, the authors
+   retain all their rights.
+
+   This document and the information contained herein are provided on an
+   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
+   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
+   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
+   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
+
+Intellectual Property
+
+   The IETF takes no position regarding the validity or scope of any
+   Intellectual Property Rights or other rights that might be claimed to
+   pertain to the implementation or use of the technology described in
+   this document or the extent to which any license under such rights
+   might or might not be available; nor does it represent that it has
+   made any independent effort to identify any such rights.  Information
+   on the procedures with respect to rights in RFC documents can be
+   found in BCP 78 and BCP 79.
+
+   Copies of IPR disclosures made to the IETF Secretariat and any
+   assurances of licenses to be made available, or the result of an
+   attempt made to obtain a general license or permission for the use of
+   such proprietary rights by implementers or users of this
+   specification can be obtained from the IETF on-line IPR repository at
+   http://www.ietf.org/ipr.
+
+   The IETF invites any interested party to bring to its attention any
+   copyrights, patents or patent applications, or other proprietary
+   rights that may cover technology that may be required to implement
+   this standard.  Please address the information to the IETF at
+   ietf-ipr@ietf.org.
+
+
+
+
+
+
+
+
+
+
+
+
+Degener & Guenther          Standards Track                    [Page 10]
+
diff -urN dovecot-1.2.4/dovecot-libsieve/doc/rfc/collation.rfc4790.txt dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/collation.rfc4790.txt
--- dovecot-1.2.4/dovecot-libsieve/doc/rfc/collation.rfc4790.txt	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/collation.rfc4790.txt	2007-03-13 18:00:27.000000000 +0100
@@ -0,0 +1,1459 @@
+
+
+
+
+
+
+Network Working Group                                          C. Newman
+Request for Comments: 4790                              Sun Microsystems
+Category: Standards Track                                      M. Duerst
+                                                Aoyama Gakuin University
+                                                          A. Gulbrandsen
+                                                                    Oryx
+                                                              March 2007
+
+
+            Internet Application Protocol Collation Registry
+
+Status of This Memo
+
+   This document specifies an Internet standards track protocol for the
+   Internet community, and requests discussion and suggestions for
+   improvements.  Please refer to the current edition of the "Internet
+   Official Protocol Standards" (STD 1) for the standardization state
+   and status of this protocol.  Distribution of this memo is unlimited.
+
+Copyright Notice
+
+   Copyright (C) The IETF Trust (2007).
+
+Abstract
+
+   Many Internet application protocols include string-based lookup,
+   searching, or sorting operations.  However, the problem space for
+   searching and sorting international strings is large, not fully
+   explored, and is outside the area of expertise for the Internet
+   Engineering Task Force (IETF).  Rather than attempt to solve such a
+   large problem, this specification creates an abstraction framework so
+   that application protocols can precisely identify a comparison
+   function, and the repertoire of comparison functions can be extended
+   in the future.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Newman, et al.              Standards Track                     [Page 1]
+
+RFC 4790                   Collation Registry                 March 2007
+
+
+Table of Contents
+
+   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4
+     1.1.  Conventions Used in This Document  . . . . . . . . . . . .  4
+   2.  Collation Definition and Purpose . . . . . . . . . . . . . . .  4
+     2.1.  Definition . . . . . . . . . . . . . . . . . . . . . . . .  4
+     2.2.  Purpose  . . . . . . . . . . . . . . . . . . . . . . . . .  4
+     2.3.  Some Other Terms Used in this Document . . . . . . . . . .  5
+     2.4.  Sort Keys  . . . . . . . . . . . . . . . . . . . . . . . .  5
+   3.  Collation Identifier Syntax  . . . . . . . . . . . . . . . . .  6
+     3.1.  Basic Syntax . . . . . . . . . . . . . . . . . . . . . . .  6
+     3.2.  Wildcards  . . . . . . . . . . . . . . . . . . . . . . . .  6
+     3.3.  Ordering Direction . . . . . . . . . . . . . . . . . . . .  7
+     3.4.  URIs . . . . . . . . . . . . . . . . . . . . . . . . . . .  7
+     3.5.  Naming Guidelines  . . . . . . . . . . . . . . . . . . . .  7
+   4.  Collation Specification Requirements . . . . . . . . . . . . .  8
+     4.1.  Collation/Server Interface . . . . . . . . . . . . . . . .  8
+     4.2.  Operations Supported . . . . . . . . . . . . . . . . . . .  8
+       4.2.1.  Validity . . . . . . . . . . . . . . . . . . . . . . .  9
+       4.2.2.  Equality . . . . . . . . . . . . . . . . . . . . . . .  9
+       4.2.3.  Substring  . . . . . . . . . . . . . . . . . . . . . .  9
+       4.2.4.  Ordering . . . . . . . . . . . . . . . . . . . . . . . 10
+     4.3.  Sort Keys  . . . . . . . . . . . . . . . . . . . . . . . . 10
+     4.4.  Use of Lookup Tables . . . . . . . . . . . . . . . . . . . 11
+   5.  Application Protocol Requirements  . . . . . . . . . . . . . . 11
+     5.1.  Character Encoding . . . . . . . . . . . . . . . . . . . . 11
+     5.2.  Operations . . . . . . . . . . . . . . . . . . . . . . . . 11
+     5.3.  Wildcards  . . . . . . . . . . . . . . . . . . . . . . . . 12
+     5.4.  String Comparison  . . . . . . . . . . . . . . . . . . . . 12
+     5.5.  Disconnected Clients . . . . . . . . . . . . . . . . . . . 12
+     5.6.  Error Codes  . . . . . . . . . . . . . . . . . . . . . . . 13
+     5.7.  Octet Collation  . . . . . . . . . . . . . . . . . . . . . 13
+   6.  Use by Existing Protocols  . . . . . . . . . . . . . . . . . . 13
+   7.  Collation Registration . . . . . . . . . . . . . . . . . . . . 14
+     7.1.  Collation Registration Procedure . . . . . . . . . . . . . 14
+     7.2.  Collation Registration Format  . . . . . . . . . . . . . . 15
+       7.2.1.  Registration Template  . . . . . . . . . . . . . . . . 15
+       7.2.2.  The Collation Element  . . . . . . . . . . . . . . . . 15
+       7.2.3.  The Identifier Element . . . . . . . . . . . . . . . . 16
+       7.2.4.  The Title Element  . . . . . . . . . . . . . . . . . . 16
+       7.2.5.  The Operations Element . . . . . . . . . . . . . . . . 16
+       7.2.6.  The Specification Element  . . . . . . . . . . . . . . 16
+       7.2.7.  The Submitter Element  . . . . . . . . . . . . . . . . 16
+       7.2.8.  The Owner Element  . . . . . . . . . . . . . . . . . . 16
+       7.2.9.  The Version Element  . . . . . . . . . . . . . . . . . 17
+       7.2.10. The Variable Element . . . . . . . . . . . . . . . . . 17
+     7.3.  Structure of Collation Registry  . . . . . . . . . . . . . 17
+     7.4.  Example Initial Registry Summary . . . . . . . . . . . . . 18
+
+
+
+Newman, et al.              Standards Track                     [Page 2]
+
+RFC 4790                   Collation Registry                 March 2007
+
+
+   8.  Guidelines for Expert Reviewer . . . . . . . . . . . . . . . . 18
+   9.  Initial Collations . . . . . . . . . . . . . . . . . . . . . . 19
+     9.1.  ASCII Numeric Collation  . . . . . . . . . . . . . . . . . 20
+       9.1.1.  ASCII Numeric Collation Description  . . . . . . . . . 20
+       9.1.2.  ASCII Numeric Collation Registration . . . . . . . . . 20
+     9.2.  ASCII Casemap Collation  . . . . . . . . . . . . . . . . . 21
+       9.2.1.  ASCII Casemap Collation Description  . . . . . . . . . 21
+       9.2.2.  ASCII Casemap Collation Registration . . . . . . . . . 22
+     9.3.  Octet Collation  . . . . . . . . . . . . . . . . . . . . . 22
+       9.3.1.  Octet Collation Description  . . . . . . . . . . . . . 22
+       9.3.2.  Octet Collation Registration . . . . . . . . . . . . . 23
+   10. IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 23
+   11. Security Considerations  . . . . . . . . . . . . . . . . . . . 23
+   12. Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 23
+   13. References . . . . . . . . . . . . . . . . . . . . . . . . . . 24
+     13.1. Normative References . . . . . . . . . . . . . . . . . . . 24
+     13.2. Informative References . . . . . . . . . . . . . . . . . . 24
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Newman, et al.              Standards Track                     [Page 3]
+
+RFC 4790                   Collation Registry                 March 2007
+
+
+1.  Introduction
+
+   The Application Configuration Access Protocol ACAP [11] specification
+   introduced the concept of a comparator (which we call collation in
+   this document), but failed to create an IANA registry.  With the
+   introduction of stringprep [6] and the Unicode Collation Algorithm
+   [7], it is now time to create that registry and populate it with some
+   initial values appropriate for an international community.  This
+   specification replaces and generalizes the definition of a comparator
+   in ACAP, and creates a collation registry.
+
+1.1.  Conventions Used in This Document
+
+   The key words "MUST", "MUST NOT", "SHOULD", "SHOULD NOT", and "MAY"
+   in this document are to be interpreted as defined in "Key words for
+   use in RFCs to Indicate Requirement Levels" [1].
+
+   The attribute syntax specifications use the Augmented Backus-Naur
+   Form (ABNF) [2] notation, including the core rules defined in
+   Appendix A.  The ABNF production "Language-tag" is imported from
+   Language Tags [5] and "reg-name" from URI: Generic Syntax [4].
+
+2.  Collation Definition and Purpose
+
+2.1.  Definition
+
+   A collation is a named function which takes two arbitrary length
+   strings as input and can be used to perform one or more of three
+   basic comparison operations: equality test, substring match, and
+   ordering test.
+
+2.2.  Purpose
+
+   Collations are an abstraction for comparison functions so that these
+   comparison functions can be used in multiple protocols.  The details
+   of a particular comparison operation can be specified by someone with
+   appropriate expertise, independent of the application protocols that
+   use that collation.  This is similar to the way a charset [13]
+   separates the details of octet to character mapping from a protocol
+   specification, such as MIME [9], or the way SASL [10] separates the
+   details of an authentication mechanism from a protocol specification,
+   such as ACAP [11].
+
+
+
+
+
+
+
+
+
+Newman, et al.              Standards Track                     [Page 4]
+
+RFC 4790                   Collation Registry                 March 2007
+
+
+   Here is a small diagram to help illustrate the value of this
+   abstraction:
+
+   +-------------------+                         +-----------------+
+   | IMAP i18n SEARCH  |--+                      | Basic           |
+   +-------------------+  |                   +--| Collation Spec  |
+                          |                   |  +-----------------+
+   +-------------------+  |  +-------------+  |  +-----------------+
+   | ACAP i18n SEARCH  |--+--| Collation   |--+--| A stringprep    |
+   +-------------------+  |  | Registry    |  |  | Collation Spec  |
+                          |  +-------------+  |  +-----------------+
+   +-------------------+  |                   |  +-----------------+
+   | ...other protocol |--+                   |  | locale-specific |
+   +-------------------+                      +--| Collation Spec  |
+                                                 +-----------------+
+
+   Thus IMAP, ACAP, and future application protocols with international
+   search capability simply specify how to interface to the collation
+   registry instead of each protocol specification having to specify all
+   the collations it supports.
+
+2.3.  Some Other Terms Used in this Document
+
+   The terms client, server, and protocol are used in somewhat unusual
+   senses.
+
+   Client means a user, or a program acting directly on behalf of a
+   user.  This may be a mail reader acting as an IMAP client, or it may
+   be an interactive shell, where the user can type protocol commands/
+   requests directly, or it may be a script or program written by the
+   user.
+
+   Server means a program that performs services requested by the
+   client.  This may be a traditional server such as an HTTP server, or
+   it may be a Sieve [14] interpreter running a Sieve script written by
+   a user.  A server needs to use the operations provided by collations
+   in order to fulfill the client's requests.
+
+   The protocol describes how the client tells the server what it wants
+   done, and (if applicable) how the server tells the client about the
+   results.  IMAP is a protocol by this definition, and so is the Sieve
+   language.
+
+2.4.  Sort Keys
+
+   One component of a collation is a transformation, which turns a
+   string into a sort key, which is then used while sorting.
+
+
+
+
+Newman, et al.              Standards Track                     [Page 5]
+
+RFC 4790                   Collation Registry                 March 2007
+
+
+   The transformation can range from an identity mapping (e.g., the
+   i;octet collation Section 9.3) to a mapping that makes the string
+   unreadable to a human.
+
+   This is an implementation detail of collations or servers.  A
+   protocol SHOULD NOT expose it to clients, since some collations leave
+   the sort key's format up to the implementation, and current
+   conformant implementations are known to use different formats.
+
+3.  Collation Identifier Syntax
+
+3.1.  Basic Syntax
+
+   The collation identifier itself is a single US-ASCII string.  The
+   identifier MUST NOT be longer than 254 characters, and obeys the
+   following grammar:
+
+     collation-char  = ALPHA / DIGIT / "-" / ";" / "=" / "."
+
+     collation-id    = collation-prefix ";" collation-core-name
+                       *collation-arg
+
+     collation-scope = Language-tag / "vnd-" reg-name
+
+     collation-core-name = ALPHA *( ALPHA / DIGIT / "-" )
+
+     collation-arg   = ";" ALPHA *( ALPHA / DIGIT ) "="
+                       1*( ALPHA / DIGIT / "." )
+
+
+   Note: the ABNF production "Language-tag" is imported from Language
+   Tags [5] and "reg-name" from URI: Generic Syntax [4].
+
+   There is a special identifier called "default".  For protocols that
+   have a default collation, "default" refers to that collation.  For
+   other protocols, the identifier "default" MUST match no collations,
+   and servers SHOULD treat it in the same way as they treat nonexistent
+   collations.
+
+3.2.  Wildcards
+
+   The string a client uses to select a collation MAY contain one or
+   more wildcard ("*") characters that match zero or more collation-
+   chars.  Wildcard characters MUST NOT be adjacent.  If the wildcard
+   string matches multiple collations, the server SHOULD attempt to
+   select a widely useful collation in preference to a narrowly useful
+   one.
+
+
+
+
+Newman, et al.              Standards Track                     [Page 6]
+
+RFC 4790                   Collation Registry                 March 2007
+
+
+     collation-wild  =  ("*" / (ALPHA ["*"])) *(collation-char ["*"])
+                         ; MUST NOT exceed 254 characters total
+
+3.3.  Ordering Direction
+
+   When used as a protocol element for ordering, the collation
+   identifier MAY be prefixed by either "+" or "-" to explicitly specify
+   an ordering direction. "+" has no effect on the ordering operation,
+   while "-" inverts the result of the ordering operation.  In general,
+   collation-order is used when a client requests a collation, and
+   collation-selected is used when the server informs the client of the
+   selected collation.
+
+     collation-selected =  ["+" / "-"] collation-id
+
+     collation-order =  ["+" / "-"] collation-wild
+
+3.4.  URIs
+
+   Some protocols are designed to use URIs [4] to refer to collations
+   rather than simple tokens.  A special section of the IANA URL space
+   is reserved for such usage.  The "collation-uri" form is used to
+   refer to a specific named collation (the collation registration may
+   not actually be present).  The "collation-auri" form is an abstract
+   name for an ordering, a collation pattern or a vendor private
+   collator.
+
+     collation-uri   =  "http://www.iana.org/assignments/collation/"
+                        collation-id ".xml"
+
+     collation-auri  =  ( "http://www.iana.org/assignments/collation/"
+                        collation-order ".xml" ) / other-uri
+
+     other-uri       =  <absoluteURI>
+                     ;  excluding the IANA collation namespace.
+
+3.5.  Naming Guidelines
+
+   While this specification makes no absolute requirements on the
+   structure of collation identifiers, naming consistency is important,
+   so the following initial guidelines are provided.
+
+   Collation identifiers with an international audience typically begin
+   with "i;".  Collation identifiers intended for a particular language
+   or locale typically begin with a language tag [5] followed by a ";".
+   After the first ";" is normally the name of the general collation
+   algorithm, followed by a series of algorithm modifications separated
+   by the ";" delimiter.  Parameterized modifications will use "=" to
+
+
+
+Newman, et al.              Standards Track                     [Page 7]
+
+RFC 4790                   Collation Registry                 March 2007
+
+
+   delimit the parameter from the value.  The version numbers of any
+   lookup tables used by the algorithm SHOULD be present as
+   parameterized modifications.
+
+   Collation identifiers of the form *;vnd-hostname;* are reserved for
+   vendor-specific collations created by the owner of the hostname
+   following the "vnd-" prefix (e.g., vnd-example.com for the vendor
+   example.com).  Registration of such collations (or the name space as
+   a whole), with intended use of the "Vendor", is encouraged when a
+   public specification or open-source implementation is available, but
+   is not required.
+
+4.  Collation Specification Requirements
+
+4.1.  Collation/Server Interface
+
+   The collation itself defines what it operates on.  Most collations
+   are expected to operate on character strings.  The i;octet
+   (Section 9.3) collation operates on octet strings.  The i;ascii-
+   numeric (Section 9.1) operation operates on numbers.
+
+   This specification defines the collation interface in terms of octet
+   strings.  However, implementations may choose to use character
+   strings instead.  Such implementations may not be able to implement
+   e.g., i;octet.  Since i;octet is not currently mandatory to implement
+   for any protocol, this should not be a problem.
+
+4.2.  Operations Supported
+
+   A collation specification MUST state which of the three basic
+   operations are supported (equality, substring, ordering) and how to
+   perform each of the supported operations on any two input character
+   strings, including empty strings.  Collations must be deterministic,
+   i.e., given a collation with a specific identifier, and any two fixed
+   input strings, the result MUST be the same for the same operation.
+
+   In general, collation operations should behave as their names
+   suggest.  While a collation may be new, the operations are not, so
+   the new collation's operations should be similar to those of older
+   collations.  For example, a date/time collation should not provide a
+   "substring" operation that would morph IMAP substring SEARCH into
+   e.g., a date-range search.
+
+   A non-obvious consequence of the rules for each collation operation
+   is that, for any single collation, either none or all of the
+   operations can return "undefined".  For example, it is not possible
+   to have an equality operation that never returns "undefined", and a
+   substring operation that occasionally does.
+
+
+
+Newman, et al.              Standards Track                     [Page 8]
+
+RFC 4790                   Collation Registry                 March 2007
+
+
+4.2.1.  Validity
+
+   The validity test takes one string as argument.  It returns valid if
+   its input string is a valid input to the collation's other
+   operations, and invalid if not.  (In other words, a string is valid
+   if it is equal to itself according to the collation's equality
+   operation.)
+
+   The validity test is provided by all collations.  It MUST NOT be
+   listed separately in the collation registration.
+
+4.2.2.  Equality
+
+   The equality test always returns "match" or "no-match" when it is
+   supplied valid input, and MAY return "undefined" if one or both input
+   strings are not valid.
+
+   The equality test MUST be reflexive and symmetric.  For valid input,
+   it MUST be transitive.
+
+   If a collation provides either a substring or an ordering test, it
+   MUST also provide an equality test.  The substring and/or ordering
+   tests MUST be consistent with the equality test.
+
+   The return values of the equality test are called "match", "no-match"
+   and "undefined" in this document.
+
+4.2.3.  Substring
+
+   The substring matching operation determines if the first string is a
+   substring of the second string, i.e., if one or more substrings of
+   the second string is equal to the first, as defined by the
+   collation's equality operation.
+
+   A collation that supports substring matching will automatically
+   support two special cases of substring matching: prefix and suffix
+   matching, if those special cases are supported by the application
+   protocol.  It returns "match" or "no-match" when it is supplied valid
+   input and returns "undefined" when supplied invalid input.
+
+   Application protocols MAY return position information for substring
+   matches.  If this is done, the position information SHOULD include
+   both the starting offset and the ending offset for each match.  This
+   is important because more sophisticated collations can match strings
+   of unequal length (for example, a pre-composed accented character can
+   match a decomposed accented character).  In general, overlapping
+   matches SHOULD be reported (as when "ana" occurs twice within
+   "banana"), although there are cases where a collation may decide not
+
+
+
+Newman, et al.              Standards Track                     [Page 9]
+
+RFC 4790                   Collation Registry                 March 2007
+
+
+   to.  For example, in a collation which treats all whitespace
+   sequences as identical, the substring operation could be defined such
+   that " 1 " (SP "1" SP) is reported just once within "  1  " (SP SP
+   "1" SP SP), not four times (SP SP "1" SP, SP "1" SP, SP "1" SP SP and
+   SP SP "1" SP SP), since the four matches are, in a sense, the same
+   match.
+
+   A string is a substring of itself.  The empty string is a substring
+   of all strings.
+
+   Note that the substring operation of some collations can match
+   strings of unequal length.  For example, a pre-composed accented
+   character can match a decomposed accented character.  The Unicode
+   Collation Algorithm [7] discusses this in more detail.
+
+   The return values of the substring operation are called "match", "no-
+   match", and "undefined" in this document.
+
+4.2.4.  Ordering
+
+   The ordering operation determines how two strings are ordered.  It
+   MUST be reflexive.  For valid input, it MUST be transitive and
+   trichotomous.
+
+   Ordering returns "less" if the first string is listed before the
+   second string, according to the collation; "greater", if the second
+   string is listed before the first string; and "equal", if the two
+   strings are equal, as defined by the collation's equality operation.
+   If one or both strings are invalid, the result of ordering is
+   "undefined".
+
+   When the collation is used with a "+" prefix, the behavior is the
+   same as when used with no prefix.  When the collation is used with a
+   "-" prefix, the result of the ordering operation of the collation
+   MUST be reversed.
+
+   The return values of the ordering operation are called "less",
+   "equal", "greater", and "undefined" in this document.
+
+4.3.  Sort Keys
+
+   A collation specification SHOULD describe the internal transformation
+   algorithm to generate sort keys.  This algorithm can be applied to
+   individual strings, and the result can be stored to potentially
+   optimize future comparison operations.  A collation MAY specify that
+   the sort key is generated by the identity function.  The sort key may
+   have no meaning to a human.  The sort key may not be valid input to
+   the collation.
+
+
+
+Newman, et al.              Standards Track                    [Page 10]
+
+RFC 4790                   Collation Registry                 March 2007
+
+
+4.4.  Use of Lookup Tables
+
+   Some collations use customizable lookup tables, e.g., because the
+   tables depend on locale, and may be modified after shipping the
+   software.  Collations that use more than one customizable lookup
+   table in a documented format MUST assign numbers to the tables they
+   use.  This permits an application protocol command to access the
+   tables used by a server collation, so that clients and servers use
+   the same tables.
+
+5.  Application Protocol Requirements
+
+   This section describes the requirements and issues that an
+   application protocol needs to consider if it offers searching,
+   substring matching and/or sorting, and permits the use of characters
+   outside the US-ASCII charset.
+
+5.1.  Character Encoding
+
+   The protocol specification has to make sure that it is clear on which
+   characters (rather than just octets) the collations are used.  This
+   can be done by specifying the protocol itself in terms of characters
+   (e.g., in the case of a query language), by specifying a single
+   character encoding for the protocol (e.g., UTF-8 [3]), or by
+   carefully describing the relevant issues of character encoding
+   labeling and conversion.  In the later case, details to consider
+   include how to handle unknown charsets, any charsets that are
+   mandatory-to-implement, any issues with byte-order that might apply,
+   and any transfer encodings that need to be supported.
+
+5.2.  Operations
+
+   The protocol must specify which of the operations defined in this
+   specification (equality matching, substring matching, and ordering)
+   can be invoked in the protocol, and how they are invoked.  There may
+   be more than one way to invoke an operation.
+
+   The protocol MUST provide a mechanism for the client to select the
+   collation to use with equality matching, substring matching, and
+   ordering.
+
+   If a protocol needs a total ordering and the collation chosen does
+   not provide it because the ordering operation returns "undefined" at
+   least once, the recommended fallback is to sort all invalid strings
+   after the valid ones, and use i;octet to order the invalid strings.
+
+   Although the collation's substring function provides a list of
+   matches, a protocol need not provide all that to the client.  It may
+
+
+
+Newman, et al.              Standards Track                    [Page 11]
+
+RFC 4790                   Collation Registry                 March 2007
+
+
+   provide only the first matching substring, or even just the
+   information that the substring search matched.  In this way,
+   collations can be used with protocols that are defined such that "x
+   is a substring of y" returns true-false.
+
+   If the protocol provides positional information for the results of a
+   substring match, that positional information SHOULD fully specify the
+   substring(s) in the result that matches, independent of the length of
+   the search string.  For example, returning both the starting and
+   ending offset of the match would suffice, as would the starting
+   offset and a length.  Returning just the starting offset is not
+   acceptable.  This rule is necessary because advanced collations can
+   treat strings of different lengths as equal (for example, pre-
+   composed and decomposed accented characters).
+
+5.3.  Wildcards
+
+   The protocol MUST specify whether it allows the use of wildcards in
+   collation identifiers.  If the protocol allows wildcards, then:
+      The protocol MUST specify how comparisons behave in the absence of
+      explicit collation negotiation, or when a collation of "default"
+      is requested.  The protocol MAY specify that the default collation
+      used in such circumstances is sensitive to server configuration.
+
+      The protocol SHOULD provide a way to list available collations
+      matching a given wildcard pattern, or patterns.
+
+5.4.  String Comparison
+
+   If a protocol compares strings in any nontrivial way, using a
+   collation may be appropriate.  As an example, many protocols use
+   case-independent strings.  In many cases, a simple ASCII mapping to
+   upper/lower case works well.  In other cases, it may be better to use
+   a specifiable collation; for example, so that a server can treat "i"
+   and "I" as equivalent in Italy, and different in Turkey (Turkish also
+   has a dotted upper-case" I" and a dotless lower-case "i").
+
+   Protocol designers should consider, in each case, whether to use a
+   specifiable collation.  Keywords often have other needs than user
+   variables, and search arguments may be different again.
+
+5.5.  Disconnected Clients
+
+   If the protocol supports disconnected clients, and a collation is
+   used that can use configurable tables (e.g., to support
+   locale-specific extensions), then the client may not be able to
+   reproduce the server's collation operations while offline.
+
+
+
+
+Newman, et al.              Standards Track                    [Page 12]
+
+RFC 4790                   Collation Registry                 March 2007
+
+
+   A mechanism to download such tables has been discussed.  Such a
+   mechanism is not included in the present specification, since the
+   problem is not yet well understood.
+
+5.6.  Error Codes
+
+   The protocol specification should consider assigning protocol error
+   codes for the following circumstances:
+
+   o  The client requests the use of a collation by identifier or
+      pattern, but no implemented collation matches that pattern.
+
+   o  The client attempts to use a collation for an operation that is
+      not supported by that collation -- for example, attempting to use
+      the "i;ascii-numeric" collation for substring matching.
+
+   o  The client uses an equality or substring matching collation, and
+      the result is an error.  It may be appropriate to distinguish
+      between the two input strings, particularly when one is supplied
+      by the client and the other is stored by the server.  It might
+      also be appropriate to distinguish the specific case of an invalid
+      UTF-8 string.
+
+5.7.  Octet Collation
+
+   The i;octet (Section 9.3) collation is only usable with protocols
+   based on octet-strings.  Clients and servers MUST NOT use i;octet
+   with other protocols.
+
+   If the protocol permits the use of collations with data structures
+   other than strings, the protocol MUST describe the default behavior
+   for a collation with those data structures.
+
+6.  Use by Existing Protocols
+
+   This section is informative.
+
+   Both ACAP [11] and Sieve [14] are standards track specifications that
+   used collations prior to the creation of this specification and
+   registry.  Those standards do not meet all the application protocol
+   requirements described in Section 5.
+
+   These protocols allow the use of the i;octet (Section 9.3) collation
+   working directly on UTF-8 data, as used in these protocols.
+
+
+
+
+
+
+
+Newman, et al.              Standards Track                    [Page 13]
+
+RFC 4790                   Collation Registry                 March 2007
+
+
+   In Sieve, all matches are either true or false.  Accordingly, Sieve
+   servers must treat "undefined" and "no-match" results of the equality
+   and substring operations as false, and only "match" as true.
+
+   In ACAP and Sieve, there are no invalid strings.  In this document's
+   terms, invalid strings sort after valid strings.
+
+   IMAP [15] also collates, although that is explicit only when the
+   COMPARATOR [17] extension is used.  The built-in IMAP substring
+   operation and the ordering provided by the SORT [16] extension may
+   not meet the requirements made in this document.
+
+   Other protocols may be in a similar position.
+
+   In IMAP, the default collation is i;ascii-casemap, because its
+   operations are understood to match IMAP's built-in operations.
+
+7.  Collation Registration
+
+7.1.  Collation Registration Procedure
+
+   The IETF will create a mailing list, collation@ietf.org, which can be
+   used for public discussion of collation proposals prior to
+   registration.  Use of the mailing list is strongly encouraged.  The
+   IESG will appoint a designated expert who will monitor the
+   collation@ietf.org mailing list and review registrations.
+
+   The registration procedure begins when a completed registration
+   template is sent to iana@iana.org and collation@ietf.org.  The
+   designated expert is expected to tell IANA and the submitter of the
+   registration within two weeks whether the registration is approved,
+   approved with minor changes, or rejected with cause.  When a
+   registration is rejected with cause, it can be re-submitted if the
+   concerns listed in the cause are addressed.  Decisions made by the
+   designated expert can be appealed to the IESG Applications Area
+   Director, then to the IESG.  They follow the normal appeals procedure
+   for IESG decisions.
+
+   Collation registrations in a standards track, BCP, or IESG-approved
+   experimental RFC are owned by the IETF, and changes to the
+   registration follow normal procedures for updating such documents.
+   Collation registrations in other RFCs are owned by the RFC author(s).
+   Other collation registrations are owned by the individual(s) listed
+   in the contact field of the registration, and IANA will preserve this
+   information.
+
+   If the registration is a change of an existing collation, it MUST be
+   approved by the owner.  In the event the owner cannot be contacted
+
+
+
+Newman, et al.              Standards Track                    [Page 14]
+
+RFC 4790                   Collation Registry                 March 2007
+
+
+   for a period of one month, and the designated expert deems the change
+   necessary, the IESG MAY re-assign ownership to an appropriate party.
+
+7.2.  Collation Registration Format
+
+   Registration of a collation is done by sending a well-formed XML
+   document to collation@ietf.org and iana@iana.org.
+
+7.2.1.  Registration Template
+
+   Here is a template for the registration:
+
+   <?xml version='1.0'?>
+   <!DOCTYPE collation SYSTEM 'collationreg.dtd'>
+   <collation rfc="YYYY" scope="global" intendedUse="common">
+     <identifier>collation identifier</identifier>
+     <title>technical title for collation</title>
+     <operations>equality order substring</operations>
+     <specification>specification reference</specification>
+     <owner>email address of owner or IETF</owner>
+     <submitter>email address of submitter</submitter>
+     <version>1</version>
+   </collation>
+
+7.2.2.  The Collation Element
+
+   The root of the registration document MUST be a <collation> element.
+   The collation element contains the other elements in the
+   registration, which are described in the following sub-subsections,
+   in the order given here.
+
+   The <collation> element MAY include an "rfc=" attribute if the
+   specification is in an RFC.  The "rfc=" attribute gives only the
+   number of the RFC, without any prefix, such as "RFC", or suffix, such
+   as ".txt".
+
+   The <collation> element MUST include a "scope=" attribute, which MUST
+   have one of the values "global", "local", or "other".
+
+   The <collation> element MUST include an "intendedUse=" attribute,
+   which must have one of the values "common", "limited", "vendor", or
+   "deprecated".  Collation specifications intended for "common" use are
+   expected to reference standards from standards bodies with
+   significant experience dealing with the details of international
+   character sets.
+
+   Be aware that future revisions of this specification may add
+   additional function types, as well as additional XML attributes,
+
+
+
+Newman, et al.              Standards Track                    [Page 15]
+
+RFC 4790                   Collation Registry                 March 2007
+
+
+   values, and elements.  Any system that automatically parses these XML
+   documents MUST take this into account to preserve future
+   compatibility.
+
+7.2.3.  The Identifier Element
+
+   The <identifier> element gives the precise identifier of the
+   collation, e.g., i;ascii-casemap.  The <identifier> element is
+   mandatory.
+
+7.2.4.  The Title Element
+
+   The <title> element gives the title of the collation.  The <title>
+   element is mandatory.
+
+7.2.5.  The Operations Element
+
+   The <operations> element lists which of the three operations
+   ("equality", "order" or "substring") the collation provides,
+   separated by single spaces.  The <operations> element is mandatory.
+
+7.2.6.  The Specification Element
+
+   The <specification> element describes where to find the
+   specification.  The <specification> element is mandatory.  It MAY
+   have a URI attribute.  There may be more than one <specification>
+   element, in which case, they together form the specification.
+
+   If it is discovered that parts of a collation specification conflict,
+   a new revision of the collation is necessary, and the
+   collation@ietf.org mailing list should be notified.
+
+7.2.7.  The Submitter Element
+
+   The <submitter> element provides an RFC 2822 [12] email address for
+   the person who submitted the registration.  It is optional if the
+   <owner> element contains an email address.
+
+   There may be more than one <submitter> element.
+
+7.2.8.  The Owner Element
+
+   The <owner> element contains either the four letters "IETF" or an
+   email address of the owner of the registration.  The <owner> element
+   is mandatory.  There may be more than one <owner> element.  If so,
+   all owners are equal.  Each owner can speak for all.
+
+
+
+
+
+Newman, et al.              Standards Track                    [Page 16]
+
+RFC 4790                   Collation Registry                 March 2007
+
+
+7.2.9.  The Version Element
+
+   The <version> element MUST be included when the registration is
+   likely to be revised, or has been revised in such a way that the
+   results change for one or more input strings.  The <version> element
+   is optional.
+
+7.2.10.  The Variable Element
+
+   The <variable> element specifies an optional variable to control the
+   collation's behaviour, for example whether it is case sensitive.  The
+   <variable> element is optional.  When <variable> is used, it must
+   contain <name> and <default> elements, and it may contain one or more
+   <value> elements.
+
+7.2.10.1.  The Name Element
+
+   The <name> element specifies the name value of a variable.  The
+   <name> element is mandatory.
+
+7.2.10.2.  The Default Element
+
+   The <default> element specifies the default value of a variable.  The
+   <default> element is mandatory.
+
+7.2.10.3.  The Value Element
+
+   The <value> element specifies a legal value of a variable.  The
+   <value> element is optional.  If one or more <value> elements are
+   present, only those values are legal.  If none are, then the
+   variable's legal values do not form an enumerated set, and the rules
+   MUST be specified in an RFC accompanying the registration.
+
+7.3.  Structure of Collation Registry
+
+   Once the registration is approved, IANA will store each XML
+   registration document in a URL of the form
+   http://www.iana.org/assignments/collation/collation-id.xml, where
+   collation-id is the content of the identifier element in the
+   registration.  Both the submitter and the designated expert are
+   responsible for verifying that the XML is well-formed.  The
+   registration document should avoid using new elements.  If any are
+   necessary, it is important to be consistent with other registrations.
+
+   IANA will also maintain a text summary of the registry under the name
+   http://www.iana.org/assignments/collation/collation-index.html.  This
+   summary is divided into four sections.  The first section is for
+   collations intended for common use.  This section is intended for
+
+
+
+Newman, et al.              Standards Track                    [Page 17]
+
+RFC 4790                   Collation Registry                 March 2007
+
+
+   collation registrations published in IESG-approved RFCs, or for
+   locally scoped collations from the primary standards body for that
+   locale.  The designated expert is encouraged to reject collation
+   registrations with an intended use of "common" if the expert believes
+   it should be "limited", as it is desirable to keep the number of
+   "common" registrations small and of high quality.  The second section
+   is reserved for limited-use collations.  The third section is
+   reserved for registered vendor-specific collations.  The final
+   section is reserved for deprecated collations.
+
+7.4.  Example Initial Registry Summary
+
+   The following is an example of how IANA might structure the initial
+   registry summary.html file:
+
+     Collation                              Functions Scope Reference
+     ---------                              --------- ----- ---------
+   Common Use Collations:
+     i;ascii-casemap                        e, o, s   Local [RFC 4790]
+
+   Limited Use Collations:
+     i;octet                                e, o, s   Other [RFC 4790]
+     i;ascii-numeric                        e, o      Other [RFC 4790]
+
+   Vendor Collations:
+
+   Deprecated Collations:
+
+
+   References
+   ----------
+   [RFC 4790]  Newman, C., Duerst, M., Gulbrandsen, A., "Internet
+               Application Protocol Collation Registry", RFC 4790,
+               Sun Microsystems, March 2007.
+
+8.  Guidelines for Expert Reviewer
+
+   The expert reviewer appointed by the IESG has fairly broad latitude
+   for this registry.  While a number of collations are expected
+   (particularly customizations of the UCA for localized use), an
+   explosion of collations (particularly common-use collations) is not
+   desirable for widespread interoperability.  However, it is important
+   for the expert reviewer to provide cause when rejecting a
+   registration, and, when possible, to describe corrective action to
+
+
+
+
+
+
+
+Newman, et al.              Standards Track                    [Page 18]
+
+RFC 4790                   Collation Registry                 March 2007
+
+
+   permit the registration to proceed.  The following table includes
+   some example reasons to reject a registration with cause:
+
+   o  The registration is not a well-formed XML document.
+
+   o  The registration has an intended use of "common", but there is no
+      evidence the collation will be widely deployed, so it should be
+      listed as "limited".
+
+   o  The registration has an intended use of "common", but it is
+      redundant with the functionality of a previously registered
+      "common" collation.
+
+   o  The registration has an intended use of "common", but the
+      specification is not detailed enough to allow interoperable
+      implementations by others.
+
+   o  The collation identifier fails to precisely identify the version
+      numbers of relevant tables to use.
+
+   o  The registration fails to meet one of the "MUST" requirements in
+      Section 4.
+
+   o  The collation identifier fails to meet the syntax in Section 3.
+
+   o  The collation specification referenced in the registration is
+      vague or has optional features without a clear behavior specified.
+
+   o  The referenced specification does not adequately address security
+      considerations specific to that collation.
+
+   o  The registration's operations are needlessly different from those
+      of traditional operations.
+
+   o  The registration's XML is needlessly different from that of
+      already registered collations.
+
+9.  Initial Collations
+
+   This section registers the three collations that were originally
+   defined in [11], and are implemented in most [14] engines.  Some of
+   the behavior of these collations is perhaps not ideal, such as
+   i;ascii-casemap accepting non-ASCII input.  Compatibility with widely
+   deployed code was judged more important than fixing the collations.
+   Some of the aspects of these collations are necessary to maintain
+   compatibility with widely deployed code.
+
+
+
+
+
+Newman, et al.              Standards Track                    [Page 19]
+
+RFC 4790                   Collation Registry                 March 2007
+
+
+9.1.  ASCII Numeric Collation
+
+9.1.1.  ASCII Numeric Collation Description
+
+   The "i;ascii-numeric" collation is a simple collation intended for
+   use with arbitrarily-sized, unsigned decimal integer numbers stored
+   as octet strings.  US-ASCII digits (0x30 to 0x39) represent digits of
+   the numbers.  Before converting from string to integer, the input
+   string is truncated at the first non-digit character.  All input is
+   valid; strings that do not start with a digit represent positive
+   infinity.
+
+   The collation supports equality and ordering, but does not support
+   the substring operation.
+
+   The equality operation returns "match" if the two strings represent
+   the same number (i.e., leading zeroes and trailing non-digits are
+   disregarded), and "no-match" if the two strings represent different
+   numbers.
+
+   The ordering operation returns "less" if the first string represents
+   a smaller number than the second, "equal" if they represent the same
+   number, and "greater" if the first string represents a larger number
+   than the second.
+
+   Some examples: "0" is less than "1", and "1" is less than
+   "4294967298". "4294967298", "04294967298", and "4294967298b" are all
+   equal. "04294967298" is less than "". "", "x", and "y" are equal.
+
+9.1.2.  ASCII Numeric Collation Registration
+
+   <?xml version='1.0'?>
+   <!DOCTYPE collation SYSTEM 'collationreg.dtd'>
+   <collation rfc="4790" scope="other" intendedUse="limited">
+     <identifier>i;ascii-numeric</identifier>
+     <title>ASCII Numeric</title>
+     <operations>equality order</operations>
+     <specification>RFC 4790</specification>
+     <owner>IETF</owner>
+     <submitter>chris.newman@sun.com</submitter>
+   </collation>
+
+
+
+
+
+
+
+
+
+
+Newman, et al.              Standards Track                    [Page 20]
+
+RFC 4790                   Collation Registry                 March 2007
+
+
+9.2.  ASCII Casemap Collation
+
+9.2.1.  ASCII Casemap Collation Description
+
+   The "i;ascii-casemap" collation is a simple collation that operates
+   on octet strings and treats US-ASCII letters case-insensitively.  It
+   provides equality, substring, and ordering operations.  All input is
+   valid.  Note that letters outside ASCII are not treated case-
+   insensitively.
+
+   Its equality, ordering, and substring operations are as for i;octet,
+   except that at first, the lower-case letters (octet values 97-122) in
+   each input string are changed to upper case (octet values 65-90).
+
+   Care should be taken when using OS-supplied functions to implement
+   this collation, as it is not locale sensitive.  Functions, such as
+   strcasecmp and toupper, are sometimes locale sensitive, and may
+   inappropriately map lower-case letters other than a-z to upper case.
+
+   The i;ascii-casemap collation is well-suited for use with many
+   Internet protocols and computer languages.  Use with natural language
+   is often inappropriate; even though the collation apparently supports
+   languages such as Swahili and English, in real-world use, it tends to
+   mis-sort a number of types of string:
+
+   o  people and place names containing non-ASCII,
+
+   o  words such as "naive" (if spelled with an accent, the accented
+      character could push the word to the wrong spot in a sorted list),
+
+   o  names such as "Lloyd" (which, in Welsh, sorts after "Lyon", unlike
+      in English),
+
+   o  strings containing euro and pound sterling symbols, quotation
+      marks other than '"', dashes/hyphens, etc.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Newman, et al.              Standards Track                    [Page 21]
+
+RFC 4790                   Collation Registry                 March 2007
+
+
+9.2.2.  ASCII Casemap Collation Registration
+
+   <?xml version='1.0'?>
+   <!DOCTYPE collation SYSTEM 'collationreg.dtd'>
+   <collation rfc="4790" scope="local" intendedUse="common">
+     <identifier>i;ascii-casemap</identifier>
+     <title>ASCII Casemap</title>
+     <operations>equality order substring</operations>
+     <specification>RFC 4790</specification>
+     <owner>IETF</owner>
+     <submitter>chris.newman@sun.com</submitter>
+   </collation>
+
+9.3.  Octet Collation
+
+9.3.1.  Octet Collation Description
+
+   The "i;octet" collation is a simple and fast collation intended for
+   use on binary octet strings rather than on character data.  Protocols
+   that want to make this collation available have to do so by
+   explicitly allowing it.  If not explicitly allowed, it MUST NOT be
+   used.  It never returns an "undefined" result.  It provides equality,
+   substring, and ordering operations.
+
+   The ordering algorithm is as follows:
+
+   1.  If both strings are the empty string, return the result "equal".
+
+   2.  If the first string is empty and the second is not, return the
+       result "less".
+
+   3.  If the second string is empty and the first is not, return the
+       result "greater".
+
+   4.  If both strings begin with the same octet value, remove the first
+       octet from both strings and repeat this algorithm from step 1.
+
+   5.  If the unsigned value (0 to 255) of the first octet of the first
+       string is less than the unsigned value of the first octet of the
+       second string, then return "less".
+
+   6.  If this step is reached, return "greater".
+
+   This algorithm is roughly equivalent to the C library function
+   memcmp, with appropriate length checks added.
+
+
+
+
+
+
+Newman, et al.              Standards Track                    [Page 22]
+
+RFC 4790                   Collation Registry                 March 2007
+
+
+   The matching operation returns "match" if the sorting algorithm would
+   return "equal".  Otherwise, the matching operation returns "no-
+   match".
+
+   The substring operation returns "match" if the first string is the
+   empty string, or if there exists a substring of the second string of
+   length equal to the length of the first string, which would result in
+   a "match" result from the equality function.  Otherwise, the
+   substring operation returns "no-match".
+
+9.3.2.  Octet Collation Registration
+
+   This collation is defined with intendedUse="limited" because it can
+   only be used by protocols that explicitly allow it.
+
+   <?xml version='1.0'?>
+   <!DOCTYPE collation SYSTEM 'collationreg.dtd'>
+   <collation rfc="4790" scope="global" intendedUse="limited">
+     <identifier>i;octet</identifier>
+     <title>Octet</title>
+     <operations>equality order substring</operations>
+     <specification>RFC 4790</specification>
+     <owner>IETF</owner>
+     <submitter>chris.newman@sun.com</submitter>
+   </collation>
+
+10.  IANA Considerations
+
+   Section 7 defines how to register collations with IANA.  Section 9
+   defines a list of predefined collations that have been registered
+   with IANA.
+
+11.  Security Considerations
+
+   Collations will normally be used with UTF-8 strings.  Thus, the
+   security considerations for UTF-8 [3], stringprep [6], and Unicode
+   TR-36 [8] also apply, and are normative to this specification.
+
+12.  Acknowledgements
+
+   The authors want to thank all who have contributed to this document,
+   including Brian Carpenter, John Cowan, Dave Cridland, Mark Davis,
+   Spencer Dawkins, Lisa Dusseault, Lars Eggert, Frank Ellermann, Philip
+   Guenther, Tony Hansen, Ted Hardie, Sam Hartman, Kjetil Torgrim Homme,
+   Michael Kay, John Klensin, Alexey Melnikov, Jim Melton, and Abhijit
+   Menon-Sen.
+
+
+
+
+
+Newman, et al.              Standards Track                    [Page 23]
+
+RFC 4790                   Collation Registry                 March 2007
+
+
+13.  References
+
+13.1.  Normative References
+
+   [1]   Bradner, S., "Key words for use in RFCs to Indicate Requirement
+         Levels", BCP 14, RFC 2119, March 1997.
+
+   [2]   Crocker, D. and P. Overell, "Augmented BNF for Syntax
+         Specifications: ABNF", RFC 4234, October 2005.
+
+   [3]   Yergeau, F., "UTF-8, a transformation format of ISO 10646",
+         STD 63, RFC 3629, November 2003.
+
+   [4]   Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
+         Resource Identifier (URI): Generic Syntax", RFC 3986,
+         January 2005.
+
+   [5]   Phillips, A. and M. Davis, "Tags for Identifying Languages",
+         BCP 47, RFC 4646, September 2006.
+
+   [6]   Hoffman, P. and M. Blanchet, "Preparation of Internationalized
+         Strings ("stringprep")", RFC 3454, December 2002.
+
+   [7]   Davis, M. and K. Whistler, "Unicode Collation Algorithm version
+         14", May 2005,
+         <http://www.unicode.org/reports/tr10/tr10-14.html>.
+
+   [8]   Davis, M. and M. Suignard, "Unicode Security Considerations",
+         February 2006, <http://www.unicode.org/reports/tr36/>.
+
+13.2.  Informative References
+
+   [9]   Freed, N. and N. Borenstein, "Multipurpose Internet Mail
+         Extensions (MIME) Part One: Format of Internet Message Bodies",
+         RFC 2045, November 1996.
+
+   [10]  Melnikov, A., "Simple Authentication and Security Layer
+         (SASL)", RFC 4422, June 2006.
+
+   [11]  Newman, C. and J. Myers, "ACAP -- Application Configuration
+         Access Protocol", RFC 2244, November 1997.
+
+   [12]  Resnick, P., "Internet Message Format", RFC 2822, April 2001.
+
+   [13]  Freed, N. and J. Postel, "IANA Charset Registration
+         Procedures", BCP 19, RFC 2978, October 2000.
+
+
+
+
+
+Newman, et al.              Standards Track                    [Page 24]
+
+RFC 4790                   Collation Registry                 March 2007
+
+
+   [14]  Showalter, T., "Sieve: A Mail Filtering Language", RFC 3028,
+         January 2001.
+
+   [15]  Crispin, M., "Internet Message Access Protocol - Version
+         4rev1", RFC 3501, March 2003.
+
+   [16]  Crispin, M. and K. Murchison, "Internet Message Access Protocol
+         - Sort and Thread Extensions", Work in Progress, May 2004.
+
+   [17]  Newman, C. and A. Gulbrandsen, "Internet Message Access
+         Protocol Internationalization", Work in Progress, January 2006.
+
+Authors' Addresses
+
+   Chris Newman
+   Sun Microsystems
+   1050 Lakes Drive
+   West Covina, CA  91790
+   USA
+
+   EMail: chris.newman@sun.com
+
+
+   Martin Duerst
+   Aoyama Gakuin University
+   5-10-1 Fuchinobe
+   Sagamihara, Kanagawa  229-8558
+   Japan
+
+   Phone: +81 42 759 6329
+   Fax:   +81 42 759 6495
+   EMail: duerst@it.aoyama.ac.jp
+   URI:   http://www.sw.it.aoyama.ac.jp/D%C3%BCrst/
+
+   Note: Please write "Duerst" with u-umlaut wherever possible, for
+   example as "D&#252;rst" in XML and HTML.
+
+
+   Arnt Gulbrandsen
+   Oryx Mail Systems GmbH
+   Schweppermannstr. 8
+   81671 Munich
+   Germany
+
+   Fax:   +49 89 4502 9758
+   EMail: arnt@oryx.com
+   URI:   http://www.oryx.com/arnt/
+
+
+
+
+Newman, et al.              Standards Track                    [Page 25]
+
+RFC 4790                   Collation Registry                 March 2007
+
+
+Full Copyright Statement
+
+   Copyright (C) The IETF Trust (2007).
+
+   This document is subject to the rights, licenses and restrictions
+   contained in BCP 78, and except as set forth therein, the authors
+   retain all their rights.
+
+   This document and the information contained herein are provided on an
+   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
+   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
+   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
+   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
+
+Intellectual Property
+
+   The IETF takes no position regarding the validity or scope of any
+   Intellectual Property Rights or other rights that might be claimed to
+   pertain to the implementation or use of the technology described in
+   this document or the extent to which any license under such rights
+   might or might not be available; nor does it represent that it has
+   made any independent effort to identify any such rights.  Information
+   on the procedures with respect to rights in RFC documents can be
+   found in BCP 78 and BCP 79.
+
+   Copies of IPR disclosures made to the IETF Secretariat and any
+   assurances of licenses to be made available, or the result of an
+   attempt made to obtain a general license or permission for the use of
+   such proprietary rights by implementers or users of this
+   specification can be obtained from the IETF on-line IPR repository at
+   http://www.ietf.org/ipr.
+
+   The IETF invites any interested party to bring to its attention any
+   copyrights, patents or patent applications, or other proprietary
+   rights that may cover technology that may be required to implement
+   this standard.  Please address the information to the IETF at
+   ietf-ipr@ietf.org.
+
+Acknowledgement
+
+   Funding for the RFC Editor function is currently provided by the
+   Internet Society.
+
+
+
+
+
+
+
+Newman, et al.              Standards Track                    [Page 26]
+
diff -urN dovecot-1.2.4/dovecot-libsieve/doc/rfc/copy.rfc3894.txt dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/copy.rfc3894.txt
--- dovecot-1.2.4/dovecot-libsieve/doc/rfc/copy.rfc3894.txt	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/copy.rfc3894.txt	2008-08-04 10:39:20.000000000 +0200
@@ -0,0 +1,283 @@
+
+
+
+
+
+
+Network Working Group                                         J. Degener
+Request for Comments: 3894                                Sendmail, Inc.
+Category: Standards Track                                   October 2004
+
+
+             Sieve Extension: Copying Without Side Effects
+
+Status of this Memo
+
+   This document specifies an Internet standards track protocol for the
+   Internet community, and requests discussion and suggestions for
+   improvements.  Please refer to the current edition of the "Internet
+   Official Protocol Standards" (STD 1) for the standardization state
+   and status of this protocol.  Distribution of this memo is unlimited.
+
+Copyright Notice
+
+   Copyright (C) The Internet Society (2004).
+
+Abstract
+
+   The Sieve scripting language allows users to control handling and
+   disposal of their incoming e-mail.  By default, an e-mail message
+   that is processed by a Sieve script is saved in the owner's "inbox".
+   Actions such as "fileinto" and "redirect" cancel this default
+   behavior.
+
+   This document defines a new keyword parameter, ":copy", to be used
+   with the Sieve "fileinto" and "redirect" actions.  Adding ":copy" to
+   an action suppresses cancellation of the default "inbox" save.  It
+   allows users to add commands to an existing script without changing
+   the meaning of the rest of the script.
+
+1.  Introduction
+
+   The Sieve scripting language [SIEVE] allows users to control handling
+   and disposal of their incoming e-mail.  Two frequently used Sieve
+   commands are "fileinto" (saving into a local message store, such as
+   an IMAP server) and "redirect" (forwarding to another e-mail
+   address).  Both of these cancel the Sieve default behavior of saving
+   into the user's "inbox".
+
+   But some users have the notion of forwarding an extra copy of a
+   message for safekeeping to another e-mail address, or of saving a
+   copy in a folder - in addition to the regular message delivery, which
+   shouldn't be affected by the copy.
+
+
+
+
+
+Degener                     Standards Track                     [Page 1]
+
+RFC 3894      Sieve Extension - Copy Without Side Effects   October 2004
+
+
+   If saving an extra copy is all the user wanted to do,
+
+      fileinto "unfiltered";
+      keep;
+
+   would do the job.  The "keep" command does explicitly what the
+   cancelled default behavior did.  But the explicit "keep" is a poor
+   substitute for the implicit "keep" when more processing follows:
+
+      fileinto "unfiltered";
+      keep;
+
+      if header "Subject" "MAKE MONEY FAST!!!"
+      {
+              discard;
+      }
+
+   In this example, the "discard" is ineffective against the explicit
+   "keep"; the discarded message still ends up in the user's inbox.
+
+   It is possible to generate Sieve code that perfectly expresses a
+   user's wishes, but such code quickly grows unwieldy because it needs
+   to keep track of the state that the implicit "keep" would have had
+   without the "fileinto" or "redirect" command.
+
+   This extension tries to make life easier for user interface designers
+   and script writers by allowing them to express the "copy" semantics
+   directly.
+
+2.  Conventions used
+
+   Conventions for notations are as in [SIEVE] section 1.1, including
+   use of [KEYWORDS] and "Syntax:" label for the definition of action
+   and tagged arguments syntax.
+
+   The capability string associated with extension defined in this
+   document is "copy".
+
+3.  ":copy" extension to the "fileinto" and "redirect" commands
+
+   Syntax:
+        "fileinto" [":copy"] <folder: string>
+        "redirect" [":copy"] <address: string>
+
+   If the optional ":copy" keyword is specified with "fileinto" or
+   "redirect", the tagged command does not cancel the implicit "keep".
+   Instead, it merely files or redirects a copy in addition to whatever
+   else is happening to the message.
+
+
+
+Degener                     Standards Track                     [Page 2]
+
+RFC 3894      Sieve Extension - Copy Without Side Effects   October 2004
+
+
+   Example:
+
+      require ["copy", "fileinto"];
+      fileinto :copy "incoming";
+
+      # ... more processing follows ...
+
+4.  Security Considerations
+
+   The "copy" extension makes it easier to eavesdrop on a user's message
+   stream without the user noticing.  This was technically possible
+   before if an attacker gained read/write access to a user's Sieve
+   scripts, but now an attacker no longer needs to parse a script in
+   order to modify it.  Write access to Sieve scripts must be protected
+   as strongly as read/write access to e-mail, for example by using
+   secure directory protocols such as correctly parameterized LDAP over
+   TLS [LDAP].
+
+   Organizations that wish to monitor their users' e-mail traffic must
+   familiarize themselves with local data protection laws before
+   creating stores of old e-mail traffic without control, or perhaps
+   even knowledge, of the sender or intended recipients.
+
+   Organizations that legally use "redirect :copy" to eavesdrop on
+   correspondence (for example, by keeping a log to answer questions
+   about insider trading at a later time) can avoid future problems by
+   setting users' privacy expectations correctly.
+
+5.  IANA Considerations
+
+   The following template specifies the IANA registration of the "copy"
+   Sieve extension specified in this document.
+
+   To: iana@iana.org
+   Subject: Registration of new Sieve extension
+
+   Capability name: copy
+   Capability keyword: copy
+   Capability arguments: N/A
+   Standards Track: RFC 3894
+   Person and email address to contact for further information:
+
+      Jutta Degener
+      Sendmail, Inc.
+      6425 Christie Ave, 4th Floor
+      Emeryville, CA 94608
+
+      Email: jutta@sendmail.com
+
+
+
+Degener                     Standards Track                     [Page 3]
+
+RFC 3894      Sieve Extension - Copy Without Side Effects   October 2004
+
+
+   This information has been added to the list of Sieve extensions given
+   on http://www.iana.org/assignments/sieve-extensions.
+
+6.  Acknowledgments
+
+   Thanks to Eric Allman, Ned Freed, Will Lee, Nigel Swinson, and Rand
+   Wacker for corrections and comments.
+
+7.  References
+
+7.1.  Normative References
+
+   [KEYWORDS] Bradner, S., "Key words for use in RFCs to Indicate
+              Requirement Levels", BCP 14, RFC 2119, March 1997.
+
+   [SIEVE]    Showalter, T., "Sieve: A Mail Filtering Language", RFC
+              3028, January 2001.
+
+7.2.  Informative References
+
+   [LDAP]     Wahl, M., Alvestrand, H., Hodges, J., and R. Morgan,
+              "Authentication Methods for LDAP", RFC 2829, May 2000.
+
+Author's Address
+
+   Jutta Degener
+   Sendmail, Inc.
+   6425 Christie Ave, 4th Floor
+   Emeryville, CA 94608
+
+   EMail: jutta@sendmail.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Degener                     Standards Track                     [Page 4]
+
+RFC 3894      Sieve Extension - Copy Without Side Effects   October 2004
+
+
+Full Copyright Statement
+
+   Copyright (C) The Internet Society (2004).
+
+   This document is subject to the rights, licenses and restrictions
+   contained in BCP 78, and except as set forth therein, the authors
+   retain all their rights.
+
+   This document and the information contained herein are provided on an
+   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/S HE
+   REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE
+   INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR
+   IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
+   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
+
+Intellectual Property
+
+   The IETF takes no position regarding the validity or scope of any
+   Intellectual Property Rights or other rights that might be claimed to
+   pertain to the implementation or use of the technology described in
+   this document or the extent to which any license under such rights
+   might or might not be available; nor does it represent that it has
+   made any independent effort to identify any such rights.  Information
+   on the IETF's procedures with respect to rights in IETF Documents can
+   be found in BCP 78 and BCP 79.
+
+   Copies of IPR disclosures made to the IETF Secretariat and any
+   assurances of licenses to be made available, or the result of an
+   attempt made to obtain a general license or permission for the use of
+   such proprietary rights by implementers or users of this
+   specification can be obtained from the IETF on-line IPR repository at
+   http://www.ietf.org/ipr.
+
+   The IETF invites any interested party to bring to its attention any
+   copyrights, patents or patent applications, or other proprietary
+   rights that may cover technology that may be required to implement
+   this standard.  Please address the information to the IETF at ietf-
+   ipr@ietf.org.
+
+Acknowledgement
+
+   Funding for the RFC Editor function is currently provided by the
+   Internet Society.
+
+
+
+
+
+
+
+Degener                     Standards Track                     [Page 5]
+
diff -urN dovecot-1.2.4/dovecot-libsieve/doc/rfc/deprecated/draft-martin-sieve-notify-01.txt dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/deprecated/draft-martin-sieve-notify-01.txt
--- dovecot-1.2.4/dovecot-libsieve/doc/rfc/deprecated/draft-martin-sieve-notify-01.txt	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/deprecated/draft-martin-sieve-notify-01.txt	2001-11-29 06:42:35.000000000 +0100
@@ -0,0 +1,457 @@
+
+
+
+
+
+
+
+Network Working Group                                         Tim Martin
+Document: draft-martin-sieve-notify-01.txt            Wolfgang Segmuller
+Expires December 6, 2001                                     1 June 2001
+
+
+         Sieve -- An extension for providing instant notifications
+
+                      <draft-ietf-sieve-notify-01.txt>
+
+Status of this Memo
+
+    This document is an Internet-Draft and is in full conformance with
+    all provisions of Section 10 of RFC2026.  Internet-Drafts are
+    working documents of the Internet Engineering Task Force (IETF), its
+    areas, and its working groups.  Note that other groups may also
+    distribute working documents as Internet-Drafts.
+
+    Internet-Drafts are draft documents valid for a maximum of six
+    months and may be updated, replaced, or obsoleted by other documents
+    at any time.  It is inappropriate to use Internet- Drafts as
+    reference material or to cite them other than as "work in progress."
+
+   
+     The list of current Internet-Drafts can be accessed at
+     http://www.ietf.org/1id-abstracts.html
+
+     The list of Internet-Draft Shadow Directories can be accessed at
+     http://www.ietf.org/shadow.html.
+
+
+    Distribution of this memo is unlimited.
+
+
+Abstract
+
+    Users go to great lengths to be notified as quickly as possible that
+    they have received new mail. Most of these methods involve polling
+    to check for new messages periodically. A push method handled by the
+    final delivery agent gives users quicker notifications and saves
+    server resources. This document does not specify the notification
+    method but is expected that using existing instant messaging
+    infrastructure such as Zephyr, ICQ, or SMS messages will be popular.
+    This draft describes an extension to the Sieve mail filtering
+    language that allows users to give specific preferences for
+    notification of Sieve actions.
+
+
+
+
+
+
+
+
+
+
+
+Expires December 6, 2001        Martin                          [Page 1]
+
+Internet Draft      Sieve -- Notifications extension        June 1, 2001
+
+
+                           TTaabbllee ooff CCoonntteennttss
+
+
+
+Status of this Memo  . . . . . . . . . . . . . . . . . . . . . . . .   1
+
+Abstract . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   1
+
+1.     Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
+1.1.   Conventions Used in This Document . . . . . . . . . . . . . .   3
+
+2.     Capability Identifier . . . . . . . . . . . . . . . . . . . .   3
+
+3.     Actions . . . . . . . . . . . . . . . . . . . . . . . . . . .   3
+3.1.   Notify action . . . . . . . . . . . . . . . . . . . . . . . .   3
+3.2.   Denotify Action . . . . . . . . . . . . . . . . . . . . . . .   5
+
+4.     Interaction with Other Sieve Actions  . . . . . . . . . . . .   6
+
+5.     Security Considerations . . . . . . . . . . . . . . . . . . .   7
+
+6.     Acknowledgments . . . . . . . . . . . . . . . . . . . . . . .   7
+
+7.     Copyright . . . . . . . . . . . . . . . . . . . . . . . . . .   7
+
+8.     References  . . . . . . . . . . . . . . . . . . . . . . . . .   8
+
+9.     Author's Addresses  . . . . . . . . . . . . . . . . . . . . .   8
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Expires December 6, 2001        Martin                          [Page 2]
+
+Internet Draft      Sieve -- Notifications extension        June 1, 2001
+
+
+1.  Introduction
+
+    This is an extension to the Sieve language defined by [SIEVE] for
+    providing instant notifications of sieve actions that have been
+    preformed. It defines the new action "notify".
+
+    This document does not dictate the notification method used.
+    Examples of possible notification methods are Zephyr and ICQ. The
+    method shall be site-defined.
+
+    Sieve interpreters for which notifications are impractical or is not
+    possible SHOULD ignore this extension.
+
+    Conventions for notations are as in [SIEVE] section 1.1, including
+    use of [KEYWORDS].
+
+
+1.1.  Conventions Used in This Document
+    The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
+    "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
+    document are to be interpreted as described in [KEYWORDS].
+
+
+
+2.  Capability Identifier
+
+    The capability string associated with the extension defined in this
+    document is "notify".
+
+
+
+3.  Actions
+
+
+
+
+3.1.  Notify action
+
+    Syntax:   notify [":method" string]
+               [":id" string]
+               [":options" 1*(string-list / number)]
+               [<":low" / ":normal" / ":high">]
+               ["message:" string]
+
+    The Notify action specifies that a notification should be sent to
+    the user upon successful handling of this message.
+
+    The format of the notification is implementation-defined. However,
+
+
+
+Expires December 6, 2001        Martin                          [Page 3]
+
+Internet Draft      Sieve -- Notifications extension        June 1, 2001
+
+
+    all content specified in the notify action, including Sieve actions
+    taken on the message, SHOULD be included. If errors occurred in
+    another action they SHOULD be reported in the notification. In
+    addition, if the notification method does not provide a timestamp,
+    one SHOULD be appended to the notification. Implementations SHOULD
+    NOT include extraneous information.
+
+    The :method tag identifies the notification method that will be
+    used. If the :method tag is not specified, the default
+    implementation defined notification method MUST be used.  The
+    possible values of this will be site-specific.  If a method is
+    specified that the implementation does not support, the notification
+    MUST be ignored. An implementation treats this as a warning
+    condition and execution of the sieve script MUST continue.
+
+    The :id tag can be used to give the notify action an unique
+    identifier. This identifier can be used later in the script to
+    cancel the specific notify. The string may have any value and SHOULD
+    NOT be included in the notification.
+
+    The :options tag is used to send parameters to the notification
+    method. This might be the phone number for an SMS message or a
+    user's ICQ identifier.
+
+    The priority parameter specifies the importance of the notification.
+    The priority parameter has the following values: ":high" (very
+    important), ":normal", and ":low" (not very important). If no
+    priority is given, a default priority of ":normal" SHOULD be
+    assumed. Some notification methods allow users to specify their
+    state of activity (for example "busy" or "away from keyboard"). If
+    the notification method provides this information it SHOULD be used
+    to selectively send notifications.  If, for example, the user marks
+    herself as "busy", an implementation SHOULD NOT send a notification
+    for a new mailing list message with a priority of :low, however the
+    user should be notified of a high priority action.  If the
+    notification method allows users to filter messages based upon
+    certain parameters in the message, users should be able to filter
+    based upon priority. If the notification method does not support
+    priority, then this parameter MUST be ignored.
+
+    The :message tag specifies the message data to be included in the
+    notification. The entirety of the string SHOULD be sent but
+    implementations MAY shorten the message for technical or aesthetic
+    reasons. Message may include the message variables defined below. If
+    the message parameter is absent, a default message of "$from$:
+    $subject$" will be used.
+
+         $from$     - the display name or address of the RFC 822 from
+
+
+
+Expires December 6, 2001        Martin                          [Page 4]
+
+Internet Draft      Sieve -- Notifications extension        June 1, 2001
+
+
+         $env-from$ - the address of the RFC 821 from
+
+         $subject$  - the subject of the message
+
+         $text$     - the first text/* part
+
+         $text[n]$  - the first n bytes of the first text/* part
+
+    If there are errors sending the notification, the Sieve interpreter
+    SHOULD ignore the notification and not retry indefinitely.
+
+    This action MUST NOT cancel the implicit keep.
+
+    Example:
+         require ["notify","fileinto"];
+
+            if header :contains "from" "boss@example.org" {
+                notify :high "This is probably very important";
+            }
+
+            if header :contains "to" "sievemailinglist@example.org" {
+                notify :low "[SIEVE] $from$: $subject$";
+                fileinto "INBOX.sieve";
+            }
+
+
+
+
+3.2.  Denotify Action
+
+    Syntax: denotify [MATCH-TYPE string] [<":low" / ":normal" /
+    ":high">]
+
+    The denotify action can be used to cancel a previous notification.
+    If the priority, ":low" / ":normal" / ":high", is specified, then
+    only cancel those notifications with the specified priority.  If a
+    MATCH-TYPE with a string is specified, then only those notifications
+    whose :id tag matches the specified string using the match-type
+    operator are canceled.  The ascii-casemap comparator MUST be used.
+
+    If no notifications exist that match the search criteria, then the
+    denotify has no effect.  A denotify only cancels notifications that
+    have already been requested.  It is not possible to preemptively
+    cancel a notification.
+
+    The sequence:
+
+      denotify;
+
+
+
+Expires December 6, 2001        Martin                          [Page 5]
+
+Internet Draft      Sieve -- Notifications extension        June 1, 2001
+
+
+      notify;
+
+    will still generate a notification.  The denotify does not cancel
+    the notify.
+
+    The following table shows which notifies would get cancelled:
+
+                                        # what is cancelled
+      denotify                          # all notifications
+      denotify :matches "*"             # all notifications with :id tag
+      denotify :high                    # all high priority notifications
+      denotify :is "foobar"             # all notifications with id "foobar"
+      denotify :matches "foo*" :normal  # all normal priority notifications
+                                        #   with id that starts with "foo"
+
+    Example:
+             require "notify";
+
+             notify :method "sms" :options "408-555-1212" :id "foobar";
+             if header :contains "from" "boss@example.org" {
+                notify :method "sms" :options "408-555-1212" :id "foobar" :high
+                       :message "BOSS: $subject$";
+             }
+
+             if header :contains "to" "sievemailinglist@example.org" {
+                denotify :is "foobar";
+             }
+
+             if header :contains "subject" "FYI:" {
+                # don't need high priority notification for
+                # a 'for your information'
+                denotify :is "foobar" :high;
+             }
+
+
+
+
+4.  Interaction with Other Sieve Actions
+
+    Notifications MUST be sent in all cases, unless a reject action is
+    also executed. Users may wish to be notified of a message being
+    discarded, for example. The reject action is given an exception
+    because implementations may wish to restrict users from seeing the
+    contents of a rejected message. However, notifications MAY be
+    modified to not include any data from the original rejected message.
+
+    The notify action MUST NOT cancel the implicit keep.
+
+
+
+
+Expires December 6, 2001        Martin                          [Page 6]
+
+Internet Draft      Sieve -- Notifications extension        June 1, 2001
+
+
+    The denotify action MUST NOT affect any actions other than the
+    notify action.
+
+    Failures of other actions MAY be reported in the notification.
+
+
+
+
+
+5.  Security Considerations
+
+    Security considerations are discussed in [SIEVE]. Additionally
+    implementations must be careful to follow the security
+    considerations of the specific notification methods. It is believed
+    that this extension does not introduce any additional security
+    concerns.
+
+    The notify action is potentially very dangerous.  The path the
+    notification takes through the network may not be secure.  An error
+    in the options string may cause the message to be transmitted to
+    someone it was not intended for.
+
+    Just because a notification is received doesn't mean it was sent by
+    the sieve implementation.  It might be possible to forge
+    notifications with some notification methods.
+
+
+6.  Acknowledgments
+
+    Thanks to Larry Greenfield, Sarah Robeson, Tim Showalter, and Barry
+    Leiba for help with this document.
+
+
+
+7.  Copyright
+
+    Copyright (C) The Internet Society 1999. All Rights Reserved.
+
+    This document and translations of it may be copied and furnished to
+    others, and derivative works that comment on or otherwise explain it
+    or assist in its implementation may be prepared, copied, published
+    and distributed, in whole or in part, without restriction of any
+    kind, provided that the above copyright notice and this paragraph
+    are included on all such copies and derivative works.  However, this
+    document itself may not be modified in any way, such as by removing
+    the copyright notice or references to the Internet Society or other
+    Internet organizations, except as needed for the purpose of
+    developing Internet standards in which case the procedures for
+
+
+
+Expires December 6, 2001        Martin                          [Page 7]
+
+Internet Draft      Sieve -- Notifications extension        June 1, 2001
+
+
+    copyrights defined in the Internet Standards process must be
+    followed, or as required to translate it into languages other than
+    English.
+
+    The limited permissions granted above are perpetual and will not be
+    revoked by the Internet Society or its successors or assigns.
+
+    This document and the information contained herein is provided on an
+    "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
+    TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
+    BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
+    HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
+    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
+
+
+8.  References
+
+    [ABNF] Crocker, Overell, "Augmented BNF for Syntax Specifications:
+    ABNF", RFC 2234, Internet Mail Consortium, Demon Internet Ltd,
+    November 1997.
+
+    [SIEVE]; Showalter, T.; "Sieve: A Mail Filtering Language"; RFC
+    3028; Mirapoint, Inc.; January 2001
+
+
+9.  Author's Addresses
+
+    Tim Martin
+    Mirapoint Inc.
+    909 Hermosa Court
+    Sunnyvale, CA 94085
+
+    Phone: (408) 720-3835
+    EMail: tmartin@mirapoint.com
+
+    Wolfgang Segmuller
+    IBM T.J. Watson Research Center
+    30 Saw Mill River Rd
+    Hawthorne, NY  10532
+
+    Phone: (914) 784-7408
+    Email: whs@watson.ibm.com
+
+
+
+
+
+
+
+
+
+Expires December 6, 2001        Martin                          [Page 8]
+
diff -urN dovecot-1.2.4/dovecot-libsieve/doc/rfc/deprecated/draft-melnikov-sieve-imapflags-03.txt dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/deprecated/draft-melnikov-sieve-imapflags-03.txt
--- dovecot-1.2.4/dovecot-libsieve/doc/rfc/deprecated/draft-melnikov-sieve-imapflags-03.txt	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/deprecated/draft-melnikov-sieve-imapflags-03.txt	2000-07-24 17:42:00.000000000 +0200
@@ -0,0 +1,426 @@
+Network Working Group                                       
+Internet Draft: Sieve -- IMAP flag Extension                 A. Melnikov
+Document: draft-melnikov-sieve-imapflags-03.txt   Messaging Direct, Ltd.
+Expires: January 2001                                          July 2000
+
+
+                      Sieve -- IMAP flag Extension
+
+
+Status of this memo
+
+   This document is an Internet-Draft and is in full conformance with
+   all provisions of Section 10 of RFC2026.  Internet-Drafts are
+   working documents of the Internet Engineering Task Force (IETF), its
+   areas, and its working groups.  Note that other groups may also
+   distribute working documents as Internet-Drafts.
+
+   Internet-Drafts are draft documents valid for a maximum of six
+   months and may be updated, replaced, or obsoleted by other documents
+   at any time.  It is inappropriate to use Internet- Drafts as
+   reference material or to cite them other than as "work in progress."
+
+  
+     The list of current Internet-Drafts can be accessed at
+     http://www.ietf.org/ietf/1id-abstracts.txt
+
+     The list of Internet-Draft Shadow Directories can be accessed at
+     http://www.ietf.org/shadow.html.
+
+   The protocol discussed in this document is experimental and subject
+   to change.  Persons planning on either implementing or  using  this
+   protocol  are STRONGLY URGED to get in touch with the author before
+   embarking on such a project.
+
+Copyright
+
+   Copyright (C) The Internet Society 2000.  All Rights Reserved.
+
+Abstract
+
+   Recent discussions   have  shown  that  it  is  desirable  to  set
+   different [IMAP] flags on message delivery.  This can be done, for
+   example, by a SIEVE interpreter that works as a part of a Mail Delivery
+   Agent.
+
+   This document describes an extension to the  Sieve  mail  filtering
+   language for setting [IMAP] flags. The extension allows to set both 
+   [IMAP] system flags and [IMAP] keywords.
+
+
+0. Meta-information on this draft
+
+   This information  is intended to facilitate discussion.  It will be
+   removed when this document leaves the Internet-Draft stage.
+
+
+0.1. Discussion
+
+   This draft is intended to be compared with the Sieve mail filtering
+   language,  an  Internet-Draft  being  discussed  on the MTA Filters
+   mailing list at <ietf-mta-filters@imc.org>.  Subscription  requests
+   can  be  sent  to <ietf-mta-filters-request@imc.org> (send an email
+   message with the word "subscribe" in the body). More information on
+   the  mailing  list  along  with  a  WWW archive of back messages is
+   available at <http://www.imc.org/ietf-mta-filters/>.
+
+
+0.2. Changes from the version submitted to the SIEVE mailing list
+
+   1. Added addflag and removeflag actions
+
+   2. Changed the semantics of setflag (setflag is not additive any more)
+
+   3. Corrected   section  "Interaction  with  Other  Sieve  Actions".
+      Removed incorrect reference to  the  forward  action  as  to  an
+      action that prohibits setflag.
+
+   4. Added  paragraph  about  the  mutual  order of fileinto/keep and
+      setflag/addflag/removeflag actions.
+
+
+0.3. Changes from the revision 00
+
+   1. Corrected Capability Identifier section (Section 2)
+
+   2. Corrected "Interaction with Other Sieve Actions" section (Section 4)
+
+   3. Examples were updated to be compatible with Sieve-07 draft
+
+   4. Added "mark" and "unmark" actions
+
+
+0.4. Changes from the revision 01
+
+   1. Some language fixes based on Tony Hansen comments
+
+   2. Clarified that the extension allows to set both IMAP System Flags and Keywords
+
+
+0.5. Changes from the revision 02
+
+   1. BugFix: all backslashes must be escaped
+
+   2. Added extended example and more detailed description of addflag/removeflag additivity.
+
+   3. Minor example bugfixes
+
+
+1. Introduction
+
+   This is  an  extension to the Sieve language defined by [SIEVE] for
+   setting [IMAP] flags.  It defines several  new  actions  "setflag",
+   "addflag", "removeflag", "mark" and "unmark".
+
+   This document  doesn't dictate how the SIEVE interpreter will set the [IMAP]
+   flags. In particular, the SIEVE interpreter may work as an IMAP client,
+   or may have direct access to the mailstore.
+
+   SIEVE interpreters  that  don't  support  integration  with IMAP
+   SHOULD ignore this extension.
+
+   Conventions for notations are as in [SIEVE] section 1.1,  including
+   use of [KEYWORDS].
+
+
+2. Capability Identifier
+
+   The capability string associated with extension defined in this document
+   is "imapflags".
+
+
+3. Actions
+
+   All actions described in this specification (setflag, addflag, removeflag,
+   mark, unmark) operate on an internal variable that contains the set of [IMAP] flags
+   associated with the message being delivered. When the interpreter starts executing
+   a script this variable contains an empty set. The 'addflag' action adds flags
+   to the existing set. The 'removeflag' action removes flags from the existing set. 
+   The 'setflag' action replaces the existing set of flags with a new set. 
+   Whenever the interpreter encounters a 'fileinto' or 'keep' action it files
+   the message with the current set of flags.
+
+
+3.1. Setflag Action
+
+   Syntax:   setflag <list-of-flags>
+
+   Setflag is used for setting  [IMAP]  system flags or keywords. Setflag
+   replaces  any previously  set  flags.  It  should  be  used together with keep
+   or fileinto.  It MUST be ignored  if  mailstore or target mailbox doesn't
+   support  the storing of any flags.
+
+   Flags can  be  set  only for the message that is currently being processed by
+   SIEVE.  When called with keep,  setflag sets flags in  the user's  main
+   mailbox.  When  called  with  fileinto,  setflag  sets flags in the
+   mailbox indicated by the parameter.
+
+   The order of setflag/fileinto or setflag/keep is important  in  the
+   script. Any setflag action applies only to subsequent fileinto/keep
+   actions in a script till next occurence of setflag/addflag/removeflag/mark/unmark.
+
+   Server MUST ignore all flags that it can't store permanently.  This
+   means,  in  particular,  that if the user's main mailbox can't store any
+   flags, then the following SIEVE script produces no actions
+
+      Example:  if size :over 500K {
+                    setflag "\\Deleted";
+                }
+
+   A more substantial example is:
+
+      Example:
+        if header :contains "from" "boss@frobnitzm.edu" {
+          setflag "\\Flagged";
+          fileinto "INBOX.From Boss";
+        }
+
+
+3.2. Addflag action
+
+   Syntax:   addflag <list-of-flags>
+
+   Addflag is used for setting [IMAP] flags. However unlike setflag it
+   doesn't replace any previously set flags.  This means that multiple
+   occurrences of addflag are treated additively.
+
+   For example, the following two actions
+
+      addflag "\\Deleted";
+      addflag "\\Answered";
+
+   produce the same result as the single action
+
+      addflag ["\\Deleted", "\\Answered"];
+
+   In all other  respects  addflag  behaves  the  same  way  as
+   setflag.
+
+
+3.3. Removeflag Action
+
+   Syntax:   removeflag <list-of-flags>
+
+   Removeflag is used for  setting  [IMAP]  flags.  Removeflag  clears
+   flags previously set by setflag/addflag.  Calling removeflag with a
+   flag that wasn't set before is not an error and is ignored.
+   Multiple occurrences of removeflag are treated additively.
+
+   In all other respects removeflag behaves  the  same  way  as
+   setflag.
+
+      Example:
+        if header :contains "Disposition-Notification-To" "mel@example.com" {
+          addflag "$MDNRequired";
+        }
+        if header :contains "from" "imap@cac.washington.edu" {
+          removeflag "$MDNRequired";
+          fileinto "INBOX.imap-list";
+        }
+
+
+3.4. Mark and Unmark Actions
+
+   Syntax:   mark
+
+   Syntax:   unmark
+
+   The mark action allows a message to be marked as urgent. Implementers are free
+   to choose any flag or any  combination  of  [IMAP] flags,  however  it  is
+   RECOMMENDED  that  the [IMAP]  \Flagged  flag be  used.  The mark  action is
+   semantically equivalent to 'addflag "\\Flagged"'.
+
+   The unmark action allows the flag previously  set  by  the Mark
+   action to be unset. Unmark SHOULD at least clear the [IMAP] \Flagged flag
+   and MUST clear all flags that could be added with mark.
+   Unmark MAY clear other flags as well.  The unmark action is semantically
+   equivalent to 'removeflag "\\Flagged"'.
+
+
+3.5 Extended example
+
+   #
+   # Example Sieve Filter
+   # Declare any optional features or extension used by the script
+   #
+   require ["fileinto", "reject", "imapflags"];
+
+   #
+   # Reject any large messages
+   #
+   if size :over 1M
+           {
+           if header :is "From" "boss@company.com"
+                      {
+                      addflag "\\Flagged $Big";
+   # The message will be marked as "\Flagged $Big" when filed into mailbox "Big messages"
+                      }
+           fileinto "Big messages";
+           }
+
+   if header :is "From" "grandma@example.net"
+           {
+           addflag ["\\Answered", "$MDNSent"];
+   # If the message is bigger than 1Mb it will be marked as "\Flagged $Big \Answered $MDNSent" 
+   # when filed into mailbox "grandma". If the message is shorter than 1Mb it will be marked as
+   # "\Answered $MDNSent"
+           fileinto "GrandMa";  # move to "GrandMa" folder
+           }
+
+   #
+   # Handle messages from known mailing lists
+   # Move messages from IETF filter discussion list to filter folder
+   #
+   if header :is "Sender" "owner-ietf-mta-filters@imc.org"
+           {
+           setflag "\\Flagged";
+   # Message will always have just "\Flagged" flag
+           keep;
+           }
+
+   #
+   # Keep all messages to or from people in my company
+   #
+   elsif anyof address :domain :is ["From", "To"] "company.com"
+           {
+           keep;               # keep in "In" folder
+           }
+   #
+   # Try and catch unsolicited email.  If a message is not to me,
+   # or it contains a subject known to be spam, file it away.
+   #
+   elsif anyof (not address :all :contains
+                  ["To", "Cc", "Bcc"] "me@company.com",
+                header :matches "subject"
+                  ["*make*money*fast*", "*university*dipl*mas*"])
+           {
+           removeflag "\\Flagged";
+           # If message header does not contain my address,
+           # it's from a list.
+           fileinto "spam";   # move to "spam" folder
+           }
+   else
+           {
+           # Move all other (non-company) mail to "personal"
+           # folder.
+           fileinto "personal";
+           }
+
+
+
+4. Interaction with Other Sieve Actions
+
+   Sieve actions sometimes  prohibit  each  other  in  order  to  make
+   filtering scripts less likely to cause serious problems.
+
+   It is   strongly   discouraged  to  use setflag/addflag/removeflag/mark/unmark
+   actions together with reject,  because  that  action doesn't allow keeping  a
+   received message.
+
+   The SIEVE interpreter  MUST  ignore any setflag/addflag/removeflag/mark/unmark
+   commands when they are used  with  reject. The SIEVE interpreter MUST ignore these
+   commands when no keep (implicit or explicit) or fileinto actions will be taken.
+
+   A SIEVE verifier SHOULD reject a script that contains a
+   setflag/addflag/removeflag/mark/unmark action together with  reject.
+
+
+5. Other Considerations
+
+   This extension intentionally doesn't allow setting [IMAP] flags  on an
+   arbitrary message in the [IMAP] message store.
+
+
+6. Security Considerations
+
+   Security considerations are discussed in the [IMAP] and [SIEVE].
+   It is belived that this  extension  doesn't  introduce any
+   additional security concerns.
+
+
+7. Formal Grammar
+
+   The grammar used in this section is the same as the ABNF described in
+   [ABNF].
+
+   action =/ setflag / addflag / removeflag / mark / unmark
+
+   setflag = "setflag" WSP string-list
+     ;; a list of [IMAP] flags
+
+   addflag = "addflag" WSP string-list
+     ;; a list of [IMAP] flags
+
+   removeflag = "removeflag" WSP string-list
+     ;; a list of [IMAP] flags
+
+   mark = "mark"
+
+   unmark = "unmark"
+
+
+8.  Acknowledgments
+
+    This document has been revised in part based on comments and
+    discussions which took place on and off the SIEVE mailing list.
+    The help of those who took the time to review the draft and make
+    suggestions is appreciated, especially that of Tim Showalter,
+    Barry Leiba, and Randall Gellens. Special thanks to Tony Hansen,
+    David Lamb and Roman Migal for helping me explain better the concept.
+
+
+9. Author's Address
+
+    Alexey Melnikov
+    Messaging Direct, Ltd.
+
+    Address : #900, 10117 Jasper Avenue, Edmonton, Alberta, Canada,
+    T5J1W8
+
+    Email: mel@messagingdirect.com
+
+
+Appendices
+
+Appendix A.  References
+
+   [SIEVE] Showalter, T.,  "Sieve: A Mail Filtering Language", Mirapoint,
+   Work in Progress, draft-showalter-sieve-XX.txt
+
+   [ABNF] Crocker, D.,  "Augmented BNF for Syntax Specifications: ABNF",
+   Internet Mail Consortium, RFC 2234, November, 1997.
+
+   [KEYWORDS] Bradner, S., "Key  words  for  use  in  RFCs  to  Indicate
+   Requirement Levels", Harvard University, RFC 2119, March 1997.
+
+   [IMAP] Crispin, M., "INTERNET MESSAGE ACCESS PROTOCOL - VERSION 4rev1",
+   University of Washington, RFC 2060, December 1996.
+
+
+Appendix B. Full Copyright Statement
+
+    Copyright (C) The Internet Society 2000. All Rights Reserved.
+
+    This document and translations of it may be copied and furnished to
+    others, and derivative works that comment on or otherwise explain it
+    or assist in its implementation may be prepared, copied, published
+    and distributed, in whole or in part, without restriction of any
+    kind, provided that the above copyright notice and this paragraph
+    are included on all such copies and derivative works.  However, this
+    document itself may not be modified in any way, such as by removing
+    the copyright notice or references to the Internet Society or other
+    Internet organizations, except as needed for the purpose of
+    developing Internet standards in which case the procedures for
+    copyrights defined in the Internet Standards process must be
+    followed, or as required to translate it into languages other than
+    English.
+
+    The limited permissions granted above are perpetual and will not be
+    revoked by the Internet Society or its successors or assigns.
+
+    This document and the information contained herein is provided on an
+    "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
+    TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
+    BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
+    HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
+    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
diff -urN dovecot-1.2.4/dovecot-libsieve/doc/rfc/draft-degener-sieve-multiscript-00.txt dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/draft-degener-sieve-multiscript-00.txt
--- dovecot-1.2.4/dovecot-libsieve/doc/rfc/draft-degener-sieve-multiscript-00.txt	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/draft-degener-sieve-multiscript-00.txt	2009-01-21 23:50:10.000000000 +0100
@@ -0,0 +1,244 @@
+Network Working Group                                       Jutta Degener
+Internet Draft					              Rand Wacker
+Expires: October 2003                                          April 2003
+
+
+              Sieve -- Sequential Execution of Multiple Scripts
+		  <draft-degener-sieve-multiscript-00.txt>
+
+
+Status of this memo
+
+   This document is an Internet-Draft and is subject to all
+   provisions of Section 10 of RFC2026.
+
+   Internet-Drafts are working documents of the Internet Engineering
+   Task Force (IETF), its areas, and its working groups.  Note that
+   other groups may also distribute working documents as
+   Internet-Drafts.
+
+   Internet-Drafts are draft documents valid for a maximum of six
+   months and may be updated, replaced, or obsoleted by other
+   documents at any time.  It is inappropriate to use Internet-
+   Drafts as reference material or to cite them other than as
+   "work in progress."
+
+   The list of current Internet-Drafts can be accessed at
+   http://www.ietf.org/1id-abstracts.html
+
+   The list of Internet-Draft Shadow Directories can be accessed at
+   http://www.ietf.org/shadow.html
+
+
+Abstract
+
+   This document defines sieve behavior relevant when multiple
+   scripts are executed sequentially on the same message.
+
+
+1. Introduction
+
+   E-mail messages frequently are processed by multiple agents
+   that implement nested layers of corporate policies.
+
+   For example, a provider may offer access to services that
+   perform spam- and virus filtering; a single corporation
+   may restrict e-mail to certain subdomains, or filter for
+   keywords; individual divisions within a corporation may
+   implement even more intrusive handling of e-mail messages,
+   for example by keeping a copy of all correspondence.
+   Amidst all of this, of course, users may still use sieve
+   filters to presort, redirect, or notify other accounts
+   as in the classic sieve use scenario.
+
+   In this context, it is desirable to specify an execution
+   model for sieve scripts when executed in series.  This
+   allows each layer of the mail filtering hierarchy to use
+   a separate sieve script to express its policies.
+
+
+2. Conventions used.
+
+   Conventions for notations are as in [SIEVE] section 1.1, including
+   use of [KEYWORDS] and "Syntax:" label for the definition of action
+   and tagged arguments syntax.
+
+   This document defines no sieve extensions and no capability string.
+
+
+3. Sequential Script Execution Model
+
+   When multiple scripts are executed for a message, they
+   are executed in a specific order.
+
+   Within this order, this document defines that trailing
+   scripts will be executed as long as the message is being
+   "kept", that is, as long as either an implicit or explicit
+   "keep" is in effect.
+
+   In other words, for every script but the last, "keep"
+   doesn't mean "file this message into INBOX", it means
+   "process this message with the next sieve script."
+
+
+4. Locality of script actions
+
+   This document strongly limits the effects of scripts
+   on each other.
+
+   The "require" clauses at the beginning of a script
+   only apply to this particular script, not to following
+   ones.   Different stages in the script processing
+   may support different "require" areas.  For example,
+   it is conceivable that "fileinto" is not supported
+   for a stage other than a user's private script.
+
+   The "stop;" command ends the execution of its single
+   containing script, not of scripts in general.
+
+   After one script terminates, the next script is executed
+   if an implicit or explicit "keep" is in effect.
+   (To end all script execution, a script should execute
+   "discard; stop;".)
+
+   For sieve engines that implement the "variables" extension,
+   variable state is not carried over between scripts.
+
+   For sieve engines that implement the "notify" extension,
+   the "denotify" action in one script can only cancel
+   "notify" actions from that same script.
+
+   However, if a sequence of script executions results in
+   the same message sent to the same recipient, or filed to
+   the same destination folder, more than once, an implementation
+   MAY only produce a single message, even if the commands
+   executed stem from multiple scripts.
+
+   If a sieve implementation enforces the incompatibility
+   of "reject" with other actions (a SHOULD in [SIEVE]),
+   it MUST only enforce it within one script; an action
+   in a preceding script MUST be compatible with a "reject"
+   in a later script.
+
+
+5. Script Errors
+
+   When an error occurs during processing of any of the
+   scripts, all message processing stops, and the message
+   is treated as if the final script had executed a "keep;".
+
+
+6. Security Considerations
+
+   A script executed before another script can prevent the
+   trailing script from running (by executing "discard; stop;"
+   or by encountering an error.)  This is deliberate.
+
+   Corporate filtering of employee e-mail may violate the
+   privacy expectations of employees.  However, since these
+   instances are the ones running the software that handles
+   employee e-mail to begin with, they already have the
+   technical capability to do this.
+
+
+7. Acknowledgments
+
+   Thanks to Eric Allman, Will Lee, Dowson Tong, and Chris Markle for comments.
+
+
+8. Authors' Addresses
+
+   Jutta Degener
+   Sendmail, Inc.
+   6425 Christie Ave, 4th Floor
+   Emeryville, CA 94608
+   Email: jutta@sendmail.com
+
+   Rand Wacker
+   Sendmail, Inc.
+   6425 Christie Ave, 4th Floor
+   Emeryville, CA 94608
+   Email: rand@sendmail.com
+
+
+9. Discussion
+
+   This section will be removed when this document leaves the
+   Internet-Draft stage.
+
+   This draft is intended as an extension to the Sieve mail filtering
+   language.  Sieve extensions are discussed on the MTA Filters mailing
+   list at <ietf-mta-filters@imc.org>.  Subscription  requests can
+   be sent to <ietf-mta-filters-request@imc.org> (send an email
+   message with the word "subscribe" in the body).
+
+   More information on the mailing list along with a WWW archive of
+   back messages is available at <http://www.imc.org/ietf-mta-filters/>.
+
+
+9.1 Comparison to draft-daboo-sieve-include-00
+
+   The "include" sieve extension describes a mechanism for
+   naming and combining multiple scripts.  This document doesn't
+   do that; how the sequence of scripts to be executed on a
+   message is determined is left up to the environment and likely
+   out of control of the script owner.
+
+   The "include" sieve extension creates a hierarchical
+   tree of nested scripts; this extension describes sequential,
+   not hierarchical execution.
+
+   The "include" sieve extension defines the semantics of
+   "stop" to stop all sieve execution, not just that of the
+   innermost containing script.  It adds a new "return" command
+   to explicitly end execution of a single script.
+   This document specifies that "stop" just stops a single script, 
+   and uses the redefined meaning of "keep" to regulate the
+   flow of messages through scripts.
+
+
+9.2 "require" keyword
+
+   This draft started out with a "require" keyword, "multiscript",
+   but since what it describes lies outside the domain of strict
+   sieve language behavior, I'm not sure it needs one.
+
+
+Appendices
+
+Appendix A.  References
+
+   [KEYWORDS] 	Bradner, S., "Key words for use in RFCs to Indicate
+   		Requirement Levels", RFC 2119, March 1997.
+
+   [SIEVE] 	Showalter, T.,  "Sieve: A Mail Filtering Language", RFC 3028,
+		January 2001.
+
+
+Appendix B. Full Copyright Statement
+
+    Copyright (C) The Internet Society 2002,2003. All Rights Reserved.
+
+    This document and translations of it may be copied and furnished to
+    others, and derivative works that comment on or otherwise explain it
+    or assist in its implementation may be prepared, copied, published
+    and distributed, in whole or in part, without restriction of any
+    kind, provided that the above copyright notice and this paragraph
+    are included on all such copies and derivative works.  However, this
+    document itself may not be modified in any way, such as by removing
+    the copyright notice or references to the Internet Society or other
+    Internet organizations, except as needed for the purpose of
+    developing Internet standards in which case the procedures for
+    copyrights defined in the Internet Standards process must be
+    followed, or as required to translate it into languages other than
+    English.
+
+    The limited permissions granted above are perpetual and will not be
+    revoked by the Internet Society or its successors or assigns.
+
+    This document and the information contained herein is provided on an
+    "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
+    TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
+    BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
+    HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
+    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
diff -urN dovecot-1.2.4/dovecot-libsieve/doc/rfc/draft-duerst-mailto-bis-05.txt dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/draft-duerst-mailto-bis-05.txt
--- dovecot-1.2.4/dovecot-libsieve/doc/rfc/draft-duerst-mailto-bis-05.txt	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/draft-duerst-mailto-bis-05.txt	2008-12-09 17:43:27.000000000 +0100
@@ -0,0 +1,1064 @@
+
+
+
+Network Working Group                                          M. Duerst
+Internet-Draft                                  Aoyama Gakuin University
+Obsoletes: 2368 (if approved)                                L. Masinter
+Intended status: Standards Track              Adobe Systems Incorporated
+Expires: August 28, 2008                                     J. Zawinski
+                                                              DNA Lounge
+                                                       February 25, 2008
+
+
+                        The 'mailto' URI Scheme
+                       draft-duerst-mailto-bis-05
+
+Status of this Memo
+
+   By submitting this Internet-Draft, each author represents that any
+   applicable patent or other IPR claims of which he or she is aware
+   have been or will be disclosed, and any of which he or she becomes
+   aware will be disclosed, in accordance with Section 6 of BCP 79.
+
+   Internet-Drafts are working documents of the Internet Engineering
+   Task Force (IETF), its areas, and its working groups.  Note that
+   other groups may also distribute working documents as Internet-
+   Drafts.
+
+   Internet-Drafts are draft documents valid for a maximum of six months
+   and may be updated, replaced, or obsoleted by other documents at any
+   time.  It is inappropriate to use Internet-Drafts as reference
+   material or to cite them other than as "work in progress."
+
+   The list of current Internet-Drafts can be accessed at
+   http://www.ietf.org/ietf/1id-abstracts.txt.
+
+   The list of Internet-Draft Shadow Directories can be accessed at
+   http://www.ietf.org/shadow.html.
+
+   This Internet-Draft will expire on August 28, 2008.
+
+Copyright Notice
+
+   Copyright (C) The IETF Trust (2008).
+
+Abstract
+
+   This document defines the format of Uniform Resource Identifiers
+   (URI) to identify resources that are reached using Internet mail.  It
+   adds better internationalization and compatibility with IRIs (RFC
+   3987) to the previous syntax of 'mailto' URIs (RFC 2368).
+
+
+
+
+Duerst, et al.           Expires August 28, 2008                [Page 1]
+
+Internet-Draft           The 'mailto' URI Scheme           February 2008
+
+
+Table of Contents
+
+   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3
+   2.  Syntax of a mailto URI . . . . . . . . . . . . . . . . . . . .  3
+   3.  Semantics and Operations . . . . . . . . . . . . . . . . . . .  6
+   4.  Unsafe Header Fields . . . . . . . . . . . . . . . . . . . . .  6
+   5.  Encoding . . . . . . . . . . . . . . . . . . . . . . . . . . .  7
+   6.  Deployment of UTF-8-Based Percent-Encoding . . . . . . . . . .  7
+   7.  Examples . . . . . . . . . . . . . . . . . . . . . . . . . . .  8
+     7.1.  Examples Conforming to RFC2368 . . . . . . . . . . . . . .  8
+     7.2.  Examples of Complicated Email Addresses  . . . . . . . . .  9
+     7.3.  Examples Using UTF-8-Based Percent-Encoding  . . . . . . . 10
+   8.  Security Considerations  . . . . . . . . . . . . . . . . . . . 11
+   9.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 12
+     9.1.  Registration of the Body Header Field  . . . . . . . . . . 13
+   10. Main Changes from RFC 2368 . . . . . . . . . . . . . . . . . . 13
+   11. Change Log . . . . . . . . . . . . . . . . . . . . . . . . . . 14
+     11.1. Changes between draft 04 and draft 05  . . . . . . . . . . 14
+     11.2. Changes between draft 03 and draft 04  . . . . . . . . . . 14
+     11.3. Changes between draft 02 and draft 03  . . . . . . . . . . 15
+     11.4. Changes between draft 01 and draft 02  . . . . . . . . . . 15
+     11.5. Changes between draft 00 and draft 01  . . . . . . . . . . 15
+     11.6. Changes from RFC 2368  . . . . . . . . . . . . . . . . . . 16
+   12. Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 16
+   13. References . . . . . . . . . . . . . . . . . . . . . . . . . . 16
+     13.1. Normative References . . . . . . . . . . . . . . . . . . . 16
+     13.2. Informative References . . . . . . . . . . . . . . . . . . 17
+   Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . . . 17
+   Intellectual Property and Copyright Statements . . . . . . . . . . 19
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Duerst, et al.           Expires August 28, 2008                [Page 2]
+
+Internet-Draft           The 'mailto' URI Scheme           February 2008
+
+
+1.  Introduction
+
+   The 'mailto' URI scheme is used to identify resources that are
+   reached using Internet mail.  In its simplest form, a 'mailto' URI
+   contains an Internet mail address.  For interactions that require
+   message headers or message bodies to be specified, the 'mailto' URI
+   scheme also allows setting mail header fields and the message body.
+
+   This specification extends the previous scheme definition to also
+   allow character data to be percent-encoded based on UTF-8, which
+   offers a better and more consistent way of dealing with non-ASCII
+   characters for internationalization.
+
+   This specification does not address the needs of the ongoing Email
+   Address Internationalization effort (see [RFC4952]).  In particular,
+   this specification does not include syntax for fallback addresses.
+   This may be fixed in a future version of this specification.
+
+   In this document, the key words "MUST", "MUST NOT", "REQUIRED",
+   "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
+   and "OPTIONAL" are to be interpreted as described in [RFC2119].
+
+   In this document, URIs are enclosed in '<' and '>' as described in
+   Appendix C of [STD66].  Extra whitespace and line breaks added to
+   present long URIs are not part of the actual URI.
+
+
+2.  Syntax of a mailto URI
+
+   The syntax of a 'mailto' URI is described using the ABNF of [STD68],
+   non-terminal definitions from [RFC2822] (domain, dot-atom, quoted-
+   string) and non-terminal definitions from [STD66] (unreserved, pct-
+   encoded):
+
+      mailtoURI   = "mailto:" [ to ] [ hfields ]
+      to          = [ addr-spec *("%2C" addr-spec ) ]
+      hfields     = "?" hfield *( "&" hfield )
+      hfield      = hfname "=" hfvalue
+      hfname      = *qchar
+      hfvalue     = *qchar
+      addr-spec   = local-part "@" domain
+      local-part  = dot-atom / quoted-string
+      qchar       = unreserved / pct-encoded / some-delims
+      some-delims = "!" / "$" / "'" / "(" / ")" / "*"
+                  / "+" / "," / ";" / ":" / "@"
+
+   <addr-spec> is a mail address as specified in [RFC2822], but
+   excluding <comment> from [RFC2822].  However, the following changes
+
+
+
+Duerst, et al.           Expires August 28, 2008                [Page 3]
+
+Internet-Draft           The 'mailto' URI Scheme           February 2008
+
+
+   apply:
+
+   1.  A number of characters that can appear in <addr-spec> have to be
+       percent-encoded.  These are the characters that cannot appear in
+       an URI according to [STD66] as well as "%" (because it is used
+       for percent-encoding) and all the characters in gen-delims except
+       "@" (i.e. "/", "?", "#", "[" and "]").  Of the characters in sub-
+       delims, at least the following also have to be percent-encoded:
+       "&", ";", and "=".  Care has to be taken both when encoding as
+       well as when decoding to make sure these operations are applied
+       only once.
+
+   2.  <obs-local-part> and <NO-WS-CTL> as defined in [RFC2822] are not
+       allowed.
+
+   3.  Whitespace and comments within <local-part> and <domain> are not
+       allowed.  They would not have any operational semantics.
+
+   4.  Percent-encoding can be used in the <domain> part of an <addr-
+       spec>, in order to denote an internationalized domain name.  The
+       considerations for <reg-name> in [STD66] apply.  In particular,
+       non-ASCII characters must first be encoded according to UTF-8
+       [STD63], and then each octet of the corresponding UTF-8 sequence
+       must be percent-encoded to be represented as URI characters.  URI
+       producing applications must not use percent-encoding in domain
+       names unless it is used to represent a UTF-8 character sequence.
+       When the internationalized domain name is used to compose a
+       message, the name must be transformed to the IDNA encoding where
+       appropriate [RFC3490].  URI producers should provide these domain
+       names in the IDNA encoding, rather than percent-encoded, if they
+       wish to maximize interoperability with legacy 'mailto' URI
+       interpreters.
+
+   5.  Percent-encoding of non-ASCII octets in the <local-part> of an
+       <addr-spec> is reserved for the internationalization of the
+       <local-part>.  Non-ASCII characters must first be encoded
+       according to UTF-8 [STD63], and then each octet of the
+       corresponding UTF-8 sequence must be percent-encoded to be
+       represented as URI characters.  Any other percent-encoding of
+       non-ASCII characters is prohibited.  When a <local-part>
+       containing non-ASCII characters will be used to compose a
+       message, the <local-part> must be transformed to conform to
+       whatever encoding may be defined in a future specification for
+       the internationalization of email addresses.
+
+   <hfname> and <hfvalue> are encodings of an [RFC2822] header field
+   name and value, respectively.  Percent-encoding is needed for the
+   same characters as listed above for <addr-spec>. <hfname> is case-
+
+
+
+Duerst, et al.           Expires August 28, 2008                [Page 4]
+
+Internet-Draft           The 'mailto' URI Scheme           February 2008
+
+
+   insensitive, but <hfvalue> in general is case-sensitive.
+
+   The special <hfname> "body" indicates that the associated <hfvalue>
+   is the body of the message.  The "body" field value should contain
+   the content for the first text/plain body part of the message.  The
+   "body" pseudo header field is primarily intended for the generation
+   of short text messages for automatic processing (such as "subscribe"
+   messages for mailing lists), not for general MIME bodies.  The "body"
+   pseudo header field name has been registered with IANA for this
+   special purpose, see Section 9.1.
+
+   Within 'mailto' URIs, the characters "?", "=", and "&" are reserved.
+
+   Because the "&" (ampersand) character is reserved in HTML and XML,
+   any 'mailto' URI which contains an ampersand must be spelled
+   differently in HTML and XML than in other contexts.  A 'mailto' URI
+   which appears in an HTML or XML document must escape the "&", e.g. as
+   "&amp;".
+
+   Non-ASCII characters can be encoded in hfvalue as follows:
+
+   1.  MIME encoded words (as defined in [RFC2047]) are permitted in
+       header field values, but not in an <hfvalue> of a "body"
+       <hfname>.
+
+   2.  Non-ASCII characters can be encoded according to UTF-8 [STD63],
+       and then each octet of the corresponding UTF-8 sequence is
+       percent-encoded to be represented as URI characters.  When header
+       field values encoded in this way are used to compose a message,
+       the <hfvalue> must be transformed into MIME encoded words
+       [RFC2047], except for an <hfvalue> of a "body" <hfname>, which
+       has to be encoded according to [RFC2045].  Please note that for
+       MIME encoded words and for bodies in composed email messages,
+       encodings other than UTF-8 MAY be used as long as the characters
+       are properly transcoded.
+
+   MIME encoded words and UTF-8-based percent-encoding SHOULD NOT both
+   be used sequentially in the same <hfvalue>, and MUST NOT be combined.
+
+   Also note that it is legal to specify both <to> and an <hfname> whose
+   value is "to".  That is,
+
+   <mailto:addr1@an.example%2C%20addr2@an.example>
+
+   is equivalent to
+
+   <mailto:?to=addr1@an.example%2C%20addr2@an.example>
+
+
+
+
+Duerst, et al.           Expires August 28, 2008                [Page 5]
+
+Internet-Draft           The 'mailto' URI Scheme           February 2008
+
+
+   is equivalent to
+
+   <mailto:addr1@an.example?to=addr2@an.example>
+
+   However, the latter form is NOT RECOMMENDED.  Implementations should
+   be careful not to produce two "To:" header fields in a message; the
+   "To:" header field may occur at most once in a message ([RFC2822],
+   Section 3.6).  Also, creators of 'mailto' URIs should be careful to
+   not include other message header fields multiple times if these
+   header fields can only be used once in a message.
+
+   Creators of 'mailto' URIs SHOULD avoid using the same <hfname>
+   multiple times in the same URI to avoid interoperability problems.
+   If the same <hfname> appears multiple times in an URI, behavior
+   varies widely for different user agents, and for each <hfname>.
+   Examples include only using the first or last <hfname>/<hfvalue>
+   pair, combining each <hfvalue> by simple concatenation, or in a way
+   appropriate for the corresponding header field, or creating multiple
+   header fields.
+
+
+3.  Semantics and Operations
+
+   A 'mailto' URI designates an "internet resource", which is the
+   mailbox specified in the address.  When additional header fields are
+   supplied, the resource designated is the same address, but with an
+   additional profile for accessing the resource.  While there are
+   Internet resources that can only be accessed via electronic mail, the
+   'mailto' URI is not intended as a way of retrieving such objects
+   automatically.
+
+   In current practice, resolving URIs such as those in the 'http' URI
+   scheme causes an immediate interaction between client software and a
+   host running an interactive server.  The 'mailto' URI has unusual
+   semantics because resolving such a URI does not cause an immediate
+   interaction.  Instead, the client creates a message to the designated
+   address with the various header fields set as default.  The user can
+   edit the message, send this message unedited, or choose not to send
+   the message.  The operation of how any URI scheme is resolved is not
+   mandated by the URI specifications.
+
+
+4.  Unsafe Header Fields
+
+   The user agent interpreting a 'mailto' URI SHOULD choose not to
+   create a message if any of the header fields are considered
+   dangerous; it may also choose to create a message with only a subset
+   of the header fields given in the URI.  Only a limited set of header
+
+
+
+Duerst, et al.           Expires August 28, 2008                [Page 6]
+
+Internet-Draft           The 'mailto' URI Scheme           February 2008
+
+
+   fields such as Subject and Keywords, as well as Body, are believed to
+   be both safe and useful in the general case.  In cases where the
+   source of an URI is well known, and/or specific header fields are
+   limited to specific well-known values, other header fields may be
+   considered safe, too.
+
+   The creator of a 'mailto' URI cannot expect the resolver of a URI to
+   understand more than the "subject" header field and "body".  Clients
+   that resolve 'mailto' URIs into mail messages MUST be able to
+   correctly create [RFC2822]-compliant mail messages using the
+   "subject" header field and "body".
+
+
+5.  Encoding
+
+   [STD66] requires that many characters in URIs be encoded.  This
+   affects the 'mailto' URI scheme for some common characters that might
+   appear in addresses, header fields, or message contents.  One such
+   character is space (" ", ASCII hex 20).  Note the examples below that
+   use "%20" for space in the message body.  Also note that line breaks
+   in the body of a message MUST be encoded with "%0D%0A".
+
+   People creating 'mailto' URIs must be careful to encode any reserved
+   characters that are used in the URIs so that properly-written URI
+   interpreters can read them.  Also, client software that reads URIs
+   must be careful to decode strings before creating the mail message so
+   that the mail messages appear in a form that the recipient software
+   will understand.  These strings should be decoded before showing the
+   message to the sending user.
+
+   Software creating 'mailto' URIs likewise has to be careful to encode
+   any reserved characters that are used.  One kind of software creating
+   'mailto' URIs are HTML forms.  Current implementations encode a space
+   as '+', but this creates problems because such a '+' standing for a
+   space cannot be distinguished from a real '+' in a 'mailto' URI.
+   When producing 'mailto' URIs, all spaces SHOULD be encoded as %20.
+
+   The 'mailto' URI scheme is limited in that it does not provide for
+   substitution of variables.  Thus, a message body that must include a
+   user's email address cannot be encoded using the 'mailto' URI.  This
+   limitation also prevents 'mailto' URIs that are signed with public
+   keys and other such variable information.
+
+
+6.  Deployment of UTF-8-Based Percent-Encoding
+
+   UTF-8-based percent-encoding should only be used in actual 'mailto'
+   URIs once it is well deployed in software that interprets 'mailto'
+
+
+
+Duerst, et al.           Expires August 28, 2008                [Page 7]
+
+Internet-Draft           The 'mailto' URI Scheme           February 2008
+
+
+   URIs (such as mail user agents).
+
+
+7.  Examples
+
+7.1.  Examples Conforming to RFC2368
+
+   A URI for an ordinary individual mailing address:
+
+   <mailto:chris@example.com>
+
+   A URI for a mail response system that requires the name of the file
+   in the subject:
+
+   <mailto:infobot@example.com?subject=current-issue>
+
+   A mail response system that requires a "send" request in the body:
+
+   <mailto:infobot@example.com?body=send%20current-issue>
+
+   A similar URI, with two lines with different "send" requests (in this
+   case, "send current-issue" and, on the next line, "send index"):
+
+   <mailto:infobot@
+   example.com?body=send%20current-issue%0D%0Asend%20index>
+
+   An interesting use of 'mailto' URIs occurs when browsing archives of
+   messages.  A link can be provided that allows to reply to a message
+   and conserve threading information.  This is done by adding a In-
+   Reply-To header field containing the Message-ID of the message where
+   the link is added, for example:
+
+   <mailto:list@example.org?In-Reply-To=%3C3469A91.D10AF4C@
+   example.com%3E>
+
+   A request to subscribe to a mailing list:
+
+   <mailto:majordomo@example.com?body=subscribe%20bamboo-l>
+
+   A URI for a single user which includes a CC of another user:
+
+   <mailto:joe@example.com?cc=bob@example.com&body=hello>
+
+   Note the use of the "&" reserved character above.  The following
+   example, using "?" twice, is incorrect:
+
+   <mailto:joe@example.com?cc=bob@example.com?body=hello> ; WRONG!
+
+
+
+
+Duerst, et al.           Expires August 28, 2008                [Page 8]
+
+Internet-Draft           The 'mailto' URI Scheme           February 2008
+
+
+   According to [RFC2822], the characters "?", "&", and even "%" may
+   occur in addr-specs.  The fact that they are reserved characters is
+   not a problem: those characters may appear in 'mailto' URIs, they
+   just may not appear in unencoded form.  The standard URI encoding
+   mechanisms ("%" followed by a two-digit hex number) must be used in
+   these cases.
+
+   To indicate the address "gorby%kremvax@example.com" one would use:
+
+   <mailto:gorby%25kremvax@example.com>
+
+   To indicate the address "unlikely?address@example.com", and include
+   another header field, one would use:
+
+   <mailto:unlikely%3Faddress@example.com?blat=foop>
+
+   As described above, the "&" (ampersand) character is reserved in HTML
+   and must be replaced e.g. with "&amp;".  Thus, a URI with an internal
+   ampersand might look like:
+
+   Click <a href="mailto:joe@an.example?cc=bob@
+   an.example&amp;body=hello">mailto:joe@an.example?cc=bob@
+   an.example&amp;body=hello</a> to send a greeting message to Joe and
+   Bob.
+
+   When an email address itself includes an "&" (ampersand) character,
+   that character has to be percent-escaped.  For example, the 'mailto'
+   URI to send mail to "Mike&family@example.org" is
+   <mailto:Mike%26family@example.org>.
+
+7.2.  Examples of Complicated Email Addresses
+
+   Following are a few examples of how to treat email addresses that
+   contain complicated escaping syntax.
+
+   Email address: "not@me"@example.org; corresponding 'mailto' URI:
+
+   <mailto:%22not%40me%22@example.org>.
+
+   Email address: "oh\\no"@example.org; corresponding 'mailto' URI:
+
+   <mailto:%22oh%5C%5Cno%22@example.org>.
+
+   Email address: "\\\"it's\ ugly\\\""@example.org; corresponding
+   'mailto' URI:
+
+   <mailto:%22%5C%5C%5C%22it's%22%20ugly%5C%5C%5C%22%22@example.org>.
+
+
+
+
+Duerst, et al.           Expires August 28, 2008                [Page 9]
+
+Internet-Draft           The 'mailto' URI Scheme           February 2008
+
+
+7.3.  Examples Using UTF-8-Based Percent-Encoding
+
+   Sending a mail with the subject "coffee" in French, i.e. "cafe" where
+   the final e is an e-acute, using UTF-8 and percent-encoding:
+
+   <mailto:user@example.org?subject=caf%C3%A9>
+
+   The same subject, this time using an encoded-word (escaping the "="
+   and "?" characters used in the encoded-word syntax, because they are
+   reserved):
+
+   <mailto:user@
+   example.org?subject=%3D%3Futf-8%3FQ%3Fcaf%3DC3%3DA9%3F%3D>
+
+   The same subject, this time encoded as iso-8859-1:
+
+   <mailto:user@
+   example.org?subject=%3D%3Fiso-8859-1%3FQ%3Fcaf%3DE9%3F%3D>
+
+   Going back to straight UTF-8 and adding a body with the same value:
+
+   <mailto:user@example.org?subject=caf%C3%A9&body=caf%C3%A9>
+
+   This 'mailto' URI may result in a message looking like this:
+
+      From: sender@example.net
+      To: user@example.org
+      Subject: =?utf-8?Q?caf=C3=A9?=
+      Content-Type: text/plain;charset=utf-8
+      Content-Transfer-Encoding: quoted-printable
+
+      caf=C3=A9
+
+   The software sending the email is not restricted to UTF-8, but can
+   use other encodings.  The following shows the same email using iso-
+   8859-1 two times:
+
+      From: sender@example.net
+      To: user@example.org
+      Subject: =?iso-8859-1?Q?caf=E9?=
+      Content-Type: text/plain;charset=iso-8859-1
+      Content-Transfer-Encoding: quoted-printable
+
+      caf=E9
+
+   Different content transfer encodings (i.e. "8bit" or "base64" instead
+   of "quoted-printable") and different encodings in encoded words (i.e.
+   "B" instead of "Q") can also be used.
+
+
+
+Duerst, et al.           Expires August 28, 2008               [Page 10]
+
+Internet-Draft           The 'mailto' URI Scheme           February 2008
+
+
+   For more examples of encoding the word coffee in different languages,
+   see [RFC2324].
+
+   The following example uses the Japanese word "natto" (Unicode
+   characters U+7D0D U+8C46) as a domain name label, sending a mail to a
+   user at "natto".example.org:
+
+   <mailto:user@%E7%B4%8D%E8%B1%86.example.org?subject=Test&body=NATTO>
+
+   When constructing the email, the domain name label is converted to
+   punycode.  The resulting message may look as follows:
+
+      From: sender@example.net
+      To: user@xn--99zt52a.example.org
+      Subject: Test
+      Content-Type: text/plain
+      Content-Transfer-Encoding: 7bit
+
+      NATTO
+
+
+8.  Security Considerations
+
+   The 'mailto' URI scheme can be used to send a message from one user
+   to another, and thus can introduce many security concerns.  Mail
+   messages can be logged at the originating site, the recipient site,
+   and intermediary sites along the delivery path.  If the messages are
+   not encoded, they can also be read at any of those sites.
+
+   A 'mailto' URI gives a template for a message that can be sent by
+   mail client software.  The contents of that template may be opaque or
+   difficult to read by the user at the time of specifying the URI.
+   Thus, a mail client should never send a message based on a 'mailto'
+   URI without first showing the full message that will be sent to the
+   user (including all header fields that were specified by the 'mailto'
+   URI), fully decoded, and asking the user for approval to send the
+   message as electronic mail.  The mail client should also make it
+   clear that the user is about to send an electronic mail message,
+   since the user may not be aware that this is the result of a 'mailto'
+   URI.
+
+   A mail client should never send anything without complete disclosure
+   to the user of what will be sent; it should disclose not only the
+   message destination, but also any header fields.  Unrecognized header
+   fields, or header fields with values inconsistent with those the mail
+   client would normally send should be especially suspect.  MIME header
+   fields (MIME- Version, Content-*) are most likely inappropriate,
+   except when added by the MUA to correctly encode the text(s) being
+
+
+
+Duerst, et al.           Expires August 28, 2008               [Page 11]
+
+Internet-Draft           The 'mailto' URI Scheme           February 2008
+
+
+   sent, as are those relating to routing (From, Apparently-To, etc.)
+
+   Note that some header fields are inherently unsafe to include in a
+   message generated from a URI.  For example, header fields such as
+   "From:", and so on, should never be interpreted from a URI.  In
+   general, the fewer header fields interpreted from the URI, the less
+   likely it is that a sending agent will create an unsafe message.
+
+   Examples of problems with sending unapproved mail include:
+
+      mail that breaks laws upon delivery, such as making illegal
+      threats;
+
+      mail that identifies the sender as someone interested in breaking
+      laws;
+
+      mail that identifies the sender to an unwanted third party;
+
+      mail that causes a financial charge to be incurred on the sender;
+
+      mail that causes an action on the recipient machine that causes
+      damage that might be attributed to the sender.
+
+   Programs that interpret 'mailto' URIs should ensure that the SMTP
+   "From" address (the SMTP envelope return path given as an argument to
+   the SMTP MAIL FROM command) is set and correct, and that the
+   resulting email is a complete, workable message.
+
+   'mailto' URIs on public Web pages expose mail addresses for
+   harvesting.  This applies to all mail addresses included in the
+   'mailto' URI, including the addresses in a "bcc" hfvalue.  Those
+   addresses will not be sent to the recipients in the 'to' field and in
+   the "to" and "cc" hfvalues, but will still be publicly visible in the
+   URI.
+
+   The security considerations of [STD66], [RFC3490], [RFC3491], and
+   [RFC3987] also apply.  Implementers and users are recommended to
+   check them carefully.
+
+
+9.  IANA Considerations
+
+   This document changes the definition of the 'mailto' URI scheme; the
+   registry of URI schemes needs to be updated to refer to this document
+   rather than its predecessor, [RFC2368].
+
+
+
+
+
+
+Duerst, et al.           Expires August 28, 2008               [Page 12]
+
+Internet-Draft           The 'mailto' URI Scheme           February 2008
+
+
+9.1.  Registration of the Body Header Field
+
+   IANA is herewith requested to register the Body header field in the
+   Message Header Fields Registry ([RFC3864]) as follows:
+
+   Header field name:
+      Body
+
+   Applicable protocol:
+      None. This registration is made to assure that this header field
+      name is not used at all, in order to not create any problems
+      for 'mailto' URIs.
+
+   Status:
+      reserved
+
+   Author/Change controller:
+      IETF
+
+   Specification document(s):
+      Internet-Draft draft-duerst-mailto-bis-05.txt
+      (Note to RFC Editor: Replace this with
+       RFC YYYY (RFC number of this specification))
+
+   Related information:
+      none
+
+
+10.  Main Changes from RFC 2368
+
+   The main changes from RFC 2368 are as follows:
+
+   o  Changed syntax from RFC 2822 <mailbox> to RFC 2822 <addr-spec>.
+
+   o  Allowed UTF-8-based percent-encoding for domain names and in
+      <hfvalue>.
+
+   o  Nailed down percent-encoding in <local-part> to be based on UTF-8,
+      reserved for future use.
+
+   o  Removed prohibition against "Bcc:" header fields, but added a
+      warning about their visibility and harvesting for spam.
+
+   o  Added clarifications for escaping.
+
+
+
+
+
+
+
+Duerst, et al.           Expires August 28, 2008               [Page 13]
+
+Internet-Draft           The 'mailto' URI Scheme           February 2008
+
+
+11.  Change Log
+
+   [RFC Editor, please remove this section before publication.]
+
+11.1.  Changes between draft 04 and draft 05
+
+   o  Added "Main Changes from RFC 2368" to help implementation updates
+      from RFC 2368.
+
+   o  Added a warning about spam harvesting and visibility of bcc
+      addresses.
+
+   o  Clarified that <addr-spec> does not include comments.
+
+   o  Changed names of syntax productions to be better in line with
+      standard terminology: headers -> hfields, header -> hfield, hname
+      -> hfname, hvalue -> hfvalue.
+
+   o  Streamlined terminology: mailto, mailto: -> 'mailto'; LHS ->
+      <local-part>; consistently used '<' and '>' for ABNF production
+      names.
+
+   o  Changed section heading from "Unsafe Headers" to "Unsafe Header
+      Fields".
+
+   o  Got rid of references and the word 'update' in the Abstract.
+
+   o  Updated ABNF reference to [STD68]
+
+   o  Some minor wording cleanup.
+
+11.2.  Changes between draft 03 and draft 04
+
+   o  Added mention of internationalization (not just IRI) to abstract.
+
+   o  Updated reference from draft-ietf-eai-framework to RFC 4952,
+      simplified referring text.
+
+   o  Used MUST for resolvers to understand Subject and Body for clear
+      interoperability.
+
+   o  Noted that multiple identical hnames can cause interoperability
+      problems and SHOULD be avoided.
+
+   o  Note the problem of '+' produced by HTML forms, made clear that
+      %20 SHOULD be used for encoding spaces.
+
+
+
+
+
+Duerst, et al.           Expires August 28, 2008               [Page 14]
+
+Internet-Draft           The 'mailto' URI Scheme           February 2008
+
+
+   o  Removed warning against using bcc; doesn't seem to be of any harm
+      if user checks explicitly.
+
+   o  Some minor wording cleanup.
+
+11.3.  Changes between draft 02 and draft 03
+
+   o  Adjusted description of mailto URI in abstract to match intro.
+
+   o  Added registration template for body header field.
+
+   o  Clarified requirements for produced email message.
+
+   o  Clarified case (in)sensitivity of header field names and values.
+
+   o  Introduced reference to EAI-framework, explained to what extent it
+      has been taken into account.
+
+   o  Changed reference label from RFC3986 to STD66.
+
+11.4.  Changes between draft 01 and draft 02
+
+   o  Fixed phone/fax for Martin.
+
+   o  Changed examples to reduce cases with both a 'to' field and a 'to'
+      hname.
+
+   o  Fixed syntax to not rely on non-terminals from RFC 2396.  Changed
+      description of set of characters that needs to be escaped.
+
+   o  Mollified warning about header fields other than Subject,
+      Keywords, and Body.
+
+   o  Clarified prohibition of mixing different encodings (%-escaping
+      and Mime encoded words) for header fields.
+
+   o  Improved some examples.  Fixed some terminology.
+
+11.5.  Changes between draft 00 and draft 01
+
+   o  Added clarification about permitted syntax and escaping on email
+      address LHS, and more complicated examples.
+
+   o  Added text about more safe headers in case origin or mailto URIs
+      is known.
+
+   o  Fixed date of [STD66]
+
+
+
+
+Duerst, et al.           Expires August 28, 2008               [Page 15]
+
+Internet-Draft           The 'mailto' URI Scheme           February 2008
+
+
+   o  Added a sentence referencing [RFC2119]
+
+   o  Added Jamie back in as a co-author.  Changed address/affiliation
+      for Martin.
+
+11.6.  Changes from RFC 2368
+
+   o  For interoperability with IRIs ([RFC3987]), allowed percent-
+      encoding, fixed to UTF-8, in the domain name part of an email
+      address, in LHS part of an address (currently reserved because not
+      operationally usable), and in hvalue parts.
+
+   o  Changed from 'URL' to 'URI'
+
+   o  Updated references: ABNF to [STD68]; message syntax to [RFC2822],
+      URI Generic Syntax to [STD66]
+
+   o  Expanded "#mailbox", because the "#" shortcut is no longer
+      available; needs checking
+
+
+12.  Acknowledgments
+
+   This document was derived from [RFC2368]; the acknowledgments from
+   this specification still apply.  In addition, we thank Paul Hoffman
+   for his work on [RFC2368].
+
+   Valuable input on this document was received from (in no particular
+   order): Paul Hoffman, Charles Lindsey, Tim Kindberg, Frank Ellermann,
+   Etan Wexler, Michael Haardt, Michael Anthony Puls II, and Alfred
+   Hoenes.
+
+
+13.  References
+
+13.1.  Normative References
+
+   [RFC2045]  Freed, N. and N. Borenstein, "Multipurpose Internet Mail
+              Extensions (MIME) Part One: Format of Internet Message
+              Bodies", November 1996.
+
+   [RFC2047]  Moore, K., "MIME Part Three: Message Header Extensions for
+              Non-ASCII Text", RFC 2047, November 1996.
+
+   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
+              Requirement Levels", BCP 14, RFC 2119, March 1997.
+
+   [RFC2822]  Resnik, P., "Internet Message Format", RFC 2822,
+
+
+
+Duerst, et al.           Expires August 28, 2008               [Page 16]
+
+Internet-Draft           The 'mailto' URI Scheme           February 2008
+
+
+              April 2001.
+
+   [RFC3490]  Faltstrom, P., Hoffman, P., and A. Costello,
+              "Internationalizing Domain Names in Applications (IDNA)",
+              RFC 3490, March 2003.
+
+   [RFC3491]  Hoffman, P. and M. Blanchet, "Nameprep: A Stringprep
+              Profile for Internationalized Domain Names (IDN)",
+              RFC 3491, March 2003.
+
+   [RFC3864]  Klyne, G., Nottingham, M., and J. Mogul, "Registration
+              Procedures for Message Header Fields", RFC 3864, BCP 90,
+              September 2004.
+
+   [RFC3987]  Duerst, M. and M. Suignard, "Internationalized Resource
+              Identifiers (IRIs)", RFC 3987, January 2005.
+
+   [STD63]    Yergeau, F., "UTF-8, a transformation format of ISO
+              10646", STD 63, RFC 3629, November 2003.
+
+   [STD66]    Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
+              Resource Identifier (URI): Generic Syntax", STD 66,
+              RFC 3986, January 2005.
+
+   [STD68]    Crocker, D. and P. Overell, "Augmented BNF for Syntax
+              Specifications: ABNF", STD 68, RFC 5234, January 2008.
+
+13.2.  Informative References
+
+   [RFC2324]  Masinter, L., "Hyper Text Coffee Pot Control Protocol
+              (HTCPCP/1.0)", RFC 2324, April 1998.
+
+   [RFC2368]  Hoffman, P., Masinter, L., and J. Zawinski, "The mailto
+              URL scheme", RFC 2368, July 1998.
+
+   [RFC4952]  Klensin, J. and Y. Ko, "Overview and Framework for
+              Internationalized Email", RFC 4952, July 2007.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Duerst, et al.           Expires August 28, 2008               [Page 17]
+
+Internet-Draft           The 'mailto' URI Scheme           February 2008
+
+
+Authors' Addresses
+
+   Martin Duerst (Note: Please write "Duerst" with u-umlaut wherever possible, for example as "D&#252;rst" in XML and HTML.)
+   Aoyama Gakuin University
+   5-10-1 Fuchinobe
+   Sagamihara, Kanagawa  229-8558
+   Japan
+
+   Phone: +81 42 759 6329
+   Fax:   +81 42 759 6495
+   Email: mailto:duerst@it.aoyama.ac.jp
+   URI:   http://www.sw.it.aoyama.ac.jp/D%C3%BCrst/
+
+
+   Larry Masinter
+   Adobe Systems Incorporated
+   345 Park Ave
+   San Jose, CA  95110
+   USA
+
+   Phone: +1-408-536-3024
+   Email: LMM@acm.org
+   URI:   http://larry.masinter.net/
+
+
+   Jamie Zawinski
+   DNA Lounge
+   375 Eleventh Street
+   San Francisco, CA  94103
+   USA
+
+   Email: jwz@jwz.org
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Duerst, et al.           Expires August 28, 2008               [Page 18]
+
+Internet-Draft           The 'mailto' URI Scheme           February 2008
+
+
+Full Copyright Statement
+
+   Copyright (C) The IETF Trust (2008).
+
+   This document is subject to the rights, licenses and restrictions
+   contained in BCP 78, and except as set forth therein, the authors
+   retain all their rights.
+
+   This document and the information contained herein are provided on an
+   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
+   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
+   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
+   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
+
+
+Intellectual Property
+
+   The IETF takes no position regarding the validity or scope of any
+   Intellectual Property Rights or other rights that might be claimed to
+   pertain to the implementation or use of the technology described in
+   this document or the extent to which any license under such rights
+   might or might not be available; nor does it represent that it has
+   made any independent effort to identify any such rights.  Information
+   on the procedures with respect to rights in RFC documents can be
+   found in BCP 78 and BCP 79.
+
+   Copies of IPR disclosures made to the IETF Secretariat and any
+   assurances of licenses to be made available, or the result of an
+   attempt made to obtain a general license or permission for the use of
+   such proprietary rights by implementers or users of this
+   specification can be obtained from the IETF on-line IPR repository at
+   http://www.ietf.org/ipr.
+
+   The IETF invites any interested party to bring to its attention any
+   copyrights, patents or patent applications, or other proprietary
+   rights that may cover technology that may be required to implement
+   this standard.  Please address the information to the IETF at
+   ietf-ipr@ietf.org.
+
+
+Acknowledgment
+
+   Funding for the RFC Editor function is provided by the IETF
+   Administrative Support Activity (IASA).
+
+
+
+
+
+Duerst, et al.           Expires August 28, 2008               [Page 19]
+
diff -urN dovecot-1.2.4/dovecot-libsieve/doc/rfc/draft-ietf-sieve-include-01.txt dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/draft-ietf-sieve-include-01.txt
--- dovecot-1.2.4/dovecot-libsieve/doc/rfc/draft-ietf-sieve-include-01.txt	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/draft-ietf-sieve-include-01.txt	2009-03-29 19:26:28.000000000 +0200
@@ -0,0 +1,616 @@
+
+
+
+Network Working Group                                           C. Daboo
+Internet-Draft                                                  A. Stone
+Expires: September 30, 2009                               March 29, 2009
+
+
+                Sieve Email Filtering: Include Extension
+                      draft-ietf-sieve-include-01
+
+Status of this Memo
+
+   This Internet-Draft is submitted to IETF in full conformance with the
+   provisions of BCP 78 and BCP 79.  This document may contain material
+   from IETF Documents or IETF Contributions published or made publicly
+   available before November 10, 2008.  The person(s) controlling the
+   copyright in some of this material may not have granted the IETF
+   Trust the right to allow modifications of such material outside the
+   IETF Standards Process.  Without obtaining an adequate license from
+   the person(s) controlling the copyright in such materials, this
+   document may not be modified outside the IETF Standards Process, and
+   derivative works of it may not be created outside the IETF Standards
+   Process, except to format it for publication as an RFC or to
+   translate it into languages other than English.
+
+   Internet-Drafts are working documents of the Internet Engineering
+   Task Force (IETF), its areas, and its working groups.  Note that
+   other groups may also distribute working documents as Internet-
+   Drafts.
+
+   Internet-Drafts are draft documents valid for a maximum of six months
+   and may be updated, replaced, or obsoleted by other documents at any
+   time.  It is inappropriate to use Internet-Drafts as reference
+   material or to cite them other than as "work in progress."
+
+   The list of current Internet-Drafts can be accessed at
+   http://www.ietf.org/ietf/1id-abstracts.txt.
+
+   The list of Internet-Draft Shadow Directories can be accessed at
+   http://www.ietf.org/shadow.html.
+
+   This Internet-Draft will expire on September 30, 2009.
+
+Copyright Notice
+
+   Copyright (c) 2009 IETF Trust and the persons identified as the
+   document authors.  All rights reserved.
+
+   This document is subject to BCP 78 and the IETF Trust's Legal
+   Provisions Relating to IETF Documents in effect on the date of
+
+
+
+Daboo & Stone          Expires September 30, 2009               [Page 1]
+
+Internet-Draft          Sieve Extension: Include              March 2009
+
+
+   publication of this document (http://trustee.ietf.org/license-info).
+   Please review these documents carefully, as they describe your rights
+   and restrictions with respect to this document.
+
+Abstract
+
+   The Sieve Email Filtering "include" extension permits users to
+   include one Sieve script inside another.  This can make managing
+   large scripts or multiple sets of scripts much easier, and allows a
+   site and its users to build up libraries of scripts.  Users are able
+   to include their own personal scripts or site-wide scripts.
+
+Change History (to be removed prior to publication as an RFC)
+
+   Changes from ietf-00 to ietf-01:
+   a.  Replaced import/export with global.
+   b.  Added :once modifier to include.
+   c.  Added global namespace to see if it holds water.
+
+   Changes from daboo-06 to ietf-00:
+   a.  None
+
+   Changes from -05 to -06:
+   a.  Aaron Stone joins as author.
+   b.  Removed | characters from the script examples.
+   c.  Updated draft references to published RFCs.
+
+   Changes from -04 to -05:
+   a.  Fixed examples.
+   b.  Relaxed requirement that imported/exported variables be set
+       before being used.
+
+   Changes from -03 to -04:
+   a.  Fixed missing 2119 definitions.
+   b.  Defined interaction with variables through use of import and
+       export commands.
+
+   Changes from -02 to -03:
+   a.  Refreshing expired draft (updated for nits).
+   b.  Syntax -> Usage.
+   c.  Updated to 3028bis reference.
+
+   Changes from -01 to -02:
+   a.  Minor formatting changes only - refreshing expired draft.
+
+   Changes from -00 to -01:
+
+
+
+
+
+Daboo & Stone          Expires September 30, 2009               [Page 2]
+
+Internet-Draft          Sieve Extension: Include              March 2009
+
+
+   a.  Added IPR boiler plate.
+   b.  Re-ordered sections at start to conform to RFC style.
+   c.  Moved recursion comment into General Considerations section.
+   d.  Switched to using optional parameter to indicate personal vs
+       global.
+   e.  Explicitly state that an error occurs when a missing script is
+       included.
+
+Open Issues (to be resolved prior to publication as an RFC)
+
+   a.  Interaction with variables (scoping).  Idea 1: use a "global"
+       command to make a variable shared between scripts.  Idea 2: use a
+       "global" variable namespace and no additional commands.
+
+
+Table of Contents
+
+   1.  Introduction and Overview  . . . . . . . . . . . . . . . . . .  4
+   2.  Conventions Used in This Document  . . . . . . . . . . . . . .  4
+   3.  Include Extension  . . . . . . . . . . . . . . . . . . . . . .  4
+     3.1.  General Considerations . . . . . . . . . . . . . . . . . .  4
+     3.2.  Control Structure include  . . . . . . . . . . . . . . . .  5
+     3.3.  Control Structure return . . . . . . . . . . . . . . . . .  8
+     3.4.  Interaction with Variables . . . . . . . . . . . . . . . .  8
+       3.4.1.  Control Structure global . . . . . . . . . . . . . . .  9
+       3.4.2.  Variables Namespace global . . . . . . . . . . . . . . 10
+   4.  Security Considerations  . . . . . . . . . . . . . . . . . . . 10
+   5.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 11
+     5.1.  "include" Extension Registration . . . . . . . . . . . . . 11
+   6.  Normative References . . . . . . . . . . . . . . . . . . . . . 11
+   Appendix A.  Acknowledgments . . . . . . . . . . . . . . . . . . . 11
+   Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . . . 11
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Daboo & Stone          Expires September 30, 2009               [Page 3]
+
+Internet-Draft          Sieve Extension: Include              March 2009
+
+
+1.  Introduction and Overview
+
+   It's convenient to be able to break SIEVE [RFC5228] scripts down into
+   smaller components which can be reused in a variety of different
+   circumstances.  For example, users may want to have a default script
+   and a special 'vacation' script, the latter being activated when the
+   user goes on vacation.  In that case the default actions should
+   continue to be run, but a vacation command should be executed first.
+   One option is to edit the default script to add or remove the
+   vacation command as needed.  Another is to have a vacation script
+   that simply has a vacation command and then includes the default
+   script.
+
+
+2.  Conventions Used in This Document
+
+   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
+   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
+   document are to be interpreted as described in [RFC2119].
+
+   Conventions for notations are as in SIEVE [RFC5228] Section 1.1.
+
+
+3.  Include Extension
+
+3.1.  General Considerations
+
+   Sieve implementations that implement the "include", "return", and
+   "global" commands described below have an identifier of "include" for
+   use with the capability mechanism.  If any of the "include",
+   "return", or "global" commands are used in a script, the "include"
+   capability MUST be listed in the "require" statement in that script.
+
+   Sieve implementations must track the use of actions in included
+   scripts so that implicit "keep" behavior can be properly determined
+   based on whether any actions have executed in any script.
+
+   Sieve implementations are allowed to limit the total number of nested
+   included scripts, but MUST provide for a total of at least three
+   levels of nested scripts including the top-level script.  An error
+   MUST be generated either when the script is uploaded to the Sieve
+   repository, or when the script is executed, if any nesting limit is
+   exceeded.  If such an error is detected whilst processing a Sieve
+   script, an implicit "keep" action MUST be executed to prevent loss of
+   any messages.
+
+   Sieve implementations MUST ensure that recursive includes are not
+   possible.  For example, if script "A" includes script "B", and script
+
+
+
+Daboo & Stone          Expires September 30, 2009               [Page 4]
+
+Internet-Draft          Sieve Extension: Include              March 2009
+
+
+   "B" includes script "A" an error MUST be generated either when the
+   script is uploaded to the Sieve repository, or when the script is
+   executed.  If such an error is detected whilst processing a Sieve
+   script, an implicit "keep" action MUST be executed to prevent loss of
+   any messages.
+
+   Sieve implementations MUST handle missing scripts being referenced
+   via an includes in an existing script.  An error MUST be generated
+   when a missing included script is discovered during execution.  If
+   such an error is detected an implicit "keep" action MUST be executed
+   to prevent loss of any messages.
+
+   If the Sieve "variables" extension [RFC5229] is present, an issue
+   arises with the "scope" of variables defined in scripts that may
+   include each other.  For example, if a script defines the variable
+   "${status}" with one particular meaning or usage, and another defines
+   "${status}" with a different meaning, then if one script includes the
+   other there is an issue as to which "${status}" is being referenced.
+   To solve this problem, Sieve implementations MUST follow the scoping
+   rules defined in Section 3.4 and support the "global" command defined
+   there.
+
+3.2.  Control Structure include
+
+      Usage:   include [LOCATION] [ONCE] <value: string>
+
+               LOCATION = ":personal" / ":global"
+
+               ONCE = ":once"
+
+   The "include" command takes an optional "location" parameter, an
+   optional ":once" parameter, and a single string argument representing
+   the name of the script to include for processing at that point.
+
+   The "location" parameter MUST default to ":personal" if not
+   specified.  The "location" has the following meanings:
+
+   :personal
+      Indicates that the named script is stored in the user's own
+      personal (private) Sieve repository.
+   :global
+      Indicates that the named script is stored in a site-wide Sieve
+      repository, accessible to all users of the Sieve system.
+
+   The ":once" parameter tells the interpreter only to include the Sieve
+   script if it has not already been included at any other point during
+   the script execution.  If the script has already been included,
+   processing continues immediately following the include command.
+
+
+
+Daboo & Stone          Expires September 30, 2009               [Page 5]
+
+Internet-Draft          Sieve Extension: Include              March 2009
+
+
+   Implementations MUST NOT generate an error if an "include :once"
+   command names a script whose inclusion would be recursive; in this
+   case, the script MUST be considered previously included and therefore
+   "include :once" will not include it again.
+
+   Note: It is RECOMMENDED that script authors / generators use this
+   parameter only when including a script that performs general duties
+   such as declaring global variables and making sanity checks of the
+   environment.
+
+   The included script MUST be a valid Sieve script, including having
+   necessary "require" statements for all optional capabilities used by
+   the script.  The scope of a "require" statement in an included script
+   is for that script only, not the including script.  For example, if
+   script "A" includes script "B", and script "B" uses the "fileinto"
+   extension, script "B" must have a "require" statement for "fileinto",
+   irrespective of whether script "A" has one.  In addition, if script
+   "A" does not have a "require" statement for "fileinto", "fileinto"
+   cannot be used anywhere in script "A", even after inclusion of script
+   "B".
+
+   A "stop" command in an included script MUST stop all script
+   processing, including the processing of the scripts that include the
+   current one.  The "return" command (described below) stops processing
+   of the current script only, and allows the scripts that include it to
+   continue.
+
+   Examples:
+
+   The user has four scripts stored in their personal repository:
+
+   "default"
+
+      This is the default active script that includes several others.
+
+      require ["include"];
+
+      include :personal "always_allow";
+      include :global "spam_tests";
+      include :personal "spam_tests";
+      include :personal "mailing_lists";
+
+   Personal script "always_allow"
+
+      This script special cases some correspondent email addresses and
+      makes sure any message containing those addresses are always kept.
+
+
+
+
+
+Daboo & Stone          Expires September 30, 2009               [Page 6]
+
+Internet-Draft          Sieve Extension: Include              March 2009
+
+
+      if header :is "From" "boss@example.com"
+      {
+          keep;
+      }
+      elsif header :is "From" "ceo@example.com"
+      {
+          keep;
+      }
+
+   Personal script "spam_tests"
+
+      This script does some user-specific spam tests to catch spam
+      messages not caught by the site-wide spam tests.
+
+      require ["reject"];
+
+      if header :contains "Subject" "XXXX"
+      {
+          reject;
+      }
+      elsif header :is "From" "money@example.com"
+      {
+          reject;
+      }
+
+   Personal script "mailing_lists"
+
+      This script looks for messages from different mailing lists and
+      files each into a mailbox specific to the mailing list.
+
+      require ["fileinto"];
+
+      if header :is "Sender" "owner-ietf-mta-filters@imc.org"
+      {
+          fileinto "lists.sieve";
+      }
+      elsif header :is "Sender" "owner-ietf-imapext@imc.org"
+      {
+          fileinto "lists.imapext";
+      }
+
+   There is one script stored in the global repository:
+
+   Site script "spam_tests"
+
+      This script does some site-wide spam tests which any user at the
+      site can include in their own scripts at a suitable point.  The
+      script content is kept up to date by the site administrator.
+
+
+
+Daboo & Stone          Expires September 30, 2009               [Page 7]
+
+Internet-Draft          Sieve Extension: Include              March 2009
+
+
+      require ["reject"];
+
+      if anyof (header :contains "Subject" "$$",
+                header :contains "Subject" "Make money")
+      {
+          reject;
+      }
+
+   The "include" command may appear anywhere in the script where a
+   control structure is legal.
+
+   Example:
+
+      require ["include"];
+
+      if anyof (header :contains "Subject" "$$",
+                header :contains "Subject" "Make money")
+      {
+          include "my_reject_script";
+      }
+
+3.3.  Control Structure return
+
+      Usage: return
+
+   The "return" command stops processing of the currently included
+   script only and returns processing control to the script which
+   includes it.  If used in the main script (i.e. not in an included
+   script), it has the same effect as the "stop" command, including the
+   appropriate "keep" action if no other actions have been executed up
+   to that point.
+
+3.4.  Interaction with Variables
+
+   In order to avoid problems of variables in an included script
+   "overwriting" those from the script that includes it, this
+   specification requires that all variables defined in a script MUST be
+   kept "private" to that script by default - i.e. they are not
+   "visible" to other scripts.  This ensures that two script authors
+   cannot inadvertently cause problems by choosing the same name for a
+   variable.
+
+   However, sometimes there is a need to make a variable defined in one
+   script available to others.  This specification defines the new
+   command "global" to declare that a variable is shared among scripts.
+   Effectively, two namespaces are defined: one local to the current
+   script, and another shared among all scripts.  Implementations MUST
+   allow a non-global variable to have the same name as a global
+
+
+
+Daboo & Stone          Expires September 30, 2009               [Page 8]
+
+Internet-Draft          Sieve Extension: Include              March 2009
+
+
+   variable but have no interaction between them.
+
+3.4.1.  Control Structure global
+
+      Usage:   global <value: string-list>
+
+   The "global" command contains a string list argument that defines one
+   or more names of variables to be stored in the global variable space.
+
+   The "global" command, if present, MUST be used immediately after any
+   "require" commands (at least one of which will be present listing the
+   "include" extension).  Multiple "global" commands are allowed.  An
+   error occurs if an "global" command appears after a command other
+   than "require" or "global".  Use of the "global" command makes the
+   listed variables immediately available for use in the body of the
+   script that uses it.
+
+   If a "global" command lists a variable that has not been defined in
+   the global namespace, the name of the variable is nonetheless marked
+   as global, and any subsequent "set" command will set the value of the
+   variable in global scope.
+
+   Interpretation of a string containing a variable marked as global,
+   but without any value set, SHALL behave as any other access to an
+   unknown variable, as specified in Section 3 of [RFC5229] (that is,
+   the unknown variable reference evaltuates to an empty string).
+
+   Example:
+
+      require ["variables", "include"];
+      global "test";
+      global "test-mailbox";
+
+      # The included script may contain repetitive code that is
+      # effectively a subroutine that can be factored out.
+      set "test" "$$"
+      include "spam_filter_script";
+
+      set "test" "Make money"
+      include "spam_filter_script";
+
+      # Message will be filed according to the test that matched last.
+      if string :count "${test-mailbox}" "1"
+      {
+          fileinto "INBOX${test-mailbox}";
+          stop;
+      }
+
+
+
+
+Daboo & Stone          Expires September 30, 2009               [Page 9]
+
+Internet-Draft          Sieve Extension: Include              March 2009
+
+
+      # If nothing matched, the message is implicitly kept.
+
+                               Active script
+
+
+      require ["variables", "include"];
+      global ["test", "test-mailbox"];
+
+      if header :contains "Subject" "${test}"
+      {
+          set "test-mailbox" "spam-${test};
+      }
+
+                            spam_filter_script
+
+3.4.2.  Variables Namespace global
+
+   In addition to the "global" command, this document defines the
+   variables namespace "global", per [RFC5229], Section 3.
+
+   Example:
+
+      require ["variables", "include"];
+
+      set "global.i_am_on_vacation" "1";
+
+   [[[ Does it make sense to have this form instead of the "global"
+   command?  Does it make sense to have both?  If both, it would make
+   sense that the two syntaxes reference the same set of variables.  By
+   way of example:
+
+      require ["variables", "include"];
+      global "i_am_on_vacation";
+
+      set "global.i_am_on_vacation" "1";
+
+      if string :is "${i_am_on_vacation}" "1"
+      {
+          vacation "It's true, I am on vacation."
+      }
+
+   ]]]
+
+
+4.  Security Considerations
+
+   Sieve implementations MUST ensure adequate security for the global
+   script repository to prevent unauthorized changes to global scripts.
+
+
+
+Daboo & Stone          Expires September 30, 2009              [Page 10]
+
+Internet-Draft          Sieve Extension: Include              March 2009
+
+
+   Beyond that, the "include" extension does not raise any security
+   considerations that are not present in the base Sieve protocol, and
+   these issues are discussed in Sieve.
+
+
+5.  IANA Considerations
+
+   The following template specifies the IANA registration of the Sieve
+   extension specified in this document:
+
+5.1.  "include" Extension Registration
+
+   Capability name: include
+   Description:     add the "include" command to execute other Sieve
+                    scripts.
+   RFC number:      this RFC
+   Contact address: the Sieve discussion list <ietf-mta-filters@imc.org>
+
+
+6.  Normative References
+
+   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
+              Requirement Levels", BCP 14, RFC 2119, March 1997.
+
+   [RFC5228]  Guenther, P. and T. Showalter, "Sieve: An Email Filtering
+              Language", RFC 5228, January 2008.
+
+   [RFC5229]  Homme, K., "Sieve Email Filtering: Variables Extension",
+              RFC 5229, January 2008.
+
+
+Appendix A.  Acknowledgments
+
+   Thanks to Ken Murchison, Rob Siemborski, Alexey Melnikov, Marc Mutz
+   and Kjetil Torgrim Homme for comments and corrections.
+
+
+Authors' Addresses
+
+   Cyrus Daboo
+
+   Email: cyrus@daboo.name
+
+
+   Aaron Stone
+
+   Email: aaron@serendipity.palo-alto.ca.us
+
+
+
+
+Daboo & Stone          Expires September 30, 2009              [Page 11]
+
diff -urN dovecot-1.2.4/dovecot-libsieve/doc/rfc/draft-murchison-sieve-regex-07.txt dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/draft-murchison-sieve-regex-07.txt
--- dovecot-1.2.4/dovecot-libsieve/doc/rfc/draft-murchison-sieve-regex-07.txt	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/draft-murchison-sieve-regex-07.txt	2008-08-25 10:25:08.000000000 +0200
@@ -0,0 +1,451 @@
+
+
+
+
+
+
+
+Internet Draft                                               K. Murchison
+Category: Standards Track                              Oceana Matrix Ltd.
+Expires: May 23, 2004                                    18 November 2003
+
+
+            Sieve Email Filtering -- Regular Expression Extension
+
+                    <draft-murchison-sieve-regex-07.txt>
+
+Status of this Memo
+
+    This document is an Internet-Draft and is subject to all provisions
+    of Section 10 of RFC2026.
+
+    Internet-Drafts are working documents of the Internet Engineering
+    Task Force (IETF), its areas, and its working groups.  Note that
+    other groups may also distribute working documents as
+    Internet-Drafts.
+
+    Internet-Drafts are draft documents valid for a maximum of six months
+    and may be updated, replaced, or obsoleted by other documents at any
+    time.  It is inappropriate to use Internet-Drafts as reference
+    material or to cite them other than as "work in progress."
+
+    The list of current Internet-Drafts can be accessed at
+    http://www.ietf.org/1id-abstracts.html
+
+    The list of Internet-Draft Shadow Directories can be accessed at
+    http://www.ietf.org/shadow.html
+
+Copyright Notice
+
+    Copyright (C) The Internet Society (2003). All Rights Reserved.
+
+
+Abstract
+
+    In some cases, it is desirable to have a string matching mechanism
+    which is more powerful than a simple exact match, a substring match
+    or a glob-style wildcard match.  The regular expression matching
+    mechanism defined in this draft should allow users to isolate just
+    about any string or address in a message header or envelope.
+
+
+
+
+
+
+
+
+
+Expires: May 23, 2004         Murchison                         [Page 1]
+
+Internet Draft          Sieve -- Regex Extension       November 18, 2004
+
+
+                           Table of Contents
+
+
+
+0.     Meta-information on this draft  . . . . . . . . . . . . . . .   3
+
+0.1.   Discussion  . . . . . . . . . . . . . . . . . . . . . . . . .   3
+
+0.2.   Noted Changes Since -06 . . . . . . . . . . . . . . . . . . .   3
+
+0.3.   Open Issues . . . . . . . . . . . . . . . . . . . . . . . . .   3
+
+1.     Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4
+
+2.     Capability Identifier . . . . . . . . . . . . . . . . . . . .   4
+
+3.     Regex Match Type  . . . . . . . . . . . . . . . . . . . . . .   4
+
+4.     Security Considerations . . . . . . . . . . . . . . . . . . .   6
+
+5.     IANA Considerations . . . . . . . . . . . . . . . . . . . . .   6
+
+6.     Normative References  . . . . . . . . . . . . . . . . . . . .   7
+
+7.     Acknowledgments . . . . . . . . . . . . . . . . . . . . . . .   7
+
+8.     Intellectual Property Statement . . . . . . . . . . . . . . .   7
+
+9.     Author's Address  . . . . . . . . . . . . . . . . . . . . . .   8
+
+10.    Full Copyright Statement  . . . . . . . . . . . . . . . . . .   8
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Expires: May 23, 2004         Murchison                         [Page 2]
+
+Internet Draft          Sieve -- Regex Extension       November 18, 2004
+
+
+
+0.     Meta-information on this draft
+
+    This information is intended to facilitate discussion.  It will be
+    removed when this document leaves the Internet-Draft stage.
+
+
+0.1.   Discussion
+
+    This draft is intended to be an extension to the Sieve mail filtering
+    language, available from the RFC repository as
+    <ftp://ftp.ietf.org/rfc/rfc3028.txt>.
+
+    This draft and the Sieve language itself are being discussed on the
+    MTA Filters mailing list at <ietf-mta-filters@imc.org>.  Subscription
+    requests can be sent to <ietf-mta-filters-request@imc.org> (send an
+    email message with the word "subscribe" in the body).  More
+    information on the mailing list along with a WWW archive of back
+    messages is available at <http://www.imc.org/ietf-mta-filters/>.
+
+
+0.2.   Noted Changes Since -06
+
+    Added more open issues.
+
+    Added IANA considerations.
+
+    Editorial changes.
+
+
+0.3.   Open Issues
+
+    The major open issue with this draft is what to do, if anything,
+    about localization/internationalization.  Are [POSIX.2] collating
+    sequences and character equivalents sufficient?  Should we reference
+    the unicode technical specification?  Should we punt and publish the
+    document as experimental?
+
+    Should we allow shorthands such as \b (word boundary) and \w (word
+    character)?
+
+    Should we allow backreferences (useful for matching double words,
+    etc.)?
+
+    Should we integrate with variables, so that $1, $2, ...  correspond
+    to the first, second, ... groups within the regex?
+
+
+
+
+
+Expires: May 23, 2004         Murchison                         [Page 3]
+
+Internet Draft          Sieve -- Regex Extension       November 18, 2004
+
+
+1.  Introduction
+
+    This is an extension to the Sieve language defined by [SIEVE] for
+    comparing strings to regular expressions.
+
+    Conventions for notations are as in [SIEVE] section 1.1, including
+    use of [KEYWORDS].
+
+
+2.  Capability Identifier
+
+    The capability string associated with the extension defined in this
+    document is "regex".
+
+
+3.  Regex Match Type
+
+    Commands that support matching may take the optional tagged argument
+    ":regex" to specify that a regular expression match should be
+    performed.  The ":regex" match type is subject to the same rules and
+    restrictions as the standard match types defined in [SIEVE].  For
+    convenience, the "MATCH-TYPE" syntax element defined in [SIEVE] is
+    augmented here as follows:
+
+         MATCH-TYPE  =/  ":regex"
+
+    Example:
+
+          require "regex";
+
+          # Try to catch unsolicited email.
+          if anyof (
+            # if a message is not to me (with optional +detail),
+            not address :regex ["to", "cc", "bcc"]
+              "me(\\+.*)?@company\\.com",
+
+            # or the subject is all uppercase (no lowercase)
+            header :regex :comparator "i;octet" "subject"
+              "^[^[:lower:]]+$" ) {
+
+            discard;     # junk it
+          }
+
+    The ":regex" match type is compatible with both the "i;octet" and
+    "i;ascii-casemap" comparators and may be used with them.
+
+    Implementations MUST support extended regular expressions (EREs) as
+    defined by [POSIX.2].  Any regular expression not defined by
+
+
+
+Expires: May 23, 2004         Murchison                         [Page 4]
+
+Internet Draft          Sieve -- Regex Extension       November 18, 2004
+
+
+    [POSIX.2], as well as [POSIX.2] basic regular expressions, word
+    boundaries and backreferences are not supported by this extension.
+    Implementations SHOULD reject regular expressions that are
+    unsupported by this specification as a syntax error.
+
+    The following table provides a brief summary of the regular
+    expressions that MUST be supported.  This table is presented here
+    only as a guideline.  [POSIX.2] should be used as the definitive
+    reference.
+
+
+    +------------+-----------------------------------------------------+
+    | Expression |  Pattern                                            |
+    +------------+-----------------------------------------------------+
+    |                Items to match a single character                 |
+    +------------+-----------------------------------------------------+
+    |     .      |  Match any single character except newline.         |
+    |    [ ]     |  Bracket expression.  Match any one of the enclosed |
+    |            |  characters.  A hypen (-) indicates a range of      |
+    |            |  consecutive characters.                            |
+    |   [^  ]    |  Negated bracket expression.  Match any one         |
+    |            |  character NOT in the enclosed list.  A hypen (-)   |
+    |            |  indicates a range of consecutive characters.       |
+    |    \\      |  Escape the following special character (match      |
+    |            |  the literal character).  Undefined for other       |
+    |            |  characters.                                        |
+    |            |  NOTE: Unlike [POSIX.2], a double-backslash is      |
+    |            |  required as per section 2.4.2 of [SIEVE].          |
+    +------------+-----------------------------------------------------+
+    |   Items to be used within a bracket expression (localization)    |
+    +------------+-----------------------------------------------------+
+    |   [: :]    |  Character class (alnum, alpha, blank, cntrl,       |
+    |            |  digit, graph, lower, print, punct, space,          |
+    |            |  upper, xdigit).                                    |
+    |   [= =]    |  Character equivalents.                             |
+    |   [. .]    |  Collating sequence.                                |
+    +------------+-----------------------------------------------------+
+    |  Quantifiers - Items to count the preceding regular expression   |
+    +------------+-----------------------------------------------------+
+    |     ?      |  Match zero or one instances.                       |
+    |     *      |  Match zero or more instances.                      |
+    |     +      |  Match one or more instances.                       |
+    |   {n,m}    |  Match any number of instances between              |
+    |            |  n and m (inclusive).  {n} matches exactly n        |
+    |            |  instances.  {n,} matches n or more instances.      |
+    +------------+-----------------------------------------------------+
+
+
+
+
+
+Expires: May 23, 2004         Murchison                         [Page 5]
+
+Internet Draft          Sieve -- Regex Extension       November 18, 2004
+
+
+    +------------+-----------------------------------------------------+
+    | Expression |  Pattern                                            |
+    +------------+-----------------------------------------------------+
+    |              Anchoring - Items to match positions                |
+    +------------+-----------------------------------------------------+
+    |     ^      |  Match the beginning of the line or string.         |
+    |     $      |  Match the end of the line or string.               |
+    +------------+-----------------------------------------------------+
+    |                        Other constructs                          |
+    +------------+-----------------------------------------------------+
+    |     |      |  Alternation.  Match either of the separated        |
+    |            |  regular expressions.                               |
+    |    ( )     |  Group the enclosed regular expression(s).          |
+    +------------+-----------------------------------------------------+
+
+
+4.  Security Considerations
+
+    Security considerations are discussed in [SIEVE].  It is believed
+    that this extension doesn't introduce any additional security
+    concerns.
+
+    However, a poor implementation COULD introduce security problems
+    ranging from degradation of performance to denial of service.  If an
+    implementation uses a third-party regular expression library, that
+    library should be checked for potentially problematic regular
+    expressions, such as "(.*)*".
+
+
+5.  IANA Considerations
+
+    The following template specifies the IANA registration of the Sieve
+    extension specified in this document:
+
+    To: iana@iana.org
+    Subject: Registration of new Sieve extension
+
+    Capability name: regex
+    Capability keyword: regex
+    Capability arguments: N/A
+    Standards Track/IESG-approved experimental RFC number: this RFC
+    Person and email address to contact for further information:
+
+    Kenneth Murchison
+    ken@oceana.com
+
+    This information should be added to the list of sieve extensions
+    given on http://www.iana.org/assignments/sieve-extensions.
+
+
+
+Expires: May 23, 2004         Murchison                         [Page 6]
+
+Internet Draft          Sieve -- Regex Extension       November 18, 2004
+
+
+6.
+    Normative References
+
+     [KEYWORDS] Bradner, S., "Key words for use in RFCs to Indicate
+         Requirement Levels", RFC 2119, March 1997.
+
+
+     [SIEVE] Showalter, T., "Sieve: A Mail Filtering Language",
+         RFC 3028, January 2001.
+
+
+     [POSIX.2], "Portable Operating System Interface (POSIX). Part 2,
+         Shell and utilities", National Institute of Standards and
+         Technology (U.S.).
+
+
+
+7.  Acknowledgments
+
+    Thanks to Tim Showalter, Alexey Melnikov, Tony Hansen, Phil Pennock,
+    Jutta Degener and Ned Freed for their help with this document.
+
+
+8.  Intellectual Property Statement
+
+    The IETF takes no position regarding the validity or scope of any
+    intellectual property or other rights that might be claimed to per
+    tain to the implementation or use of the technology described in
+    this document or the extent to which any license under such rights
+    might or might not be available; neither does it represent that it
+    has made any effort to identify any such rights.  Information on the
+    IETF's procedures with respect to rights in standards-track and
+    standards-related documentation can be found in BCP-11.  Copies of
+    claims of rights made available for publication and any assurances
+    of licenses to be made available, or the result of an attempt made
+    to obtain a general license or permission for the use of such pro
+    prietary rights by implementors or users of this specification can
+    be obtained from the IETF Secretariat.
+
+    The IETF invites any interested party to bring to its attention any
+    copyrights, patents or patent applications, or other proprietary
+    rights which may cover technology that may be required to practice
+    this standard.  Please address the information to the IETF Executive
+    Director.
+
+
+
+
+
+
+
+Expires: May 23, 2004         Murchison                         [Page 7]
+
+Internet Draft          Sieve -- Regex Extension       November 18, 2004
+
+
+9.  Author's Address
+
+    Kenneth Murchison
+    Oceana Matrix Ltd.
+    21 Princeton Place
+    Orchard Park, NY  14127
+
+    Phone: (716) 662-8973
+
+    EMail: ken@oceana.com
+
+
+10.
+    Full Copyright Statement
+
+    Copyright (C) The Internet Society (2003). All Rights Reserved.
+
+    This document and translations of it may be copied and furnished to
+    others, and derivative works that comment on or otherwise explain it
+    or assist in its implmentation may be prepared, copied, published and
+    distributed, in whole or in part, without restriction of any kind,
+    provided that the above copyright notice and this paragraph are
+    included on all such copies and derivative works.  However, this
+    document itself may not be modified in any way, such as by removing
+    the copyright notice or references to the Internet Society or other
+    Internet organizations, except as needed for the  purpose of
+    developing Internet standards in which case the procedures for
+    copyrights defined in the Internet Standards process must be followed,
+    or as required to translate it into languages other than English.
+
+    The limited permissions granted above are perpetual and will not be
+    revoked by the Internet Society or its successors or assigns.
+
+    This document and the information contained herein is provided on an
+    "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET
+    ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED,
+    INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
+    INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
+    WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
+
+
+
+
+
+
+
+
+
+
+
+
+Expires: May 23, 2004         Murchison                         [Page 8]
diff -urN dovecot-1.2.4/dovecot-libsieve/doc/rfc/environment.rfc5183.txt dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/environment.rfc5183.txt
--- dovecot-1.2.4/dovecot-libsieve/doc/rfc/environment.rfc5183.txt	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/environment.rfc5183.txt	2009-04-13 21:35:39.000000000 +0200
@@ -0,0 +1,563 @@
+
+
+
+
+
+
+Network Working Group                                           N. Freed
+Request for Comments: 5183                              Sun Microsystems
+Category: Standards Track                                       May 2008
+
+
+              Sieve Email Filtering: Environment Extension
+
+Status of This Memo
+
+   This document specifies an Internet standards track protocol for the
+   Internet community, and requests discussion and suggestions for
+   improvements.  Please refer to the current edition of the "Internet
+   Official Protocol Standards" (STD 1) for the standardization state
+   and status of this protocol.  Distribution of this memo is unlimited.
+
+Abstract
+
+   This document describes the "environment" extension to the Sieve
+   email filtering language.  The "environment" extension gives a Sieve
+   script access to information about the Sieve interpreter itself,
+   where it is running, and about any transport connection currently
+   involved in transferring the message.
+
+1.  Introduction
+
+   Sieve [RFC5228] is a language for filtering email messages at or
+   around the time of final delivery.  It is designed to be
+   implementable on either a mail client or mail server.  It is suitable
+   for running on a mail server where users may not be allowed to
+   execute arbitrary programs, such as on black box Internet Message
+   Access Protocol [RFC3501] servers, as it has no user-controlled loops
+   or the ability to run external programs.
+
+   Although Sieve is intended to be independent of access protocol, mail
+   architecture, and operating system, in some cases it is useful to
+   allow scripts to access information about their execution context.
+   The "environment" extension provides a new environment test that can
+   be used to implement scripts that behave differently when moved from
+   one system to another, when messages arrive from different remote
+   sources or when otherwise operated in different contexts.
+
+2.  Conventions Used in This Document
+
+   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
+   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
+   document are to be interpreted as described in [RFC2119].
+
+
+
+
+
+Freed                       Standards Track                     [Page 1]
+
+RFC 5183              Sieve Environment Extension               May 2008
+
+
+   The terms used to describe the various components of the Sieve
+   language are taken from Section 1.1 of [RFC5228].
+
+   This document refers to the ABNF productions IPv4-address-literal,
+   IPv6-address-literal, and General-address-literal defined in Section
+   4.1.3 of [RFC2821].
+
+   The location item makes use of standard terms for email service
+   components.  Additional information and background on these terms can
+   be found in [EMAIL-ARCH].
+
+3.  Capability Identifiers
+
+   The capability string associated with the extension defined in this
+   document is "environment".
+
+4.  Environment Test
+
+   Usage:   environment [COMPARATOR] [MATCH-TYPE]
+                        <name: string>
+                        <key-list: string-list>
+
+   The environment test retrieves the item of environment information
+   specified by the name string and matches it to the values specified
+   in the key-list argument.  The test succeeds if a match occurs.  The
+   type of match defaults to ":is" and the default comparator is
+   "i;ascii-casemap".
+
+   The current message is not a direct source of information for the
+   environment test; the item of information specified by the name
+   string is extracted from the script's operating environment and the
+   key-list argument comes from the script.
+
+   The environment test MUST fail unconditionally if the specified
+   information item does not exist.  A script MUST NOT fail with an
+   error if the item does not exist.  This allows scripts to be written
+   that handle nonexistent items gracefully.  In particular, the test:
+
+     if environment :contains "item" "" { ... }
+
+   only succeeds if "item" is known to the implementation, and always
+   succeeds if it is.
+
+   The "relational" extension [RFC5231] adds a match type called
+   ":count".  The count of an environment test is 0 if the environment
+   information returned is the empty string, or 1 otherwise.
+
+
+
+
+
+Freed                       Standards Track                     [Page 2]
+
+RFC 5183              Sieve Environment Extension               May 2008
+
+
+   Environment items can be standardized or vendor-defined.  An IANA
+   registry is defined for both types of items.  Extensions designed for
+   interoperable use SHOULD be defined in standards track or
+   experimental RFCs.
+
+4.1.  Initial Standard Environment Items
+
+   The initial set of standardized environment items is as follows:
+
+    "domain"  => The primary DNS domain associated with the Sieve
+                 execution context, usually but not always a proper
+                 suffix of the host name.
+
+    "host"    => The fully-qualified domain name of the host where
+                 the Sieve script is executing.
+
+    "location"
+              => Sieve evaluation can be performed at various
+                 different points as messages are processed.  This item
+                 provides additional information about the type of
+                 service that is evaluating the script.  Possible values
+                 are "MTA", meaning the Sieve is being evaluated by a
+                 Message Transfer Agent, "MDA", meaning evaluation is
+                 being performed by a Mail Delivery Agent, "MUA",
+                 meaning evaluation is being performed by a Mail User
+                 Agent, and "MS", meaning evaluation is being performed
+                 by a Message Store.  Additional information and
+                 background on these terms can be found in
+                 [EMAIL-ARCH].
+
+    "name"    => The product name associated with the Sieve interpreter.
+
+    "phase"   => The point relative to final delivery where the
+                 Sieve script is being evaluated.  Possible values are
+                 "pre", "during", and "post", referring respectively to
+                 processing before, during, and after final delivery
+                 has taken place.
+
+    "remote-host"
+              => Host name of remote SMTP/LMTP/Submission client
+                 expressed as a Fully Qualified Domain Name (FQDN),
+                 if applicable and available.  The empty string will be
+                 returned if for some reason this information cannot be
+                 obtained for the current client.
+
+
+
+
+
+
+
+Freed                       Standards Track                     [Page 3]
+
+RFC 5183              Sieve Environment Extension               May 2008
+
+
+    "remote-ip"
+              => IP address of remote SMTP/LMTP/Submission client, if
+                 applicable and available.  IPv4, IPv6, and other types
+                 of addresses are respectively represented in the
+                 formats defined by the IPv4-address-literal,
+                 IPv6-address-literal, and General-address-literal
+                 productions defined in Section 4.1.3 of [RFC2821].
+
+    "version" => The product version associated with the Sieve
+                 interpreter.  The meaning of the product version string
+                 is product-specific and should always be considered
+                 in the context of the product name given by the
+                 "name" item.
+
+   Implementations SHOULD support as many of the items on this initial
+   list as possible.  Additional standardized items can only be defined
+   in standards-track or experimental RFCs.
+
+4.2.  Vendor-defined Environment Items
+
+   Environment item names beginning with "vnd." represent vendor-defined
+   extensions.  Such extensions are not defined by Internet standards or
+   RFCs, but are still registered with IANA in order to prevent
+   conflicts.
+
+4.3.  IANA Registration of Environment Items
+
+   A registry of environment items is provided by IANA.  Item names may
+   be registered on a first-come, first-served basis.
+
+   Groups of items defined in a standards track or experimental RFC MAY
+   choose to use a common name prefix of the form "name.", where "name"
+   is a string that identifies the group of related items.
+
+   Items not defined in a standards track or experimental RFC MUST have
+   a name that begins with the "vnd." prefix, and this prefix is
+   followed by the name of the vendor or product, such as
+   "vnd.acme.rocket-sled-status".
+
+
+
+
+
+
+
+
+
+
+
+
+
+Freed                       Standards Track                     [Page 4]
+
+RFC 5183              Sieve Environment Extension               May 2008
+
+
+4.3.1.  Template for Environment Registrations
+
+   The following template is to be used for registering new Sieve
+   environment item names with IANA.
+
+      To: iana@iana.org
+      Subject: Registration of new Sieve environment item
+
+      Item name: [the string for use in the 'environment' test]
+      Description:     [a brief description of the semantics of the
+                        value the item returns]
+
+      RFC number:      [for extensions published as RFCs]
+      Contact address: [email and/or physical address to contact for
+                        additional information]
+
+   Multiple items and descriptions MAY be specified in a single
+   registration request.  Both standardized and vendor-defined items use
+   this form.
+
+5.  Security Considerations
+
+   The environment extension may be used to obtain information about the
+   system the Sieve implementation is running on.  This information in
+   turn may reveal details about service provider or enterprise
+   infrastructure.
+
+   An implementation can use any technique to determine the remote-host
+   environment item defined in this specification, and the
+   trustworthiness of the result will vary.  One common method will be
+   to perform a PTR DNS lookup on the client IP address.  This
+   information may come from an untrusted source.  For example, the
+   test:
+
+     if environment :matches "remote-host" "*.example.com" { ... }
+
+   is not a good way to test whether the message came from "outside"
+   because anyone who can create a PTR record can create one that refers
+   to whatever domain they choose.
+
+   All of the security considerations given in the base Sieve
+   specification also apply to this extension.
+
+
+
+
+
+
+
+
+
+Freed                       Standards Track                     [Page 5]
+
+RFC 5183              Sieve Environment Extension               May 2008
+
+
+6.  IANA Considerations
+
+   The following template specifies the IANA registration of the Sieve
+   extension specified in this document:
+
+      To: iana@iana.org
+      Subject: Registration of new Sieve extension
+
+      Capability name: environment
+      Description:     The "environment" extension provides a new
+                       environment test that can be used to implement
+                       scripts that behave differently when moved
+                       from one system to another or otherwise
+                       operated in different contexts.
+      RFC number:      RFC 5183
+      Contact address: Sieve discussion list <ietf-mta-filters@imc.org>
+
+   This specification also defines a new IANA registry for Sieve
+   environment item names.  The specifics of this registry are given in
+   Section 4.3.  The initial contents of the registry are given in the
+   following section.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Freed                       Standards Track                     [Page 6]
+
+RFC 5183              Sieve Environment Extension               May 2008
+
+
+6.1.  Initial Environment Item Registrations
+
+   The following template specifies the initial IANA registrations for
+   the environment items defined in this document:
+
+      To: iana@iana.org
+      Subject: Registration of new Sieve environment items
+
+      Capability name: domain
+      Description:     The primary DNS domain associated with the Sieve
+                       execution context, usually but not always a
+                       proper suffix of the host name.
+
+      Capability name: host
+      Description:     The fully-qualified domain name of the host
+                       where the Sieve script is executing.
+
+      Capability name: location
+      Description:     Type of service executing the Sieve script.
+
+      Capability name: name
+      Description:     The product name associated with the Sieve
+                       interpreter.
+
+      Capability name: phase
+      Description:     Point relative to final delivery at which the
+                       Sieve script is being evaluated.
+
+      Capability name: remote-host
+      Description:     Host name of remote SMTP client, if applicable
+                       and available.
+
+      Capability name: remote-ip
+      Description:     IP address of remote SMTP client, if applicable
+                       and available.
+
+      Capability name: version
+      Description:     The product version associated with the Sieve
+                       interpreter.
+
+      RFC number:      RFC 5183
+      Contact address: Sieve discussion list <ietf-mta-filters@imc.org>
+
+
+
+
+
+
+
+
+
+Freed                       Standards Track                     [Page 7]
+
+RFC 5183              Sieve Environment Extension               May 2008
+
+
+7.  References
+
+7.1.  Normative references
+
+   [RFC2119]     Bradner, S., "Key words for use in RFCs to Indicate
+                 Requirement Levels", BCP 14, RFC 2119, March 1997.
+
+   [RFC2821]     Klensin, J., "Simple Mail Transfer Protocol", RFC 2821,
+                 April 2001.
+
+   [RFC5228]     Guenther, P. and T. Showalter, "Sieve: An Email
+                 Filtering Language", RFC 5228, January 2008.
+
+   [RFC5231]     Segmuller, W. and B. Leiba, "Sieve Email Filtering:
+                 Relational Extension", RFC 5231, January 2008.
+
+7.2.  Informative references
+
+   [EMAIL-ARCH]  Crocker, D., "Internet Mail Architecture", Work
+                 in Progress, February 2008.
+
+   [RFC3501]     Crispin, M., "INTERNET MESSAGE ACCESS PROTOCOL -
+                 VERSION 4rev1", RFC 3501, March 2003.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Freed                       Standards Track                     [Page 8]
+
+RFC 5183              Sieve Environment Extension               May 2008
+
+
+Appendix A.  Acknowledgements
+
+   Brian Carpenter, Dave Crocker, Cyrus Daboo, Philip Guenther, Kjetil
+   Torgrim Homme, John Klensin, Mark Mallett, Alexey Melnikov, and
+   Dilyan Palauzo provided helpful suggestions and corrections.
+
+Author's Address
+
+   Ned Freed
+   Sun Microsystems
+   3401 Centrelake Drive, Suite 410
+   Ontario, CA  92761-1205
+   USA
+
+   Phone: +1 909 457 4293
+   EMail: ned.freed@mrochek.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Freed                       Standards Track                     [Page 9]
+
+RFC 5183              Sieve Environment Extension               May 2008
+
+
+Full Copyright Statement
+
+   Copyright (C) The IETF Trust (2008).
+
+   This document is subject to the rights, licenses and restrictions
+   contained in BCP 78, and except as set forth therein, the authors
+   retain all their rights.
+
+   This document and the information contained herein are provided on an
+   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
+   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
+   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
+   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
+
+Intellectual Property
+
+   The IETF takes no position regarding the validity or scope of any
+   Intellectual Property Rights or other rights that might be claimed to
+   pertain to the implementation or use of the technology described in
+   this document or the extent to which any license under such rights
+   might or might not be available; nor does it represent that it has
+   made any independent effort to identify any such rights.  Information
+   on the procedures with respect to rights in RFC documents can be
+   found in BCP 78 and BCP 79.
+
+   Copies of IPR disclosures made to the IETF Secretariat and any
+   assurances of licenses to be made available, or the result of an
+   attempt made to obtain a general license or permission for the use of
+   such proprietary rights by implementers or users of this
+   specification can be obtained from the IETF on-line IPR repository at
+   http://www.ietf.org/ipr.
+
+   The IETF invites any interested party to bring to its attention any
+   copyrights, patents or patent applications, or other proprietary
+   rights that may cover technology that may be required to implement
+   this standard.  Please address the information to the IETF at
+   ietf-ipr@ietf.org.
+
+
+
+
+
+
+
+
+
+
+
+
+Freed                       Standards Track                    [Page 10]
+
diff -urN dovecot-1.2.4/dovecot-libsieve/doc/rfc/imail.rfc2822.txt dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/imail.rfc2822.txt
--- dovecot-1.2.4/dovecot-libsieve/doc/rfc/imail.rfc2822.txt	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/imail.rfc2822.txt	2008-07-18 12:11:28.000000000 +0200
@@ -0,0 +1,2859 @@
+
+
+
+
+
+
+Network Working Group                                 P. Resnick, Editor
+Request for Comments: 2822                         QUALCOMM Incorporated
+Obsoletes: 822                                                April 2001
+Category: Standards Track
+
+
+                        Internet Message Format
+
+Status of this Memo
+
+   This document specifies an Internet standards track protocol for the
+   Internet community, and requests discussion and suggestions for
+   improvements.  Please refer to the current edition of the "Internet
+   Official Protocol Standards" (STD 1) for the standardization state
+   and status of this protocol.  Distribution of this memo is unlimited.
+
+Copyright Notice
+
+   Copyright (C) The Internet Society (2001).  All Rights Reserved.
+
+Abstract
+
+   This standard specifies a syntax for text messages that are sent
+   between computer users, within the framework of "electronic mail"
+   messages.  This standard supersedes the one specified in Request For
+   Comments (RFC) 822, "Standard for the Format of ARPA Internet Text
+   Messages", updating it to reflect current practice and incorporating
+   incremental changes that were specified in other RFCs.
+
+Table of Contents
+
+   1. Introduction ............................................... 3
+   1.1. Scope .................................................... 3
+   1.2. Notational conventions ................................... 4
+   1.2.1. Requirements notation .................................. 4
+   1.2.2. Syntactic notation ..................................... 4
+   1.3. Structure of this document ............................... 4
+   2. Lexical Analysis of Messages ............................... 5
+   2.1. General Description ...................................... 5
+   2.1.1. Line Length Limits ..................................... 6
+   2.2. Header Fields ............................................ 7
+   2.2.1. Unstructured Header Field Bodies ....................... 7
+   2.2.2. Structured Header Field Bodies ......................... 7
+   2.2.3. Long Header Fields ..................................... 7
+   2.3. Body ..................................................... 8
+   3. Syntax ..................................................... 9
+   3.1. Introduction ............................................. 9
+   3.2. Lexical Tokens ........................................... 9
+
+
+
+Resnick                     Standards Track                     [Page 1]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+   3.2.1. Primitive Tokens ....................................... 9
+   3.2.2. Quoted characters ......................................10
+   3.2.3. Folding white space and comments .......................11
+   3.2.4. Atom ...................................................12
+   3.2.5. Quoted strings .........................................13
+   3.2.6. Miscellaneous tokens ...................................13
+   3.3. Date and Time Specification ..............................14
+   3.4. Address Specification ....................................15
+   3.4.1. Addr-spec specification ................................16
+   3.5 Overall message syntax ....................................17
+   3.6. Field definitions ........................................18
+   3.6.1. The origination date field .............................20
+   3.6.2. Originator fields ......................................21
+   3.6.3. Destination address fields .............................22
+   3.6.4. Identification fields ..................................23
+   3.6.5. Informational fields ...................................26
+   3.6.6. Resent fields ..........................................26
+   3.6.7. Trace fields ...........................................28
+   3.6.8. Optional fields ........................................29
+   4. Obsolete Syntax ............................................29
+   4.1. Miscellaneous obsolete tokens ............................30
+   4.2. Obsolete folding white space .............................31
+   4.3. Obsolete Date and Time ...................................31
+   4.4. Obsolete Addressing ......................................33
+   4.5. Obsolete header fields ...................................33
+   4.5.1. Obsolete origination date field ........................34
+   4.5.2. Obsolete originator fields .............................34
+   4.5.3. Obsolete destination address fields ....................34
+   4.5.4. Obsolete identification fields .........................35
+   4.5.5. Obsolete informational fields ..........................35
+   4.5.6. Obsolete resent fields .................................35
+   4.5.7. Obsolete trace fields ..................................36
+   4.5.8. Obsolete optional fields ...............................36
+   5. Security Considerations ....................................36
+   6. Bibliography ...............................................37
+   7. Editor's Address ...........................................38
+   8. Acknowledgements ...........................................39
+   Appendix A. Example messages ..................................41
+   A.1. Addressing examples ......................................41
+   A.1.1. A message from one person to another with simple
+          addressing .............................................41
+   A.1.2. Different types of mailboxes ...........................42
+   A.1.3. Group addresses ........................................43
+   A.2. Reply messages ...........................................43
+   A.3. Resent messages ..........................................44
+   A.4. Messages with trace fields ...............................46
+   A.5. White space, comments, and other oddities ................47
+   A.6. Obsoleted forms ..........................................47
+
+
+
+Resnick                     Standards Track                     [Page 2]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+   A.6.1. Obsolete addressing ....................................48
+   A.6.2. Obsolete dates .........................................48
+   A.6.3. Obsolete white space and comments ......................48
+   Appendix B. Differences from earlier standards ................49
+   Appendix C. Notices ...........................................50
+   Full Copyright Statement ......................................51
+
+1. Introduction
+
+1.1. Scope
+
+   This standard specifies a syntax for text messages that are sent
+   between computer users, within the framework of "electronic mail"
+   messages.  This standard supersedes the one specified in Request For
+   Comments (RFC) 822, "Standard for the Format of ARPA Internet Text
+   Messages" [RFC822], updating it to reflect current practice and
+   incorporating incremental changes that were specified in other RFCs
+   [STD3].
+
+   This standard specifies a syntax only for text messages.  In
+   particular, it makes no provision for the transmission of images,
+   audio, or other sorts of structured data in electronic mail messages.
+   There are several extensions published, such as the MIME document
+   series [RFC2045, RFC2046, RFC2049], which describe mechanisms for the
+   transmission of such data through electronic mail, either by
+   extending the syntax provided here or by structuring such messages to
+   conform to this syntax.  Those mechanisms are outside of the scope of
+   this standard.
+
+   In the context of electronic mail, messages are viewed as having an
+   envelope and contents.  The envelope contains whatever information is
+   needed to accomplish transmission and delivery.  (See [RFC2821] for a
+   discussion of the envelope.)  The contents comprise the object to be
+   delivered to the recipient.  This standard applies only to the format
+   and some of the semantics of message contents.  It contains no
+   specification of the information in the envelope.
+
+   However, some message systems may use information from the contents
+   to create the envelope.  It is intended that this standard facilitate
+   the acquisition of such information by programs.
+
+   This specification is intended as a definition of what message
+   content format is to be passed between systems.  Though some message
+   systems locally store messages in this format (which eliminates the
+   need for translation between formats) and others use formats that
+   differ from the one specified in this standard, local storage is
+   outside of the scope of this standard.
+
+
+
+
+Resnick                     Standards Track                     [Page 3]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+   Note: This standard is not intended to dictate the internal formats
+   used by sites, the specific message system features that they are
+   expected to support, or any of the characteristics of user interface
+   programs that create or read messages.  In addition, this standard
+   does not specify an encoding of the characters for either transport
+   or storage; that is, it does not specify the number of bits used or
+   how those bits are specifically transferred over the wire or stored
+   on disk.
+
+1.2. Notational conventions
+
+1.2.1. Requirements notation
+
+   This document occasionally uses terms that appear in capital letters.
+   When the terms "MUST", "SHOULD", "RECOMMENDED", "MUST NOT", "SHOULD
+   NOT", and "MAY" appear capitalized, they are being used to indicate
+   particular requirements of this specification.  A discussion of the
+   meanings of these terms appears in [RFC2119].
+
+1.2.2. Syntactic notation
+
+   This standard uses the Augmented Backus-Naur Form (ABNF) notation
+   specified in [RFC2234] for the formal definitions of the syntax of
+   messages.  Characters will be specified either by a decimal value
+   (e.g., the value %d65 for uppercase A and %d97 for lowercase A) or by
+   a case-insensitive literal value enclosed in quotation marks (e.g.,
+   "A" for either uppercase or lowercase A).  See [RFC2234] for the full
+   description of the notation.
+
+1.3. Structure of this document
+
+   This document is divided into several sections.
+
+   This section, section 1, is a short introduction to the document.
+
+   Section 2 lays out the general description of a message and its
+   constituent parts.  This is an overview to help the reader understand
+   some of the general principles used in the later portions of this
+   document.  Any examples in this section MUST NOT be taken as
+   specification of the formal syntax of any part of a message.
+
+   Section 3 specifies formal ABNF rules for the structure of each part
+   of a message (the syntax) and describes the relationship between
+   those parts and their meaning in the context of a message (the
+   semantics).  That is, it describes the actual rules for the structure
+   of each part of a message (the syntax) as well as a description of
+   the parts and instructions on how they ought to be interpreted (the
+   semantics).  This includes analysis of the syntax and semantics of
+
+
+
+Resnick                     Standards Track                     [Page 4]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+   subparts of messages that have specific structure.  The syntax
+   included in section 3 represents messages as they MUST be created.
+   There are also notes in section 3 to indicate if any of the options
+   specified in the syntax SHOULD be used over any of the others.
+
+   Both sections 2 and 3 describe messages that are legal to generate
+   for purposes of this standard.
+
+   Section 4 of this document specifies an "obsolete" syntax.  There are
+   references in section 3 to these obsolete syntactic elements.  The
+   rules of the obsolete syntax are elements that have appeared in
+   earlier revisions of this standard or have previously been widely
+   used in Internet messages.  As such, these elements MUST be
+   interpreted by parsers of messages in order to be conformant to this
+   standard.  However, since items in this syntax have been determined
+   to be non-interoperable or to cause significant problems for
+   recipients of messages, they MUST NOT be generated by creators of
+   conformant messages.
+
+   Section 5 details security considerations to take into account when
+   implementing this standard.
+
+   Section 6 is a bibliography of references in this document.
+
+   Section 7 contains the editor's address.
+
+   Section 8 contains acknowledgements.
+
+   Appendix A lists examples of different sorts of messages.  These
+   examples are not exhaustive of the types of messages that appear on
+   the Internet, but give a broad overview of certain syntactic forms.
+
+   Appendix B lists the differences between this standard and earlier
+   standards for Internet messages.
+
+   Appendix C has copyright and intellectual property notices.
+
+2. Lexical Analysis of Messages
+
+2.1. General Description
+
+   At the most basic level, a message is a series of characters.  A
+   message that is conformant with this standard is comprised of
+   characters with values in the range 1 through 127 and interpreted as
+   US-ASCII characters [ASCII].  For brevity, this document sometimes
+   refers to this range of characters as simply "US-ASCII characters".
+
+
+
+
+
+Resnick                     Standards Track                     [Page 5]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+   Note: This standard specifies that messages are made up of characters
+   in the US-ASCII range of 1 through 127.  There are other documents,
+   specifically the MIME document series [RFC2045, RFC2046, RFC2047,
+   RFC2048, RFC2049], that extend this standard to allow for values
+   outside of that range.  Discussion of those mechanisms is not within
+   the scope of this standard.
+
+   Messages are divided into lines of characters.  A line is a series of
+   characters that is delimited with the two characters carriage-return
+   and line-feed; that is, the carriage return (CR) character (ASCII
+   value 13) followed immediately by the line feed (LF) character (ASCII
+   value 10).  (The carriage-return/line-feed pair is usually written in
+   this document as "CRLF".)
+
+   A message consists of header fields (collectively called "the header
+   of the message") followed, optionally, by a body.  The header is a
+   sequence of lines of characters with special syntax as defined in
+   this standard. The body is simply a sequence of characters that
+   follows the header and is separated from the header by an empty line
+   (i.e., a line with nothing preceding the CRLF).
+
+2.1.1. Line Length Limits
+
+   There are two limits that this standard places on the number of
+   characters in a line. Each line of characters MUST be no more than
+   998 characters, and SHOULD be no more than 78 characters, excluding
+   the CRLF.
+
+   The 998 character limit is due to limitations in many implementations
+   which send, receive, or store Internet Message Format messages that
+   simply cannot handle more than 998 characters on a line. Receiving
+   implementations would do well to handle an arbitrarily large number
+   of characters in a line for robustness sake. However, there are so
+   many implementations which (in compliance with the transport
+   requirements of [RFC2821]) do not accept messages containing more
+   than 1000 character including the CR and LF per line, it is important
+   for implementations not to create such messages.
+
+   The more conservative 78 character recommendation is to accommodate
+   the many implementations of user interfaces that display these
+   messages which may truncate, or disastrously wrap, the display of
+   more than 78 characters per line, in spite of the fact that such
+   implementations are non-conformant to the intent of this
+   specification (and that of [RFC2821] if they actually cause
+   information to be lost). Again, even though this limitation is put on
+   messages, it is encumbant upon implementations which display messages
+
+
+
+
+
+Resnick                     Standards Track                     [Page 6]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+   to handle an arbitrarily large number of characters in a line
+   (certainly at least up to the 998 character limit) for the sake of
+   robustness.
+
+2.2. Header Fields
+
+   Header fields are lines composed of a field name, followed by a colon
+   (":"), followed by a field body, and terminated by CRLF.  A field
+   name MUST be composed of printable US-ASCII characters (i.e.,
+   characters that have values between 33 and 126, inclusive), except
+   colon.  A field body may be composed of any US-ASCII characters,
+   except for CR and LF.  However, a field body may contain CRLF when
+   used in header "folding" and  "unfolding" as described in section
+   2.2.3.  All field bodies MUST conform to the syntax described in
+   sections 3 and 4 of this standard.
+
+2.2.1. Unstructured Header Field Bodies
+
+   Some field bodies in this standard are defined simply as
+   "unstructured" (which is specified below as any US-ASCII characters,
+   except for CR and LF) with no further restrictions.  These are
+   referred to as unstructured field bodies.  Semantically, unstructured
+   field bodies are simply to be treated as a single line of characters
+   with no further processing (except for header "folding" and
+   "unfolding" as described in section 2.2.3).
+
+2.2.2. Structured Header Field Bodies
+
+   Some field bodies in this standard have specific syntactical
+   structure more restrictive than the unstructured field bodies
+   described above. These are referred to as "structured" field bodies.
+   Structured field bodies are sequences of specific lexical tokens as
+   described in sections 3 and 4 of this standard.  Many of these tokens
+   are allowed (according to their syntax) to be introduced or end with
+   comments (as described in section 3.2.3) as well as the space (SP,
+   ASCII value 32) and horizontal tab (HTAB, ASCII value 9) characters
+   (together known as the white space characters, WSP), and those WSP
+   characters are subject to header "folding" and "unfolding" as
+   described in section 2.2.3.  Semantic analysis of structured field
+   bodies is given along with their syntax.
+
+2.2.3. Long Header Fields
+
+   Each header field is logically a single line of characters comprising
+   the field name, the colon, and the field body.  For convenience
+   however, and to deal with the 998/78 character limitations per line,
+   the field body portion of a header field can be split into a multiple
+   line representation; this is called "folding".  The general rule is
+
+
+
+Resnick                     Standards Track                     [Page 7]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+   that wherever this standard allows for folding white space (not
+   simply WSP characters), a CRLF may be inserted before any WSP.  For
+   example, the header field:
+
+           Subject: This is a test
+
+   can be represented as:
+
+           Subject: This
+            is a test
+
+   Note: Though structured field bodies are defined in such a way that
+   folding can take place between many of the lexical tokens (and even
+   within some of the lexical tokens), folding SHOULD be limited to
+   placing the CRLF at higher-level syntactic breaks.  For instance, if
+   a field body is defined as comma-separated values, it is recommended
+   that folding occur after the comma separating the structured items in
+   preference to other places where the field could be folded, even if
+   it is allowed elsewhere.
+
+   The process of moving from this folded multiple-line representation
+   of a header field to its single line representation is called
+   "unfolding". Unfolding is accomplished by simply removing any CRLF
+   that is immediately followed by WSP.  Each header field should be
+   treated in its unfolded form for further syntactic and semantic
+   evaluation.
+
+2.3. Body
+
+   The body of a message is simply lines of US-ASCII characters.  The
+   only two limitations on the body are as follows:
+
+   - CR and LF MUST only occur together as CRLF; they MUST NOT appear
+     independently in the body.
+
+   - Lines of characters in the body MUST be limited to 998 characters,
+     and SHOULD be limited to 78 characters, excluding the CRLF.
+
+   Note: As was stated earlier, there are other standards documents,
+   specifically the MIME documents [RFC2045, RFC2046, RFC2048, RFC2049]
+   that extend this standard to allow for different sorts of message
+   bodies.  Again, these mechanisms are beyond the scope of this
+   document.
+
+
+
+
+
+
+
+
+Resnick                     Standards Track                     [Page 8]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+3. Syntax
+
+3.1. Introduction
+
+   The syntax as given in this section defines the legal syntax of
+   Internet messages.  Messages that are conformant to this standard
+   MUST conform to the syntax in this section.  If there are options in
+   this section where one option SHOULD be generated, that is indicated
+   either in the prose or in a comment next to the syntax.
+
+   For the defined expressions, a short description of the syntax and
+   use is given, followed by the syntax in ABNF, followed by a semantic
+   analysis.  Primitive tokens that are used but otherwise unspecified
+   come from [RFC2234].
+
+   In some of the definitions, there will be nonterminals whose names
+   start with "obs-".  These "obs-" elements refer to tokens defined in
+   the obsolete syntax in section 4.  In all cases, these productions
+   are to be ignored for the purposes of generating legal Internet
+   messages and MUST NOT be used as part of such a message.  However,
+   when interpreting messages, these tokens MUST be honored as part of
+   the legal syntax.  In this sense, section 3 defines a grammar for
+   generation of messages, with "obs-" elements that are to be ignored,
+   while section 4 adds grammar for interpretation of messages.
+
+3.2. Lexical Tokens
+
+   The following rules are used to define an underlying lexical
+   analyzer, which feeds tokens to the higher-level parsers.  This
+   section defines the tokens used in structured header field bodies.
+
+   Note: Readers of this standard need to pay special attention to how
+   these lexical tokens are used in both the lower-level and
+   higher-level syntax later in the document.  Particularly, the white
+   space tokens and the comment tokens defined in section 3.2.3 get used
+   in the lower-level tokens defined here, and those lower-level tokens
+   are in turn used as parts of the higher-level tokens defined later.
+   Therefore, the white space and comments may be allowed in the
+   higher-level tokens even though they may not explicitly appear in a
+   particular definition.
+
+3.2.1. Primitive Tokens
+
+   The following are primitive tokens referred to elsewhere in this
+   standard, but not otherwise defined in [RFC2234].  Some of them will
+   not appear anywhere else in the syntax, but they are convenient to
+   refer to in other parts of this document.
+
+
+
+
+Resnick                     Standards Track                     [Page 9]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+   Note: The "specials" below are just such an example.  Though the
+   specials token does not appear anywhere else in this standard, it is
+   useful for implementers who use tools that lexically analyze
+   messages.  Each of the characters in specials can be used to indicate
+   a tokenization point in lexical analysis.
+
+NO-WS-CTL       =       %d1-8 /         ; US-ASCII control characters
+                        %d11 /          ;  that do not include the
+                        %d12 /          ;  carriage return, line feed,
+                        %d14-31 /       ;  and white space characters
+                        %d127
+
+text            =       %d1-9 /         ; Characters excluding CR and LF
+                        %d11 /
+                        %d12 /
+                        %d14-127 /
+                        obs-text
+
+specials        =       "(" / ")" /     ; Special characters used in
+                        "<" / ">" /     ;  other parts of the syntax
+                        "[" / "]" /
+                        ":" / ";" /
+                        "@" / "\" /
+                        "," / "." /
+                        DQUOTE
+
+   No special semantics are attached to these tokens.  They are simply
+   single characters.
+
+3.2.2. Quoted characters
+
+   Some characters are reserved for special interpretation, such as
+   delimiting lexical tokens.  To permit use of these characters as
+   uninterpreted data, a quoting mechanism is provided.
+
+quoted-pair     =       ("\" text) / obs-qp
+
+   Where any quoted-pair appears, it is to be interpreted as the text
+   character alone.  That is to say, the "\" character that appears as
+   part of a quoted-pair is semantically "invisible".
+
+   Note: The "\" character may appear in a message where it is not part
+   of a quoted-pair.  A "\" character that does not appear in a
+   quoted-pair is not semantically invisible.  The only places in this
+   standard where quoted-pair currently appears are ccontent, qcontent,
+   dcontent, no-fold-quote, and no-fold-literal.
+
+
+
+
+
+Resnick                     Standards Track                    [Page 10]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+3.2.3. Folding white space and comments
+
+   White space characters, including white space used in folding
+   (described in section 2.2.3), may appear between many elements in
+   header field bodies.  Also, strings of characters that are treated as
+   comments may be included in structured field bodies as characters
+   enclosed in parentheses.  The following defines the folding white
+   space (FWS) and comment constructs.
+
+   Strings of characters enclosed in parentheses are considered comments
+   so long as they do not appear within a "quoted-string", as defined in
+   section 3.2.5.  Comments may nest.
+
+   There are several places in this standard where comments and FWS may
+   be freely inserted.  To accommodate that syntax, an additional token
+   for "CFWS" is defined for places where comments and/or FWS can occur.
+   However, where CFWS occurs in this standard, it MUST NOT be inserted
+   in such a way that any line of a folded header field is made up
+   entirely of WSP characters and nothing else.
+
+FWS             =       ([*WSP CRLF] 1*WSP) /   ; Folding white space
+                        obs-FWS
+
+ctext           =       NO-WS-CTL /     ; Non white space controls
+
+                        %d33-39 /       ; The rest of the US-ASCII
+                        %d42-91 /       ;  characters not including "(",
+                        %d93-126        ;  ")", or "\"
+
+ccontent        =       ctext / quoted-pair / comment
+
+comment         =       "(" *([FWS] ccontent) [FWS] ")"
+
+CFWS            =       *([FWS] comment) (([FWS] comment) / FWS)
+
+   Throughout this standard, where FWS (the folding white space token)
+   appears, it indicates a place where header folding, as discussed in
+   section 2.2.3, may take place.  Wherever header folding appears in a
+   message (that is, a header field body containing a CRLF followed by
+   any WSP), header unfolding (removal of the CRLF) is performed before
+   any further lexical analysis is performed on that header field
+   according to this standard.  That is to say, any CRLF that appears in
+   FWS is semantically "invisible."
+
+   A comment is normally used in a structured field body to provide some
+   human readable informational text.  Since a comment is allowed to
+   contain FWS, folding is permitted within the comment.  Also note that
+   since quoted-pair is allowed in a comment, the parentheses and
+
+
+
+Resnick                     Standards Track                    [Page 11]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+   backslash characters may appear in a comment so long as they appear
+   as a quoted-pair.  Semantically, the enclosing parentheses are not
+   part of the comment; the comment is what is contained between the two
+   parentheses.  As stated earlier, the "\" in any quoted-pair and the
+   CRLF in any FWS that appears within the comment are semantically
+   "invisible" and therefore not part of the comment either.
+
+   Runs of FWS, comment or CFWS that occur between lexical tokens in a
+   structured field header are semantically interpreted as a single
+   space character.
+
+3.2.4. Atom
+
+   Several productions in structured header field bodies are simply
+   strings of certain basic characters.  Such productions are called
+   atoms.
+
+   Some of the structured header field bodies also allow the period
+   character (".", ASCII value 46) within runs of atext.  An additional
+   "dot-atom" token is defined for those purposes.
+
+atext           =       ALPHA / DIGIT / ; Any character except controls,
+                        "!" / "#" /     ;  SP, and specials.
+                        "$" / "%" /     ;  Used for atoms
+                        "&" / "'" /
+                        "*" / "+" /
+                        "-" / "/" /
+                        "=" / "?" /
+                        "^" / "_" /
+                        "`" / "{" /
+                        "|" / "}" /
+                        "~"
+
+atom            =       [CFWS] 1*atext [CFWS]
+
+dot-atom        =       [CFWS] dot-atom-text [CFWS]
+
+dot-atom-text   =       1*atext *("." 1*atext)
+
+   Both atom and dot-atom are interpreted as a single unit, comprised of
+   the string of characters that make it up.  Semantically, the optional
+   comments and FWS surrounding the rest of the characters are not part
+   of the atom; the atom is only the run of atext characters in an atom,
+   or the atext and "." characters in a dot-atom.
+
+
+
+
+
+
+
+Resnick                     Standards Track                    [Page 12]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+3.2.5. Quoted strings
+
+   Strings of characters that include characters other than those
+   allowed in atoms may be represented in a quoted string format, where
+   the characters are surrounded by quote (DQUOTE, ASCII value 34)
+   characters.
+
+qtext           =       NO-WS-CTL /     ; Non white space controls
+
+                        %d33 /          ; The rest of the US-ASCII
+                        %d35-91 /       ;  characters not including "\"
+                        %d93-126        ;  or the quote character
+
+qcontent        =       qtext / quoted-pair
+
+quoted-string   =       [CFWS]
+                        DQUOTE *([FWS] qcontent) [FWS] DQUOTE
+                        [CFWS]
+
+   A quoted-string is treated as a unit.  That is, quoted-string is
+   identical to atom, semantically.  Since a quoted-string is allowed to
+   contain FWS, folding is permitted.  Also note that since quoted-pair
+   is allowed in a quoted-string, the quote and backslash characters may
+   appear in a quoted-string so long as they appear as a quoted-pair.
+
+   Semantically, neither the optional CFWS outside of the quote
+   characters nor the quote characters themselves are part of the
+   quoted-string; the quoted-string is what is contained between the two
+   quote characters.  As stated earlier, the "\" in any quoted-pair and
+   the CRLF in any FWS/CFWS that appears within the quoted-string are
+   semantically "invisible" and therefore not part of the quoted-string
+   either.
+
+3.2.6. Miscellaneous tokens
+
+   Three additional tokens are defined, word and phrase for combinations
+   of atoms and/or quoted-strings, and unstructured for use in
+   unstructured header fields and in some places within structured
+   header fields.
+
+word            =       atom / quoted-string
+
+phrase          =       1*word / obs-phrase
+
+
+
+
+
+
+
+
+Resnick                     Standards Track                    [Page 13]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+utext           =       NO-WS-CTL /     ; Non white space controls
+                        %d33-126 /      ; The rest of US-ASCII
+                        obs-utext
+
+unstructured    =       *([FWS] utext) [FWS]
+
+3.3. Date and Time Specification
+
+   Date and time occur in several header fields.  This section specifies
+   the syntax for a full date and time specification.  Though folding
+   white space is permitted throughout the date-time specification, it
+   is RECOMMENDED that a single space be used in each place that FWS
+   appears (whether it is required or optional); some older
+   implementations may not interpret other occurrences of folding white
+   space correctly.
+
+date-time       =       [ day-of-week "," ] date FWS time [CFWS]
+
+day-of-week     =       ([FWS] day-name) / obs-day-of-week
+
+day-name        =       "Mon" / "Tue" / "Wed" / "Thu" /
+                        "Fri" / "Sat" / "Sun"
+
+date            =       day month year
+
+year            =       4*DIGIT / obs-year
+
+month           =       (FWS month-name FWS) / obs-month
+
+month-name      =       "Jan" / "Feb" / "Mar" / "Apr" /
+                        "May" / "Jun" / "Jul" / "Aug" /
+                        "Sep" / "Oct" / "Nov" / "Dec"
+
+day             =       ([FWS] 1*2DIGIT) / obs-day
+
+time            =       time-of-day FWS zone
+
+time-of-day     =       hour ":" minute [ ":" second ]
+
+hour            =       2DIGIT / obs-hour
+
+minute          =       2DIGIT / obs-minute
+
+second          =       2DIGIT / obs-second
+
+zone            =       (( "+" / "-" ) 4DIGIT) / obs-zone
+
+
+
+
+
+Resnick                     Standards Track                    [Page 14]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+   The day is the numeric day of the month.  The year is any numeric
+   year 1900 or later.
+
+   The time-of-day specifies the number of hours, minutes, and
+   optionally seconds since midnight of the date indicated.
+
+   The date and time-of-day SHOULD express local time.
+
+   The zone specifies the offset from Coordinated Universal Time (UTC,
+   formerly referred to as "Greenwich Mean Time") that the date and
+   time-of-day represent.  The "+" or "-" indicates whether the
+   time-of-day is ahead of (i.e., east of) or behind (i.e., west of)
+   Universal Time.  The first two digits indicate the number of hours
+   difference from Universal Time, and the last two digits indicate the
+   number of minutes difference from Universal Time.  (Hence, +hhmm
+   means +(hh * 60 + mm) minutes, and -hhmm means -(hh * 60 + mm)
+   minutes).  The form "+0000" SHOULD be used to indicate a time zone at
+   Universal Time.  Though "-0000" also indicates Universal Time, it is
+   used to indicate that the time was generated on a system that may be
+   in a local time zone other than Universal Time and therefore
+   indicates that the date-time contains no information about the local
+   time zone.
+
+   A date-time specification MUST be semantically valid.  That is, the
+   day-of-the-week (if included) MUST be the day implied by the date,
+   the numeric day-of-month MUST be between 1 and the number of days
+   allowed for the specified month (in the specified year), the
+   time-of-day MUST be in the range 00:00:00 through 23:59:60 (the
+   number of seconds allowing for a leap second; see [STD12]), and the
+   zone MUST be within the range -9959 through +9959.
+
+3.4. Address Specification
+
+   Addresses occur in several message header fields to indicate senders
+   and recipients of messages.  An address may either be an individual
+   mailbox, or a group of mailboxes.
+
+address         =       mailbox / group
+
+mailbox         =       name-addr / addr-spec
+
+name-addr       =       [display-name] angle-addr
+
+angle-addr      =       [CFWS] "<" addr-spec ">" [CFWS] / obs-angle-addr
+
+group           =       display-name ":" [mailbox-list / CFWS] ";"
+                        [CFWS]
+
+
+
+
+Resnick                     Standards Track                    [Page 15]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+display-name    =       phrase
+
+mailbox-list    =       (mailbox *("," mailbox)) / obs-mbox-list
+
+address-list    =       (address *("," address)) / obs-addr-list
+
+   A mailbox receives mail.  It is a conceptual entity which does not
+   necessarily pertain to file storage.  For example, some sites may
+   choose to print mail on a printer and deliver the output to the
+   addressee's desk.  Normally, a mailbox is comprised of two parts: (1)
+   an optional display name that indicates the name of the recipient
+   (which could be a person or a system) that could be displayed to the
+   user of a mail application, and (2) an addr-spec address enclosed in
+   angle brackets ("<" and ">").  There is also an alternate simple form
+   of a mailbox where the addr-spec address appears alone, without the
+   recipient's name or the angle brackets.  The Internet addr-spec
+   address is described in section 3.4.1.
+
+   Note: Some legacy implementations used the simple form where the
+   addr-spec appears without the angle brackets, but included the name
+   of the recipient in parentheses as a comment following the addr-spec.
+   Since the meaning of the information in a comment is unspecified,
+   implementations SHOULD use the full name-addr form of the mailbox,
+   instead of the legacy form, to specify the display name associated
+   with a mailbox.  Also, because some legacy implementations interpret
+   the comment, comments generally SHOULD NOT be used in address fields
+   to avoid confusing such implementations.
+
+   When it is desirable to treat several mailboxes as a single unit
+   (i.e., in a distribution list), the group construct can be used.  The
+   group construct allows the sender to indicate a named group of
+   recipients. This is done by giving a display name for the group,
+   followed by a colon, followed by a comma separated list of any number
+   of mailboxes (including zero and one), and ending with a semicolon.
+   Because the list of mailboxes can be empty, using the group construct
+   is also a simple way to communicate to recipients that the message
+   was sent to one or more named sets of recipients, without actually
+   providing the individual mailbox address for each of those
+   recipients.
+
+3.4.1. Addr-spec specification
+
+   An addr-spec is a specific Internet identifier that contains a
+   locally interpreted string followed by the at-sign character ("@",
+   ASCII value 64) followed by an Internet domain.  The locally
+   interpreted string is either a quoted-string or a dot-atom.  If the
+   string can be represented as a dot-atom (that is, it contains no
+   characters other than atext characters or "." surrounded by atext
+
+
+
+Resnick                     Standards Track                    [Page 16]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+   characters), then the dot-atom form SHOULD be used and the
+   quoted-string form SHOULD NOT be used. Comments and folding white
+   space SHOULD NOT be used around the "@" in the addr-spec.
+
+addr-spec       =       local-part "@" domain
+
+local-part      =       dot-atom / quoted-string / obs-local-part
+
+domain          =       dot-atom / domain-literal / obs-domain
+
+domain-literal  =       [CFWS] "[" *([FWS] dcontent) [FWS] "]" [CFWS]
+
+dcontent        =       dtext / quoted-pair
+
+dtext           =       NO-WS-CTL /     ; Non white space controls
+
+                        %d33-90 /       ; The rest of the US-ASCII
+                        %d94-126        ;  characters not including "[",
+                                        ;  "]", or "\"
+
+   The domain portion identifies the point to which the mail is
+   delivered. In the dot-atom form, this is interpreted as an Internet
+   domain name (either a host name or a mail exchanger name) as
+   described in [STD3, STD13, STD14].  In the domain-literal form, the
+   domain is interpreted as the literal Internet address of the
+   particular host.  In both cases, how addressing is used and how
+   messages are transported to a particular host is covered in the mail
+   transport document [RFC2821].  These mechanisms are outside of the
+   scope of this document.
+
+   The local-part portion is a domain dependent string.  In addresses,
+   it is simply interpreted on the particular host as a name of a
+   particular mailbox.
+
+3.5 Overall message syntax
+
+   A message consists of header fields, optionally followed by a message
+   body.  Lines in a message MUST be a maximum of 998 characters
+   excluding the CRLF, but it is RECOMMENDED that lines be limited to 78
+   characters excluding the CRLF.  (See section 2.1.1 for explanation.)
+   In a message body, though all of the characters listed in the text
+   rule MAY be used, the use of US-ASCII control characters (values 1
+   through 8, 11, 12, and 14 through 31) is discouraged since their
+   interpretation by receivers for display is not guaranteed.
+
+
+
+
+
+
+
+Resnick                     Standards Track                    [Page 17]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+message         =       (fields / obs-fields)
+                        [CRLF body]
+
+body            =       *(*998text CRLF) *998text
+
+   The header fields carry most of the semantic information and are
+   defined in section 3.6.  The body is simply a series of lines of text
+   which are uninterpreted for the purposes of this standard.
+
+3.6. Field definitions
+
+   The header fields of a message are defined here.  All header fields
+   have the same general syntactic structure: A field name, followed by
+   a colon, followed by the field body.  The specific syntax for each
+   header field is defined in the subsequent sections.
+
+   Note: In the ABNF syntax for each field in subsequent sections, each
+   field name is followed by the required colon.  However, for brevity
+   sometimes the colon is not referred to in the textual description of
+   the syntax.  It is, nonetheless, required.
+
+   It is important to note that the header fields are not guaranteed to
+   be in a particular order.  They may appear in any order, and they
+   have been known to be reordered occasionally when transported over
+   the Internet.  However, for the purposes of this standard, header
+   fields SHOULD NOT be reordered when a message is transported or
+   transformed.  More importantly, the trace header fields and resent
+   header fields MUST NOT be reordered, and SHOULD be kept in blocks
+   prepended to the message.  See sections 3.6.6 and 3.6.7 for more
+   information.
+
+   The only required header fields are the origination date field and
+   the originator address field(s).  All other header fields are
+   syntactically optional.  More information is contained in the table
+   following this definition.
+
+fields          =       *(trace
+                          *(resent-date /
+                           resent-from /
+                           resent-sender /
+                           resent-to /
+                           resent-cc /
+                           resent-bcc /
+                           resent-msg-id))
+                        *(orig-date /
+                        from /
+                        sender /
+                        reply-to /
+
+
+
+Resnick                     Standards Track                    [Page 18]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+                        to /
+                        cc /
+                        bcc /
+                        message-id /
+                        in-reply-to /
+                        references /
+                        subject /
+                        comments /
+                        keywords /
+                        optional-field)
+
+   The following table indicates limits on the number of times each
+   field may occur in a message header as well as any special
+   limitations on the use of those fields.  An asterisk next to a value
+   in the minimum or maximum column indicates that a special restriction
+   appears in the Notes column.
+
+Field           Min number      Max number      Notes
+
+trace           0               unlimited       Block prepended - see
+                                                3.6.7
+
+resent-date     0*              unlimited*      One per block, required
+                                                if other resent fields
+                                                present - see 3.6.6
+
+resent-from     0               unlimited*      One per block - see
+                                                3.6.6
+
+resent-sender   0*              unlimited*      One per block, MUST
+                                                occur with multi-address
+                                                resent-from - see 3.6.6
+
+resent-to       0               unlimited*      One per block - see
+                                                3.6.6
+
+resent-cc       0               unlimited*      One per block - see
+                                                3.6.6
+
+resent-bcc      0               unlimited*      One per block - see
+                                                3.6.6
+
+resent-msg-id   0               unlimited*      One per block - see
+                                                3.6.6
+
+orig-date       1               1
+
+from            1               1               See sender and 3.6.2
+
+
+
+Resnick                     Standards Track                    [Page 19]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+sender          0*              1               MUST occur with multi-
+                                                address from - see 3.6.2
+
+reply-to        0               1
+
+to              0               1
+
+cc              0               1
+
+bcc             0               1
+
+message-id      0*              1               SHOULD be present - see
+                                                3.6.4
+
+in-reply-to     0*              1               SHOULD occur in some
+                                                replies - see 3.6.4
+
+references      0*              1               SHOULD occur in some
+                                                replies - see 3.6.4
+
+subject         0               1
+
+comments        0               unlimited
+
+keywords        0               unlimited
+
+optional-field  0               unlimited
+
+   The exact interpretation of each field is described in subsequent
+   sections.
+
+3.6.1. The origination date field
+
+   The origination date field consists of the field name "Date" followed
+   by a date-time specification.
+
+orig-date       =       "Date:" date-time CRLF
+
+   The origination date specifies the date and time at which the creator
+   of the message indicated that the message was complete and ready to
+   enter the mail delivery system.  For instance, this might be the time
+   that a user pushes the "send" or "submit" button in an application
+   program.  In any case, it is specifically not intended to convey the
+   time that the message is actually transported, but rather the time at
+   which the human or other creator of the message has put the message
+   into its final form, ready for transport.  (For example, a portable
+   computer user who is not connected to a network might queue a message
+
+
+
+
+Resnick                     Standards Track                    [Page 20]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+   for delivery.  The origination date is intended to contain the date
+   and time that the user queued the message, not the time when the user
+   connected to the network to send the message.)
+
+3.6.2. Originator fields
+
+   The originator fields of a message consist of the from field, the
+   sender field (when applicable), and optionally the reply-to field.
+   The from field consists of the field name "From" and a
+   comma-separated list of one or more mailbox specifications.  If the
+   from field contains more than one mailbox specification in the
+   mailbox-list, then the sender field, containing the field name
+   "Sender" and a single mailbox specification, MUST appear in the
+   message.  In either case, an optional reply-to field MAY also be
+   included, which contains the field name "Reply-To" and a
+   comma-separated list of one or more addresses.
+
+from            =       "From:" mailbox-list CRLF
+
+sender          =       "Sender:" mailbox CRLF
+
+reply-to        =       "Reply-To:" address-list CRLF
+
+   The originator fields indicate the mailbox(es) of the source of the
+   message.  The "From:" field specifies the author(s) of the message,
+   that is, the mailbox(es) of the person(s) or system(s) responsible
+   for the writing of the message.  The "Sender:" field specifies the
+   mailbox of the agent responsible for the actual transmission of the
+   message.  For example, if a secretary were to send a message for
+   another person, the mailbox of the secretary would appear in the
+   "Sender:" field and the mailbox of the actual author would appear in
+   the "From:" field.  If the originator of the message can be indicated
+   by a single mailbox and the author and transmitter are identical, the
+   "Sender:" field SHOULD NOT be used.  Otherwise, both fields SHOULD
+   appear.
+
+   The originator fields also provide the information required when
+   replying to a message.  When the "Reply-To:" field is present, it
+   indicates the mailbox(es) to which the author of the message suggests
+   that replies be sent.  In the absence of the "Reply-To:" field,
+   replies SHOULD by default be sent to the mailbox(es) specified in the
+   "From:" field unless otherwise specified by the person composing the
+   reply.
+
+   In all cases, the "From:" field SHOULD NOT contain any mailbox that
+   does not belong to the author(s) of the message.  See also section
+   3.6.3 for more information on forming the destination addresses for a
+   reply.
+
+
+
+Resnick                     Standards Track                    [Page 21]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+3.6.3. Destination address fields
+
+   The destination fields of a message consist of three possible fields,
+   each of the same form: The field name, which is either "To", "Cc", or
+   "Bcc", followed by a comma-separated list of one or more addresses
+   (either mailbox or group syntax).
+
+to              =       "To:" address-list CRLF
+
+cc              =       "Cc:" address-list CRLF
+
+bcc             =       "Bcc:" (address-list / [CFWS]) CRLF
+
+   The destination fields specify the recipients of the message.  Each
+   destination field may have one or more addresses, and each of the
+   addresses indicate the intended recipients of the message.  The only
+   difference between the three fields is how each is used.
+
+   The "To:" field contains the address(es) of the primary recipient(s)
+   of the message.
+
+   The "Cc:" field (where the "Cc" means "Carbon Copy" in the sense of
+   making a copy on a typewriter using carbon paper) contains the
+   addresses of others who are to receive the message, though the
+   content of the message may not be directed at them.
+
+   The "Bcc:" field (where the "Bcc" means "Blind Carbon Copy") contains
+   addresses of recipients of the message whose addresses are not to be
+   revealed to other recipients of the message.  There are three ways in
+   which the "Bcc:" field is used.  In the first case, when a message
+   containing a "Bcc:" field is prepared to be sent, the "Bcc:" line is
+   removed even though all of the recipients (including those specified
+   in the "Bcc:" field) are sent a copy of the message.  In the second
+   case, recipients specified in the "To:" and "Cc:" lines each are sent
+   a copy of the message with the "Bcc:" line removed as above, but the
+   recipients on the "Bcc:" line get a separate copy of the message
+   containing a "Bcc:" line.  (When there are multiple recipient
+   addresses in the "Bcc:" field, some implementations actually send a
+   separate copy of the message to each recipient with a "Bcc:"
+   containing only the address of that particular recipient.) Finally,
+   since a "Bcc:" field may contain no addresses, a "Bcc:" field can be
+   sent without any addresses indicating to the recipients that blind
+   copies were sent to someone.  Which method to use with "Bcc:" fields
+   is implementation dependent, but refer to the "Security
+   Considerations" section of this document for a discussion of each.
+
+
+
+
+
+
+Resnick                     Standards Track                    [Page 22]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+   When a message is a reply to another message, the mailboxes of the
+   authors of the original message (the mailboxes in the "From:" field)
+   or mailboxes specified in the "Reply-To:" field (if it exists) MAY
+   appear in the "To:" field of the reply since these would normally be
+   the primary recipients of the reply.  If a reply is sent to a message
+   that has destination fields, it is often desirable to send a copy of
+   the reply to all of the recipients of the message, in addition to the
+   author.  When such a reply is formed, addresses in the "To:" and
+   "Cc:" fields of the original message MAY appear in the "Cc:" field of
+   the reply, since these are normally secondary recipients of the
+   reply.  If a "Bcc:" field is present in the original message,
+   addresses in that field MAY appear in the "Bcc:" field of the reply,
+   but SHOULD NOT appear in the "To:" or "Cc:" fields.
+
+   Note: Some mail applications have automatic reply commands that
+   include the destination addresses of the original message in the
+   destination addresses of the reply.  How those reply commands behave
+   is implementation dependent and is beyond the scope of this document.
+   In particular, whether or not to include the original destination
+   addresses when the original message had a "Reply-To:" field is not
+   addressed here.
+
+3.6.4. Identification fields
+
+   Though optional, every message SHOULD have a "Message-ID:" field.
+   Furthermore, reply messages SHOULD have "In-Reply-To:" and
+   "References:" fields as appropriate, as described below.
+
+   The "Message-ID:" field contains a single unique message identifier.
+   The "References:" and "In-Reply-To:" field each contain one or more
+   unique message identifiers, optionally separated by CFWS.
+
+   The message identifier (msg-id) is similar in syntax to an angle-addr
+   construct without the internal CFWS.
+
+message-id      =       "Message-ID:" msg-id CRLF
+
+in-reply-to     =       "In-Reply-To:" 1*msg-id CRLF
+
+references      =       "References:" 1*msg-id CRLF
+
+msg-id          =       [CFWS] "<" id-left "@" id-right ">" [CFWS]
+
+id-left         =       dot-atom-text / no-fold-quote / obs-id-left
+
+id-right        =       dot-atom-text / no-fold-literal / obs-id-right
+
+no-fold-quote   =       DQUOTE *(qtext / quoted-pair) DQUOTE
+
+
+
+Resnick                     Standards Track                    [Page 23]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+no-fold-literal =       "[" *(dtext / quoted-pair) "]"
+
+   The "Message-ID:" field provides a unique message identifier that
+   refers to a particular version of a particular message.  The
+   uniqueness of the message identifier is guaranteed by the host that
+   generates it (see below).  This message identifier is intended to be
+   machine readable and not necessarily meaningful to humans.  A message
+   identifier pertains to exactly one instantiation of a particular
+   message; subsequent revisions to the message each receive new message
+   identifiers.
+
+   Note: There are many instances when messages are "changed", but those
+   changes do not constitute a new instantiation of that message, and
+   therefore the message would not get a new message identifier.  For
+   example, when messages are introduced into the transport system, they
+   are often prepended with additional header fields such as trace
+   fields (described in section 3.6.7) and resent fields (described in
+   section 3.6.6).  The addition of such header fields does not change
+   the identity of the message and therefore the original "Message-ID:"
+   field is retained.  In all cases, it is the meaning that the sender
+   of the message wishes to convey (i.e., whether this is the same
+   message or a different message) that determines whether or not the
+   "Message-ID:" field changes, not any particular syntactic difference
+   that appears (or does not appear) in the message.
+
+   The "In-Reply-To:" and "References:" fields are used when creating a
+   reply to a message.  They hold the message identifier of the original
+   message and the message identifiers of other messages (for example,
+   in the case of a reply to a message which was itself a reply).  The
+   "In-Reply-To:" field may be used to identify the message (or
+   messages) to which the new message is a reply, while the
+   "References:" field may be used to identify a "thread" of
+   conversation.
+
+   When creating a reply to a message, the "In-Reply-To:" and
+   "References:" fields of the resultant message are constructed as
+   follows:
+
+   The "In-Reply-To:" field will contain the contents of the "Message-
+   ID:" field of the message to which this one is a reply (the "parent
+   message").  If there is more than one parent message, then the "In-
+   Reply-To:" field will contain the contents of all of the parents'
+   "Message-ID:" fields.  If there is no "Message-ID:" field in any of
+   the parent messages, then the new message will have no "In-Reply-To:"
+   field.
+
+
+
+
+
+
+Resnick                     Standards Track                    [Page 24]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+   The "References:" field will contain the contents of the parent's
+   "References:" field (if any) followed by the contents of the parent's
+   "Message-ID:" field (if any).  If the parent message does not contain
+   a "References:" field but does have an "In-Reply-To:" field
+   containing a single message identifier, then the "References:" field
+   will contain the contents of the parent's "In-Reply-To:" field
+   followed by the contents of the parent's "Message-ID:" field (if
+   any).  If the parent has none of the "References:", "In-Reply-To:",
+   or "Message-ID:" fields, then the new message will have no
+   "References:" field.
+
+   Note: Some implementations parse the "References:" field to display
+   the "thread of the discussion".  These implementations assume that
+   each new message is a reply to a single parent and hence that they
+   can walk backwards through the "References:" field to find the parent
+   of each message listed there.  Therefore, trying to form a
+   "References:" field for a reply that has multiple parents is
+   discouraged and how to do so is not defined in this document.
+
+   The message identifier (msg-id) itself MUST be a globally unique
+   identifier for a message.  The generator of the message identifier
+   MUST guarantee that the msg-id is unique.  There are several
+   algorithms that can be used to accomplish this.  Since the msg-id has
+   a similar syntax to angle-addr (identical except that comments and
+   folding white space are not allowed), a good method is to put the
+   domain name (or a domain literal IP address) of the host on which the
+   message identifier was created on the right hand side of the "@", and
+   put a combination of the current absolute date and time along with
+   some other currently unique (perhaps sequential) identifier available
+   on the system (for example, a process id number) on the left hand
+   side.  Using a date on the left hand side and a domain name or domain
+   literal on the right hand side makes it possible to guarantee
+   uniqueness since no two hosts use the same domain name or IP address
+   at the same time.  Though other algorithms will work, it is
+   RECOMMENDED that the right hand side contain some domain identifier
+   (either of the host itself or otherwise) such that the generator of
+   the message identifier can guarantee the uniqueness of the left hand
+   side within the scope of that domain.
+
+   Semantically, the angle bracket characters are not part of the
+   msg-id; the msg-id is what is contained between the two angle bracket
+   characters.
+
+
+
+
+
+
+
+
+
+Resnick                     Standards Track                    [Page 25]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+3.6.5. Informational fields
+
+   The informational fields are all optional.  The "Keywords:" field
+   contains a comma-separated list of one or more words or
+   quoted-strings. The "Subject:" and "Comments:" fields are
+   unstructured fields as defined in section 2.2.1, and therefore may
+   contain text or folding white space.
+
+subject         =       "Subject:" unstructured CRLF
+
+comments        =       "Comments:" unstructured CRLF
+
+keywords        =       "Keywords:" phrase *("," phrase) CRLF
+
+   These three fields are intended to have only human-readable content
+   with information about the message.  The "Subject:" field is the most
+   common and contains a short string identifying the topic of the
+   message.  When used in a reply, the field body MAY start with the
+   string "Re: " (from the Latin "res", in the matter of) followed by
+   the contents of the "Subject:" field body of the original message.
+   If this is done, only one instance of the literal string "Re: " ought
+   to be used since use of other strings or more than one instance can
+   lead to undesirable consequences.  The "Comments:" field contains any
+   additional comments on the text of the body of the message.  The
+   "Keywords:" field contains a comma-separated list of important words
+   and phrases that might be useful for the recipient.
+
+3.6.6. Resent fields
+
+   Resent fields SHOULD be added to any message that is reintroduced by
+   a user into the transport system.  A separate set of resent fields
+   SHOULD be added each time this is done.  All of the resent fields
+   corresponding to a particular resending of the message SHOULD be
+   together.  Each new set of resent fields is prepended to the message;
+   that is, the most recent set of resent fields appear earlier in the
+   message.  No other fields in the message are changed when resent
+   fields are added.
+
+   Each of the resent fields corresponds to a particular field elsewhere
+   in the syntax.  For instance, the "Resent-Date:" field corresponds to
+   the "Date:" field and the "Resent-To:" field corresponds to the "To:"
+   field.  In each case, the syntax for the field body is identical to
+   the syntax given previously for the corresponding field.
+
+   When resent fields are used, the "Resent-From:" and "Resent-Date:"
+   fields MUST be sent.  The "Resent-Message-ID:" field SHOULD be sent.
+   "Resent-Sender:" SHOULD NOT be used if "Resent-Sender:" would be
+   identical to "Resent-From:".
+
+
+
+Resnick                     Standards Track                    [Page 26]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+resent-date     =       "Resent-Date:" date-time CRLF
+
+resent-from     =       "Resent-From:" mailbox-list CRLF
+
+resent-sender   =       "Resent-Sender:" mailbox CRLF
+
+resent-to       =       "Resent-To:" address-list CRLF
+
+resent-cc       =       "Resent-Cc:" address-list CRLF
+
+resent-bcc      =       "Resent-Bcc:" (address-list / [CFWS]) CRLF
+
+resent-msg-id   =       "Resent-Message-ID:" msg-id CRLF
+
+   Resent fields are used to identify a message as having been
+   reintroduced into the transport system by a user.  The purpose of
+   using resent fields is to have the message appear to the final
+   recipient as if it were sent directly by the original sender, with
+   all of the original fields remaining the same.  Each set of resent
+   fields correspond to a particular resending event.  That is, if a
+   message is resent multiple times, each set of resent fields gives
+   identifying information for each individual time.  Resent fields are
+   strictly informational.  They MUST NOT be used in the normal
+   processing of replies or other such automatic actions on messages.
+
+   Note: Reintroducing a message into the transport system and using
+   resent fields is a different operation from "forwarding".
+   "Forwarding" has two meanings: One sense of forwarding is that a mail
+   reading program can be told by a user to forward a copy of a message
+   to another person, making the forwarded message the body of the new
+   message.  A forwarded message in this sense does not appear to have
+   come from the original sender, but is an entirely new message from
+   the forwarder of the message.  On the other hand, forwarding is also
+   used to mean when a mail transport program gets a message and
+   forwards it on to a different destination for final delivery.  Resent
+   header fields are not intended for use with either type of
+   forwarding.
+
+   The resent originator fields indicate the mailbox of the person(s) or
+   system(s) that resent the message.  As with the regular originator
+   fields, there are two forms: a simple "Resent-From:" form which
+   contains the mailbox of the individual doing the resending, and the
+   more complex form, when one individual (identified in the
+   "Resent-Sender:" field) resends a message on behalf of one or more
+   others (identified in the "Resent-From:" field).
+
+   Note: When replying to a resent message, replies behave just as they
+   would with any other message, using the original "From:",
+
+
+
+Resnick                     Standards Track                    [Page 27]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+   "Reply-To:", "Message-ID:", and other fields.  The resent fields are
+   only informational and MUST NOT be used in the normal processing of
+   replies.
+
+   The "Resent-Date:" indicates the date and time at which the resent
+   message is dispatched by the resender of the message.  Like the
+   "Date:" field, it is not the date and time that the message was
+   actually transported.
+
+   The "Resent-To:", "Resent-Cc:", and "Resent-Bcc:" fields function
+   identically to the "To:", "Cc:", and "Bcc:" fields respectively,
+   except that they indicate the recipients of the resent message, not
+   the recipients of the original message.
+
+   The "Resent-Message-ID:" field provides a unique identifier for the
+   resent message.
+
+3.6.7. Trace fields
+
+   The trace fields are a group of header fields consisting of an
+   optional "Return-Path:" field, and one or more "Received:" fields.
+   The "Return-Path:" header field contains a pair of angle brackets
+   that enclose an optional addr-spec.  The "Received:" field contains a
+   (possibly empty) list of name/value pairs followed by a semicolon and
+   a date-time specification.  The first item of the name/value pair is
+   defined by item-name, and the second item is either an addr-spec, an
+   atom, a domain, or a msg-id.  Further restrictions may be applied to
+   the syntax of the trace fields by standards that provide for their
+   use, such as [RFC2821].
+
+trace           =       [return]
+                        1*received
+
+return          =       "Return-Path:" path CRLF
+
+path            =       ([CFWS] "<" ([CFWS] / addr-spec) ">" [CFWS]) /
+                        obs-path
+
+received        =       "Received:" name-val-list ";" date-time CRLF
+
+name-val-list   =       [CFWS] [name-val-pair *(CFWS name-val-pair)]
+
+name-val-pair   =       item-name CFWS item-value
+
+item-name       =       ALPHA *(["-"] (ALPHA / DIGIT))
+
+item-value      =       1*angle-addr / addr-spec /
+                         atom / domain / msg-id
+
+
+
+Resnick                     Standards Track                    [Page 28]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+   A full discussion of the Internet mail use of trace fields is
+   contained in [RFC2821].  For the purposes of this standard, the trace
+   fields are strictly informational, and any formal interpretation of
+   them is outside of the scope of this document.
+
+3.6.8. Optional fields
+
+   Fields may appear in messages that are otherwise unspecified in this
+   standard.  They MUST conform to the syntax of an optional-field.
+   This is a field name, made up of the printable US-ASCII characters
+   except SP and colon, followed by a colon, followed by any text which
+   conforms to unstructured.
+
+   The field names of any optional-field MUST NOT be identical to any
+   field name specified elsewhere in this standard.
+
+optional-field  =       field-name ":" unstructured CRLF
+
+field-name      =       1*ftext
+
+ftext           =       %d33-57 /               ; Any character except
+                        %d59-126                ;  controls, SP, and
+                                                ;  ":".
+
+   For the purposes of this standard, any optional field is
+   uninterpreted.
+
+4. Obsolete Syntax
+
+   Earlier versions of this standard allowed for different (usually more
+   liberal) syntax than is allowed in this version.  Also, there have
+   been syntactic elements used in messages on the Internet whose
+   interpretation have never been documented.  Though some of these
+   syntactic forms MUST NOT be generated according to the grammar in
+   section 3, they MUST be accepted and parsed by a conformant receiver.
+   This section documents many of these syntactic elements.  Taking the
+   grammar in section 3 and adding the definitions presented in this
+   section will result in the grammar to use for interpretation of
+   messages.
+
+   Note: This section identifies syntactic forms that any implementation
+   MUST reasonably interpret.  However, there are certainly Internet
+   messages which do not conform to even the additional syntax given in
+   this section.  The fact that a particular form does not appear in any
+   section of this document is not justification for computer programs
+   to crash or for malformed data to be irretrievably lost by any
+   implementation.  To repeat an example, though this document requires
+   lines in messages to be no longer than 998 characters, silently
+
+
+
+Resnick                     Standards Track                    [Page 29]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+   discarding the 999th and subsequent characters in a line without
+   warning would still be bad behavior for an implementation.  It is up
+   to the implementation to deal with messages robustly.
+
+   One important difference between the obsolete (interpreting) and the
+   current (generating) syntax is that in structured header field bodies
+   (i.e., between the colon and the CRLF of any structured header
+   field), white space characters, including folding white space, and
+   comments can be freely inserted between any syntactic tokens.  This
+   allows many complex forms that have proven difficult for some
+   implementations to parse.
+
+   Another key difference between the obsolete and the current syntax is
+   that the rule in section 3.2.3 regarding lines composed entirely of
+   white space in comments and folding white space does not apply.  See
+   the discussion of folding white space in section 4.2 below.
+
+   Finally, certain characters that were formerly allowed in messages
+   appear in this section.  The NUL character (ASCII value 0) was once
+   allowed, but is no longer for compatibility reasons.  CR and LF were
+   allowed to appear in messages other than as CRLF; this use is also
+   shown here.
+
+   Other differences in syntax and semantics are noted in the following
+   sections.
+
+4.1. Miscellaneous obsolete tokens
+
+   These syntactic elements are used elsewhere in the obsolete syntax or
+   in the main syntax.  The obs-char and obs-qp elements each add ASCII
+   value 0. Bare CR and bare LF are added to obs-text and obs-utext.
+   The period character is added to obs-phrase. The obs-phrase-list
+   provides for "empty" elements in a comma-separated list of phrases.
+
+   Note: The "period" (or "full stop") character (".") in obs-phrase is
+   not a form that was allowed in earlier versions of this or any other
+   standard.  Period (nor any other character from specials) was not
+   allowed in phrase because it introduced a parsing difficulty
+   distinguishing between phrases and portions of an addr-spec (see
+   section 4.4).  It appears here because the period character is
+   currently used in many messages in the display-name portion of
+   addresses, especially for initials in names, and therefore must be
+   interpreted properly.  In the future, period may appear in the
+   regular syntax of phrase.
+
+obs-qp          =       "\" (%d0-127)
+
+obs-text        =       *LF *CR *(obs-char *LF *CR)
+
+
+
+Resnick                     Standards Track                    [Page 30]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+obs-char        =       %d0-9 / %d11 /          ; %d0-127 except CR and
+                        %d12 / %d14-127         ;  LF
+
+obs-utext       =       obs-text
+
+obs-phrase      =       word *(word / "." / CFWS)
+
+obs-phrase-list =       phrase / 1*([phrase] [CFWS] "," [CFWS]) [phrase]
+
+   Bare CR and bare LF appear in messages with two different meanings.
+   In many cases, bare CR or bare LF are used improperly instead of CRLF
+   to indicate line separators.  In other cases, bare CR and bare LF are
+   used simply as ASCII control characters with their traditional ASCII
+   meanings.
+
+4.2. Obsolete folding white space
+
+   In the obsolete syntax, any amount of folding white space MAY be
+   inserted where the obs-FWS rule is allowed.  This creates the
+   possibility of having two consecutive "folds" in a line, and
+   therefore the possibility that a line which makes up a folded header
+   field could be composed entirely of white space.
+
+   obs-FWS         =       1*WSP *(CRLF 1*WSP)
+
+4.3. Obsolete Date and Time
+
+   The syntax for the obsolete date format allows a 2 digit year in the
+   date field and allows for a list of alphabetic time zone
+   specifications that were used in earlier versions of this standard.
+   It also permits comments and folding white space between many of the
+   tokens.
+
+obs-day-of-week =       [CFWS] day-name [CFWS]
+
+obs-year        =       [CFWS] 2*DIGIT [CFWS]
+
+obs-month       =       CFWS month-name CFWS
+
+obs-day         =       [CFWS] 1*2DIGIT [CFWS]
+
+obs-hour        =       [CFWS] 2DIGIT [CFWS]
+
+obs-minute      =       [CFWS] 2DIGIT [CFWS]
+
+obs-second      =       [CFWS] 2DIGIT [CFWS]
+
+obs-zone        =       "UT" / "GMT" /          ; Universal Time
+
+
+
+Resnick                     Standards Track                    [Page 31]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+                                                ; North American UT
+                                                ; offsets
+                        "EST" / "EDT" /         ; Eastern:  - 5/ - 4
+                        "CST" / "CDT" /         ; Central:  - 6/ - 5
+                        "MST" / "MDT" /         ; Mountain: - 7/ - 6
+                        "PST" / "PDT" /         ; Pacific:  - 8/ - 7
+
+                        %d65-73 /               ; Military zones - "A"
+                        %d75-90 /               ; through "I" and "K"
+                        %d97-105 /              ; through "Z", both
+                        %d107-122               ; upper and lower case
+
+   Where a two or three digit year occurs in a date, the year is to be
+   interpreted as follows: If a two digit year is encountered whose
+   value is between 00 and 49, the year is interpreted by adding 2000,
+   ending up with a value between 2000 and 2049.  If a two digit year is
+   encountered with a value between 50 and 99, or any three digit year
+   is encountered, the year is interpreted by adding 1900.
+
+   In the obsolete time zone, "UT" and "GMT" are indications of
+   "Universal Time" and "Greenwich Mean Time" respectively and are both
+   semantically identical to "+0000".
+
+   The remaining three character zones are the US time zones.  The first
+   letter, "E", "C", "M", or "P" stands for "Eastern", "Central",
+   "Mountain" and "Pacific".  The second letter is either "S" for
+   "Standard" time, or "D" for "Daylight" (or summer) time.  Their
+   interpretations are as follows:
+
+   EDT is semantically equivalent to -0400
+   EST is semantically equivalent to -0500
+   CDT is semantically equivalent to -0500
+   CST is semantically equivalent to -0600
+   MDT is semantically equivalent to -0600
+   MST is semantically equivalent to -0700
+   PDT is semantically equivalent to -0700
+   PST is semantically equivalent to -0800
+
+   The 1 character military time zones were defined in a non-standard
+   way in [RFC822] and are therefore unpredictable in their meaning.
+   The original definitions of the military zones "A" through "I" are
+   equivalent to "+0100" through "+0900" respectively; "K", "L", and "M"
+   are equivalent to  "+1000", "+1100", and "+1200" respectively; "N"
+   through "Y" are equivalent to "-0100" through "-1200" respectively;
+   and "Z" is equivalent to "+0000".  However, because of the error in
+   [RFC822], they SHOULD all be considered equivalent to "-0000" unless
+   there is out-of-band information confirming their meaning.
+
+
+
+
+Resnick                     Standards Track                    [Page 32]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+   Other multi-character (usually between 3 and 5) alphabetic time zones
+   have been used in Internet messages.  Any such time zone whose
+   meaning is not known SHOULD be considered equivalent to "-0000"
+   unless there is out-of-band information confirming their meaning.
+
+4.4. Obsolete Addressing
+
+   There are three primary differences in addressing.  First, mailbox
+   addresses were allowed to have a route portion before the addr-spec
+   when enclosed in "<" and ">".  The route is simply a comma-separated
+   list of domain names, each preceded by "@", and the list terminated
+   by a colon.  Second, CFWS were allowed between the period-separated
+   elements of local-part and domain (i.e., dot-atom was not used).  In
+   addition, local-part is allowed to contain quoted-string in addition
+   to just atom.  Finally, mailbox-list and address-list were allowed to
+   have "null" members.  That is, there could be two or more commas in
+   such a list with nothing in between them.
+
+obs-angle-addr  =       [CFWS] "<" [obs-route] addr-spec ">" [CFWS]
+
+obs-route       =       [CFWS] obs-domain-list ":" [CFWS]
+
+obs-domain-list =       "@" domain *(*(CFWS / "," ) [CFWS] "@" domain)
+
+obs-local-part  =       word *("." word)
+
+obs-domain      =       atom *("." atom)
+
+obs-mbox-list   =       1*([mailbox] [CFWS] "," [CFWS]) [mailbox]
+
+obs-addr-list   =       1*([address] [CFWS] "," [CFWS]) [address]
+
+   When interpreting addresses, the route portion SHOULD be ignored.
+
+4.5. Obsolete header fields
+
+   Syntactically, the primary difference in the obsolete field syntax is
+   that it allows multiple occurrences of any of the fields and they may
+   occur in any order.  Also, any amount of white space is allowed
+   before the ":" at the end of the field name.
+
+obs-fields      =       *(obs-return /
+                        obs-received /
+                        obs-orig-date /
+                        obs-from /
+                        obs-sender /
+                        obs-reply-to /
+                        obs-to /
+
+
+
+Resnick                     Standards Track                    [Page 33]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+                        obs-cc /
+                        obs-bcc /
+                        obs-message-id /
+                        obs-in-reply-to /
+                        obs-references /
+                        obs-subject /
+                        obs-comments /
+                        obs-keywords /
+                        obs-resent-date /
+                        obs-resent-from /
+                        obs-resent-send /
+                        obs-resent-rply /
+                        obs-resent-to /
+                        obs-resent-cc /
+                        obs-resent-bcc /
+                        obs-resent-mid /
+                        obs-optional)
+
+   Except for destination address fields (described in section 4.5.3),
+   the interpretation of multiple occurrences of fields is unspecified.
+   Also, the interpretation of trace fields and resent fields which do
+   not occur in blocks prepended to the message is unspecified as well.
+   Unless otherwise noted in the following sections, interpretation of
+   other fields is identical to the interpretation of their non-obsolete
+   counterparts in section 3.
+
+4.5.1. Obsolete origination date field
+
+obs-orig-date   =       "Date" *WSP ":" date-time CRLF
+
+4.5.2. Obsolete originator fields
+
+obs-from        =       "From" *WSP ":" mailbox-list CRLF
+
+obs-sender      =       "Sender" *WSP ":" mailbox CRLF
+
+obs-reply-to    =       "Reply-To" *WSP ":" mailbox-list CRLF
+
+4.5.3. Obsolete destination address fields
+
+obs-to          =       "To" *WSP ":" address-list CRLF
+
+obs-cc          =       "Cc" *WSP ":" address-list CRLF
+
+obs-bcc         =       "Bcc" *WSP ":" (address-list / [CFWS]) CRLF
+
+
+
+
+
+
+Resnick                     Standards Track                    [Page 34]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+   When multiple occurrences of destination address fields occur in a
+   message, they SHOULD be treated as if the address-list in the first
+   occurrence of the field is combined with the address lists of the
+   subsequent occurrences by adding a comma and concatenating.
+
+4.5.4. Obsolete identification fields
+
+   The obsolete "In-Reply-To:" and "References:" fields differ from the
+   current syntax in that they allow phrase (words or quoted strings) to
+   appear.  The obsolete forms of the left and right sides of msg-id
+   allow interspersed CFWS, making them syntactically identical to
+   local-part and domain respectively.
+
+obs-message-id  =       "Message-ID" *WSP ":" msg-id CRLF
+
+obs-in-reply-to =       "In-Reply-To" *WSP ":" *(phrase / msg-id) CRLF
+
+obs-references  =       "References" *WSP ":" *(phrase / msg-id) CRLF
+
+obs-id-left     =       local-part
+
+obs-id-right    =       domain
+
+   For purposes of interpretation, the phrases in the "In-Reply-To:" and
+   "References:" fields are ignored.
+
+   Semantically, none of the optional CFWS surrounding the local-part
+   and the domain are part of the obs-id-left and obs-id-right
+   respectively.
+
+4.5.5. Obsolete informational fields
+
+obs-subject     =       "Subject" *WSP ":" unstructured CRLF
+
+obs-comments    =       "Comments" *WSP ":" unstructured CRLF
+
+obs-keywords    =       "Keywords" *WSP ":" obs-phrase-list CRLF
+
+4.5.6. Obsolete resent fields
+
+   The obsolete syntax adds a "Resent-Reply-To:" field, which consists
+   of the field name, the optional comments and folding white space, the
+   colon, and a comma separated list of addresses.
+
+obs-resent-from =       "Resent-From" *WSP ":" mailbox-list CRLF
+
+obs-resent-send =       "Resent-Sender" *WSP ":" mailbox CRLF
+
+
+
+
+Resnick                     Standards Track                    [Page 35]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+obs-resent-date =       "Resent-Date" *WSP ":" date-time CRLF
+
+obs-resent-to   =       "Resent-To" *WSP ":" address-list CRLF
+
+obs-resent-cc   =       "Resent-Cc" *WSP ":" address-list CRLF
+
+obs-resent-bcc  =       "Resent-Bcc" *WSP ":"
+                         (address-list / [CFWS]) CRLF
+
+obs-resent-mid  =       "Resent-Message-ID" *WSP ":" msg-id CRLF
+
+obs-resent-rply =       "Resent-Reply-To" *WSP ":" address-list CRLF
+
+   As with other resent fields, the "Resent-Reply-To:" field is to be
+   treated as trace information only.
+
+4.5.7. Obsolete trace fields
+
+   The obs-return and obs-received are again given here as template
+   definitions, just as return and received are in section 3.  Their
+   full syntax is given in [RFC2821].
+
+obs-return      =       "Return-Path" *WSP ":" path CRLF
+
+obs-received    =       "Received" *WSP ":" name-val-list CRLF
+
+obs-path        =       obs-angle-addr
+
+4.5.8. Obsolete optional fields
+
+obs-optional    =       field-name *WSP ":" unstructured CRLF
+
+5. Security Considerations
+
+   Care needs to be taken when displaying messages on a terminal or
+   terminal emulator.  Powerful terminals may act on escape sequences
+   and other combinations of ASCII control characters with a variety of
+   consequences.  They can remap the keyboard or permit other
+   modifications to the terminal which could lead to denial of service
+   or even damaged data.  They can trigger (sometimes programmable)
+   answerback messages which can allow a message to cause commands to be
+   issued on the recipient's behalf.  They can also effect the operation
+   of terminal attached devices such as printers.  Message viewers may
+   wish to strip potentially dangerous terminal escape sequences from
+   the message prior to display.  However, other escape sequences appear
+   in messages for useful purposes (cf. [RFC2045, RFC2046, RFC2047,
+   RFC2048, RFC2049, ISO2022]) and therefore should not be stripped
+   indiscriminately.
+
+
+
+Resnick                     Standards Track                    [Page 36]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+   Transmission of non-text objects in messages raises additional
+   security issues.  These issues are discussed in [RFC2045, RFC2046,
+   RFC2047, RFC2048, RFC2049].
+
+   Many implementations use the "Bcc:" (blind carbon copy) field
+   described in section 3.6.3 to facilitate sending messages to
+   recipients without revealing the addresses of one or more of the
+   addressees to the other recipients.  Mishandling this use of "Bcc:"
+   has implications for confidential information that might be revealed,
+   which could eventually lead to security problems through knowledge of
+   even the existence of a particular mail address.  For example, if
+   using the first method described in section 3.6.3, where the "Bcc:"
+   line is removed from the message, blind recipients have no explicit
+   indication that they have been sent a blind copy, except insofar as
+   their address does not appear in the message header.  Because of
+   this, one of the blind addressees could potentially send a reply to
+   all of the shown recipients and accidentally reveal that the message
+   went to the blind recipient.  When the second method from section
+   3.6.3 is used, the blind recipient's address appears in the "Bcc:"
+   field of a separate copy of the message. If the "Bcc:" field sent
+   contains all of the blind addressees, all of the "Bcc:" recipients
+   will be seen by each "Bcc:" recipient.  Even if a separate message is
+   sent to each "Bcc:" recipient with only the individual's address,
+   implementations still need to be careful to process replies to the
+   message as per section 3.6.3 so as not to accidentally reveal the
+   blind recipient to other recipients.
+
+6. Bibliography
+
+   [ASCII]    American National Standards Institute (ANSI), Coded
+              Character Set - 7-Bit American National Standard Code for
+              Information Interchange, ANSI X3.4, 1986.
+
+   [ISO2022] International Organization for Standardization (ISO),
+              Information processing - ISO 7-bit and 8-bit coded
+              character sets - Code extension techniques, Third edition
+              - 1986-05-01, ISO 2022, 1986.
+
+   [RFC822]   Crocker, D., "Standard for the Format of ARPA Internet
+              Text Messages", RFC 822, August 1982.
+
+   [RFC2045]  Freed, N. and  N. Borenstein, "Multipurpose Internet Mail
+              Extensions (MIME) Part One: Format of Internet Message
+              Bodies", RFC 2045, November 1996.
+
+   [RFC2046]  Freed, N. and N. Borenstein, "Multipurpose Internet Mail
+              Extensions (MIME) Part Two: Media Types", RFC 2046,
+              November 1996.
+
+
+
+Resnick                     Standards Track                    [Page 37]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+   [RFC2047]  Moore, K., "Multipurpose Internet Mail Extensions (MIME)
+              Part Three: Message Header Extensions for Non-ASCII Text",
+              RFC 2047, November 1996.
+
+   [RFC2048]  Freed, N., Klensin, J. and J. Postel, "Multipurpose
+              Internet Mail Extensions (MIME) Part Four: Format of
+              Internet Message Bodies", RFC 2048, November 1996.
+
+   [RFC2049]  Freed, N. and N. Borenstein, "Multipurpose Internet Mail
+              Extensions (MIME) Part Five: Conformance Criteria and
+              Examples", RFC 2049, November 1996.
+
+   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
+              Requirement Levels", BCP 14, RFC 2119, March 1997.
+
+   [RFC2234]  Crocker, D., Editor, and P. Overell, "Augmented BNF for
+              Syntax Specifications: ABNF", RFC 2234, November 1997.
+
+   [RFC2821]  Klensin, J., Editor, "Simple Mail Transfer Protocol", RFC
+              2821, March 2001.
+
+   [STD3]     Braden, R., "Host Requirements", STD 3, RFC 1122 and RFC
+              1123, October 1989.
+
+   [STD12]    Mills, D., "Network Time Protocol", STD 12, RFC 1119,
+              September 1989.
+
+   [STD13]    Mockapetris, P., "Domain Name System", STD 13, RFC 1034
+              and RFC 1035,  November 1987.
+
+   [STD14]    Partridge, C., "Mail Routing and the Domain System", STD
+              14, RFC 974, January 1986.
+
+7. Editor's Address
+
+   Peter W. Resnick
+   QUALCOMM Incorporated
+   5775 Morehouse Drive
+   San Diego, CA 92121-1714
+   USA
+
+   Phone: +1 858 651 4478
+   Fax:   +1 858 651 1102
+   EMail: presnick@qualcomm.com
+
+
+
+
+
+
+
+Resnick                     Standards Track                    [Page 38]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+8. Acknowledgements
+
+   Many people contributed to this document.  They included folks who
+   participated in the Detailed Revision and Update of Messaging
+   Standards (DRUMS) Working Group of the Internet Engineering Task
+   Force (IETF), the chair of DRUMS, the Area Directors of the IETF, and
+   people who simply sent their comments in via e-mail.  The editor is
+   deeply indebted to them all and thanks them sincerely.  The below
+   list includes everyone who sent e-mail concerning this document.
+   Hopefully, everyone who contributed is named here:
+
+   Matti Aarnio              Barry Finkel           Larry Masinter
+   Tanaka Akira              Erik Forsberg          Denis McKeon
+   Russ Allbery              Chuck Foster           William P McQuillan
+   Eric Allman               Paul Fox               Alexey Melnikov
+   Harald Tveit Alvestrand   Klaus M. Frank         Perry E. Metzger
+   Ran Atkinson              Ned Freed              Steven Miller
+   Jos Backus                Jochen Friedrich       Keith Moore
+   Bruce Balden              Randall C. Gellens     John Gardiner Myers
+   Dave Barr                 Sukvinder Singh Gill   Chris Newman
+   Alan Barrett              Tim Goodwin            John W. Noerenberg
+   John Beck                 Philip Guenther        Eric Norman
+   J. Robert von Behren      Tony Hansen            Mike O'Dell
+   Jos den Bekker            John Hawkinson         Larry Osterman
+   D. J. Bernstein           Philip Hazel           Paul Overell
+   James Berriman            Kai Henningsen         Jacob Palme
+   Norbert Bollow            Robert Herriot         Michael A. Patton
+   Raj Bose                  Paul Hethmon           Uzi Paz
+   Antony Bowesman           Jim Hill               Michael A. Quinlan
+   Scott Bradner             Paul E. Hoffman        Eric S. Raymond
+   Randy Bush                Steve Hole             Sam Roberts
+   Tom Byrer                 Kari Hurtta            Hugh Sasse
+   Bruce Campbell            Marco S. Hyman         Bart Schaefer
+   Larry Campbell            Ofer Inbar             Tom Scola
+   W. J. Carpenter           Olle Jarnefors         Wolfgang Segmuller
+   Michael Chapman           Kevin Johnson          Nick Shelness
+   Richard Clayton           Sudish Joseph          John Stanley
+   Maurizio Codogno          Maynard Kang           Einar Stefferud
+   Jim Conklin               Prabhat Keni           Jeff Stephenson
+   R. Kelley Cook            John C. Klensin        Bernard Stern
+   Steve Coya                Graham Klyne           Peter Sylvester
+   Mark Crispin              Brad Knowles           Mark Symons
+   Dave Crocker              Shuhei Kobayashi       Eric Thomas
+   Matt Curtin               Peter Koch             Lee Thompson
+   Michael D'Errico          Dan Kohn               Karel De Vriendt
+   Cyrus Daboo               Christian Kuhtz        Matthew Wall
+   Jutta Degener             Anand Kumria           Rolf Weber
+   Mark Delany               Steen Larsen           Brent B. Welch
+
+
+
+Resnick                     Standards Track                    [Page 39]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+   Steve Dorner              Eliot Lear             Dan Wing
+   Harold A. Driscoll        Barry Leiba            Jack De Winter
+   Michael Elkins            Jay Levitt             Gregory J. Woodhouse
+   Robert Elz                Lars-Johan Liman       Greg A. Woods
+   Johnny Eriksson           Charles Lindsey        Kazu Yamamoto
+   Erik E. Fair              Pete Loshin            Alain Zahm
+   Roger Fajman              Simon Lyall            Jamie Zawinski
+   Patrik Faltstrom          Bill Manning           Timothy S. Zurcher
+   Claus Andre Farber        John Martin
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Resnick                     Standards Track                    [Page 40]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+Appendix A. Example messages
+
+   This section presents a selection of messages.  These are intended to
+   assist in the implementation of this standard, but should not be
+   taken as normative; that is to say, although the examples in this
+   section were carefully reviewed, if there happens to be a conflict
+   between these examples and the syntax described in sections 3 and 4
+   of this document, the syntax in those sections is to be taken as
+   correct.
+
+   Messages are delimited in this section between lines of "----".  The
+   "----" lines are not part of the message itself.
+
+A.1. Addressing examples
+
+   The following are examples of messages that might be sent between two
+   individuals.
+
+A.1.1. A message from one person to another with simple addressing
+
+   This could be called a canonical message.  It has a single author,
+   John Doe, a single recipient, Mary Smith, a subject, the date, a
+   message identifier, and a textual message in the body.
+
+----
+From: John Doe <jdoe@machine.example>
+To: Mary Smith <mary@example.net>
+Subject: Saying Hello
+Date: Fri, 21 Nov 1997 09:55:06 -0600
+Message-ID: <1234@local.machine.example>
+
+This is a message just to say hello.
+So, "Hello".
+----
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Resnick                     Standards Track                    [Page 41]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+   If John's secretary Michael actually sent the message, though John
+   was the author and replies to this message should go back to him, the
+   sender field would be used:
+
+----
+From: John Doe <jdoe@machine.example>
+Sender: Michael Jones <mjones@machine.example>
+To: Mary Smith <mary@example.net>
+Subject: Saying Hello
+Date: Fri, 21 Nov 1997 09:55:06 -0600
+Message-ID: <1234@local.machine.example>
+
+This is a message just to say hello.
+So, "Hello".
+----
+
+A.1.2. Different types of mailboxes
+
+   This message includes multiple addresses in the destination fields
+   and also uses several different forms of addresses.
+
+----
+From: "Joe Q. Public" <john.q.public@example.com>
+To: Mary Smith <mary@x.test>, jdoe@example.org, Who? <one@y.test>
+Cc: <boss@nil.test>, "Giant; \"Big\" Box" <sysservices@example.net>
+Date: Tue, 1 Jul 2003 10:52:37 +0200
+Message-ID: <5678.21-Nov-1997@example.com>
+
+Hi everyone.
+----
+
+   Note that the display names for Joe Q. Public and Giant; "Big" Box
+   needed to be enclosed in double-quotes because the former contains
+   the period and the latter contains both semicolon and double-quote
+   characters (the double-quote characters appearing as quoted-pair
+   construct).  Conversely, the display name for Who? could appear
+   without them because the question mark is legal in an atom.  Notice
+   also that jdoe@example.org and boss@nil.test have no display names
+   associated with them at all, and jdoe@example.org uses the simpler
+   address form without the angle brackets.
+
+
+
+
+
+
+
+
+
+
+
+Resnick                     Standards Track                    [Page 42]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+A.1.3. Group addresses
+
+----
+From: Pete <pete@silly.example>
+To: A Group:Chris Jones <c@a.test>,joe@where.test,John <jdoe@one.test>;
+Cc: Undisclosed recipients:;
+Date: Thu, 13 Feb 1969 23:32:54 -0330
+Message-ID: <testabcd.1234@silly.example>
+
+Testing.
+----
+
+   In this message, the "To:" field has a single group recipient named A
+   Group which contains 3 addresses, and a "Cc:" field with an empty
+   group recipient named Undisclosed recipients.
+
+A.2. Reply messages
+
+   The following is a series of three messages that make up a
+   conversation thread between John and Mary.  John firsts sends a
+   message to Mary, Mary then replies to John's message, and then John
+   replies to Mary's reply message.
+
+   Note especially the "Message-ID:", "References:", and "In-Reply-To:"
+   fields in each message.
+
+----
+From: John Doe <jdoe@machine.example>
+To: Mary Smith <mary@example.net>
+Subject: Saying Hello
+Date: Fri, 21 Nov 1997 09:55:06 -0600
+Message-ID: <1234@local.machine.example>
+
+This is a message just to say hello.
+So, "Hello".
+----
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Resnick                     Standards Track                    [Page 43]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+   When sending replies, the Subject field is often retained, though
+   prepended with "Re: " as described in section 3.6.5.
+
+----
+From: Mary Smith <mary@example.net>
+To: John Doe <jdoe@machine.example>
+Reply-To: "Mary Smith: Personal Account" <smith@home.example>
+Subject: Re: Saying Hello
+Date: Fri, 21 Nov 1997 10:01:10 -0600
+Message-ID: <3456@example.net>
+In-Reply-To: <1234@local.machine.example>
+References: <1234@local.machine.example>
+
+This is a reply to your hello.
+----
+
+   Note the "Reply-To:" field in the above message.  When John replies
+   to Mary's message above, the reply should go to the address in the
+   "Reply-To:" field instead of the address in the "From:" field.
+
+----
+To: "Mary Smith: Personal Account" <smith@home.example>
+From: John Doe <jdoe@machine.example>
+Subject: Re: Saying Hello
+Date: Fri, 21 Nov 1997 11:00:00 -0600
+Message-ID: <abcd.1234@local.machine.tld>
+In-Reply-To: <3456@example.net>
+References: <1234@local.machine.example> <3456@example.net>
+
+This is a reply to your reply.
+----
+
+A.3. Resent messages
+
+   Start with the message that has been used as an example several
+   times:
+
+----
+From: John Doe <jdoe@machine.example>
+To: Mary Smith <mary@example.net>
+Subject: Saying Hello
+Date: Fri, 21 Nov 1997 09:55:06 -0600
+Message-ID: <1234@local.machine.example>
+
+This is a message just to say hello.
+So, "Hello".
+----
+
+
+
+
+Resnick                     Standards Track                    [Page 44]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+   Say that Mary, upon receiving this message, wishes to send a copy of
+   the message to Jane such that (a) the message would appear to have
+   come straight from John; (b) if Jane replies to the message, the
+   reply should go back to John; and (c) all of the original
+   information, like the date the message was originally sent to Mary,
+   the message identifier, and the original addressee, is preserved.  In
+   this case, resent fields are prepended to the message:
+
+----
+Resent-From: Mary Smith <mary@example.net>
+Resent-To: Jane Brown <j-brown@other.example>
+Resent-Date: Mon, 24 Nov 1997 14:22:01 -0800
+Resent-Message-ID: <78910@example.net>
+From: John Doe <jdoe@machine.example>
+To: Mary Smith <mary@example.net>
+Subject: Saying Hello
+Date: Fri, 21 Nov 1997 09:55:06 -0600
+Message-ID: <1234@local.machine.example>
+
+This is a message just to say hello.
+So, "Hello".
+----
+
+   If Jane, in turn, wished to resend this message to another person,
+   she would prepend her own set of resent header fields to the above
+   and send that.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Resnick                     Standards Track                    [Page 45]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+A.4. Messages with trace fields
+
+   As messages are sent through the transport system as described in
+   [RFC2821], trace fields are prepended to the message.  The following
+   is an example of what those trace fields might look like.  Note that
+   there is some folding white space in the first one since these lines
+   can be long.
+
+----
+Received: from x.y.test
+   by example.net
+   via TCP
+   with ESMTP
+   id ABC12345
+   for <mary@example.net>;  21 Nov 1997 10:05:43 -0600
+Received: from machine.example by x.y.test; 21 Nov 1997 10:01:22 -0600
+From: John Doe <jdoe@machine.example>
+To: Mary Smith <mary@example.net>
+Subject: Saying Hello
+Date: Fri, 21 Nov 1997 09:55:06 -0600
+Message-ID: <1234@local.machine.example>
+
+This is a message just to say hello.
+So, "Hello".
+----
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Resnick                     Standards Track                    [Page 46]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+A.5. White space, comments, and other oddities
+
+   White space, including folding white space, and comments can be
+   inserted between many of the tokens of fields.  Taking the example
+   from A.1.3, white space and comments can be inserted into all of the
+   fields.
+
+----
+From: Pete(A wonderful \) chap) <pete(his account)@silly.test(his host)>
+To:A Group(Some people)
+     :Chris Jones <c@(Chris's host.)public.example>,
+         joe@example.org,
+  John <jdoe@one.test> (my dear friend); (the end of the group)
+Cc:(Empty list)(start)Undisclosed recipients  :(nobody(that I know))  ;
+Date: Thu,
+      13
+        Feb
+          1969
+      23:32
+               -0330 (Newfoundland Time)
+Message-ID:              <testabcd.1234@silly.test>
+
+Testing.
+----
+
+   The above example is aesthetically displeasing, but perfectly legal.
+   Note particularly (1) the comments in the "From:" field (including
+   one that has a ")" character appearing as part of a quoted-pair); (2)
+   the white space absent after the ":" in the "To:" field as well as
+   the comment and folding white space after the group name, the special
+   character (".") in the comment in Chris Jones's address, and the
+   folding white space before and after "joe@example.org,"; (3) the
+   multiple and nested comments in the "Cc:" field as well as the
+   comment immediately following the ":" after "Cc"; (4) the folding
+   white space (but no comments except at the end) and the missing
+   seconds in the time of the date field; and (5) the white space before
+   (but not within) the identifier in the "Message-ID:" field.
+
+A.6. Obsoleted forms
+
+   The following are examples of obsolete (that is, the "MUST NOT
+   generate") syntactic elements described in section 4 of this
+   document.
+
+
+
+
+
+
+
+
+Resnick                     Standards Track                    [Page 47]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+A.6.1. Obsolete addressing
+
+   Note in the below example the lack of quotes around Joe Q. Public,
+   the route that appears in the address for Mary Smith, the two commas
+   that appear in the "To:" field, and the spaces that appear around the
+   "." in the jdoe address.
+
+----
+From: Joe Q. Public <john.q.public@example.com>
+To: Mary Smith <@machine.tld:mary@example.net>, , jdoe@test   . example
+Date: Tue, 1 Jul 2003 10:52:37 +0200
+Message-ID: <5678.21-Nov-1997@example.com>
+
+Hi everyone.
+----
+
+A.6.2. Obsolete dates
+
+   The following message uses an obsolete date format, including a non-
+   numeric time zone and a two digit year.  Note that although the
+   day-of-week is missing, that is not specific to the obsolete syntax;
+   it is optional in the current syntax as well.
+
+----
+From: John Doe <jdoe@machine.example>
+To: Mary Smith <mary@example.net>
+Subject: Saying Hello
+Date: 21 Nov 97 09:55:06 GMT
+Message-ID: <1234@local.machine.example>
+
+This is a message just to say hello.
+So, "Hello".
+----
+
+A.6.3. Obsolete white space and comments
+
+   White space and comments can appear between many more elements than
+   in the current syntax.  Also, folding lines that are made up entirely
+   of white space are legal.
+
+
+
+
+
+
+
+
+
+
+
+
+Resnick                     Standards Track                    [Page 48]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+----
+From  : John Doe <jdoe@machine(comment).  example>
+To    : Mary Smith
+__
+          <mary@example.net>
+Subject     : Saying Hello
+Date  : Fri, 21 Nov 1997 09(comment):   55  :  06 -0600
+Message-ID  : <1234   @   local(blah)  .machine .example>
+
+This is a message just to say hello.
+So, "Hello".
+----
+
+   Note especially the second line of the "To:" field.  It starts with
+   two space characters.  (Note that "__" represent blank spaces.)
+   Therefore, it is considered part of the folding as described in
+   section 4.2.  Also, the comments and white space throughout
+   addresses, dates, and message identifiers are all part of the
+   obsolete syntax.
+
+Appendix B. Differences from earlier standards
+
+   This appendix contains a list of changes that have been made in the
+   Internet Message Format from earlier standards, specifically [RFC822]
+   and [STD3].  Items marked with an asterisk (*) below are items which
+   appear in section 4 of this document and therefore can no longer be
+   generated.
+
+   1. Period allowed in obsolete form of phrase.
+   2. ABNF moved out of document to [RFC2234].
+   3. Four or more digits allowed for year.
+   4. Header field ordering (and lack thereof) made explicit.
+   5. Encrypted header field removed.
+   6. Received syntax loosened to allow any token/value pair.
+   7. Specifically allow and give meaning to "-0000" time zone.
+   8. Folding white space is not allowed between every token.
+   9. Requirement for destinations removed.
+   10. Forwarding and resending redefined.
+   11. Extension header fields no longer specifically called out.
+   12. ASCII 0 (null) removed.*
+   13. Folding continuation lines cannot contain only white space.*
+   14. Free insertion of comments not allowed in date.*
+   15. Non-numeric time zones not allowed.*
+   16. Two digit years not allowed.*
+   17. Three digit years interpreted, but not allowed for generation.
+   18. Routes in addresses not allowed.*
+   19. CFWS within local-parts and domains not allowed.*
+   20. Empty members of address lists not allowed.*
+
+
+
+Resnick                     Standards Track                    [Page 49]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+   21. Folding white space between field name and colon not allowed.*
+   22. Comments between field name and colon not allowed.
+   23. Tightened syntax of in-reply-to and references.*
+   24. CFWS within msg-id not allowed.*
+   25. Tightened semantics of resent fields as informational only.
+   26. Resent-Reply-To not allowed.*
+   27. No multiple occurrences of fields (except resent and received).*
+   28. Free CR and LF not allowed.*
+   29. Routes in return path not allowed.*
+   30. Line length limits specified.
+   31. Bcc more clearly specified.
+
+Appendix C. Notices
+
+   Intellectual Property
+
+   The IETF takes no position regarding the validity or scope of any
+   intellectual property or other rights that might be claimed to
+   pertain to the implementation or use of the technology described in
+   this document or the extent to which any license under such rights
+   might or might not be available; neither does it represent that it
+   has made any effort to identify any such rights.  Information on the
+   IETF's procedures with respect to rights in standards-track and
+   standards-related documentation can be found in BCP-11.  Copies of
+   claims of rights made available for publication and any assurances of
+   licenses to be made available, or the result of an attempt made to
+   obtain a general license or permission for the use of such
+   proprietary rights by implementors or users of this specification can
+   be obtained from the IETF Secretariat.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Resnick                     Standards Track                    [Page 50]
+
+RFC 2822                Internet Message Format               April 2001
+
+
+Full Copyright Statement
+
+   Copyright (C) The Internet Society (2001).  All Rights Reserved.
+
+   This document and translations of it may be copied and furnished to
+   others, and derivative works that comment on or otherwise explain it
+   or assist in its implementation may be prepared, copied, published
+   and distributed, in whole or in part, without restriction of any
+   kind, provided that the above copyright notice and this paragraph are
+   included on all such copies and derivative works.  However, this
+   document itself may not be modified in any way, such as by removing
+   the copyright notice or references to the Internet Society or other
+   Internet organizations, except as needed for the purpose of
+   developing Internet standards in which case the procedures for
+   copyrights defined in the Internet Standards process must be
+   followed, or as required to translate it into languages other than
+   English.
+
+   The limited permissions granted above are perpetual and will not be
+   revoked by the Internet Society or its successors or assigns.
+
+   This document and the information contained herein is provided on an
+   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
+   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
+   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
+   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
+   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
+
+Acknowledgement
+
+   Funding for the RFC Editor function is currently provided by the
+   Internet Society.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Resnick                     Standards Track                    [Page 51]
+
diff -urN dovecot-1.2.4/dovecot-libsieve/doc/rfc/imap4flags.rfc5232.txt dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/imap4flags.rfc5232.txt
--- dovecot-1.2.4/dovecot-libsieve/doc/rfc/imap4flags.rfc5232.txt	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/imap4flags.rfc5232.txt	2008-08-04 10:39:20.000000000 +0200
@@ -0,0 +1,675 @@
+
+
+
+
+
+
+Network Working Group                                       A.  Melnikov
+Request for Comments: 5232                                 Isode Limited
+Category: Standards Track                                   January 2008
+
+
+              Sieve Email Filtering: Imap4flags Extension
+
+Status of This Memo
+
+   This document specifies an Internet standards track protocol for the
+   Internet community, and requests discussion and suggestions for
+   improvements.  Please refer to the current edition of the "Internet
+   Official Protocol Standards" (STD 1) for the standardization state
+   and status of this protocol.  Distribution of this memo is unlimited.
+
+Abstract
+
+   Recent discussions have shown that it is desirable to set different
+   IMAP (RFC 3501) flags on message delivery.  This can be done, for
+   example, by a Sieve interpreter that works as a part of a Mail
+   Delivery Agent.
+
+   This document describes an extension to the Sieve mail filtering
+   language for setting IMAP flags.  The extension allows setting of
+   both IMAP system flags and IMAP keywords.
+
+Table of Contents
+
+   1. Introduction ....................................................2
+      1.1. Conventions Used ...........................................2
+   2. General Requirements for Flag Handling ..........................3
+   3. Actions .........................................................3
+      3.1. Action setflag .............................................4
+      3.2. Action addflag .............................................4
+      3.3. Action removeflag ..........................................5
+   4. Test hasflag ....................................................6
+   5. Tagged Argument :flags ..........................................7
+   6. Interaction with Other Sieve Actions ............................8
+   7. Security Considerations .........................................8
+   8. IANA Considerations .............................................8
+   9. Extended Example ................................................8
+   10. Acknowledgments ...............................................10
+   11. Normative References ..........................................10
+
+
+
+
+
+
+
+
+Melnikov                    Standards Track                     [Page 1]
+
+RFC 5232              Sieve: Imap4flags Extension           January 2008
+
+
+1.  Introduction
+
+   This is an extension to the Sieve language defined by [SIEVE] for
+   setting [IMAP] flags.  It adds a new tagged argument to "keep" and
+   "fileinto" that describes the list of flags that have to be set when
+   the message is delivered to the specified mailbox.  It also adds
+   several actions to help manipulate list of flags and a test to check
+   whether a flag belongs to a list.
+
+   From the user's perspective, this extension provides several
+   capabilities.  First, it allows manipulation of sets of IMAP flags.
+   Second, it gives the ability to associate a set of IMAP flags with a
+   message that is delivered to a mailstore using the keep/fileinto
+   actions.  Third, it maintains an internal variable.  The internal
+   variable contains the default flags that will be associated with a
+   message that is delivered using the keep, implicit keep, or fileinto
+   actions, when the :flags tagged argument is not specified.  When the
+   Sieve [VARIABLES] extension is also supported by the Sieve engine, it
+   enables support for multiple variables containing sets of IMAP flags.
+
+   The capability string associated with the extension defined in this
+   document is "imap4flags".  All conformant implementations MUST
+   implement all Sieve actions (setflag, addflag, removeflag), the
+   "hasflag" test, and the ":flags" tagged argument described in this
+   document.
+
+   The "imap4flags" extension can be used with or without the
+   "variables" extension [VARIABLES].  When the "variables" extension is
+   enabled in a script using <require "variables">, the script can use
+   explicit variable names in setflag/addflag/removeflag actions and the
+   hasflag test.  See also Section 3 for more details.  When the
+   "variables" extension is not enabled, the explicit variable name
+   parameter to setflag/addflag/removeflag/hasflag MUST NOT be used and
+   MUST cause an error according to [SIEVE].
+
+1.1.  Conventions Used
+
+   Conventions for notations are as in [SIEVE], Section 1.1, including
+   use of "Usage:" label for the definition of action and tagged
+   arguments syntax.
+
+   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
+   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
+   document are to be interpreted as described in RFC 2119.
+
+
+
+
+
+
+
+Melnikov                    Standards Track                     [Page 2]
+
+RFC 5232              Sieve: Imap4flags Extension           January 2008
+
+
+2.  General Requirements for Flag Handling
+
+   The following notes apply to processing of addflag/removeflag/setflag
+   actions, the "hasflag" test and the ":flags" tagged argument.
+
+   A Sieve interpreter MUST ignore empty strings (i.e., "") in a list-
+   of-flags parameter.
+
+   A string containing a space-separated list of flag names is
+   equivalent to a string list consisting of the flags.  This
+   requirement is to simplify amalgamation of multiple flag lists.
+
+   The Sieve interpreter SHOULD check the list of flags for validity as
+   described by [IMAP] ABNF.  In particular, according to [IMAP], non-
+   ASCII characters are not allowed in flag names.  However, spaces MUST
+   always be allowed as delimiters in strings representing a list of
+   flags.  In such strings, multiple spaces between flag names MUST be
+   treated as a single space character, and leading and trailing spaces
+   MUST be ignored.
+
+   If a flag validity check fails, the flag MUST be ignored.
+
+   Note that it is not possible to use this extension to set or clear
+   the \Recent flag or any other special system flag that is not
+   settable in [IMAP].  Any such flags MUST be ignored if included in a
+   flag list.
+
+3.  Actions
+
+   All actions described in this specification (setflag, addflag,
+   removeflag) operate on string variables that contain a set of [IMAP]
+   flags.  On variable substitution, a set of flags is represented as a
+   string containing a space-separated list of flag names.
+
+   Any setflag/addflag/removeflag action MAY alter the flag list in any
+   way that leaves its semantics as a set of case-insensitive words
+   unaltered.  For example, it may reorder the flags, alter the case of
+   the letters in them, or add or remove duplicates or extraneous
+   spaces.  Scripts MUST NOT make assumptions about the ordering of
+   flags in lists or the preservation of their case.
+
+   Note that the parameter specifying a variable name to
+   setflag/addflag/removeflag actions and the hasflag test is optional.
+   If the parameter is not specified, the actions operate on the
+   internal variable, which has the empty value when the script starts
+   execution.  If the SIEVE interpreter doesn't support the "variables"
+   extension [VARIABLES], the presence of the variable name parameter
+   will cause a runtime error [SIEVE].
+
+
+
+Melnikov                    Standards Track                     [Page 3]
+
+RFC 5232              Sieve: Imap4flags Extension           January 2008
+
+
+   The "addflag" action adds flags to an existing set.  The "removeflag"
+   action removes flags from an existing set.  The "setflag" action
+   replaces an existing set of flags with a new set.  The "set" action
+   defined in [VARIABLES] can be used to replace an existing set of
+   flags with a new set as well.  However, it should be noted that the
+   "set" action can't perform any flag reordering, duplicate
+   elimination, etc.
+
+   The :flags tagged argument to "keep" and "fileinto" actions is used
+   to associate a set of flags with the current message.  If the :flags
+   tagged argument is not specified with those two actions, the current
+   value of the internal variable is used instead.  The value of the
+   internal variable also applies to the implicit keep.
+
+   Note that when keep/fileinto is used multiple times in a script and
+   duplicate message elimination is performed (as described in Section
+   2.10.3 of [SIEVE]), the last flag list value MUST win.
+
+3.1.  Action setflag
+
+   Usage:   setflag [<variablename: string>]
+            <list-of-flags: string-list>
+
+   Setflag is used for setting [IMAP] system flags or keywords.
+   Setflag replaces any previously set flags.
+
+
+   Example:  if size :over 500K {
+                 setflag "\\Deleted";
+             }
+
+   A more substantial example is the following:
+
+   Example:
+        if header :contains "from" "boss@frobnitzm.example.edu" {
+            setflag "flagvar" "\\Flagged";
+            fileinto :flags "${flagvar}" "INBOX.From Boss";
+        }
+
+3.2.  Action addflag
+
+   Usage:   addflag [<variablename: string>]
+            <list-of-flags: string-list>
+
+   Addflag is used to add flags to a list of [IMAP] flags.  It doesn't
+   replace any previously set flags.  This means that multiple
+   occurrences of addflag are treated additively.
+
+
+
+
+Melnikov                    Standards Track                     [Page 4]
+
+RFC 5232              Sieve: Imap4flags Extension           January 2008
+
+
+   The following examples demonstrate requirements described in Section
+   2.1.  The following two actions
+
+      addflag "flagvar" "\\Deleted";
+      addflag "flagvar" "\\Answered";
+
+   produce the same result as the single action
+
+      addflag "flagvar" ["\\Deleted", "\\Answered"];
+
+   or
+
+      addflag "flagvar" "\\Deleted \\Answered";
+
+   or
+
+      addflag "flagvar" "\\Answered \\Deleted";
+
+3.3.  Action removeflag
+
+   Usage:   removeflag [<variablename: string>]
+            <list-of-flags: string-list>
+
+   Removeflag is used to remove flags from a list of [IMAP] flags.
+   Removeflag clears flags previously set by "set"/"addflag".  Calling
+   removeflag with a flag that wasn't set before is not an error and is
+   ignored.  Note that if an implementation doesn't perform automatic
+   duplicate elimination, it MUST remove all occurrences of the flags
+   specified in the second parameter to removeflag.  Empty strings in
+   the list-of-flags MUST be ignored.  Also note that flag names are
+   case-insensitive, as described in [IMAP].  Multiple removeflag
+   actions are treated additively.
+
+      Example:
+        if header :contains "Disposition-Notification-To"
+           "mel@example.com" {
+            addflag "flagvar" "$MDNRequired";
+        }
+        if header :contains "from" "imap@cac.washington.example.edu" {
+            removeflag "flagvar" "$MDNRequired";
+            fileinto :flags "${flagvar}" "INBOX.imap-list";
+        }
+
+
+
+
+
+
+
+
+
+Melnikov                    Standards Track                     [Page 5]
+
+RFC 5232              Sieve: Imap4flags Extension           January 2008
+
+
+4.  Test hasflag
+
+   Usage: hasflag [MATCH-TYPE] [COMPARATOR]
+          [<variable-list: string-list>]
+          <list-of-flags: string-list>
+
+   The hasflag test evaluates to true if any of the variables matches
+   any flag name.  The type of match defaults to ":is".  If the list of
+   variables is omitted, value of the internal variable is used instead.
+
+   The default comparator is "i;ascii-casemap", which is the same case-
+   insensitive comparison as defined for IMAP flags by [IMAP].
+
+   The "relational" extension [RELATIONAL] adds a match type called
+   ":count".  The :count of a variable returns the number of distinct
+   flags in it.  The count of a list of variables is the sum of the
+   counts of the member variables.
+
+   Example:
+     If the internal variable has the value "A B", the following test
+
+      hasflag :is "b A"
+
+     evaluates to true.  The above test can also be written as
+
+      hasflag ["b","A"]
+
+   Example:
+     If the variable "MyVar" has value "NonJunk Junk gnus-forward
+     $Forwarded NotJunk JunkRecorded $Junk $NotJunk", the following
+     tests evaluate to true:
+
+      hasflag :contains "MyVar" "Junk"
+      hasflag :contains "MyVar" "forward"
+      hasflag :contains "MyVar" ["label", "forward"]
+      hasflag :contains "MyVar" ["junk", "forward"]
+
+     Note that the last of these tests can be rewritten
+     as
+
+      hasflag :contains "MyVar" "junk forward"
+
+     or
+
+      hasflag :contains "MyVar" "forward junk"
+
+     However, the last two forms are not recommended.
+
+
+
+
+Melnikov                    Standards Track                     [Page 6]
+
+RFC 5232              Sieve: Imap4flags Extension           January 2008
+
+
+     And the following tests will evaluate to false:
+
+      hasflag :contains "MyVar" "label"
+
+      hasflag :contains "MyVar" ["label1", "label2"]
+
+   Example:
+     If the variable "MyFlags" has the value "A B", the following test
+
+       hasflag :count "ge" :comparator "i;ascii-numeric"
+               "MyFlags" "2"
+
+     evaluates to true, as the variable contains 2 distinct flags.
+
+5.  Tagged Argument :flags
+
+   This specification adds a new optional tagged argument ":flags" that
+   alters the behavior of actions "keep" and "fileinto".
+
+   The :flags tagged argument specifies that the flags provided in the
+   subsequent argument should be set when fileinto/keep delivers the
+   message to the target mailbox/user's main mailbox.  If the :flags
+   tagged argument is not specified, "keep" or "fileinto" will use the
+   current value of the internal variable when delivering the message to
+   the target mailbox.
+
+   Usage:   ":flags" <list-of-flags: string-list>
+
+   The copy of the message filed into the mailbox will have only flags
+   listed after the :flags tagged argument.
+
+   The Sieve interpreter MUST ignore all flags that it can't store
+   permanently.  This means that the interpreter MUST NOT treat failure
+   to store any flag as a runtime failure to execute the Sieve script.
+   For example, if the mailbox "INBOX.From Boss" can't store any flags,
+   then
+
+     fileinto :flags "\\Deleted" "INBOX.From Boss";
+
+   and
+
+     fileinto "INBOX.From Boss";
+
+   are equivalent.
+
+   This document doesn't dictate how the Sieve interpreter will set the
+   [IMAP] flags.  In particular, the Sieve interpreter may work as an
+   IMAP client or may have direct access to the mailstore.
+
+
+
+Melnikov                    Standards Track                     [Page 7]
+
+RFC 5232              Sieve: Imap4flags Extension           January 2008
+
+
+6.  Interaction with Other Sieve Actions
+
+   This extension works only on the message that is currently being
+   processed by Sieve; it doesn't affect another message generated as a
+   side effect of any action or any other message already in the
+   mailstore.
+
+   The extension described in this document doesn't change the implicit
+   keep (see Section 2.10.2 of [SIEVE]).
+
+7.  Security Considerations
+
+   Security considerations are discussed in [IMAP], [SIEVE], and
+   [VARIABLES].
+
+   This extension intentionally doesn't allow setting [IMAP] flags on an
+   arbitrary message in the [IMAP] message store.
+
+   It is believed that this extension doesn't introduce any additional
+   security concerns.
+
+8.  IANA Considerations
+
+   The following template specifies the IANA registration of the
+   variables Sieve extension specified in this document:
+
+   To: iana@iana.org
+   Subject: Registration of new Sieve extension
+
+   Capability name: imap4flags
+   Description:     Adds actions and tests for manipulating IMAP flags
+   RFC number:      RFC 5232
+   Contact address: The Sieve discussion list <ietf-mta-filters@imc.org>
+
+   This information has been added to the list of Sieve extensions given
+   on http://www.iana.org/assignments/sieve-extensions.
+
+9.  Extended Example
+
+   #
+   # Example Sieve Filter
+   # Declare any optional features or extension used by the script
+   #
+   require ["fileinto", "imap4flags", "variables"];
+
+   #
+   # Move large messages to a special mailbox
+   #
+
+
+
+Melnikov                    Standards Track                     [Page 8]
+
+RFC 5232              Sieve: Imap4flags Extension           January 2008
+
+
+   if size :over 1M
+           {
+           addflag "MyFlags" "Big";
+           if header :is "From" "boss@company.example.com"
+                      {
+   # The message will be marked as "\Flagged Big" when filed into
+   # mailbox "Big messages"
+                      addflag "MyFlags" "\\Flagged";
+                      }
+           fileinto :flags "${MyFlags}" "Big messages";
+           }
+
+   if header :is "From" "grandma@example.net"
+           {
+           addflag "MyFlags" ["\\Answered", "$MDNSent"];
+   # If the message is bigger than 1Mb it will be marked as
+   # "Big \Answered $MDNSent" when filed into mailbox "grandma".
+   # If the message is shorter than 1Mb it will be marked as
+   # "\Answered $MDNSent"
+           fileinto :flags "${MyFlags}" "GrandMa";
+           }
+
+   #
+   # Handle messages from known mailing lists
+   # Move messages from IETF filter discussion list to filter folder
+   #
+   if header :is "Sender" "owner-ietf-mta-filters@example.org"
+           {
+           set "MyFlags" "\\Flagged $Work";
+   # Message will have both "\Flagged" and $Work flags
+           keep :flags "${MyFlags}";
+           }
+
+   #
+   # Keep all messages to or from people in my company
+   #
+   elsif anyof address :domain :is ["From", "To"] "company.example.com"
+           {
+           keep :flags "${MyFlags}"; # keep in "Inbox" folder
+           }
+
+   # Try to catch unsolicited email.  If a message is not to me,
+   # or it contains a subject known to be spam, file it away.
+   #
+   elsif anyof (not address :all :contains
+                  ["To", "Cc"] "me@company.example.com",
+                header :matches "subject"
+                  ["*make*money*fast*", "*university*dipl*mas*"])
+
+
+
+Melnikov                    Standards Track                     [Page 9]
+
+RFC 5232              Sieve: Imap4flags Extension           January 2008
+
+
+           {
+           remove "MyFlags" "\\Flagged";
+           fileinto :flags "${MyFlags}" "spam";
+           }
+   else
+           {
+           # Move all other external mail to "personal"
+           # folder.
+           fileinto :flags "${MyFlags}" "personal";
+           }
+
+10.  Acknowledgments
+
+   This document has been revised in part based on comments and
+   discussions that took place on and off the Sieve mailing list.
+
+   The help of those who took the time to review the document and make
+   suggestions is appreciated, especially that of Tim Showalter, Barry
+   Leiba, Randall Gellens, Ken Murchison, Cyrus Daboo, Matthew Elvey,
+   Jutta Degener, Ned Freed, Marc Mutz, Nigel Swinson, Kjetil Torgrim
+   Homme, Mark E.  Mallett, Dave Cridland, Arnt Gulbrandsen, Philip
+   Guenther, Rob Austein, Sam Hartman, Eric Gray, and Cullen Jennings.
+
+   Special thanks to Tony Hansen and David Lamb for helping me better
+   explain the concept.
+
+11.  Normative References
+
+   [SIEVE]      Guenther, P., Ed., and T. Showalter, Ed., "Sieve: An
+                Email Filtering Language", RFC 5228, January 2008.
+
+   [IMAP]       Crispin, M., "INTERNET MESSAGE ACCESS PROTOCOL - VERSION
+                4rev1", RFC 3501, March 2003.
+
+   [VARIABLES]  Homme, K., "Sieve Email Filtering: Variables Extension",
+                RFC 5229, January 2008.
+
+   [RELATIONAL] Segmuller, W. and B. Leiba "Sieve Email Filtering:
+                Relational Extension", RFC 5231, January 2008.
+
+
+
+
+
+
+
+
+
+
+
+
+Melnikov                    Standards Track                    [Page 10]
+
+RFC 5232              Sieve: Imap4flags Extension           January 2008
+
+
+Author's Address
+
+   Alexey Melnikov
+   Isode Limited
+
+   5 Castle Business Village
+   Hampton, Middlesex
+   United Kingdom, TW12 2BX
+
+   EMail: alexey.melnikov@isode.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Melnikov                    Standards Track                    [Page 11]
+
+RFC 5232              Sieve: Imap4flags Extension           January 2008
+
+
+Full Copyright Statement
+
+   Copyright (C) The IETF Trust (2008).
+
+   This document is subject to the rights, licenses and restrictions
+   contained in BCP 78, and except as set forth therein, the authors
+   retain all their rights.
+
+   This document and the information contained herein are provided on an
+   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
+   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
+   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
+   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
+
+Intellectual Property
+
+   The IETF takes no position regarding the validity or scope of any
+   Intellectual Property Rights or other rights that might be claimed to
+   pertain to the implementation or use of the technology described in
+   this document or the extent to which any license under such rights
+   might or might not be available; nor does it represent that it has
+   made any independent effort to identify any such rights.  Information
+   on the procedures with respect to rights in RFC documents can be
+   found in BCP 78 and BCP 79.
+
+   Copies of IPR disclosures made to the IETF Secretariat and any
+   assurances of licenses to be made available, or the result of an
+   attempt made to obtain a general license or permission for the use of
+   such proprietary rights by implementers or users of this
+   specification can be obtained from the IETF on-line IPR repository at
+   http://www.ietf.org/ipr.
+
+   The IETF invites any interested party to bring to its attention any
+   copyrights, patents or patent applications, or other proprietary
+   rights that may cover technology that may be required to implement
+   this standard.  Please address the information to the IETF at
+   ietf-ipr@ietf.org.
+
+
+
+
+
+
+
+
+
+
+
+
+Melnikov                    Standards Track                    [Page 12]
+
diff -urN dovecot-1.2.4/dovecot-libsieve/doc/rfc/mailto.rfc2368.txt dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/mailto.rfc2368.txt
--- dovecot-1.2.4/dovecot-libsieve/doc/rfc/mailto.rfc2368.txt	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/mailto.rfc2368.txt	2008-11-21 22:05:14.000000000 +0100
@@ -0,0 +1,563 @@
+
+
+
+
+
+
+Network Working Group                                       P. Hoffman
+Request for Comments: 2368                    Internet Mail Consortium
+Updates: 1738, 1808                                        L. Masinter
+Category: Standards Track                            Xerox Corporation
+                                                           J. Zawinski
+                                               Netscape Communications
+                                                             July 1998
+
+
+                         The mailto URL scheme
+
+Status of this Memo
+
+   This document specifies an Internet standards track protocol for the
+   Internet community, and requests discussion and suggestions for
+   improvements.  Please refer to the current edition of the "Internet
+   Official Protocol Standards" (STD 1) for the standardization state
+   and status of this protocol.  Distribution of this memo is unlimited.
+
+Copyright Notice
+
+   Copyright (C) The Internet Society (1998).  All Rights Reserved.
+
+Abstract
+
+   This document defines the format of Uniform Resource Locators (URL)
+   for designating electronic mail addresses. It is one of a suite of
+   documents which replace RFC 1738, 'Uniform Resource Locators', and
+   RFC 1808, 'Relative Uniform Resource Locators'. The syntax of
+   'mailto' URLs from RFC 1738 is extended to allow creation of more RFC
+   822 messages by allowing the URL to express additional header and
+   body fields.
+
+1. Introduction
+
+   The mailto URL scheme is used to designate the Internet mailing
+   address of an individual or service. In its simplest form, a mailto
+   URL contains an Internet mail address.
+
+   For greater functionality, because interaction with some resources
+   may require message headers or message bodies to be specified as well
+   as the mail address, the mailto URL scheme is extended to allow
+   setting mail header fields and the message body.
+
+2. Syntax of a mailto URL
+
+   Following the syntax conventions of RFC 1738 [RFC1738], a "mailto"
+   URL has the form:
+
+
+
+Hoffman, et. al.            Standards Track                     [Page 1]
+
+RFC 2368                 The mailto URL scheme                 July 1998
+
+
+     mailtoURL  =  "mailto:" [ to ] [ headers ]
+     to         =  #mailbox
+     headers    =  "?" header *( "&" header )
+     header     =  hname "=" hvalue
+     hname      =  *urlc
+     hvalue     =  *urlc
+
+   "#mailbox" is as specified in RFC 822 [RFC822]. This means that it
+   consists of zero or more comma-separated mail addresses, possibly
+   including "phrase" and "comment" components. Note that all URL
+   reserved characters in "to" must be encoded: in particular,
+   parentheses, commas, and the percent sign ("%"), which commonly occur
+   in the "mailbox" syntax.
+
+   "hname" and "hvalue" are encodings of an RFC 822 header name and
+   value, respectively. As with "to", all URL reserved characters must
+   be encoded.
+
+   The special hname "body" indicates that the associated hvalue is the
+   body of the message. The "body" hname should contain the content for
+   the first text/plain body part of the message. The mailto URL is
+   primarily intended for generation of short text messages that are
+   actually the content of automatic processing (such as "subscribe"
+   messages for mailing lists), not general MIME bodies.
+
+   Within mailto URLs, the characters "?", "=", "&" are reserved.
+
+   Because the "&" (ampersand) character is reserved in HTML, any mailto
+   URL which contains an ampersand must be spelled differently in HTML
+   than in other contexts.  A mailto URL which appears in an HTML
+   document must use "&amp;" instead of "&".
+
+   Also note that it is legal to specify both "to" and an "hname" whose
+   value is "to". That is,
+
+     mailto:addr1%2C%20addr2
+
+     is equivalent to
+
+     mailto:?to=addr1%2C%20addr2
+
+     is equivalent to
+
+     mailto:addr1?to=addr2
+
+   8-bit characters in mailto URLs are forbidden. MIME encoded words (as
+   defined in [RFC2047]) are permitted in header values, but not for any
+   part of a "body" hname.
+
+
+
+Hoffman, et. al.            Standards Track                     [Page 2]
+
+RFC 2368                 The mailto URL scheme                 July 1998
+
+
+3. Semantics and operations
+
+   A mailto URL designates an "internet resource", which is the mailbox
+   specified in the address. When additional headers are supplied, the
+   resource designated is the same address, but with an additional
+   profile for accessing the resource. While there are Internet
+   resources that can only be accessed via electronic mail, the mailto
+   URL is not intended as a way of retrieving such objects
+   automatically.
+
+   In current practice, resolving URLs such as those in the "http"
+   scheme causes an immediate interaction between client software and a
+   host running an interactive server. The "mailto" URL has unusual
+   semantics because resolving such a URL does not cause an immediate
+   interaction. Instead, the client creates a message to the designated
+   address with the various header fields set as default. The user can
+   edit the message, send this message unedited, or choose not to send
+   the message. The operation of how any URL scheme is resolved is not
+   mandated by the URL specifications.
+
+4. Unsafe headers
+
+   The user agent interpreting a mailto URL SHOULD choose not to create
+   a message if any of the headers are considered dangerous; it may also
+   choose to create a message with only a subset of the headers given in
+   the URL.  Only the Subject, Keywords, and Body headers are believed
+   to be both safe and useful.
+
+   The creator of a mailto URL cannot expect the resolver of a URL to
+   understand more than the "subject" and "body" headers. Clients that
+   resolve mailto URLs into mail messages should be able to correctly
+   create RFC 822-compliant mail messages using the "subject" and "body"
+   headers.
+
+5. Encoding
+
+   RFC 1738 requires that many characters in URLs be encoded. This
+   affects the mailto scheme for some common characters that might
+   appear in addresses, headers or message contents. One such character
+   is space (" ", ASCII hex 20). Note the examples above that use "%20"
+   for space in the message body.  Also note that line breaks in the
+   body of a message MUST be encoded with "%0D%0A".
+
+   People creating mailto URLs must be careful to encode any reserved
+   characters that are used in the URLs so that properly-written URL
+   interpreters can read them. Also, client software that reads URLs
+   must be careful to decode strings before creating the mail message so
+
+
+
+
+Hoffman, et. al.            Standards Track                     [Page 3]
+
+RFC 2368                 The mailto URL scheme                 July 1998
+
+
+   that the mail messages appear in a form that the recipient will
+   understand. These strings should be decoded before showing the user
+   the message.
+
+   The mailto URL scheme is limited in that it does not provide for
+   substitution of variables. Thus, a message body that must include a
+   user's email address can not be encoded using the mailto URL. This
+   limitation also prevents mailto URLs that are signed with public keys
+   and other such variable information.
+
+6. Examples
+
+   URLs for an ordinary individual mailing address:
+
+     <mailto:chris@example.com>
+
+   A URL for a mail response system that requires the name of the file
+   in the subject:
+
+     <mailto:infobot@example.com?subject=current-issue>
+
+   A mail response system that requires a "send" request in the body:
+
+     <mailto:infobot@example.com?body=send%20current-issue>
+
+   A similar URL could have two lines with different "send" requests (in
+   this case, "send current-issue" and, on the next line, "send index".)
+
+     <mailto:infobot@example.com?body=send%20current-
+     issue%0D%0Asend%20index>
+
+   An interesting use of your mailto URL is when browsing archives of
+   messages. Each browsed message might contain a mailto URL like:
+
+     <mailto:foobar@example.com?In-Reply-
+     To=%3c3469A91.D10AF4C@example.com>
+
+   A request to subscribe to a mailing list:
+
+     <mailto:majordomo@example.com?body=subscribe%20bamboo-l>
+
+   A URL for a single user which includes a CC of another user:
+
+     <mailto:joe@example.com?cc=bob@example.com&body=hello>
+
+   Another way of expressing the same thing:
+
+     <mailto:?to=joe@example.com&cc=bob@example.com&body=hello>
+
+
+
+Hoffman, et. al.            Standards Track                     [Page 4]
+
+RFC 2368                 The mailto URL scheme                 July 1998
+
+
+   Note the use of the "&" reserved character, above. The following
+   example, by using "?" twice, is incorrect:
+
+     <mailto:joe@example.com?cc=bob@example.com?body=hello>   ; WRONG!
+
+   According to RFC 822, the characters "?", "&", and even "%" may occur
+   in addr-specs. The fact that they are reserved characters in this URL
+   scheme is not a problem: those characters may appear in mailto URLs,
+   they just may not appear in unencoded form. The standard URL encoding
+   mechanisms ("%" followed by a two-digit hex number) must be used in
+   certain cases.
+
+   To indicate the address "gorby%kremvax@example.com" one would do:
+
+     <mailto:gorby%25kremvax@example.com>
+
+   To indicate the address "unlikely?address@example.com", and include
+   another header, one would do:
+
+     <mailto:unlikely%3Faddress@example.com?blat=foop>
+
+   As described above, the "&" (ampersand) character is reserved in HTML
+   and must be replacded with "&amp;". Thus, a complex URL that has
+   internal ampersands might look like:
+
+     Click
+     <a href="mailto:?to=joe@xyz.com&amp;cc=bob@xyz.com&amp;body=hello">
+     mailto:?to=joe@xyz.com&amp;cc=bob@xyz.com&amp;body=hello</a> to
+     send a greeting message to <i>Joe and Bob</i>.
+
+7. Security Considerations
+
+   The mailto scheme can be used to send a message from one user to
+   another, and thus can introduce many security concerns. Mail messages
+   can be logged at the originating site, the recipient site, and
+   intermediary sites along the delivery path. If the messages are not
+   encoded, they can also be read at any of those sites.
+
+   A mailto URL gives a template for a message that can be sent by mail
+   client software. The contents of that template may be opaque or
+   difficult to read by the user at the time of specifying the URL.
+   Thus, a mail client should never send a message based on a mailto URL
+   without first showing the user the full message that will be sent
+   (including all headers that were specified by the mailto URL), fully
+   decoded, and asking the user for approval to send the message as
+   electronic mail. The mail client should also make it clear that the
+   user is about to send an electronic mail message, since the user may
+   not be aware that this is the result of a mailto URL.
+
+
+
+Hoffman, et. al.            Standards Track                     [Page 5]
+
+RFC 2368                 The mailto URL scheme                 July 1998
+
+
+   A mail client should never send anything without complete disclosure
+   to the user of what is will be sent; it should disclose not only the
+   message destination, but also any headers. Unrecognized headers, or
+   headers with values inconsistent with those the mail client would
+   normally send should be especially suspect. MIME headers (MIME-
+   Version, Content-*) are most likely inappropriate, as are those
+   relating to routing (From, Bcc, Apparently-To, etc.)
+
+   Note that some headers are inherently unsafe to include in a message
+   generated from a URL. For example, headers such as "From:", "Bcc:",
+   and so on, should never be interpreted from a URL. In general, the
+   fewer headers interpreted from the URL, the less likely it is that a
+   sending agent will create an unsafe message.
+
+   Examples of problems with sending unapproved mail include:
+
+     * mail that breaks laws upon delivery, such as making illegal
+       threats;
+
+     * mail that identifies the sender as someone interested in breaking
+       laws;
+
+     * mail that identifies the sender to an unwanted third party;
+
+     * mail that causes a financial charge to be incurred on the sender;
+
+     * mail that causes an action on the recipient machine that causes
+       damage that might be attributed to the sender.
+
+   Programs that interpret mailto URLs should ensure that the SMTP
+   "From" address is set and correct.
+
+8. IANA Considerations
+
+   This document changes the definition of the mailto: URI scheme; any
+   registry of URI schemes should refer to this document rather than its
+   predecessor, RFC 1738.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Hoffman, et. al.            Standards Track                     [Page 6]
+
+RFC 2368                 The mailto URL scheme                 July 1998
+
+
+9. References
+
+   [RFC822] Crocker, D., "Standard for the Format of ARPA Internet Text
+            Messages", STD 11, RFC 822, August 1982.
+
+   [RFC1738] Berners-Lee, T., Masinter, L., and M. McCahill, Editors,
+             "Uniform Resource Locators (URL)", RFC 1738, December 1994.
+
+   [RFC1808] Fielding, R., "Relative Uniform Resource Locators", RFC
+             1808, June 1995.
+
+   [RFC2047] Moore, K., "MIME Part Three: Message Header Extensions for
+             Non-ASCII Text", RFC 2047, November 1996.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Hoffman, et. al.            Standards Track                     [Page 7]
+
+RFC 2368                 The mailto URL scheme                 July 1998
+
+
+A. Change from RFC 1738
+
+   RFC 1738 defined only a simple 'mailto' with no headers, just an
+   addr-spec (not a full mailbox.)  However, required usage and
+   implementation has led to the development of an extended syntax that
+   included more header fields.
+
+B. Acknowledgments
+
+   This document was derived from RFC 1738 and RFC 1808 [RFC1808]; the
+   acknowledgments from those specifications still applies.
+
+   The following people contributed to this memo or had and discussed
+   similar ideas for mailto.
+
+   Harald Alvestrand
+   Bryan Costales
+   Steve Dorner
+   Al Gilman
+   Mark Joseph
+   Laurence Lundblade
+   Keith Moore
+   Jacob Palme
+   Michael Patton
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Hoffman, et. al.            Standards Track                     [Page 8]
+
+RFC 2368                 The mailto URL scheme                 July 1998
+
+
+C. Author Contact Information
+
+   Paul E. Hoffman
+   Internet Mail Consortium
+   127 Segre Place
+   Santa Cruz, CA  95060 USA
+
+   EMail: phoffman@imc.org
+
+
+   Larry Masinter
+   Xerox Corporation
+   3333 Coyote Hill Road
+   Palo Alto, CA 94304 USA
+
+   EMail: masinter@parc.xerox.com
+
+
+   Jamie Zawinski
+   Netscape Communications Corp.
+   501 East Middlefield Road
+   Mountain View, CA 94043 USA
+
+   EMail: jwz@netscape.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Hoffman, et. al.            Standards Track                     [Page 9]
+
+RFC 2368                 The mailto URL scheme                 July 1998
+
+
+D.  Full Copyright Statement
+
+   Copyright (C) The Internet Society (1998).  All Rights Reserved.
+
+   This document and translations of it may be copied and furnished to
+   others, and derivative works that comment on or otherwise explain it
+   or assist in its implementation may be prepared, copied, published
+   and distributed, in whole or in part, without restriction of any
+   kind, provided that the above copyright notice and this paragraph are
+   included on all such copies and derivative works.  However, this
+   document itself may not be modified in any way, such as by removing
+   the copyright notice or references to the Internet Society or other
+   Internet organizations, except as needed for the purpose of
+   developing Internet standards in which case the procedures for
+   copyrights defined in the Internet Standards process must be
+   followed, or as required to translate it into languages other than
+   English.
+
+   The limited permissions granted above are perpetual and will not be
+   revoked by the Internet Society or its successors or assigns.
+
+   This document and the information contained herein is provided on an
+   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
+   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
+   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
+   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
+   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Hoffman, et. al.            Standards Track                    [Page 10]
+
diff -urN dovecot-1.2.4/dovecot-libsieve/doc/rfc/notify-mailto.rfc5436.txt dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/notify-mailto.rfc5436.txt
--- dovecot-1.2.4/dovecot-libsieve/doc/rfc/notify-mailto.rfc5436.txt	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/notify-mailto.rfc5436.txt	2009-02-02 10:17:30.000000000 +0100
@@ -0,0 +1,675 @@
+
+
+
+
+
+
+Network Working Group                                           B. Leiba
+Request for Comments: 5436               IBM T.J. Watson Research Center
+Updates: 3834                                                  M. Haardt
+Category: Standards Track                                freenet.de GmbH
+                                                            January 2009
+
+
+                  Sieve Notification Mechanism: mailto
+
+Status of This Memo
+
+   This document specifies an Internet standards track protocol for the
+   Internet community, and requests discussion and suggestions for
+   improvements.  Please refer to the current edition of the "Internet
+   Official Protocol Standards" (STD 1) for the standardization state
+   and status of this protocol.  Distribution of this memo is unlimited.
+
+Copyright Notice
+
+   Copyright (c) 2009 IETF Trust and the persons identified as the
+   document authors.  All rights reserved.
+
+   This document is subject to BCP 78 and the IETF Trust's Legal
+   Provisions Relating to IETF Documents (http://trustee.ietf.org/
+   license-info) in effect on the date of publication of this document.
+   Please review these documents carefully, as they describe your rights
+   and restrictions with respect to this document.
+
+Abstract
+
+   This document describes a profile of the Sieve extension for
+   notifications, to allow notifications to be sent by electronic mail.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Leiba & Haardt              Standards Track                     [Page 1]
+
+RFC 5436          Sieve Notification Mechanism: mailto      January 2009
+
+
+Table of Contents
+
+   1. Introduction ....................................................3
+      1.1. Overview ...................................................3
+      1.2. Conventions Used in This Document ..........................3
+   2. Definition ......................................................3
+      2.1. Notify Parameter "method" ..................................3
+      2.2. Test notify_method_capability ..............................3
+      2.3. Notify Tag ":from" .........................................3
+      2.4. Notify Tag ":importance" ...................................4
+      2.5. Notify Tag ":options" ......................................4
+      2.6. Notify Tag ":message" ......................................4
+      2.7. Other Definitions ..........................................4
+           2.7.1. The Auto-Submitted Header Field .....................6
+   3. Examples ........................................................7
+   4. Internationalization Considerations .............................8
+   5. Security Considerations .........................................9
+   6. IANA Considerations ............................................10
+      6.1. Registration of Notification Mechanism ....................10
+      6.2. New Registry for Auto-Submitted Header Field Keywords .....10
+      6.3. Initial Registration of Auto-Submitted Header
+           Field Keywords ............................................11
+   7. References .....................................................11
+      7.1. Normative References ......................................11
+      7.2. Informative References ....................................12
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Leiba & Haardt              Standards Track                     [Page 2]
+
+RFC 5436          Sieve Notification Mechanism: mailto      January 2009
+
+
+1.  Introduction
+
+1.1.  Overview
+
+   The [Notify] extension to the [Sieve] mail filtering language is a
+   framework for providing notifications by employing URIs to specify
+   the notification mechanism.  This document defines how [mailto] URIs
+   are used to generate notifications by email.
+
+1.2.  Conventions Used in This Document
+
+   Conventions for notations are as in Section 1.1 of [Sieve], including
+   the use of [Kwds].
+
+   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
+   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
+   document are to be interpreted as described in [Kwds].
+
+2.  Definition
+
+   The mailto mechanism results in the sending of a new email message (a
+   "notification message") to notify a recipient about a "triggering
+   message".
+
+2.1.  Notify Parameter "method"
+
+   The mailto notification mechanism uses standard mailto URIs as
+   specified in [mailto]. mailto URIs may contain header fields
+   consisting of a header name and value.  These header fields are
+   called "URI headers" to distinguish them from "message headers".
+
+2.2.  Test notify_method_capability
+
+   The notify_method_capability test for "online" may return "yes" or
+   "no" only if the Sieve processor can determine with certainty whether
+   or not the recipients of the notification message are online and
+   logged in.  Otherwise, the test returns "maybe" for this notification
+   method.
+
+2.3.  Notify Tag ":from"
+
+   The ":from" tag overrides the default sender of the notification
+   message.  "Sender", here, refers to the value used in the [RFC5322]
+   "From" header.  Implementations MAY also use this value in the
+   [RFC5321] "MAIL FROM" command (the "envelope sender"), or they may
+   prefer to establish a mailbox that receives bounces from notification
+   messages.
+
+
+
+
+Leiba & Haardt              Standards Track                     [Page 3]
+
+RFC 5436          Sieve Notification Mechanism: mailto      January 2009
+
+
+2.4.  Notify Tag ":importance"
+
+   The ":importance" tag has no special meaning for this notification
+   mechanism, and this specification puts no restriction on its use.
+   Implementations MAY use the value of ":importance" to set a priority
+   or importance indication on the notification message (perhaps a
+   visual indication, or perhaps making use of one of the non-standard
+   but commonly used message headers).
+
+2.5.  Notify Tag ":options"
+
+   This tag is not used by the mailto method.
+
+2.6.  Notify Tag ":message"
+
+   The value of this tag, if it is present, is used as the subject of
+   the notification message, and overrides all other mechanisms for
+   determining the subject (as described below).  Its value SHOULD NOT
+   normally be truncated, though it may be sensible to truncate an
+   excessively long value.
+
+2.7.  Other Definitions
+
+   Because the receipt of an email message is generating another email
+   message, implementations MUST take steps to avoid mail loops.  The
+   REQUIRED inclusion of an "Auto-Submitted:" field, as described in the
+   message composition guidelines, will also help in loop detection and
+   avoidance.
+
+   Implementations SHOULD NOT trigger notifications for messages
+   containing "Auto-Submitted:" header fields with any value other than
+   "No".
+
+   Implementations MUST allow messages with empty envelope senders to
+   trigger notifications.
+
+   Because this notification method uses a store-and-forward system for
+   delivery of the notification message, the Sieve processor should not
+   have a need to retry notifications.  Therefore, implementations of
+   this method SHOULD use normal mechanisms for submitting SMTP messages
+   and for retrying the initial submission.  Once the notification
+   message is submitted, implementations MUST NOT resubmit it, as this
+   is likely to result in multiple notifications, and increases the
+   danger of message loops.
+
+   Implementations SHOULD consider limiting notification messages.  In
+   particular, they SHOULD NOT sent duplicate notifications to the same
+   address from the same script invocation.  Batching of notifications
+
+
+
+Leiba & Haardt              Standards Track                     [Page 4]
+
+RFC 5436          Sieve Notification Mechanism: mailto      January 2009
+
+
+   within a short time to the same address might also be useful.
+   Different implementations, different administrative domains, and
+   different users may have different needs; configuration options are a
+   good idea here.
+
+   The overall notification message is composed using the following
+   guidelines (see [RFC5322] for references to message header fields):
+
+   o  If the envelope sender of the triggering message is empty, the
+      envelope sender of the notification message MUST be empty as well,
+      to avoid message loops.  Otherwise, the envelope sender of the
+      notification message SHOULD be set to the value of the ":from" tag
+      to the notify action, if one is specified, has email address
+      syntax, and is valid according to the implementation-specific
+      security checks (see Section 3.3 of [Notify]).  If ":from" is not
+      specified or is not valid, the envelope sender of the notification
+      message SHOULD be set either to the envelope "to" field from the
+      triggering message, as used by Sieve, or to an email address
+      associated with the notification system, at the discretion of the
+      implementation.  This MUST NOT be overridden by a "from" URI
+      header, and any such URI header MUST be ignored.
+
+   o  The envelope recipient(s) of the notification message SHOULD be
+      set to the address(es) specified in the URI (including any URI
+      headers where the hname is "to" or "cc").
+
+   o  The header field "Auto-Submitted: auto-notified" MUST be included
+      in the notification message (see Section 2.7.1).  This is to
+      reduce the likelihood of message loops, by tagging this as an
+      automatically generated message.  Among other results, it will
+      inform other notification systems not to generate further
+      notifications. mailto URI headers with hname "auto-submitted" are
+      considered unsafe and MUST be ignored.
+
+   o  The "From:" header field of the notification message SHOULD be set
+      to the value of the ":from" tag to the notify action, if one is
+      specified, has email address syntax, and is valid according to the
+      implementation-specific security checks (see Section 3.3 of
+      [Notify]).  If ":from" is not specified or is not valid, the
+      "From:" header field of the notification message SHOULD be set
+      either to the envelope "to" field from the triggering message, as
+      used by Sieve, or to an email address associated with the
+      notification system, at the discretion of the implementation.
+      This MUST NOT be overridden by a "from" URI header, and any such
+      URI header MUST be ignored.
+
+
+
+
+
+
+Leiba & Haardt              Standards Track                     [Page 5]
+
+RFC 5436          Sieve Notification Mechanism: mailto      January 2009
+
+
+   o  The "To:" header field of the notification message SHOULD be set
+      to the address(es) specified in the URI (including any URI headers
+      where the hname is "to").
+
+   o  The "Subject:" field of the notification message SHOULD contain
+      the value defined by the ":message" tag, as described in [Notify].
+      If there is no ":message" tag and there is a "subject" header on
+      the URI, then that value SHOULD be used.  If the "subject" header
+      is also absent, the subject SHOULD be retained from the triggering
+      message.  Note that Sieve [Variables] can be used to advantage
+      here, as shown in the example in Section 3.
+
+   o  The "References:" field of the notification message MAY be set to
+      refer to the triggering message, and MAY include references from
+      the triggering message.
+
+   o  If the mailto URI contains a "body" header, the value of that
+      header SHOULD be used as the body of the notification message.  If
+      there is no "body" header, it is up to the implementation whether
+      to leave the body empty or to use an excerpt of the original
+      message.
+
+   o  The "Received:" fields from the triggering message MAY be retained
+      in the notification message, as these could provide useful trace/
+      history/diagnostic information.  The "Auto-Submitted" header field
+      MUST be placed above these (see Section 2.7.1).  URI headers with
+      hname "received" are considered unsafe, and MUST be ignored.
+
+   o  Other header fields of the notification message that are normally
+      related to an individual new message (such as "Message-ID" and
+      "Date") are generated for the notification message in the normal
+      manner, and MUST NOT be copied from the triggering message.  Any
+      URI headers with those names MUST be ignored.  Further, the "Date"
+      header serves as the notification timestamp defined in [Notify].
+
+   o  All other header fields of the notification message either are as
+      specified by URI headers, or have implementation-specific values;
+      their values are not defined here.  It is suggested that the
+      implementation capitalize the first letter of URI headers and add
+      a space character after the colon between the mail header name and
+      value when adding URI headers to the message, to be consistent
+      with common practice in email headers.
+
+2.7.1.  The Auto-Submitted Header Field
+
+   The header field "Auto-Submitted: auto-notified" MUST be included in
+   the notification message (see [RFC3834]).  The "Auto-Submitted"
+   header field is considered a "trace field", similar to "Received"
+
+
+
+Leiba & Haardt              Standards Track                     [Page 6]
+
+RFC 5436          Sieve Notification Mechanism: mailto      January 2009
+
+
+   header fields (see [RFC5321]).  If the implementation retains the
+   "Received" fields from the triggering message (see above), the "Auto-
+   Submitted" field MUST be placed above those "Received" fields,
+   serving as a boundary between the ones from the triggering message
+   and those that will be part of the notification message.
+
+   The header field "Auto-Submitted: auto-notified" MUST include one or
+   both of the following parameters:
+
+   o  owner-email - specifies an email address, determined by the
+      implementation, of the owner of the Sieve script that generated
+      this notification.  If specified, it might be used to identify or
+      contact the script's owner.  The parameter attribute is "owner-
+      email", and the parameter value is a quoted string containing an
+      email address, as defined by "addr-spec" in [RFC5322].  Example:
+        Auto-Submitted: auto-notified; owner-email="me@example.com"
+
+   o  owner-token - specifies an opaque token, determined by the
+      implementation, that the administrative domain of the owner of the
+      Sieve script that generated this notification can use to identify
+      the owner.  This might be used to allow identification of the
+      owner while protecting the owner's privacy.  The parameter
+      attribute is "owner-token", and the parameter value is as defined
+      by "token" in [RFC3834].  Example:
+        Auto-Submitted: auto-notified; owner-token=af3NN2pK5dDXI0W
+
+   See Section 5 for discussion of possible uses of these parameters.
+
+3.  Examples
+
+   Triggering message (received by recipient@example.org):
+
+      Return-Path: <knitting-bounces@example.com>
+      Received: from mail.example.com by mail.example.org
+        for <recipient@example.org>; Wed, 7 Dec 2005 05:08:02 -0500
+      Received: from hobbies.example.com by mail.example.com
+        for <knitting@example.com>; Wed, 7 Dec 2005 02:00:26 -0800
+      Message-ID: <1234567.89ABCDEF@example.com>
+      Date: Wed, 07 Dec 2005 10:59:19 +0100
+      Precedence: list
+      List-Id: Knitting Mailing List <knitting.example.com>
+      Sender: knitting-bounces@example.com
+      Errors-To: knitting-bounces@example.com
+      From: "Jeff Smith" <jeff@hobbies.example.com>
+      To: "Knitting Mailing List" <knitting@example.com>
+      Subject: [Knitting] A new sweater
+
+      I just finished a great new sweater!
+
+
+
+Leiba & Haardt              Standards Track                     [Page 7]
+
+RFC 5436          Sieve Notification Mechanism: mailto      January 2009
+
+
+   Sieve script (run on behalf of recipient@example.org):
+
+      require ["enotify", "variables"];
+
+      if header :contains "list-id" "knitting.example.com" {
+        if header :matches "Subject" "[*] *" {
+          notify :message "From ${1} list: ${2}"
+              :importance "3"
+              "mailto:0123456789@sms.example.net?to=backup@example.com";
+        }
+      }
+
+
+   Notification message:
+
+      Auto-Submitted: auto-notified; owner-email="recipient@example.org"
+      Received: from mail.example.com by mail.example.org
+        for <recipient@example.org>; Wed, 7 Dec 2005 05:08:02 -0500
+      Received: from hobbies.example.com by mail.example.com
+        for <knitting@example.com>; Wed, 7 Dec 2005 02:00:26 -0800
+      Date: Wed, 7 Dec 2005 05:08:55 -0500
+      Message-ID: <A2299BB.FF7788@example.org>
+      From: recipient@example.org
+      To: 0123456789@sms.example.net, backup@example.com
+      Subject: From Knitting list: A new sweater
+
+   Note that:
+
+   o  Fields such as "Message-ID:" and "Date:" were generated afresh for
+      the notification message, and do not relate to the triggering
+      message.
+
+   o  Additional "Received:" fields will be added to the notification
+      message in transit; the ones shown were copied from the triggering
+      message.  New ones will be added above the Auto-Submitted: header
+      field.
+
+   o  If this message should appear at the mail.example.org server
+      again, the server can use the presence of a "mail.example.org"
+      received line to recognize that.  The Auto-Submitted header field
+      is also present to tell the server to avoid sending another
+      notification, and it includes an optional owner-email parameter
+      for identification.
+
+4.  Internationalization Considerations
+
+   This specification introduces no specific internationalization issues
+   that are not already addressed in [Sieve] and in [Notify].
+
+
+
+Leiba & Haardt              Standards Track                     [Page 8]
+
+RFC 5436          Sieve Notification Mechanism: mailto      January 2009
+
+
+5.  Security Considerations
+
+   Sending a notification is comparable with forwarding mail to the
+   notification recipient.  Care must be taken when forwarding mail
+   automatically, to ensure that confidential information is not sent
+   into an insecure environment.
+
+   The automated sending of email messages exposes the system to mail
+   loops, which can cause operational problems.  Implementations of this
+   specification MUST protect themselves against mail loops; see
+   Section 2.7 for discussion of this and some suggestions.  Other
+   possible mitigations for mail loops involve types of service
+   limitations.  For example, the number of notifications generated for
+   a single user might be limited to no more than, say, 30 in a
+   60-minute period.  Of course, this technique presents its own
+   problems, in that the actual rate-limit must be selected carefully,
+   to allow most legitimate situations in the given environment.  Even
+   with careful selection, it's inevitable that there will be false
+   positives -- and false negatives.
+
+   Ultimately, human intervention may be necessary to re-enable
+   notifications that have been disabled because a loop was detected, or
+   to terminate a very slow loop that's under the automatic-detection
+   radar.  Administrative mechanisms MUST be available to handle these
+   sorts of situations.
+
+   Email addresses specified as recipients of notifications might not be
+   owned by the entity that owns the Sieve script.  As a result, a
+   notification recipient could wind up as the target of unwanted
+   notifications, either through intent (using scripts to mount a mail-
+   bomb attack) or by accident (an address was mistyped or has been
+   reassigned).  The situation is arguably no worse than any other in
+   which a recipient gets unwanted email, and some of the same
+   mechanisms can be used in this case.  But those deploying this
+   extension have to be aware of the potential extra problems here,
+   where scripts might be created through means that do not adequately
+   validate email addresses, and such scripts might then be forgotten
+   and left to run indefinitely.
+
+   In particular, note that the Auto-Submitted header field is required
+   to include a value that a recipient can use when contacting the
+   source domain of the notification message (see Section 2.7.1).  That
+   value will allow the domain to track down the script's owner and have
+   the script corrected or disabled.  Domains that enable this extension
+   MUST be prepared to respond to such complaints, in order to limit the
+   damage caused by a faulty script.
+
+
+
+
+
+Leiba & Haardt              Standards Track                     [Page 9]
+
+RFC 5436          Sieve Notification Mechanism: mailto      January 2009
+
+
+   Problems can also show up if notification messages are sent to a
+   gateway into another service, such as SMS.  Information from the
+   email message is often lost in the gateway translation; and in this
+   case, critical information needed to avoid loops, to contact the
+   script owner, and to resolve other problems might be lost.
+   Developers of email gateways should consider these issues, and try to
+   preserve as much information as possible, including what appears in
+   email trace headers and the Auto-Submitted header field.
+
+   Additional security considerations are discussed in [Sieve] and in
+   [Notify].
+
+6.  IANA Considerations
+
+6.1.  Registration of Notification Mechanism
+
+   The following template specifies the IANA registration of the Sieve
+   notification mechanism specified in this document:
+
+   To: iana@iana.org
+   Subject: Registration of new Sieve notification mechanism
+   Mechanism name: mailto
+   Mechanism URI: RFC2368
+   Mechanism-specific options: none
+   Permanent and readily available reference: RFC 5436
+   Person and email address to contact for further information:
+      Michael Haardt <michael.haardt@freenet.ag>
+
+   This information should be added to the list of Sieve notification
+   mechanisms available from http://www.iana.org.
+
+6.2.  New Registry for Auto-Submitted Header Field Keywords
+
+   Because [RFC3834] does not define a registry for new keywords used in
+   the Auto-Submitted header field, we define one here, which has been
+   created and is available from http://www.iana.org.  Keywords are
+   registered using the "Specification Required" policy [IANA].
+
+   This defines the template to be used to register new keywords.
+   Initial entries to this registry follow in Section 6.3.
+
+   To: iana@iana.org
+   Subject: Registration of new auto-submitted header field keyword
+   Keyword value: [the text value of the field]
+   Description: [a brief explanation of the purpose of this value]
+   Parameters: [list any keyword-specific parameters, specify their
+      meanings, specify whether they are required or optional; use
+      "none" if there are none]
+
+
+
+Leiba & Haardt              Standards Track                    [Page 10]
+
+RFC 5436          Sieve Notification Mechanism: mailto      January 2009
+
+
+   Permanent and readily available reference: [identifies
+      the specification that defines the value being registered]
+   Contact: [name and email address to contact for further information]
+
+6.3.  Initial Registration of Auto-Submitted Header Field Keywords
+
+   The following are the initial keywords that have been registered in
+   the "Auto-Submitted Header Field Keywords" registry, available from
+   http://www.iana.org.
+
+   Keyword value: no
+   Description: Indicates that a message was NOT automatically
+      generated, but was created by a human.  It is the equivalent to
+      the absence of an Auto-Submitted header altogether.
+   Parameters: none
+   Permanent and readily available reference: RFC3834
+   Contact: Keith Moore <moore@network-heretics.com>
+
+   Keyword value: auto-generated
+   Description: Indicates that a message was generated by an automatic
+      process, and is not a direct response to another message.
+   Parameters: none
+   Permanent and readily available reference: RFC3834
+   Contact: Keith Moore <moore@network-heretics.com>
+
+   Keyword value: auto-replied
+   Description: Indicates that a message was automatically generated as
+      a direct response to another message.
+   Parameters: none
+   Permanent and readily available reference: RFC3834
+   Contact: Keith Moore <moore@network-heretics.com>
+
+   Keyword value: auto-notified
+   Description: Indicates that a message was generated by a Sieve
+      notification system.
+   Parameters: owner-email, owner-token.  At least one is required;
+      both refer to the owner of the Sieve script that generated this
+      message.  See the relevant RFC for details.
+   Permanent and readily available reference: RFC 5436
+   Contact: Michael Haardt <michael.haardt@freenet.ag>
+
+7.  References
+
+7.1.  Normative References
+
+   [IANA]       Narten, T. and H. Alvestrand, "Guidelines for Writing an
+                IANA Considerations Section in RFCs", BCP 26, RFC 5226,
+                May 2008.
+
+
+
+Leiba & Haardt              Standards Track                    [Page 11]
+
+RFC 5436          Sieve Notification Mechanism: mailto      January 2009
+
+
+   [Kwds]       Bradner, S., "Key words for use in RFCs to Indicate
+                Requirement Levels", BCP 14, RFC 2119, March 1997.
+
+   [Notify]     Melnikov, A., Ed., Leiba, B., Ed., Segmuller, W., and T.
+                Martin, "Sieve Email Filtering: Extension for
+                Notifications", RFC 5435, January 2009.
+
+   [RFC3834]    Moore, K., "Recommendations for Automatic Responses to
+                Electronic Mail", RFC 3834, August 2004.
+
+   [RFC5322]    Resnick, P., Ed., "Internet Message Format", RFC 5322,
+                October 2008.
+
+   [Sieve]      Guenther, P., Ed. and T. Showalter, Ed., "Sieve: An
+                Email Filtering Language", RFC 5228, January 2008.
+
+   [mailto]     Hoffman, P., Masinter, L., and J. Zawinski, "The mailto
+                URL scheme", RFC 2368, July 1998.
+
+7.2.  Informative References
+
+   [RFC5321]    Klensin, J., Ed., "Simple Mail Transfer Protocol",
+                RFC 5321, October 2008.
+
+   [Variables]  Homme, K., "Sieve Extension: Variables", RFC 5229,
+                January 2008.
+
+Authors' Addresses
+
+   Barry Leiba
+   IBM T.J. Watson Research Center
+   19 Skyline Drive
+   Hawthorne, NY  10532
+   US
+
+   Phone: +1 914 784 7941
+   EMail: leiba@watson.ibm.com
+
+
+   Michael Haardt
+   freenet.de GmbH
+   Willstaetter Str. 13
+   Duesseldorf, NRW  40549
+   Germany
+
+   Phone: +49 241 53087 520
+   EMail: michael.haardt@freenet.ag
+
+
+
+
+Leiba & Haardt              Standards Track                    [Page 12]
+
diff -urN dovecot-1.2.4/dovecot-libsieve/doc/rfc/notify.rfc5435.txt dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/notify.rfc5435.txt
--- dovecot-1.2.4/dovecot-libsieve/doc/rfc/notify.rfc5435.txt	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/notify.rfc5435.txt	2009-02-02 10:17:30.000000000 +0100
@@ -0,0 +1,955 @@
+
+
+
+
+
+
+Network Working Group                                   A. Melnikov, Ed.
+Request for Comments: 5435                                 Isode Limited
+Category: Standards Track                                  B. Leiba, Ed.
+                                                            W. Segmuller
+                                         IBM T.J. Watson Research Center
+                                                               T. Martin
+                                                       Endless Crossword
+                                                            January 2009
+
+
+           Sieve Email Filtering: Extension for Notifications
+
+Status of This Memo
+
+   This document specifies an Internet standards track protocol for the
+   Internet community, and requests discussion and suggestions for
+   improvements.  Please refer to the current edition of the "Internet
+   Official Protocol Standards" (STD 1) for the standardization state
+   and status of this protocol.  Distribution of this memo is unlimited.
+
+Copyright Notice
+
+   Copyright (c) 2009 IETF Trust and the persons identified as the
+   document authors.  All rights reserved.
+
+   This document is subject to BCP 78 and the IETF Trust's Legal
+   Provisions Relating to IETF Documents (http://trustee.ietf.org/
+   license-info) in effect on the date of publication of this document.
+   Please review these documents carefully, as they describe your rights
+   and restrictions with respect to this document.
+
+Abstract
+
+   Users go to great lengths to be notified as quickly as possible that
+   they have received new mail.  Most of these methods involve polling
+   to check for new messages periodically.  A push method handled by the
+   final delivery agent gives users quicker notifications and saves
+   server resources.  This document does not specify the notification
+   method, but it is expected that using existing instant messaging
+   infrastructure such as Extensible Messaging and Presence Protocol
+   (XMPP), or Global System for Mobile Communications (GSM) Short
+   Message Service (SMS) messages will be popular.  This document
+   describes an extension to the Sieve mail filtering language that
+   allows users to give specific rules for how and when notifications
+   should be sent.
+
+
+
+
+
+
+Melnikov, et al.            Standards Track                     [Page 1]
+
+RFC 5435             Sieve Extension: Notifications         January 2009
+
+
+Table of Contents
+
+   1. Introduction ....................................................3
+      1.1. Conventions Used in This Document ..........................3
+   2. Capability Identifier ...........................................3
+   3. Notify Action ...................................................3
+      3.1. Notify Action Syntax and Semantics .........................3
+      3.2. Notify Parameter "method" ..................................3
+      3.3. Notify Tag ":from" .........................................4
+      3.4. Notify Tag ":importance" ...................................4
+      3.5. Notify Tag ":options" ......................................5
+      3.6. Notify Tag ":message" ......................................5
+      3.7. Examples ...................................................6
+      3.8. Requirements on Notification Methods Specifications ........7
+   4. Test valid_notify_method ........................................8
+   5. Test notify_method_capability ...................................9
+   6. Modifier encodeurl to the 'set' Action .........................10
+   7. Interactions with Other Sieve Actions ..........................11
+   8. Security Considerations ........................................11
+   9. IANA Considerations ............................................13
+      9.1. Registration of Sieve Extension ...........................13
+      9.2. New Registry for Sieve Notification Mechanisms ............14
+      9.3. New Registry for Notification-Capability Parameters .......14
+   10. Acknowledgements ..............................................15
+   11. References ....................................................16
+      11.1. Normative References .....................................16
+      11.2. Informative References ...................................16
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Melnikov, et al.            Standards Track                     [Page 2]
+
+RFC 5435             Sieve Extension: Notifications         January 2009
+
+
+1.  Introduction
+
+   This is an extension to the Sieve language defined by [Sieve] for
+   providing instant notifications.  It defines the new action "notify".
+
+   This document does not specify the notification methods.  Examples of
+   possible notification methods are email and XMPP.  To allow for the
+   portability of scripts that use notifications, implementation of the
+   [MailTo] method is mandatory.  Other available methods shall depend
+   upon the implementation and configuration of the system.
+
+1.1.  Conventions Used in This Document
+
+   Conventions for notations are as in [Sieve], Section 1.1, including
+   the use of [ABNF].
+
+   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
+   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
+   document are to be interpreted as described in [Kwds].
+
+2.  Capability Identifier
+
+   The capability string associated with the extension defined in this
+   document is "enotify".
+
+3.  Notify Action
+
+3.1.  Notify Action Syntax and Semantics
+
+   Usage:  notify [":from" string]
+           [":importance" <"1" / "2" / "3">]
+           [":options" string-list]
+           [":message" string]
+           <method: string>
+
+   The "notify" action specifies that a notification should be sent to a
+   user.  The format of the notification is implementation-defined and
+   is also affected by the notification method used (see Section 3.2).
+   However, all content specified in the ":message" parameter SHOULD be
+   included.
+
+3.2.  Notify Parameter "method"
+
+   The "method" positional parameter identifies the notification method
+   that will be used; it is a URI [URI].  For example, the notification
+   method can be a tel URI [TEL-URI] with a phone number to send SMS
+   messages to, or an XMPP [XMPP] URI containing an XMPP identifier
+   [XMPP-URI].
+
+
+
+Melnikov, et al.            Standards Track                     [Page 3]
+
+RFC 5435             Sieve Extension: Notifications         January 2009
+
+
+   The supported URI values will be site-specific, but support for the
+   [MailTo] method is REQUIRED in order to ensure interoperability.  If
+   a URI schema is specified that the implementation does not support,
+   the notification MUST cause an error condition at run time.  Sieve
+   scripts can check the supported methods using the valid_notify_method
+   test to be sure that they only use supported ones, to avoid such
+   error conditions.
+
+   If the "method" parameter contains a supported URI schema, then the
+   URI MUST be checked for syntactic validity.  Invalid URI syntax or an
+   unsupported URI extension MUST cause an error.  An implementation MAY
+   enforce other semantic restrictions on URIs -- for example, to
+   restrict phone numbers in a tel: URI to a particular geographical
+   region -- and will treat violations of such semantic restrictions as
+   errors.
+
+3.3.  Notify Tag ":from"
+
+   A ":from" tag may be used to specify an author of the notification.
+   The syntax of this parameter's value is method-specific.
+   Implementations SHOULD check the syntax according to the notification
+   method specification and generate an error when a syntactically
+   invalid ":from" tag is specified.
+
+   In order to minimize/prevent forgery of the author value,
+   implementations SHOULD impose restrictions on what values can be
+   specified in a ":from" tag.  For example, an implementation may
+   restrict this value to be a member of a list of known author
+   addresses or to belong to a particular domain.  It is suggested that
+   values that don't satisfy such restrictions simply be ignored rather
+   than causing the "notify" action to fail.
+
+3.4.  Notify Tag ":importance"
+
+   The ":importance" tag specifies the importance of quick delivery of
+   the notification, as perceived by the Sieve script owner.  The
+   ":importance" tag is followed by a numeric value represented as a
+   string: "1" (high importance), "2" (normal importance), and "3" (low
+   importance).  If no importance is given, the default value "2" SHOULD
+   be assumed.  A notification method MAY treat the importance value as
+   a transport indicator.  For example, it might deliver notifications
+   of high importance quicker than notifications of normal or low
+   importance.  Some notification methods allow users to specify their
+   state of activity (for example, "busy" or "away from keyboard").  If
+   the notification method provides this information, it SHOULD be used
+   to selectively send notifications.  If, for example, the user marks
+
+
+
+
+
+Melnikov, et al.            Standards Track                     [Page 4]
+
+RFC 5435             Sieve Extension: Notifications         January 2009
+
+
+   herself as "busy", a notification method can require that a
+   notification with importance of "3" is not to be sent; however, the
+   user might be notified of a notification with higher importance.
+
+   If the notification method allows users to filter messages based upon
+   certain parameters in the message, users SHOULD be able to filter
+   based upon importance.  If the notification method does not support
+   importance, then this parameter MUST be ignored.  An implementation
+   MAY include the importance value in the default message, Section 3.6,
+   if one is not provided.
+
+3.5.  Notify Tag ":options"
+
+   The ":options" tag is used to send additional parameters to the
+   notification method.  Interpretation of the parameters is method-
+   specific.  This document doesn't specify any such additional
+   parameter.
+
+   Each string in the options string list has the following syntax:
+   "<optionname>=<value>"
+   where optionname has the following ABNF [ABNF]:
+
+
+      l-d = ALPHA / DIGIT
+      l-d-p = l-d / "." / "-" / "_"
+      optionname = l-d *l-d-p
+      value = *(%x01-09 / %x0B-0C / %x0E-FF)
+
+3.6.  Notify Tag ":message"
+
+   The ":message" tag specifies the message data to be included in the
+   notification.  The entirety of the string SHOULD be sent, but
+   implementations MAY shorten the message for technical or aesthetic
+   reasons.  If the ":message" parameter is absent, a default
+   implementation-specific message is used.  Unless otherwise specified
+   by a particular notification mechanism, an implementation default
+   containing at least the value of the "From" header field and the
+   value of the "Subject" header field is RECOMMENDED.
+
+   In order to construct more complex messages, the notify extension can
+   be used together with the Sieve variables extension [Variables], as
+   shown in the examples below.
+
+
+
+
+
+
+
+
+
+Melnikov, et al.            Standards Track                     [Page 5]
+
+RFC 5435             Sieve Extension: Notifications         January 2009
+
+
+3.7.  Examples
+
+   Example 1:
+       require ["enotify", "fileinto", "variables"];
+
+       if header :contains "from" "boss@example.org" {
+           notify :importance "1"
+               :message "This is probably very important"
+                           "mailto:alm@example.com";
+           # Don't send any further notifications
+           stop;
+       }
+
+       if header :contains "to" "sievemailinglist@example.org" {
+           # :matches is used to get the value of the Subject header
+           if header :matches "Subject" "*" {
+               set "subject" "${1}";
+           }
+
+           # :matches is used to get the value of the From header
+           if header :matches "From" "*" {
+               set "from" "${1}";
+           }
+
+           notify :importance "3"
+               :message "[SIEVE] ${from}: ${subject}"
+               "mailto:alm@example.com";
+           fileinto "INBOX.sieve";
+       }
+
+   Example 2:
+       require ["enotify", "fileinto", "variables", "envelope"];
+
+       if header :matches "from" "*@*.example.org" {
+           # :matches is used to get the MAIL FROM address
+           if envelope :all :matches "from" "*" {
+               set "env_from" " [really: ${1}]";
+           }
+
+           # :matches is used to get the value of the Subject header
+           if header :matches "Subject" "*" {
+               set "subject" "${1}";
+           }
+
+           # :matches is used to get the address from the From header
+           if address :matches :all "from" "*" {
+               set "from_addr" "${1}";
+           }
+
+
+
+Melnikov, et al.            Standards Track                     [Page 6]
+
+RFC 5435             Sieve Extension: Notifications         January 2009
+
+
+           notify :message "${from_addr}${env_from}: ${subject}"
+                           "mailto:alm@example.com";
+       }
+
+ Example 3:
+     require ["enotify", "variables"];
+
+     set "notif_method"
+     "xmpp:tim@example.com?message;subject=SIEVE;body=You%20got%20mail";
+
+     if header :contains "subject" "Your dog" {
+         set "notif_method" "tel:+14085551212";
+     }
+
+     if header :contains "to" "sievemailinglist@example.org" {
+         set "notif_method" "";
+     }
+
+     if not string :is "${notif_method}" "" {
+         notify "${notif_method}";
+     }
+
+     if header :contains "from" "boss@example.org" {
+         # :matches is used to get the value of the Subject header
+         if header :matches "Subject" "*" {
+             set "subject" "${1}";
+         }
+
+         # don't need high importance notification for
+         # a 'for your information'
+         if not header :contains "subject" "FYI:" {
+             notify :importance "1" :message "BOSS: ${subject}"
+                                "tel:+14085551212";
+         }
+     }
+
+3.8.  Requirements on Notification Methods Specifications
+
+   This section describes requirements for documents that define
+   specific Sieve notification methods.
+
+   Notification mechanisms MUST NOT add new Sieve tags to the "notify"
+   action.
+
+   A notification method MAY allow modification of the final
+   notification text -- for example, truncating it if it exceeds a
+   length limit or modifying characters that can not be represented in
+   the target character set.  Characters in the notification text that
+
+
+
+Melnikov, et al.            Standards Track                     [Page 7]
+
+RFC 5435             Sieve Extension: Notifications         January 2009
+
+
+   can't be represented by the notification method SHOULD be replaced
+   with a symbol indicating an unknown character.  Allowed modifications
+   MUST be documented in the document describing the notification
+   method.
+
+   A notification method MAY ignore parameters specified in the "notify"
+   action.
+
+   A notification method MAY recommend the default message value to be
+   used if the ":message" argument is not specified.
+
+   Notifications SHOULD include timestamps, if the notification method
+   allows for their transmission outside of the textual message.
+   Implementation methods that can only transmit timestamps in the
+   textual message MAY include them in the textual message.
+
+   A notification MUST include means to identify/track its origin in
+   order to allow a recipient to stop notifications or find out how to
+   contact the sender.  This requirement is to help with tracking a
+   misconfigured or abusive origin of notifications.
+
+   Methods SHOULD NOT include any other extraneous information not
+   specified in parameters to the "notify" action.
+
+   Methods MUST specify which URI parameters (if any) must be ignored,
+   which ones must be used in the resulting notification, and which ones
+   must cause an error.
+
+   Methods MUST specify what values are returned by the
+   notify_method_capability test, Section 5, in particular for the
+   "online" notification-capability.
+
+   If there are errors sending the notification, the Sieve interpreter
+   SHOULD ignore the notification and not retry indefinitely.  The Sieve
+   interpreter MAY throttle notifications; if it does, a request to send
+   a notification MAY be silently ignored.  Documents describing
+   notification methods SHOULD describe how retries, throttling,
+   duplicate suppression (if any), etc. are to be handled by
+   implementations.
+
+4.  Test valid_notify_method
+
+   Usage:  valid_notify_method <notification-uris: string-list>
+
+   The valid_notify_method test is true if the notification methods
+   listed in the notification-uris argument are supported and they are
+   valid both syntactically (including URI parameters) and semantically
+
+
+
+
+Melnikov, et al.            Standards Track                     [Page 8]
+
+RFC 5435             Sieve Extension: Notifications         January 2009
+
+
+   (including implementation-specific semantic restrictions).  This test
+   MUST perform exactly the same validation as would be performed on the
+   "method" parameter to the "notify" action.
+
+   The test is true only if ALL of the listed notification methods are
+   supported and valid.
+
+   Example 4 (partial):
+             if not valid_notify_method ["mailto:",
+                     "http://gw.example.net/notify?test"] {
+                 stop;
+             }
+
+5.  Test notify_method_capability
+
+   Usage:  notify_method_capability [COMPARATOR] [MATCH-TYPE]
+           <notification-uri: string>
+           <notification-capability: string>
+           <key-list: string-list>
+
+   The notify_method_capability test retrieves the notification
+   capability specified by the notification-capability string that is
+   specific to the notification-uri and matches it to the values
+   specified in the key-list.  The test succeeds if a match occurs.  The
+   type of match defaults to ":is", and the default comparator is
+   "i;ascii-casemap".
+
+   The notification-capability parameter is case insensitive.
+
+   The notify_method_capability test MUST fail unconditionally if the
+   specified notification-uri is syntactically invalid (as determined by
+   the valid_notify_method test, Section 4) or specifies an unsupported
+   notification method.  However this MUST NOT cause an error.
+
+   The notify_method_capability test MUST fail unconditionally if the
+   specified notification-capability item is not known to the Sieve
+   interpreter.  A script MUST NOT fail with an error if the item does
+   not exist.  This allows scripts to be written that handle nonexistent
+   items gracefully.
+
+   This document defines a single notification-capability value
+   "online", which is described below.  Additional notification-
+   capability values may be defined by using the procedure defined in
+   Section 9.3.
+
+   The "relational" extension [Relational] adds a match type called
+   ":count".  The count of an notify_method_capability test is 0, if the
+   returned information is the empty string, or 1.
+
+
+
+Melnikov, et al.            Standards Track                     [Page 9]
+
+RFC 5435             Sieve Extension: Notifications         January 2009
+
+
+   For the "online" notification-capability, the
+   notify_method_capability test can match one of the following key-list
+   values:
+
+   o  "yes" - the entity identified by the notification-uri can receive
+      a notify notification immediately.  Note that even after this
+      value is returned, there is no guarantee that the entity would
+      actually be able to receive any notification immediately or even
+      receive it at all.  Transport errors, recipient policy, etc. can
+      prevent that.
+
+   o  "no" - the entity identified by the notification-uri is not
+      currently available to receive an immediate notification.
+
+   o  "maybe" - the Sieve interpreter can't determine if the entity
+      identified by the notification-uri is online or not.
+
+   Example 5:
+             require ["enotify"];
+
+             if notify_method_capability
+                    "xmpp:tim@example.com?message;subject=SIEVE"
+                    "Online"
+                    "yes" {
+                 notify :importance "1" :message "You got mail"
+                      "xmpp:tim@example.com?message;subject=SIEVE";
+             } else {
+                 notify :message "You got mail" "tel:+14085551212";
+             }
+
+6.  Modifier encodeurl to the 'set' Action
+
+   Usage:  ":encodeurl"
+
+   When the Sieve script specifies both "variables" [Variables] and
+   "enotify" capabilities in the "require", a new "set" action modifier
+   (see [Variables]) ":encodeurl" becomes available to Sieve scripts.
+   This modifier performs percent-encoding of any octet in the string
+   that doesn't belong to the "unreserved" set (see [URI]).  The
+   percent-encoding procedure is described in [URI].
+
+   The ":encodeurl" modifier has precedence 15.
+
+
+
+
+
+
+
+
+
+Melnikov, et al.            Standards Track                    [Page 10]
+
+RFC 5435             Sieve Extension: Notifications         January 2009
+
+
+   Example 6:
+       require ["enotify", "variables"];
+
+       set :encodeurl "body_param" "Safe body&evil=evilbody";
+
+       notify "mailto:tim@example.com?body=${body_param}";
+
+7.  Interactions with Other Sieve Actions
+
+   The "notify" action is compatible with all other actions, and does
+   not affect the operation of other actions.  In particular, the
+   "notify" action MUST NOT cancel the implicit keep.
+
+   Multiple executed "notify" actions are allowed.  Specific
+   notification methods MAY allow multiple notifications from the same
+   script to be collapsed into one.
+
+8.  Security Considerations
+
+   Security considerations are discussed in [Sieve].  Additionally,
+   implementations must be careful to follow the security considerations
+   of the specific notification methods.
+
+   The "notify" action is potentially very dangerous.  The path the
+   notification takes through the network may not be secure.  An error
+   in the options string may cause the message to be transmitted to
+   someone it was not intended for, or may expose information to
+   eavesdroppers.
+
+   Just because a notification is received doesn't mean that it was sent
+   by the Sieve implementation.  It might be possible to forge
+   notifications or modify parts of valid notifications with some
+   notification methods.
+
+   Forgery of the ":importance" value (for example, by unauthorized
+   script modification) can potentially result in slowdown in
+   notification delivery.
+
+   Note that some components of notifications should not be trusted.
+   For example, the timestamp field can be easily forged or modified
+   when some notification transports are used.  Even if the timestamp is
+   believed to be correct by the sender and is not modified in transit,
+   it might be misleading on the receiving system due to clock
+   differences.
+
+
+
+
+
+
+
+Melnikov, et al.            Standards Track                    [Page 11]
+
+RFC 5435             Sieve Extension: Notifications         January 2009
+
+
+   An organization may have a policy about the forwarding of classified
+   information to unclassified networks.  Unless the policy is also
+   enforced in the module responsible for the generating (or sending) of
+   notifications, users can use the extension defined in this document
+   to extract classified information and bypass the policy.
+
+   Notifications can result in loops and bounces.  Also, allowing a
+   single script to notify multiple destinations can be used as a means
+   of amplifying the number of messages in an attack.  Moreover, if loop
+   detection is not properly implemented, it may be possible to set up
+   exponentially growing notification loops.  Accordingly, Sieve
+   notification methods:
+
+   1.  MUST provide mechanisms for avoiding notification loops.
+
+   2.  MUST provide the means for administrators to limit the ability of
+       users to abuse notify.  In particular, it MUST be possible to
+       limit the number of "notify" actions a script can perform.
+       Additionally, if no use cases exist for using "notify" with
+       multiple destinations, this limit SHOULD be set to 1.  Additional
+       limits, such as the ability to restrict "notify" to local users,
+       MAY also be implemented.
+
+   3.  MUST provide facilities to log the use of "notify" in order to
+       facilitate tracking down abuse.
+
+   4.  MAY use script analysis to determine whether or not a given
+       script can be executed safely.  While the Sieve language is
+       sufficiently complex so that full analysis of all possible
+       scripts is computationally infeasible, the majority of real-world
+       scripts are amenable to analysis.  For example, an implementation
+       might allow scripts that it has determined to be safe to run
+       unhindered, block scripts that are potentially problematic, and
+       subject unclassifiable scripts to additional auditing and
+       logging.
+
+   Allowing "notify" action at all may not be appropriate in situations
+   where Sieve scripts are associated with email accounts that are
+   freely-available and/or not trackable to a human who can be held
+   accountable for creating message bombs or other abuse.
+
+   Implementations that construct URIs internally from various notify
+   parameters MUST make sure that all components of such URIs are
+   properly percent-encoded (see [URI]).  In particular, this applies to
+   values of the ":from" and ":message" tagged arguments and may apply
+   to the ":options" values.
+
+
+
+
+
+Melnikov, et al.            Standards Track                    [Page 12]
+
+RFC 5435             Sieve Extension: Notifications         January 2009
+
+
+   Header/envelope tests [Sieve], together with Sieve variables, can be
+   used to extract the list of users to receive notifications from the
+   incoming email message or its envelope.  This is potentially quite
+   dangerous, as this can be used for denial-of-service attacks on
+   recipients controlled by the message sender.  For this reason,
+   implementations SHOULD NOT allow the use of variables containing
+   values extracted from the email message in the "method" parameter to
+   the "notify" action.  Note that violation of this SHOULD NOT may
+   result in the creation of an open relay, i.e., any sender would be
+   able to create specially crafted email messages that would result in
+   notifications delivered to recipients under the control of the
+   sender.  In the worst case, this might result in financial loss by
+   the user controlling the Sieve script and/or by recipients of
+   notifications (e.g., if a notification is an SMS message).
+
+   Note that the last SHOULD NOT is not a generic prohibition of use of
+   variables in the "notify" action, as controlling the target of a
+   notification by extracting it from user-owned data stores (such as
+   user's Lightweight Directory Access Protocol (LDAP) entry) is
+   considered to be useful.
+
+   It is imperative that whatever implementations use to store the user-
+   defined filtering scripts protect them from unauthorized
+   modification, to preserve the integrity of the mail system.  An
+   attacker who can modify a script can cause mail to be discarded,
+   rejected, or forwarded to an unauthorized recipient.  In addition,
+   it's possible that Sieve scripts might expose private information,
+   such as mailbox names or email addresses of favored (or disfavored)
+   correspondents.  Because of that, scripts SHOULD also be protected
+   from unauthorized retrieval.
+
+9.  IANA Considerations
+
+9.1.  Registration of Sieve Extension
+
+   To:  iana@iana.org
+   Subject:  Registration of new Sieve extension
+   Capability name:  enotify
+   Description:  adds the "notify" action for notifying user about the
+      received message.  It also provides two new tests:
+         valid_notify_method checks notification URIs for validity;
+         notify_method_capability can check recipients capabilities.
+   RFC number:  this RFC
+   Contact address:  The Sieve discussion list
+      <ietf-mta-filters@imc.org>
+
+   This information has been added to the list of Sieve extensions
+   available from http://www.iana.org/.
+
+
+
+Melnikov, et al.            Standards Track                    [Page 13]
+
+RFC 5435             Sieve Extension: Notifications         January 2009
+
+
+9.2.  New Registry for Sieve Notification Mechanisms
+
+   IANA has created a new registry for Sieve notification mechanisms.
+   This registry contains both vendor-controlled notification mechanism
+   names (beginning with "vnd.") and IETF-controlled notification
+   mechanism names.  Vendor-controlled notification mechanism names have
+   the format as defined in the following paragraph and may be
+   registered on a "First Come First Served" basis [IANA-GUIDELINES], by
+   applying to IANA with the form specified later in this section.
+   Registration of notification mechanisms that do not begin with "vnd."
+   are registered using a "Specification Required" policy
+   [IANA-GUIDELINES].
+
+   Vendor-controlled notification mechanism names MUST have the form
+   "vnd.<vendor-name>.<mechanism-name>", where <vendor-name> is as
+   specified in the Application Configuration Access Protocol (ACAP)
+   Vendor Subtree registry [ACAP].
+
+   This defines the template for a new registry for Sieve notification
+   mechanisms, which has been created and is available from
+   http://www.iana.org/.  There are no initial entries for this
+   registry.
+
+   To:  iana@iana.org
+   Subject:  Registration of new Sieve notification mechanism
+   Mechanism name:  [the name of the mechanism]
+   Mechanism URI:  [the RFC number of the document that defines the URI
+      used by this mechanism.  Different mechanisms MUST use different
+      URI schema.]
+   Mechanism-specific options:  [the names of any Sieve notify options
+      (as used in the ":options" parameter) that are specific to this
+      mechanism, or "none"]
+   Permanent and readily available reference:  [the RFC number or an URL
+      of the document that defines this notification mechanism]
+   Person and email address to contact for further information:  [the
+      name and email address of the technical contact for information
+      about this mechanism]
+
+9.3.  New Registry for Notification-Capability Parameters
+
+   IANA has created a new registry for the notification-capability
+   parameters of the notify_method_capability test.  This registry
+   contains both vendor-controlled notification-capability values
+   (beginning with "vnd.") and IETF-controlled notification-capability
+   values.  Vendor-controlled notification-capability values have the
+   format as defined in the following paragraph and may be registered on
+   a "First Come First Served" basis [IANA-GUIDELINES], by applying to
+   IANA with the form specified later in this section.  Registration of
+
+
+
+Melnikov, et al.            Standards Track                    [Page 14]
+
+RFC 5435             Sieve Extension: Notifications         January 2009
+
+
+   notification-capability values that do not begin with "vnd." are
+   registered using the "Specification Required" policy
+   [IANA-GUIDELINES].
+
+   Vendor-controlled notification-capability values MUST have the form
+   "vnd.<vendor-name>.<capability-name>", where <vendor-name> is as
+   specified in the ACAP Vendor Subtree registry [ACAP].
+
+   The following template must be used for registering notification-
+   capability parameters:
+
+   To:  iana@iana.org
+   Subject:  Registration of a new notification-capability parameter
+   Capability name:  [the name of the notification-capability]
+   Description:  [an explanation of the purpose of the notification-
+      capability]
+   Syntax:  [formal definition of allowed values and their syntax]
+   Permanent and readily available reference(s):  [the RFC number(s) or
+      an URL of the document that defines this notification mechanism]
+   Contact information:  [the name and email address of the technical
+      contact for information about this mechanism]
+
+   Below is the registration form for the "online" notification-
+   capability:
+
+   To:  iana@iana.org
+   Subject:  Registration of a new notification-capability parameter
+   Capability name:  online
+   Description:  Returns whether the entity identified by the
+      notification-uri parameter to the notify_method_capability test
+      can receive a notify notification immediately.
+   Syntax:  Can contain one of three values: "yes", "no", and, "maybe".
+      Values MUST be in lowercase.
+   Permanent and readily available reference(s):  This RFC
+   Contact information:  The Sieve discussion list
+      <ietf-mta-filters@imc.org>
+
+10.  Acknowledgements
+
+   Thanks to Larry Greenfield, Sarah Robeson, Tim Showalter, Cyrus
+   Daboo, Nigel Swinson, Kjetil Torgrim Homme, Michael Haardt, Mark E.
+   Mallett, Ned Freed, Lisa Dusseault, Dilyan Palauzov, Arnt
+   Gulbrandsen, Peter Saint-Andre, Sean Turner, Cullen Jennings, and
+   Pasi Eronen for help with this document.
+
+
+
+
+
+
+
+Melnikov, et al.            Standards Track                    [Page 15]
+
+RFC 5435             Sieve Extension: Notifications         January 2009
+
+
+11.  References
+
+11.1.  Normative References
+
+   [ABNF]             Crocker, D., Ed. and P. Overell, "Augmented BNF
+                      for Syntax Specifications: ABNF", STD 68,
+                      RFC 5234, January 2008.
+
+   [Kwds]             Bradner, S., "Key words for use in RFCs to
+                      Indicate Requirement Levels", BCP 14, RFC 2119,
+                      March 1997.
+
+   [MailTo]           Leiba, B. and M. Haardt, "Sieve Notification
+                      Mechanism: mailto", RFC 5436, January 2009.
+
+   [Relational]       Segmuller, W. and B. Leiba, "Sieve Extension:
+                      Relational Tests", RFC 5231, January 2008.
+
+   [Sieve]            Guenther, P., Ed. and T. Showalter, Ed., "Sieve:
+                      An Email Filtering Language", RFC 5228,
+                      January 2008.
+
+   [URI]              Berners-Lee, T., Fielding, R., and L. Masinter,
+                      "Uniform Resource Identifier (URI): Generic
+                      Syntax", STD 66, RFC 3986, January 2005.
+
+   [Variables]        Homme, K., "Sieve Extension: Variables", RFC 5229,
+                      January 2008.
+
+11.2.  Informative References
+
+   [ACAP]             Newman, C. and J. Myers, "ACAP -- Application
+                      Configuration Access Protocol", RFC 2244,
+                      November 1997.
+
+   [IANA-GUIDELINES]  Narten, T. and H. Alvestrand, "Guidelines for
+                      Writing an IANA Considerations Section in RFCs",
+                      BCP 26, RFC 5226, May 2008.
+
+   [TEL-URI]          Schulzrinne, H., "The tel URI for Telephone
+                      Numbers", RFC 3966, December 2004.
+
+   [XMPP]             Saint-Andre, Ed., P., "Extensible Messaging and
+                      Presence Protocol (XMPP): Core", RFC 3920,
+                      October 2004.
+
+
+
+
+
+
+Melnikov, et al.            Standards Track                    [Page 16]
+
+RFC 5435             Sieve Extension: Notifications         January 2009
+
+
+   [XMPP-URI]         Saint-Andre, P., "Internationalized Resource
+                      Identifiers (IRIs) and Uniform Resource
+                      Identifiers (URIs) for the Extensible Messaging
+                      and Presence Protocol (XMPP)", RFC 5122,
+                      February 2008.
+
+Authors' Addresses
+
+   Alexey Melnikov (editor)
+   Isode Limited
+   5 Castle Business Village
+   36 Station Road
+   Hampton, Middlesex  TW12 2BX
+   UK
+
+   EMail: Alexey.Melnikov@isode.com
+
+
+   Barry Leiba (editor)
+   IBM T.J. Watson Research Center
+   19 Skyline Drive
+   Hawthorne, NY  10532
+   US
+
+   Phone: +1 914 784 7941
+   EMail: leiba@watson.ibm.com
+
+
+   Wolfgang Segmuller
+   IBM T.J. Watson Research Center
+   19 Skyline Drive
+   Hawthorne, NY  10532
+   US
+
+   Phone: +1 914 784 7408
+   EMail: werewolf@us.ibm.com
+
+
+   Tim Martin
+   Endless Crossword
+   672 Haight st.
+   San Francisco, CA  94117
+   US
+
+   Phone: +1 510 260-4175
+   EMail: timmartin@alumni.cmu.edu
+
+
+
+
+
+Melnikov, et al.            Standards Track                    [Page 17]
+
diff -urN dovecot-1.2.4/dovecot-libsieve/doc/rfc/reject-ereject.rfc5429.txt dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/reject-ereject.rfc5429.txt
--- dovecot-1.2.4/dovecot-libsieve/doc/rfc/reject-ereject.rfc5429.txt	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/reject-ereject.rfc5429.txt	2009-07-20 23:30:49.000000000 +0200
@@ -0,0 +1,787 @@
+
+
+
+
+
+
+Network Working Group                                      A. Stone, Ed.
+Request for Comments: 5429                                   Serendipity
+Obsoletes: 3028                                               March 2009
+Updates: 5228
+Category: Standards Track
+
+
+      Sieve Email Filtering: Reject and Extended Reject Extensions
+
+Status of This Memo
+
+   This document specifies an Internet standards track protocol for the
+   Internet community, and requests discussion and suggestions for
+   improvements.  Please refer to the current edition of the "Internet
+   Official Protocol Standards" (STD 1) for the standardization state
+   and status of this protocol.  Distribution of this memo is unlimited.
+
+Copyright Notice
+
+   Copyright (c) 2009 IETF Trust and the persons identified as the
+   document authors.  All rights reserved.
+
+   This document is subject to BCP 78 and the IETF Trust's Legal
+   Provisions Relating to IETF Documents in effect on the date of
+   publication of this document (http://trustee.ietf.org/license-info).
+   Please review these documents carefully, as they describe your rights
+   and restrictions with respect to this document.
+
+   This document may contain material from IETF Documents or IETF
+   Contributions published or made publicly available before November
+   10, 2008.  The person(s) controlling the copyright in some of this
+   material may not have granted the IETF Trust the right to allow
+   modifications of such material outside the IETF Standards Process.
+   Without obtaining an adequate license from the person(s) controlling
+   the copyright in such materials, this document may not be modified
+   outside the IETF Standards Process, and derivative works of it may
+   not be created outside the IETF Standards Process, except to format
+   it for publication as an RFC or to translate it into languages other
+   than English.
+
+Abstract
+
+   This memo updates the definition of the Sieve mail filtering language
+   "reject" extension, originally defined in RFC 3028.
+
+   A "Joe-job" is a spam run forged to appear as though it came from an
+   innocent party, who is then generally flooded by automated bounces,
+   Message Disposition Notifications (MDNs), and personal messages with
+
+
+
+Stone                       Standards Track                     [Page 1]
+
+RFC 5429                Sieve Extension: Reject               March 2009
+
+
+   complaints.  The original Sieve "reject" action defined in RFC 3028
+   required use of MDNs for rejecting messages, thus contributing to the
+   flood of Joe-job spam to victims of Joe-jobs.
+
+   This memo updates the definition of the "reject" action to allow
+   messages to be refused during the SMTP transaction, and defines the
+   "ereject" action to require messages to be refused during the SMTP
+   transaction, if possible.
+
+   The "ereject" action is intended to replace the "reject" action
+   wherever possible.  The "ereject" action is similar to "reject", but
+   will always favor protocol-level message rejection.
+
+Table of Contents
+
+   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3
+     1.1.  Conventions Used in This Document  . . . . . . . . . . . .  3
+   2.  Sieve "reject" and "ereject" Extensions  . . . . . . . . . . .  4
+     2.1.  Action ereject . . . . . . . . . . . . . . . . . . . . . .  4
+       2.1.1.  Rejecting a Message at the SMTP/LMTP Protocol Level  .  5
+       2.1.2.  Rejecting a Message by Sending a DSN . . . . . . . . .  5
+     2.2.  Action reject  . . . . . . . . . . . . . . . . . . . . . .  6
+       2.2.1.  Rejecting a Message by Sending an MDN  . . . . . . . .  7
+     2.3.  Silent Upgrade from "reject" to "ereject"  . . . . . . . .  8
+     2.4.  Compatibility with Other Actions . . . . . . . . . . . . .  9
+     2.5.  Details of Protocol-Level Refusal  . . . . . . . . . . . .  9
+   3.  Changes from RFC 3028  . . . . . . . . . . . . . . . . . . . . 11
+   4.  Security Considerations  . . . . . . . . . . . . . . . . . . . 11
+   5.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 11
+     5.1.  "reject" Extension Registration  . . . . . . . . . . . . . 11
+     5.2.  "ereject" Extension Registration . . . . . . . . . . . . . 12
+   6.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 12
+     6.1.  Normative References . . . . . . . . . . . . . . . . . . . 12
+     6.2.  Informative References . . . . . . . . . . . . . . . . . . 13
+   Appendix A.  Acknowledgements  . . . . . . . . . . . . . . . . . . 14
+   Appendix B.  Contributors  . . . . . . . . . . . . . . . . . . . . 14
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Stone                       Standards Track                     [Page 2]
+
+RFC 5429                Sieve Extension: Reject               March 2009
+
+
+1.  Introduction
+
+   The Sieve mail filtering language, as originally defined in RFC 3028
+   [RFC3028], specified that the "reject" action shall discard a message
+   and send a Message Disposition Notification [MDN] to the envelope
+   sender along with an explanatory message.  The Sieve mail filtering
+   language, as updated in RFC 5228 [SIEVE], does not define any
+   "reject" action, hence that is the purpose of this document.
+
+   This document updates the definition of the "reject" action to permit
+   refusal of the message during the SMTP transaction, if possible, and
+   defines a new "ereject" action to require refusal of the message
+   during the SMTP transaction, if possible.
+
+   An important goal of this document is to reduce the risk of Sieve
+   scripts being used to perpetrate "Joe-job" spam runs, where the MDN
+   is sent notifying the sender of a message of its non-delivery is in
+   fact sent to an innocent third-party.  The original Sieve "reject"
+   action defined in RFC 3028 required use of MDNs for rejecting
+   messages, thus contributing to the flood of Joe-job spam to victims
+   of Joe-jobs.  By rejecting the message at the protocol level, it is
+   less likely that an MDN will be needed, and thus less likely that an
+   MDN will be misdirected at an innocent third-party.
+
+   Implementations are further encouraged to use spam-detection systems
+   to determine the level of risk associated with sending an MDN, and
+   this document allows implementations to silently drop the MDN if the
+   rejected message is deemed likely to be spam.
+
+   This document also describes how to use "reject"/"ereject" at varying
+   points in the email stack: Mail Transfer Agent (MTA), Mail Delivery
+   Agent (MDA), and Mail User Agent (MUA).  See [EMAIL-ARCH] for a
+   comprehensive discussion of these environments.
+
+   In general, an MDN is generated by an MUA, and can be used to
+   indicate the status of a message with respect to its recipient, while
+   a Delivery Status Notification (DSN) [DSN] is generated by an MTA,
+   and can be used to indicate whether or not a message was received and
+   delivered by the mail system.
+
+   Further discussion highlighting the risks of generating MDNs and the
+   benefits of protocol-level refusal can be found in [Joe-DoS].
+
+1.1.  Conventions Used in This Document
+
+   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
+   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
+   document are to be interpreted as described in [KEYWORDS].
+
+
+
+Stone                       Standards Track                     [Page 3]
+
+RFC 5429                Sieve Extension: Reject               March 2009
+
+
+   Conventions for notations are as in Section 1.1 of RFC 5228 [SIEVE].
+
+   This document does not attempt to define spam or how it should be
+   identified, nor does it attempt to define an email virus or how it
+   should be detected.  Implementors are advised to follow best
+   practices and keep abreast of current research in these fields.
+
+2.  Sieve "reject" and "ereject" Extensions
+
+2.1.  Action ereject
+
+   Usage: ereject <reason: string>
+
+   Sieve implementations that implement the "ereject" action must use
+   the "ereject" capability string.
+
+   The "ereject" action cancels the implicit keep and refuses delivery
+   of a message.  The "reason" string is a UTF-8 [UTF-8] string
+   specifying the reason for refusal.  How a message is refused depends
+   on the capabilities of the mail component (MDA or MTA) executing the
+   Sieve script.  The Sieve interpreter MUST carry out one of the
+   following actions (listed in order from most to least preferred),
+   MUST carry out the most preferable action possible, and MUST fall
+   back to lesser actions if a preferred action fails.
+
+   1.  Refuse message delivery by sending a 5XX response code over SMTP
+       [SMTP] or Local Mail Transfer Protocol (LMTP) [LMTP].  See
+       Section 2.1.1 for more details.
+
+   2.  Send a non-delivery report to the envelope sender ([REPORT]
+       [DSN]), unless the envelope sender address is determined to be a
+       forged or otherwise invalid address.
+
+   Note that the determination of whether or not an envelope sender is a
+   forgery may be performed by site-specific and implementation-specific
+   heuristic techniques, such as "return-path verification", details of
+   which are outside the scope of this document.  Implementations SHOULD
+   log instances when a non-delivery report is not sent and the reason
+   for not sending the report (e.g., content was spam, return-path
+   invalid, etc.).
+
+   The "ereject" action MUST NOT be available in environments that do
+   not support protocol-level rejection, e.g., an MUA, and MUST be
+   available in all other environments that support the "reject" action.
+
+
+
+
+
+
+
+Stone                       Standards Track                     [Page 4]
+
+RFC 5429                Sieve Extension: Reject               March 2009
+
+
+       Example:
+               require ["ereject"];
+
+               if address "from" "someone@example.com" {
+                   ereject "I no longer accept mail from this address";
+               }
+
+2.1.1.  Rejecting a Message at the SMTP/LMTP Protocol Level
+
+   Sieve implementations that are able to reject messages at the SMTP/
+   LMTP level MUST do so and SHOULD use the 550 response code.  Note
+   that if a message is arriving over SMTP and has multiple recipients,
+   some of whom have accepted the message, Section 2.1.2 defines how to
+   reject such a message.
+
+   The risk that these actions will generate blowback spam are minimized
+   but cannot be eliminated completely even in the case of "ereject", so
+   caution is advised when using these actions to deal with messages
+   determined to be spam.
+
+   Note that SMTP [SMTP] does not allow non-US-ACSII characters in the
+   SMTP response text.  If non-US-ACSII characters appear in the
+   "reason" string, they can be sent at the protocol level if and only
+   if the client and the server use an SMTP extension that allows for
+   transmission of non-US-ACSII reply text.  (One example of such an
+   SMTP extension is described in [UTF8-RESP].)  In the absence of such
+   an SMTP extension, the Sieve engine MUST replace any "reason" string
+   being sent at the protocol level and containing non-US-ACSII
+   characters with an implementation-defined US-ACSII-only string.
+
+   Users who don't like this behavior should consider using the "reject"
+   action described in Section 2.2, if available.
+
+   See Section 2.5 for the detailed instructions about performing
+   protocol-level rejection.
+
+2.1.2.  Rejecting a Message by Sending a DSN
+
+   An implementation may receive a message via SMTP that has more than
+   one RCPT TO that has been accepted by the server, and at least one
+   but not all of them are refusing delivery (whether the refusal is
+   caused by a Sieve "ereject" action or for some other reason).  In
+   this case, the server MUST accept the message and generate DSNs for
+   all recipients that are refusing it.  Note that this exception does
+   not apply to LMTP, as LMTP is able to reject messages on a per-
+   recipient basis.  (However, the LMTP client may then have no choice
+   but to generate a DSN to report the error, which may result in
+   blowback spam.)
+
+
+
+Stone                       Standards Track                     [Page 5]
+
+RFC 5429                Sieve Extension: Reject               March 2009
+
+
+   Note that according to [DSN], Delivery Status Notifications MUST NOT
+   be generated if the MAIL FROM (or Return-Path) is empty.
+
+   The DSN message MUST follow the requirements of [DSN] and [REPORT].
+   The action-value field defined in [DSN], Section 2.3.3, MUST contain
+   the value "failed".  The human-readable portion of the non-delivery
+   report MUST contain the "reason" string from the "ereject" action and
+   SHOULD contain additional text alerting the apparent original sender
+   that the message was refused by an email filter.  This part of the
+   report might appear as follows:
+
+   ------------------------------------------------------------
+   Your message was refused by the recipient's mail filtering program.
+   The reason given is as follows:
+
+   I am not taking mail from you, and I don't want your birdseed,
+   either!
+   ------------------------------------------------------------
+
+2.2.  Action reject
+
+   This section updates the definition of the "reject" action in Section
+   4.1 of RFC 3028 [RFC3028] and is an optional extension to [SIEVE].
+
+          Usage:   reject <reason: string>
+
+   Sieve implementations that implement the "reject" action must use the
+   "reject" capability string.
+
+   The "reject" action cancels the implicit keep and refuses delivery of
+   a message.  The "reason" string is a UTF-8 [UTF-8] string specifying
+   the reason for refusal.  Unlike the "ereject" action described above,
+   this action would always favor preserving the exact text of the
+   refusal reason.  Typically, the "reject" action refuses delivery of a
+   message by sending back an MDN to the sender (see Section 2.2.1).
+   However, implementations MAY refuse delivery over SMTP/LMTP protocol
+   (as detailed in Section 2.5), if and only if all of the following
+   conditions are true:
+
+   1.  The "reason" string consists of only US-ASCII characters
+         or
+       The "reason" string contains non-US-ASCII and both the client and
+       server support and negotiate use of an SMTP/LMTP extension for
+       sending UTF-8 responses.
+
+
+
+
+
+
+
+Stone                       Standards Track                     [Page 6]
+
+RFC 5429                Sieve Extension: Reject               March 2009
+
+
+   2.  LMTP protocol is used
+         or
+       SMTP protocol is used and the message has a single recipient
+         or
+       SMTP protocol is used, the message has multiple recipients, and
+       all of them refused message delivery (whether or not Sieve is
+       being used).
+
+
+      Example:
+              require ["reject"];
+
+              if size :over 100K {
+                  reject text:
+      Your message is too big.  If you want to send me a big attachment,
+      put it on a public web site and send me a URL.
+      .
+                  ;
+              }
+
+   (Pretend that the "reason" string above contains some non-US-ACSII
+   text.)
+
+   Implementations may use techniques as described in Section 2.1 to
+   determine if a non-delivery report should not be sent to a forged
+   sender.  Implementations SHOULD log instances when a non-delivery
+   report is not sent and the reason for not sending the report.
+
+2.2.1.  Rejecting a Message by Sending an MDN
+
+   The "reject" action resends the received message to the envelope
+   sender specified by the MAIL FROM (or Return-Path) address, wrapping
+   it in a "reject" form, explaining that it was rejected by the
+   recipient.
+
+   Note that according to [MDN], Message Disposition Notifications MUST
+   NOT be generated if the MAIL FROM (or Return-Path) is empty.
+
+   A reject message MUST take the form of a failure MDN as specified by
+   [MDN].  The human-readable portion of the message, the first
+   component of the MDN, contains the human-readable message describing
+   the error, and it SHOULD contain additional text alerting the
+   apparent original sender that mail was refused by an email filter.
+
+   The MDN disposition-field as defined in the MDN specification MUST be
+   "deleted" and MUST have the "MDN-sent-automatically" and "automatic-
+   action" modes set (see Section 3.2.6 of [MDN]).
+
+
+
+
+Stone                       Standards Track                     [Page 7]
+
+RFC 5429                Sieve Extension: Reject               March 2009
+
+
+   In the following script, a message is rejected and returned to the
+   sender.
+
+       Example:
+               require ["reject"];
+
+               if header :contains "from" "coyote@desert.example.org" {
+                   reject text:
+       I am not taking mail from you, and I don't
+       want your birdseed, either!
+       .
+                   ;
+               }
+
+   For this script, the first part of the MDN might appear as follows:
+
+   ------------------------------------------------------------
+   The message was refused by the recipient's mail filtering program.
+   The reason given was as follows:
+
+   I am not taking mail from you, and I don't want your birdseed,
+   either!
+   ------------------------------------------------------------
+
+2.3.  Silent Upgrade from "reject" to "ereject"
+
+   Implementations MUST NOT silently upgrade "reject" actions to
+   "ereject" actions in a Sieve script because this might lead to
+   unpleasant changes of behavior not expected by the script owner.
+
+   User interfaces that present a generic rejection option, and generate
+   Sieve script output, MAY switch from generating "reject" to "ereject"
+   actions, so long as doing so does not create a confusing change for
+   the script owner.
+
+   Script generators SHOULD ensure that a rejection action being
+   executed as a result of an anti-spam/anti-virus positive test be done
+   using the "ereject" action, as it is more suitable for such
+   rejections.
+
+   Script generators MAY automatically upgrade scripts that previously
+   used the "reject" action for anti-spam/anti-virus related rejections.
+   Note that such generators MUST make sure that the target environment
+   can support the "ereject" action.
+
+
+
+
+
+
+
+Stone                       Standards Track                     [Page 8]
+
+RFC 5429                Sieve Extension: Reject               March 2009
+
+
+2.4.  Compatibility with Other Actions
+
+   This section applies equally to "reject" and "ereject" actions.  All
+   references to the "reject" action in this section can be replaced
+   with the "ereject" action.
+
+   A "reject" action cancels the implicit keep.
+
+   Implementations MUST prohibit the execution of more than one "reject"
+   in a Sieve script.
+
+   "reject" MUST be incompatible with the "vacation" [VACATION] action.
+   It is NOT RECOMMENDED that implementations permit the use of "reject"
+   with actions that cause mail delivery, such as "keep", "fileinto",
+   and "redirect".
+
+   Making "reject" compatible with actions that cause mail delivery
+   violates the RFC 5321 [SMTP] principle that a message is either
+   delivered or bounced back to the sender.  So bouncing a message back
+   (rejecting) and delivering it will make the sender believe that the
+   message was not delivered.
+
+   However, there are existing laws requiring certain organizations to
+   archive all received messages, even the rejected ones.  Also, it can
+   be quite useful to save copies of rejected messages for later
+   analysis.
+
+   Any action that would modify the message body will not have an effect
+   on the body of any message refused by "reject" using an SMTP response
+   code and MUST NOT have any effect on the content of generated DSN/
+   MDNs.
+
+2.5.  Details of Protocol-Level Refusal
+
+   If the "reason" string consists of multiple CRLF separated lines,
+   then the reason text MUST be returned as a multiline SMTP/LMTP
+   response, per Section 4.2.1 of [SMTP].  Any line MUST NOT exceed the
+   SMTP limit on the maximal line length.  To make the "reason" string
+   conform to any such limits, the server MAY insert CRLFs and turn the
+   response into a multiline response.
+
+   In the following script (which assumes support for the "spamtest"
+   [SPAMTEST] and "fileinto" extensions), messages that test highly
+   positive for spam are refused.
+
+
+
+
+
+
+
+Stone                       Standards Track                     [Page 9]
+
+RFC 5429                Sieve Extension: Reject               March 2009
+
+
+       Example:
+               require ["ereject", "spamtest", "fileinto",
+                        "comparator-i;ascii-numeric"];
+
+               if spamtest :value "ge"
+                           :comparator "i;ascii-numeric" "6" {
+                   ereject text:
+       AntiSpam engine thinks your message is spam.
+       It is therefore being refused.
+       Please call 1-900-PAY-US if you want to reach us.
+       .
+                   ;
+               } elsif spamtest :value "ge"
+                                :comparator "i;ascii-numeric" "4" {
+                   fileinto "Suspect";
+               }
+
+   The following excerpt from an SMTP session shows it in action.
+
+         ...
+         C: DATA
+         S: 354 Send message, ending in CRLF.CRLF.
+          ...
+         C: .
+         S: 550-AntiSpam engine thinks your message is spam.
+         S: 550-It is therefore being refused.
+         S: 550 Please call 1-900-PAY-US if you want to reach us.
+
+   If the SMTP/LMTP server supports RFC 2034 [ENHANCED-CODES], it MUST
+   prepend an appropriate Enhanced Error Code to the "reason" text.
+   Enhanced Error code 5.7.1 or a more generic 5.7.0 are RECOMMENDED.
+   With an Enhanced Error Code, the response to a DATA command in the
+   SMTP example below will look like:
+
+         S: 550-5.7.1 AntiSpam engine thinks your message is spam.
+         S: 550-5.7.1 It is therefore being refused.
+         S: 550 5.7.1 Please call 1-900-PAY-US if you want to reach us.
+
+   if the server selected "5.7.1" as appropriate.
+
+   If a Sieve implementation that supports "ereject" does not wish to
+   immediately disclose the reason for rejection (for example, that it
+   detected spam), it may delay immediately sending of the 550 error
+   code by sending a 4XX error code on the first attempt to receive the
+   message.
+
+
+
+
+
+
+Stone                       Standards Track                    [Page 10]
+
+RFC 5429                Sieve Extension: Reject               March 2009
+
+
+3.  Changes from RFC 3028
+
+   Clarified that the "reject" action cancels the implicit keep.
+   Extended the list of allowable actions on "reject" to include
+   protocol-level message rejection.
+
+   Added the "ereject" action that is similar to "reject", but will
+   always favor protocol-level message rejection.
+
+4.  Security Considerations
+
+   The introduction to this document discusses why rejecting messages
+   before delivery is better than accepting and bouncing them.
+
+   While the details of techniques that can be used to determine when to
+   silently drop a non-delivery report are outside the scope of this
+   document, the explicit permission this document gives to take such
+   action may enable denial-of-service situations.  Techniques such as
+   spam-checking, return-path verification, and others, can and do have
+   false-positives.  Care should be exercised to prevent the loss of
+   legitimate messages by failing to notify the sender of non-delivery.
+
+   Security issues associated with email auto-responders are fully
+   discussed in the Security Considerations section of [RFC3834].  This
+   document is not believed to introduce any additional security
+   considerations in this general area.
+
+   The "ereject" extension does not raise any other security
+   considerations that are not already present in the base [SIEVE]
+   specification, and these issues are discussed in [SIEVE].
+
+5.  IANA Considerations
+
+   The following section provides the IANA registrations for the Sieve
+   extensions specified in this document.
+
+5.1.  "reject" Extension Registration
+
+   IANA is requested to update the registration for the Sieve "reject"
+   extension as detailed below:
+
+   Capability name: reject
+   Description:     adds the "reject" action for refusing delivery
+                    of a message.  The exact reason for refusal is
+                    conveyed back to the client.
+   RFC number:      RFC 5429
+   Contact address: the Sieve discussion list <ietf-mta-filters@imc.org>
+
+
+
+
+Stone                       Standards Track                    [Page 11]
+
+RFC 5429                Sieve Extension: Reject               March 2009
+
+
+5.2.  "ereject" Extension Registration
+
+   IANA is requested to replace the preliminary registration of the
+   Sieve refuse extension with the following registration:
+
+   Capability name: ereject
+   Description:     adds the "ereject" action for refusing delivery
+                    of a message.  The refusal should happen as early
+                    as possible (e.g., at the protocol level) and might
+                    not preserve the exact reason for refusal if it
+                    contains non-US-ASCII text.
+   RFC number:      RFC 5429
+   Contact address: the Sieve discussion list <ietf-mta-filters@imc.org>
+
+6.  References
+
+6.1.  Normative References
+
+   [DSN]             Moore, K. and G. Vaudreuil, "An Extensible Message
+                     Format for Delivery Status Notifications",
+                     RFC 3464, January 2003.
+
+   [ENHANCED-CODES]  Freed, N., "SMTP Service Extension for Returning
+                     Enhanced Error Codes", RFC 2034, October 1996.
+
+   [KEYWORDS]        Bradner, S., "Key words for use in RFCs to Indicate
+                     Requirement Levels", BCP 14, RFC 2119, March 1997.
+
+   [LMTP]            Myers, J., "Local Mail Transfer Protocol",
+                     RFC 2033, October 1996.
+
+   [MDN]             Hansen, T. and G. Vaudreuil, "Message Disposition
+                     Notification", RFC 3798, May 2004.
+
+   [REPORT]          Vaudreuil, G., "The Multipart/Report Content Type
+                     for the Reporting of Mail System Administrative
+                     Messages", RFC 3462, January 2003.
+
+   [SIEVE]           Guenther, P. and T. Showalter, "Sieve: An Email
+                     Filtering Language", RFC 5228, January 2008.
+
+   [SMTP]            Klensin, J., "Simple Mail Transfer Protocol",
+                     RFC 5321, October 2008.
+
+   [UTF-8]           Yergeau, F., "UTF-8, a transformation format of ISO
+                     10646", STD 63, RFC 3629, November 2003.
+
+
+
+
+
+Stone                       Standards Track                    [Page 12]
+
+RFC 5429                Sieve Extension: Reject               March 2009
+
+
+   [VACATION]        Showalter, T. and N. Freed, "Sieve Email Filtering:
+                     Vacation Extension", RFC 5230, January 2008.
+
+6.2.  Informative References
+
+   [EMAIL-ARCH]      Crocker, D., "Internet Mail Architecture", Work
+                     in Progress, October 2008.
+
+   [Joe-DoS]         Frei, S., Silvestri, I., and G. Ollman, "Mail Non-
+                     Delivery Notice Attacks", April 2004, <http://
+                     www.techzoom.net/papers/
+                     mail_non_delivery_notice_attacks_2004.pdf>.
+
+   [RFC3028]         Showalter, T., "Sieve: A Mail Filtering Language",
+                     RFC 3028, January 2001.
+
+   [RFC3834]         Moore, K., "Recommendations for Automatic Responses
+                     to Electronic Mail", RFC 3834, August 2004.
+
+   [SPAMTEST]        Daboo, C., "Sieve Email Filtering: Spamtest and
+                     Virustest Extensions", RFC 5235, January 2008.
+
+   [UTF8-RESP]       Melnikov, A., "SMTP Language Extension", Work
+                     in Progress, June 2007.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Stone                       Standards Track                    [Page 13]
+
+RFC 5429                Sieve Extension: Reject               March 2009
+
+
+Appendix A.  Acknowledgements
+
+   Thanks to Ned Freed, Cyrus Daboo, Arnt Gulbrandsen, Kristin Hubner,
+   Mark E. Mallett, Philip Guenther, Michael Haardt, and Randy Gellens
+   for comments and corrections.
+
+   The authors gratefully acknowledge the extensive work of Tim
+   Showalter as the author of the RFC 3028, which originally defined the
+   "reject" action.
+
+Appendix B.  Contributors
+
+   Matthew Elvey
+   The Elvey Partnership, LLC
+   1819 Polk Street, Suite 133
+   San Francisco, CA  94109
+   USA
+
+   EMail: matthew@elvey.com
+
+
+   Alexey Melnikov
+   Isode Limited
+   5 Castle Business Village
+   36 Station Road
+   Hampton, Middlesex  TW12 2BX
+   UK
+
+   EMail: Alexey.Melnikov@isode.com
+
+Author's Address
+
+   Aaron Stone (editor)
+   Serendipity
+   260 El Verano Ave
+   Palo Alto, CA  94306
+   USA
+
+   EMail: aaron@serendipity.palo-alto.ca.us
+
+
+
+
+
+
+
+
+
+
+
+
+Stone                       Standards Track                    [Page 14]
+
diff -urN dovecot-1.2.4/dovecot-libsieve/doc/rfc/relational.rfc5231.txt dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/relational.rfc5231.txt
--- dovecot-1.2.4/dovecot-libsieve/doc/rfc/relational.rfc5231.txt	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/relational.rfc5231.txt	2008-08-25 10:25:08.000000000 +0200
@@ -0,0 +1,507 @@
+
+
+
+
+
+
+Network Working Group                                       W. Segmuller
+Request for Comments: 5231                                      B. Leiba
+Obsoletes: 3431                          IBM T.J. Watson Research Center
+Category: Standards Track                                   January 2008
+
+
+              Sieve Email Filtering: Relational Extension
+
+Status of This Memo
+
+   This document specifies an Internet standards track protocol for the
+   Internet community, and requests discussion and suggestions for
+   improvements.  Please refer to the current edition of the "Internet
+   Official Protocol Standards" (STD 1) for the standardization state
+   and status of this protocol.  Distribution of this memo is unlimited.
+
+Abstract
+
+   This document describes the RELATIONAL extension to the Sieve mail
+   filtering language defined in RFC 3028.  This extension extends
+   existing conditional tests in Sieve to allow relational operators.
+   In addition to testing their content, it also allows for testing of
+   the number of entities in header and envelope fields.
+
+   This document obsoletes RFC 3431.
+
+Table of Contents
+
+   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . . . 2
+   2.  Conventions Used in This Document . . . . . . . . . . . . . . . 2
+   3.  Comparators . . . . . . . . . . . . . . . . . . . . . . . . . . 2
+   4.  Match Types . . . . . . . . . . . . . . . . . . . . . . . . . . 3
+     4.1.  Match Type VALUE  . . . . . . . . . . . . . . . . . . . . . 3
+     4.2.  Match Type COUNT  . . . . . . . . . . . . . . . . . . . . . 3
+   5.  Interaction with Other Sieve Actions  . . . . . . . . . . . . . 4
+   6.  Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
+   7.  Extended Example  . . . . . . . . . . . . . . . . . . . . . . . 6
+   8.  Changes since RFC 3431  . . . . . . . . . . . . . . . . . . . . 6
+   9.  IANA Considerations . . . . . . . . . . . . . . . . . . . . . . 7
+   10. Security Considerations . . . . . . . . . . . . . . . . . . . . 7
+   11. Normative References  . . . . . . . . . . . . . . . . . . . . . 7
+
+
+
+
+
+
+
+
+
+
+Segmuller & Leiba           Standards Track                     [Page 1]
+
+RFC 5231              Sieve: Relational Extension           January 2008
+
+
+1.  Introduction
+
+   The RELATIONAL extension to the Sieve mail filtering language [Sieve]
+   provides relational operators on the address, envelope, and header
+   tests.  This extension also provides a way of counting the entities
+   in a message header or address field.
+
+   With this extension, the Sieve script may now determine if a field is
+   greater than or less than a value instead of just equivalent.  One
+   use is for the x-priority field: move messages with a priority
+   greater than 3 to the "work on later" folder.  Mail could also be
+   sorted by the from address.  Those userids that start with 'a'-'m' go
+   to one folder, and the rest go to another folder.
+
+   The Sieve script can also determine the number of fields in the
+   header, or the number of addresses in a recipient field, for example,
+   whether there are more than 5 addresses in the to and cc fields.
+
+   The capability string associated with the extension defined in this
+   document is "relational".
+
+2.  Conventions Used in This Document
+
+   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
+   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
+   document are to be interpreted as described in BCP 14, RFC 2119.
+
+   Conventions for notations are as in [Sieve] section 1.1, including
+   the use of [Kwds] and the use of [ABNF].
+
+3.  Comparators
+
+   This document does not define any comparators or exempt any
+   comparators from the require clause.  Any comparator used must be
+   treated as defined in [Sieve].
+
+   The "i;ascii-numeric" comparator, as defined in [RFC4790], MUST be
+   supported for any implementation of this extension.  The comparator
+   "i;ascii-numeric" MUST support at least 32-bit unsigned integers.
+
+   Larger integers MAY be supported.  Note: the "i;ascii-numeric"
+   comparator does not support negative numbers.
+
+
+
+
+
+
+
+
+
+Segmuller & Leiba           Standards Track                     [Page 2]
+
+RFC 5231              Sieve: Relational Extension           January 2008
+
+
+4.  Match Types
+
+   This document defines two new match types.  They are the VALUE match
+   type and the COUNT match type.
+
+   The syntax is:
+
+   MATCH-TYPE =/ COUNT / VALUE
+
+   COUNT = ":count" relational-match
+
+   VALUE = ":value" relational-match
+
+   relational-match = DQUOTE
+           ("gt" / "ge" / "lt" / "le" / "eq" / "ne") DQUOTE
+           ; "gt" means "greater than", the C operator ">".
+           ; "ge" means "greater than or equal", the C operator ">=".
+           ; "lt" means "less than", the C operator "<".
+           ; "le" means "less than or equal", the C operator "<=".
+           ; "eq" means "equal to", the C operator "==".
+           ; "ne" means "not equal to", the C operator "!=".
+
+4.1.  Match Type VALUE
+
+   The VALUE match type does a relational comparison between strings.
+
+   The VALUE match type may be used with any comparator that returns
+   sort information.
+
+   A value from the message is considered the left side of the relation.
+   A value from the test expression, the key-list for address, envelope,
+   and header tests, is the right side of the relation.
+
+   If there are multiple values on either side or both sides, the test
+   is considered true if any pair is true.
+
+4.2.  Match Type COUNT
+
+   The COUNT match type first determines the number of the specified
+   entities in the message and does a relational comparison of the
+   number of entities, as defined below, to the values specified in the
+   test expression.
+
+   The COUNT match type SHOULD only be used with numeric comparators.
+
+   The Address Test counts the number of addresses (the number of
+   "mailbox" elements, as defined in [RFC2822]) in the specified fields.
+   Group names are ignored, but the contained mailboxes are counted.
+
+
+
+Segmuller & Leiba           Standards Track                     [Page 3]
+
+RFC 5231              Sieve: Relational Extension           January 2008
+
+
+   The Envelope Test counts the number of addresses in the specified
+   envelope parts.  The envelope "to" will always have only one entry,
+   which is the address of the user for whom the Sieve script is
+   running.  Using this test, there is no way a Sieve script can
+   determine if the message was actually sent to someone else.  The
+   envelope "from" will be 0 if the MAIL FROM is empty, or 1 if MAIL
+   FROM is not empty.
+
+   The Header Test counts the total number of instances of the specified
+   fields.  This does not count individual addresses in the "to", "cc",
+   and other recipient fields.
+
+   In all cases, if more than one field name is specified, the counts
+   for all specified fields are added together to obtain the number for
+   comparison.  Thus, specifying ["to", "cc"] in an address COUNT test
+   compares the total number of "to" and "cc" addresses; if separate
+   counts are desired, they must be done in two comparisons, perhaps
+   joined by "allof" or "anyof".
+
+5.  Interaction with Other Sieve Actions
+
+   This specification adds two match types.  The VALUE match type only
+   works with comparators that return sort information.  The COUNT match
+   type only makes sense with numeric comparators.
+
+   There is no interaction with any other Sieve operations, nor with any
+   known extensions.  In particular, this specification has no effect on
+   implicit KEEP, nor on any explicit message actions.
+
+6.  Example
+
+   Using the message:
+
+      received: ...
+      received: ...
+      subject: example
+      to: foo@example.com, baz@example.com
+      cc: qux@example.com
+
+   The test:
+
+      address :count "ge" :comparator "i;ascii-numeric"
+                      ["to", "cc"] ["3"]
+
+   would evaluate to true, and the test
+
+
+
+
+
+
+Segmuller & Leiba           Standards Track                     [Page 4]
+
+RFC 5231              Sieve: Relational Extension           January 2008
+
+
+      anyof ( address :count "ge" :comparator "i;ascii-numeric"
+                      ["to"] ["3"],
+              address :count "ge" :comparator "i;ascii-numeric"
+                      ["cc"] ["3"] )
+
+   would evaluate to false.
+
+   To check the number of received fields in the header, the following
+   test may be used:
+
+      header :count "ge" :comparator "i;ascii-numeric"
+                      ["received"] ["3"]
+
+   This would evaluate to false.  But
+
+      header :count "ge" :comparator "i;ascii-numeric"
+                      ["received", "subject"] ["3"]
+
+   would evaluate to true.
+
+   The test:
+
+      header :count "ge" :comparator "i;ascii-numeric"
+                      ["to", "cc"] ["3"]
+
+   will always evaluate to false on an RFC 2822 compliant message
+   [RFC2822], since a message can have at most one "to" field and at
+   most one "cc" field.  This test counts the number of fields, not the
+   number of addresses.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Segmuller & Leiba           Standards Track                     [Page 5]
+
+RFC 5231              Sieve: Relational Extension           January 2008
+
+
+7.  Extended Example
+
+      require ["relational", "comparator-i;ascii-numeric", "fileinto"];
+
+      if header :value "lt" :comparator "i;ascii-numeric"
+                ["x-priority"] ["3"]
+      {
+         fileinto "Priority";
+      }
+
+      elsif address :count "gt" :comparator "i;ascii-numeric"
+                 ["to"] ["5"]
+      {
+         # everything with more than 5 recipients in the "to" field
+         # is considered SPAM
+         fileinto "SPAM";
+      }
+
+      elsif address :value "gt" :all :comparator "i;ascii-casemap"
+                 ["from"] ["M"]
+      {
+         fileinto "From N-Z";
+      } else {
+         fileinto "From A-M";
+      }
+
+      if allof ( address :count "eq" :comparator "i;ascii-numeric"
+                         ["to", "cc"] ["1"] ,
+                 address :all :comparator "i;ascii-casemap"
+                         ["to", "cc"] ["me@foo.example.com"] )
+      {
+         fileinto "Only me";
+      }
+
+8.  Changes since RFC 3431
+
+   Apart from several minor editorial/wording changes, the following
+   list describes the notable changes to this specification since RFC
+   3431.
+
+   o  Updated references, including changing the comparator reference
+      from the Application Configuration Access Protocol (ACAP) to the
+      "Internet Application Protocol Collation Registry" document
+      [RFC4790].
+
+   o  Updated and corrected the examples.
+
+
+
+
+
+Segmuller & Leiba           Standards Track                     [Page 6]
+
+RFC 5231              Sieve: Relational Extension           January 2008
+
+
+   o  Added definition comments to ABNF for "gt", "lt", etc.
+
+   o  Clarified what RFC 2822 elements are counted in the COUNT test.
+
+   o  Removed the requirement to strip white space from header fields
+      before comparing; a more general version of this requirement has
+      been added to the Sieve base spec.
+
+9.  IANA Considerations
+
+   The following template specifies the IANA registration of the
+   relational Sieve extension specified in this document:
+
+   To: iana@iana.org
+   Subject: Registration of new Sieve extension
+
+   Capability name: relational
+   Description:     Extends existing conditional tests in Sieve language
+                    to allow relational operators
+   RFC number:      RFC 5231
+   Contact address: The Sieve discussion list <ietf-mta-filters@imc.org>
+
+10.  Security Considerations
+
+   An implementation MUST ensure that the test for envelope "to" only
+   reflects the delivery to the current user.  Using this test, it MUST
+   not be possible for a user to determine if this message was delivered
+   to someone else.
+
+   Additional security considerations are discussed in [Sieve].
+
+11.  Normative References
+
+   [ABNF]     Crocker, D., Ed. and P. Overell, "Augmented BNF for Syntax
+              Specifications: ABNF", RFC 4234, October 2005.
+
+   [Kwds]     Bradner, S., "Key words for use in RFCs to Indicate
+              Requirement Levels", RFC 2119, March 1997.
+
+   [RFC2822]  Resnick, P., "Internet Message Format", RFC 2822,
+              April 2001.
+
+   [RFC4790]  Newman, C., Duerst, M., and A. Gulbrandsen, "Internet
+              Application Protocol Collation Registry", RFC 4790,
+              March 2007.
+
+   [Sieve]    Guenther, P., Ed. and T. Showalter, Ed., "Sieve: An Email
+              Filtering Language", RFC 5228, January 2008.
+
+
+
+Segmuller & Leiba           Standards Track                     [Page 7]
+
+RFC 5231              Sieve: Relational Extension           January 2008
+
+
+Authors' Addresses
+
+   Wolfgang Segmuller
+   IBM T.J. Watson Research Center
+   19 Skyline Drive
+   Hawthorne, NY  10532
+   US
+
+   Phone: +1 914 784 7408
+   EMail: werewolf@us.ibm.com
+
+
+   Barry Leiba
+   IBM T.J. Watson Research Center
+   19 Skyline Drive
+   Hawthorne, NY  10532
+   US
+
+   Phone: +1 914 784 7941
+   EMail: leiba@watson.ibm.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Segmuller & Leiba           Standards Track                     [Page 8]
+
+RFC 5231              Sieve: Relational Extension           January 2008
+
+
+Full Copyright Statement
+
+   Copyright (C) The IETF Trust (2008).
+
+   This document is subject to the rights, licenses and restrictions
+   contained in BCP 78, and except as set forth therein, the authors
+   retain all their rights.
+
+   This document and the information contained herein are provided on an
+   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
+   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
+   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
+   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
+
+Intellectual Property
+
+   The IETF takes no position regarding the validity or scope of any
+   Intellectual Property Rights or other rights that might be claimed to
+   pertain to the implementation or use of the technology described in
+   this document or the extent to which any license under such rights
+   might or might not be available; nor does it represent that it has
+   made any independent effort to identify any such rights.  Information
+   on the procedures with respect to rights in RFC documents can be
+   found in BCP 78 and BCP 79.
+
+   Copies of IPR disclosures made to the IETF Secretariat and any
+   assurances of licenses to be made available, or the result of an
+   attempt made to obtain a general license or permission for the use of
+   such proprietary rights by implementers or users of this
+   specification can be obtained from the IETF on-line IPR repository at
+   http://www.ietf.org/ipr.
+
+   The IETF invites any interested party to bring to its attention any
+   copyrights, patents or patent applications, or other proprietary
+   rights that may cover technology that may be required to implement
+   this standard.  Please address the information to the IETF at
+   ietf-ipr@ietf.org.
+
+
+
+
+
+
+
+
+
+
+
+
+Segmuller & Leiba           Standards Track                     [Page 9]
+
diff -urN dovecot-1.2.4/dovecot-libsieve/doc/rfc/RFC-questions.txt dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/RFC-questions.txt
--- dovecot-1.2.4/dovecot-libsieve/doc/rfc/RFC-questions.txt	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/RFC-questions.txt	2008-10-20 01:35:49.000000000 +0200
@@ -0,0 +1,46 @@
+Date: Sun, 19 Oct 2008 12:31:58 +0200
+From: Stephan Bosch <stephan@rename-it.nl>
+To: ietf-mta-filters@imc.org
+Subject: Questions regarding RFC 5228
+Content-Type: text/plain; charset=ISO-8859-1; format=flowed
+Content-Transfer-Encoding: 7bit
+
+Hello,
+
+I am finishing up a first release of my Sieve implementation, and one of 
+the TODO items that yet remains is getting some answers to questions 
+that arose during development. I've collected these into a file an now I 
+submit them to this list to get some clarification. Any help is greatly 
+appreciated.
+
+* RFC 5228 (Sieve) : 5.1.  Test address:
+"Implementations MUST restrict the address test to headers that contain 
+addresses, but MUST include at least From, To, Cc, Bcc, Sender, 
+Resent-From, and Resent-To, and it SHOULD include any other header that 
+utilizes an "address-list" structured header body."
+   
+  -> Will this cause a compile error, or are the disallowed headers 
+simply ignored? My implementation currently considers this to be a 
+compile error.
+  -> Given the variables extension, sometimes the specified header names 
+aren't known until runtime. If the previous answer was to cause a 
+compile error, should this abort the script at runtime?
+    
+* RFC 5228 (Sieve) : 5.4.  Test envelope:
+"The "envelope" test is true if the specified part of the [SMTP] (or 
+equivalent) envelope matches the specified key.  This specification 
+defines the interpretation of the (case insensitive) "from" and "to" 
+envelope-parts.  Additional envelope-parts may be defined by other 
+extensions; implementations SHOULD consider unknown envelope parts an 
+error."
+   
+  -> Given the variables extension, sometimes the specified envelope 
+parts aren't known until runtime. Should invalid ones abort the script 
+or is ignoring them a better practice?
+
+Regards,
+
+--
+Stephan Bosch
+stephan@rename-it.nl
+
diff -urN dovecot-1.2.4/dovecot-libsieve/doc/rfc/sieve.rfc5228.txt dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/sieve.rfc5228.txt
--- dovecot-1.2.4/dovecot-libsieve/doc/rfc/sieve.rfc5228.txt	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/sieve.rfc5228.txt	2008-07-18 12:11:28.000000000 +0200
@@ -0,0 +1,2355 @@
+
+
+
+
+
+
+Network Working Group                                   P. Guenther, Ed.
+Request for Comments: 5228                                Sendmail, Inc.
+Obsoletes: 3028                                        T. Showalter, Ed.
+Category: Standards Track                                   January 2008
+
+
+                   Sieve: An Email Filtering Language
+
+Status of This Memo
+
+   This document specifies an Internet standards track protocol for the
+   Internet community, and requests discussion and suggestions for
+   improvements.  Please refer to the current edition of the "Internet
+   Official Protocol Standards" (STD 1) for the standardization state
+   and status of this protocol.  Distribution of this memo is unlimited.
+
+Abstract
+
+   This document describes a language for filtering email messages at
+   time of final delivery.  It is designed to be implementable on either
+   a mail client or mail server.  It is meant to be extensible, simple,
+   and independent of access protocol, mail architecture, and operating
+   system.  It is suitable for running on a mail server where users may
+   not be allowed to execute arbitrary programs, such as on black box
+   Internet Message Access Protocol (IMAP) servers, as the base language
+   has no variables, loops, or ability to shell out to external
+   programs.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Guenther & Showalter        Standards Track                     [Page 1]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+Table of Contents
+
+   1. Introduction ....................................................4
+      1.1. Conventions Used in This Document ..........................4
+      1.2. Example Mail Messages ......................................5
+   2. Design ..........................................................6
+      2.1. Form of the Language .......................................6
+      2.2. Whitespace .................................................7
+      2.3. Comments ...................................................7
+      2.4. Literal Data ...............................................7
+           2.4.1. Numbers .............................................7
+           2.4.2. Strings .............................................8
+                  2.4.2.1. String Lists ...............................9
+                  2.4.2.2. Headers ....................................9
+                  2.4.2.3. Addresses .................................10
+                  2.4.2.4. Encoding Characters Using
+                           "encoded-character" .......................10
+      2.5. Tests .....................................................11
+           2.5.1. Test Lists .........................................12
+      2.6. Arguments .................................................12
+           2.6.1. Positional Arguments ...............................12
+           2.6.2. Tagged Arguments ...................................12
+           2.6.3. Optional Arguments .................................13
+           2.6.4. Types of Arguments .................................13
+      2.7. String Comparison .........................................13
+           2.7.1. Match Type .........................................14
+           2.7.2. Comparisons across Character Sets ..................15
+           2.7.3. Comparators ........................................15
+           2.7.4. Comparisons against Addresses ......................16
+      2.8. Blocks ....................................................17
+      2.9. Commands ..................................................17
+      2.10. Evaluation ...............................................18
+           2.10.1. Action Interaction ................................18
+           2.10.2. Implicit Keep .....................................18
+           2.10.3. Message Uniqueness in a Mailbox ...................19
+           2.10.4. Limits on Numbers of Actions ......................19
+           2.10.5. Extensions and Optional Features ..................19
+           2.10.6. Errors ............................................20
+           2.10.7. Limits on Execution ...............................20
+   3. Control Commands ...............................................21
+      3.1. Control if ................................................21
+      3.2. Control require ...........................................22
+      3.3. Control stop ..............................................22
+   4. Action Commands ................................................23
+      4.1. Action fileinto ...........................................23
+      4.2. Action redirect ...........................................23
+      4.3. Action keep ...............................................24
+      4.4. Action discard ............................................25
+
+
+
+Guenther & Showalter        Standards Track                     [Page 2]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+   5. Test Commands ..................................................26
+      5.1. Test address ..............................................26
+      5.2. Test allof ................................................27
+      5.3. Test anyof ................................................27
+      5.4. Test envelope .............................................27
+      5.5. Test exists ...............................................28
+      5.6. Test false ................................................28
+      5.7. Test header ...............................................29
+      5.8. Test not ..................................................29
+      5.9. Test size .................................................29
+      5.10. Test true ................................................30
+   6. Extensibility ..................................................30
+      6.1. Capability String .........................................31
+      6.2. IANA Considerations .......................................31
+           6.2.1. Template for Capability Registrations ..............32
+           6.2.2. Handling of Existing Capability Registrations ......32
+           6.2.3. Initial Capability Registrations ...................32
+      6.3. Capability Transport ......................................33
+   7. Transmission ...................................................33
+   8. Parsing ........................................................34
+      8.1. Lexical Tokens ............................................34
+      8.2. Grammar ...................................................36
+      8.3. Statement Elements ........................................36
+   9. Extended Example ...............................................37
+   10. Security Considerations .......................................38
+   11. Acknowledgments ...............................................39
+   12. Normative References ..........................................39
+   13. Informative References ........................................40
+   14. Changes from RFC 3028 .........................................41
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Guenther & Showalter        Standards Track                     [Page 3]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+1.  Introduction
+
+   This memo documents a language that can be used to create filters for
+   electronic mail.  It is not tied to any particular operating system
+   or mail architecture.  It requires the use of [IMAIL]-compliant
+   messages, but should otherwise generalize to many systems.
+
+   The language is powerful enough to be useful but limited in order to
+   allow for a safe server-side filtering system.  The intention is to
+   make it impossible for users to do anything more complex (and
+   dangerous) than write simple mail filters, along with facilitating
+   the use of graphical user interfaces (GUIs) for filter creation and
+   manipulation.  The base language was not designed to be Turing-
+   complete: it does not have a loop control structure or functions.
+
+   Scripts written in Sieve are executed during final delivery, when the
+   message is moved to the user-accessible mailbox.  In systems where
+   the Mail Transfer Agent (MTA) does final delivery, such as
+   traditional Unix mail, it is reasonable to filter when the MTA
+   deposits mail into the user's mailbox.
+
+   There are a number of reasons to use a filtering system.  Mail
+   traffic for most users has been increasing due to increased usage of
+   email, the emergence of unsolicited email as a form of advertising,
+   and increased usage of mailing lists.
+
+   Experience at Carnegie Mellon has shown that if a filtering system is
+   made available to users, many will make use of it in order to file
+   messages from specific users or mailing lists.  However, many others
+   did not make use of the Andrew system's FLAMES filtering language
+   [FLAMES] due to difficulty in setting it up.
+
+   Because of the expectation that users will make use of filtering if
+   it is offered and easy to use, this language has been made simple
+   enough to allow many users to make use of it, but rich enough that it
+   can be used productively.  However, it is expected that GUI-based
+   editors will be the preferred way of editing filters for a large
+   number of users.
+
+1.1.  Conventions Used in This Document
+
+   In the sections of this document that discuss the requirements of
+   various keywords and operators, the following conventions have been
+   adopted.
+
+   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
+   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
+   document are to be interpreted as described in [KEYWORDS].
+
+
+
+Guenther & Showalter        Standards Track                     [Page 4]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+   Each section on a command (test, action, or control) has a line
+   labeled "Usage:".  This line describes the usage of the command,
+   including its name and its arguments.  Required arguments are listed
+   inside angle brackets ("<" and ">").  Optional arguments are listed
+   inside square brackets ("[" and "]").  Each argument is followed by
+   its type, so "<key: string>" represents an argument called "key" that
+   is a string.  Literal strings are represented with double-quoted
+   strings.  Alternatives are separated with slashes, and parentheses
+   are used for grouping, similar to [ABNF].
+
+   In the "Usage:" line, there are three special pieces of syntax that
+   are frequently repeated, MATCH-TYPE, COMPARATOR, and ADDRESS-PART.
+   These are discussed in sections 2.7.1, 2.7.3, and 2.7.4,
+   respectively.
+
+   The formal grammar for these commands is defined in section 8 and is
+   the authoritative reference on how to construct commands, but the
+   formal grammar does not specify the order, semantics, number or types
+   of arguments to commands, or the legal command names.  The intent is
+   to allow for extension without changing the grammar.
+
+1.2.  Example Mail Messages
+
+   The following mail messages will be used throughout this document in
+   examples.
+
+   Message A
+   -----------------------------------------------------------
+   Date: Tue, 1 Apr 1997 09:06:31 -0800 (PST)
+   From: coyote@desert.example.org
+   To: roadrunner@acme.example.com
+   Subject: I have a present for you
+
+   Look, I'm sorry about the whole anvil thing, and I really
+   didn't mean to try and drop it on you from the top of the
+   cliff.  I want to try to make it up to you.  I've got some
+   great birdseed over here at my place--top of the line
+   stuff--and if you come by, I'll have it all wrapped up
+   for you.  I'm really sorry for all the problems I've caused
+   for you over the years, but I know we can work this out.
+   --
+   Wile E. Coyote   "Super Genius"   coyote@desert.example.org
+   -----------------------------------------------------------
+
+
+
+
+
+
+
+
+Guenther & Showalter        Standards Track                     [Page 5]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+   Message B
+   -----------------------------------------------------------
+   From: youcouldberich!@reply-by-postal-mail.invalid
+   Sender: b1ff@de.res.example.com
+   To: rube@landru.example.com
+   Date:  Mon, 31 Mar 1997 18:26:10 -0800
+   Subject: $$$ YOU, TOO, CAN BE A MILLIONAIRE! $$$
+
+   YOU MAY HAVE ALREADY WON TEN MILLION DOLLARS, BUT I DOUBT
+   IT!  SO JUST POST THIS TO SIX HUNDRED NEWSGROUPS!  IT WILL
+   GUARANTEE THAT YOU GET AT LEAST FIVE RESPONSES WITH MONEY!
+   MONEY! MONEY! COLD HARD CASH!  YOU WILL RECEIVE OVER
+   $20,000 IN LESS THAN TWO MONTHS!  AND IT'S LEGAL!!!!!!!!!
+   !!!!!!!!!!!!!!!!!!111111111!!!!!!!11111111111!!1  JUST
+   SEND $5 IN SMALL, UNMARKED BILLS TO THE ADDRESSES BELOW!
+   -----------------------------------------------------------
+
+2.  Design
+
+2.1.  Form of the Language
+
+   The language consists of a set of commands.  Each command consists of
+   a set of tokens delimited by whitespace.  The command identifier is
+   the first token and it is followed by zero or more argument tokens.
+   Arguments may be literal data, tags, blocks of commands, or test
+   commands.
+
+   With the exceptions of strings and comments, the language is limited
+   to US-ASCII characters.  Strings and comments may contain octets
+   outside the US-ASCII range.  Specifically, they will normally be in
+   UTF-8, as specified in [UTF-8].  NUL (US-ASCII 0) is never permitted
+   in scripts, while CR and LF can only appear as the CRLF line ending.
+
+      Note: While this specification permits arbitrary octets to appear
+      in Sieve scripts inside strings and comments, this has made it
+      difficult to robustly handle Sieve scripts in programs that are
+      sensitive to the encodings used.  The "encoded-character"
+      capability (section 2.4.2.4) provides an alternative means of
+      representing such octets in strings using just US-ASCII
+      characters.  As such, the use of non-UTF-8 text in scripts should
+      be considered a deprecated feature that may be abandoned.
+
+   Tokens other than strings are considered case-insensitive.
+
+
+
+
+
+
+
+
+Guenther & Showalter        Standards Track                     [Page 6]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+2.2.  Whitespace
+
+   Whitespace is used to separate tokens.  Whitespace is made up of
+   tabs, newlines (CRLF, never just CR or LF), and the space character.
+   The amount of whitespace used is not significant.
+
+2.3.  Comments
+
+   Two types of comments are offered.  Comments are semantically
+   equivalent to whitespace and can be used anyplace that whitespace is
+   (with one exception in multi-line strings, as described in the
+   grammar).
+
+   Hash comments begin with a "#" character that is not contained within
+   a string and continue until the next CRLF.
+
+   Example:  if size :over 100k { # this is a comment
+                discard;
+             }
+
+   Bracketed comments begin with the token "/*" and end with "*/"
+   outside of a string.  Bracketed comments may span multiple lines.
+   Bracketed comments do not nest.
+
+   Example:  if size :over 100K { /* this is a comment
+                this is still a comment */ discard /* this is a comment
+                */ ;
+             }
+
+2.4.  Literal Data
+
+   Literal data means data that is not executed, merely evaluated "as
+   is", to be used as arguments to commands.  Literal data is limited to
+   numbers, strings, and string lists.
+
+2.4.1.  Numbers
+
+   Numbers are given as ordinary decimal numbers.  As a shorthand for
+   expressing larger values, such as message sizes, a suffix of "K",
+   "M", or "G" MAY be appended to indicate a multiple of a power of two.
+   To be comparable with the power-of-two-based versions of SI units
+   that computers frequently use, "K" specifies kibi-, or 1,024 (2^10)
+   times the value of the number; "M" specifies mebi-, or 1,048,576
+   (2^20) times the value of the number; and "G" specifies gibi-, or
+   1,073,741,824 (2^30) times the value of the number [BINARY-SI].
+
+
+
+
+
+
+Guenther & Showalter        Standards Track                     [Page 7]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+   Implementations MUST support integer values in the inclusive range
+   zero to 2,147,483,647 (2^31 - 1), but MAY support larger values.
+
+   Only non-negative integers are permitted by this specification.
+
+2.4.2.  Strings
+
+   Scripts involve large numbers of string values as they are used for
+   pattern matching, addresses, textual bodies, etc.  Typically, short
+   quoted strings suffice for most uses, but a more convenient form is
+   provided for longer strings such as bodies of messages.
+
+   A quoted string starts and ends with a single double quote (the <">
+   character, US-ASCII 34).  A backslash ("\", US-ASCII 92) inside of a
+   quoted string is followed by either another backslash or a double
+   quote.  These two-character sequences represent a single backslash or
+   double quote within the value, respectively.
+
+   Scripts SHOULD NOT escape other characters with a backslash.
+
+   An undefined escape sequence (such as "\a" in a context where "a" has
+   no special meaning) is interpreted as if there were no backslash (in
+   this case, "\a" is just "a"), though that may be changed by
+   extensions.
+
+   Non-printing characters such as tabs, CRLF, and control characters
+   are permitted in quoted strings.  Quoted strings MAY span multiple
+   lines.  An unencoded NUL (US-ASCII 0) is not allowed in strings; see
+   section 2.4.2.4 for how it can be encoded.
+
+   As message header data is converted to [UTF-8] for comparison (see
+   section 2.7.2), most string values will use the UTF-8 encoding.
+   However, implementations MUST accept all strings that match the
+   grammar in section 8.  The ability to use non-UTF-8 encoded strings
+   matches existing practice and has proven to be useful both in tests
+   for invalid data and in arguments containing raw MIME parts for
+   extension actions that generate outgoing messages.
+
+   For entering larger amounts of text, such as an email message, a
+   multi-line form is allowed.  It starts with the keyword "text:",
+   followed by a CRLF, and ends with the sequence of a CRLF, a single
+   period, and another CRLF.  The CRLF before the final period is
+   considered part of the value.  In order to allow the message to
+   contain lines with a single dot, lines are dot-stuffed.  That is,
+   when composing a message body, an extra '.' is added before each line
+   that begins with a '.'.  When the server interprets the script, these
+   extra dots are removed.  Note that a line that begins with a dot
+   followed by a non-dot character is not interpreted as dot-stuffed;
+
+
+
+Guenther & Showalter        Standards Track                     [Page 8]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+   that is, ".foo" is interpreted as ".foo".  However, because this is
+   potentially ambiguous, scripts SHOULD be properly dot-stuffed so such
+   lines do not appear.
+
+   Note that a hashed comment or whitespace may occur in between the
+   "text:" and the CRLF, but not within the string itself.  Bracketed
+   comments are not allowed here.
+
+2.4.2.1.  String Lists
+
+   When matching patterns, it is frequently convenient to match against
+   groups of strings instead of single strings.  For this reason, a list
+   of strings is allowed in many tests, implying that if the test is
+   true using any one of the strings, then the test is true.
+
+   For instance, the test 'header :contains ["To", "Cc"]
+   ["me@example.com", "me00@landru.example.com"]' is true if either a To
+   header or Cc header of the input message contains either of the email
+   addresses "me@example.com" or "me00@landru.example.com".
+
+   Conversely, in any case where a list of strings is appropriate, a
+   single string is allowed without being a member of a list: it is
+   equivalent to a list with a single member.  This means that the test
+   'exists "To"' is equivalent to the test 'exists ["To"]'.
+
+2.4.2.2.  Headers
+
+   Headers are a subset of strings.  In the Internet Message
+   Specification [IMAIL], each header line is allowed to have whitespace
+   nearly anywhere in the line, including after the field name and
+   before the subsequent colon.  Extra spaces between the header name
+   and the ":" in a header field are ignored.
+
+   A header name never contains a colon.  The "From" header refers to a
+   line beginning "From:" (or "From   :", etc.).  No header will match
+   the string "From:" due to the trailing colon.
+
+   Similarly, no header will match a syntactically invalid header name.
+   An implementation MUST NOT cause an error for syntactically invalid
+   header names in tests.
+
+   Header lines are unfolded as described in [IMAIL] section 2.2.3.
+   Interpretation of header data SHOULD be done according to [MIME3]
+   section 6.2 (see section 2.7.2 below for details).
+
+
+
+
+
+
+
+Guenther & Showalter        Standards Track                     [Page 9]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+2.4.2.3.  Addresses
+
+   A number of commands call for email addresses, which are also a
+   subset of strings.  When these addresses are used in outbound
+   contexts, addresses must be compliant with [IMAIL], but are further
+   constrained within this document.  Using the symbols defined in
+   [IMAIL], section 3, the syntax of an address is:
+
+   sieve-address = addr-spec                ; simple address
+                 / phrase "<" addr-spec ">" ; name & addr-spec
+
+   That is, routes and group syntax are not permitted.  If multiple
+   addresses are required, use a string list.  Named groups are not
+   permitted.
+
+   It is an error for a script to execute an action with a value for use
+   as an outbound address that doesn't match the "sieve-address" syntax.
+
+2.4.2.4.  Encoding Characters Using "encoded-character"
+
+   When the "encoded-character" extension is in effect, certain
+   character sequences in strings are replaced by their decoded value.
+   This happens after escape sequences are interpreted and dot-
+   unstuffing has been done.  Implementations SHOULD support "encoded-
+   character".
+
+   Arbitrary octets can be embedded in strings by using the syntax
+   encoded-arb-octets.  The sequence is replaced by the octets with the
+   hexadecimal values given by each hex-pair.
+
+   blank                = WSP / CRLF
+   encoded-arb-octets   = "${hex:" hex-pair-seq "}"
+   hex-pair-seq         = *blank hex-pair *(1*blank hex-pair) *blank
+   hex-pair             = 1*2HEXDIG
+
+   Where WSP and HEXDIG non-terminals are defined in Appendix B.1 of
+   [ABNF].
+
+   It may be inconvenient or undesirable to enter Unicode characters
+   verbatim, and for these cases the syntax encoded-unicode-char can be
+   used.  The sequence is replaced by the UTF-8 encoding of the
+   specified Unicode characters, which are identified by the hexadecimal
+   value of unicode-hex.
+
+   encoded-unicode-char = "${unicode:" unicode-hex-seq "}"
+   unicode-hex-seq      = *blank unicode-hex
+                          *(1*blank unicode-hex) *blank
+   unicode-hex          = 1*HEXDIG
+
+
+
+Guenther & Showalter        Standards Track                    [Page 10]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+   It is an error for a script to use a hexadecimal value that isn't in
+   either the range 0 to D7FF or the range E000 to 10FFFF.  (The range
+   D800 to DFFF is excluded as those character numbers are only used as
+   part of the UTF-16 encoding form and are not applicable to the UTF-8
+   encoding that the syntax here represents.)
+
+      Note: Implementations MUST NOT raise an error for an out-of-range
+      Unicode value unless the sequence containing it is well-formed
+      according to the grammar.
+
+   The capability string for use with the require command is "encoded-
+   character".
+
+   In the following script, message B is discarded, since the specified
+   test string is equivalent to "$$$".
+
+   Example:  require "encoded-character";
+             if header :contains "Subject" "$${hex:24 24}" {
+                discard;
+             }
+   The following examples demonstrate valid and invalid encodings and
+   how they are handled:
+
+     "$${hex:40}"         -> "$@"
+     "${hex: 40 }"        -> "@"
+     "${HEX: 40}"         -> "@"
+     "${hex:40"           -> "${hex:40"
+     "${hex:400}"         -> "${hex:400}"
+     "${hex:4${hex:30}}"  -> "${hex:40}"
+     "${unicode:40}"      -> "@"
+     "${ unicode:40}"     -> "${ unicode:40}"
+     "${UNICODE:40}"      -> "@"
+     "${UnICoDE:0000040}" -> "@"
+     "${Unicode:40}"      -> "@"
+     "${Unicode:Cool}"    -> "${Unicode:Cool}"
+     "${unicode:200000}"  -> error
+     "${Unicode:DF01}     -> error
+
+2.5.  Tests
+
+   Tests are given as arguments to commands in order to control their
+   actions.  In this document, tests are given to if/elsif to decide
+   which block of code is run.
+
+
+
+
+
+
+
+
+Guenther & Showalter        Standards Track                    [Page 11]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+2.5.1.  Test Lists
+
+   Some tests ("allof" and "anyof", which implement logical "and" and
+   logical "or", respectively) may require more than a single test as an
+   argument.  The test-list syntax element provides a way of grouping
+   tests as a comma-separated list in parentheses.
+
+   Example:  if anyof (not exists ["From", "Date"],
+                   header :contains "from" "fool@example.com") {
+                discard;
+             }
+
+2.6.  Arguments
+
+   In order to specify what to do, most commands take arguments.  There
+   are three types of arguments: positional, tagged, and optional.
+
+   It is an error for a script, on a single command, to use conflicting
+   arguments or to use a tagged or optional argument more than once.
+
+2.6.1.  Positional Arguments
+
+   Positional arguments are given to a command that discerns their
+   meaning based on their order.  When a command takes positional
+   arguments, all positional arguments must be supplied and must be in
+   the order prescribed.
+
+2.6.2.  Tagged Arguments
+
+   This document provides for tagged arguments in the style of
+   CommonLISP.  These are also similar to flags given to commands in
+   most command-line systems.
+
+   A tagged argument is an argument for a command that begins with ":"
+   followed by a tag naming the argument, such as ":contains".  This
+   argument means that zero or more of the next tokens have some
+   particular meaning depending on the argument.  These next tokens may
+   be literal data, but they are never blocks.
+
+   Tagged arguments are similar to positional arguments, except that
+   instead of the meaning being derived from the command, it is derived
+   from the tag.
+
+   Tagged arguments must appear before positional arguments, but they
+   may appear in any order with other tagged arguments.  For simplicity
+   of the specification, this is not expressed in the syntax definitions
+
+
+
+
+
+Guenther & Showalter        Standards Track                    [Page 12]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+   with commands, but they still may be reordered arbitrarily provided
+   they appear before positional arguments.  Tagged arguments may be
+   mixed with optional arguments.
+
+   Tagged arguments SHOULD NOT take tagged arguments as arguments.
+
+2.6.3.  Optional Arguments
+
+   Optional arguments are exactly like tagged arguments except that they
+   may be left out, in which case a default value is implied.  Because
+   optional arguments tend to result in shorter scripts, they have been
+   used far more than tagged arguments.
+
+   One particularly noteworthy case is the ":comparator" argument, which
+   allows the user to specify which comparator [COLLATION] will be used
+   to compare two strings, since different languages may impose
+   different orderings on UTF-8 [UTF-8] strings.
+
+2.6.4.  Types of Arguments
+
+   Abstractly, arguments may be literal data, tests, or blocks of
+   commands.  In this way, an "if" control structure is merely a command
+   that happens to take a test and a block as arguments and may execute
+   the block of code.
+
+   However, this abstraction is ambiguous from a parsing standpoint.
+
+   The grammar in section 8.2 presents a parsable version of this:
+   Arguments are string lists (string-lists), numbers, and tags, which
+   may be followed by a test or a test list (test-list), which may be
+   followed by a block of commands.  No more than one test or test list,
+   or more than one block of commands, may be used, and commands that
+   end with a block of commands do not end with semicolons.
+
+2.7.  String Comparison
+
+   When matching one string against another, there are a number of ways
+   of performing the match operation.  These are accomplished with three
+   types of matches: an exact match, a substring match, and a wildcard
+   glob-style match.  These are described below.
+
+   In order to provide for matches between character sets and case
+   insensitivity, Sieve uses the comparators defined in the Internet
+   Application Protocol Collation Registry [COLLATION].
+
+
+
+
+
+
+
+Guenther & Showalter        Standards Track                    [Page 13]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+   However, when a string represents the name of a header, the
+   comparator is never user-specified.  Header comparisons are always
+   done with the "i;ascii-casemap" operator, i.e., case-insensitive
+   comparisons, because this is the way things are defined in the
+   message specification [IMAIL].
+
+2.7.1.  Match Type
+
+   Commands that perform string comparisons may have an optional match
+   type argument.  The three match types in this specification are
+   ":contains", ":is", and ":matches".
+
+   The ":contains" match type describes a substring match.  If the value
+   argument contains the key argument as a substring, the match is true.
+   For instance, the string "frobnitzm" contains "frob" and "nit", but
+   not "fbm".  The empty key ("") is contained in all values.
+
+   The ":is" match type describes an absolute match; if the contents of
+   the first string are absolutely the same as the contents of the
+   second string, they match.  Only the string "frobnitzm" is the string
+   "frobnitzm".  The empty key ("") only ":is" matches with the empty
+   value.
+
+   The ":matches" match type specifies a wildcard match using the
+   characters "*" and "?"; the entire value must be matched.  "*"
+   matches zero or more characters in the value and "?" matches a single
+   character in the value, where the comparator that is used (see
+   section 2.7.3) defines what a character is.  For example, the
+   comparators "i;octet" and "i;ascii-casemap" define a character to be
+   a single octet, so "?"  will always match exactly one octet when one
+   of those comparators is in use.  In contrast, a Unicode-based
+   comparator would define a character to be any UTF-8 octet sequence
+   encoding one Unicode character and thus "?" may match more than one
+   octet.  "?" and "*" may be escaped as "\\?" and "\\*" in strings to
+   match against themselves.  The first backslash escapes the second
+   backslash; together, they escape the "*".  This is awkward, but it is
+   commonplace in several programming languages that use globs and
+   regular expressions.
+
+   In order to specify what type of match is supposed to happen,
+   commands that support matching take optional arguments ":matches",
+   ":is", and ":contains".  Commands default to using ":is" matching if
+   no match type argument is supplied.  Note that these modifiers
+   interact with comparators; in particular, only comparators that
+   support the "substring match" operation are suitable for matching
+   with ":contains" or ":matches".  It is an error to use a comparator
+   with ":contains" or ":matches" that is not compatible with it.
+
+
+
+
+Guenther & Showalter        Standards Track                    [Page 14]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+   It is an error to give more than one of these arguments to a given
+   command.
+
+   For convenience, the "MATCH-TYPE" syntax element is defined here as
+   follows:
+
+   Syntax:   ":is" / ":contains" / ":matches"
+
+2.7.2.  Comparisons across Character Sets
+
+   Messages may involve a number of character sets.  In order for
+   comparisons to work across character sets, implementations SHOULD
+   implement the following behavior:
+
+      Comparisons are performed on octets.  Implementations convert text
+      from header fields in all charsets [MIME3] to Unicode, encoded as
+      UTF-8, as input to the comparator (see section 2.7.3).
+      Implementations MUST be capable of converting US-ASCII, ISO-8859-
+      1, the US-ASCII subset of ISO-8859-* character sets, and UTF-8.
+      Text that the implementation cannot convert to Unicode for any
+      reason MAY be treated as plain US-ASCII (including any [MIME3]
+      syntax) or processed according to local conventions.  An encoded
+      NUL octet (character zero) SHOULD NOT cause early termination of
+      the header content being compared against.
+
+   If implementations fail to support the above behavior, they MUST
+   conform to the following:
+
+      No two strings can be considered equal if one contains octets
+      greater than 127.
+
+2.7.3.  Comparators
+
+   In order to allow for language-independent, case-independent matches,
+   the match type may be coupled with a comparator name.  The Internet
+   Application Protocol Collation Registry [COLLATION] provides the
+   framework for describing and naming comparators.
+
+   All implementations MUST support the "i;octet" comparator (simply
+   compares octets) and the "i;ascii-casemap" comparator (which treats
+   uppercase and lowercase characters in the US-ASCII subset of UTF-8 as
+   the same).  If left unspecified, the default is "i;ascii-casemap".
+
+   Some comparators may not be usable with substring matches; that is,
+   they may only work with ":is".  It is an error to try to use a
+   comparator with ":matches" or ":contains" that is not compatible with
+   it.
+
+
+
+
+Guenther & Showalter        Standards Track                    [Page 15]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+   Sieve treats a comparator result of "undefined" the same as a result
+   of "no-match".  That is, this base specification does not provide any
+   means to directly detect invalid comparator input.
+
+   A comparator is specified by the ":comparator" option with commands
+   that support matching.  This option is followed by a string providing
+   the name of the comparator to be used.  For convenience, the syntax
+   of a comparator is abbreviated to "COMPARATOR", and (repeated in
+   several tests) is as follows:
+
+   Syntax:   ":comparator" <comparator-name: string>
+
+   So in this example,
+
+   Example:  if header :contains :comparator "i;octet" "Subject"
+                   "MAKE MONEY FAST" {
+                discard;
+             }
+
+   would discard any message with subjects like "You can MAKE MONEY
+   FAST", but not "You can Make Money Fast", since the comparator used
+   is case-sensitive.
+
+   Comparators other than "i;octet" and "i;ascii-casemap" must be
+   declared with require, as they are extensions.  If a comparator
+   declared with require is not known, it is an error, and execution
+   fails.  If the comparator is not declared with require, it is also an
+   error, even if the comparator is supported.  (See section 2.10.5.)
+
+   Both ":matches" and ":contains" match types are compatible with the
+   "i;octet" and "i;ascii-casemap" comparators and may be used with
+   them.
+
+   It is an error to give more than one of these arguments to a given
+   command.
+
+2.7.4.  Comparisons against Addresses
+
+   Addresses are one of the most frequent things represented as strings.
+   These are structured, and being able to compare against the local-
+   part or the domain of an address is useful, so some tests that act
+   exclusively on addresses take an additional optional argument that
+   specifies what the test acts on.
+
+   These optional arguments are ":localpart", ":domain", and ":all",
+   which act on the local-part (left side), the domain-part (right
+   side), and the whole address.
+
+
+
+
+Guenther & Showalter        Standards Track                    [Page 16]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+   If an address is not syntactically valid, then it will not be matched
+   by tests specifying ":localpart" or ":domain".
+
+   The kind of comparison done, such as whether or not the test done is
+   case-insensitive, is specified as a comparator argument to the test.
+
+   If an optional address-part is omitted, the default is ":all".
+
+   It is an error to give more than one of these arguments to a given
+   command.
+
+   For convenience, the "ADDRESS-PART" syntax element is defined here as
+   follows:
+
+   Syntax:   ":localpart" / ":domain" / ":all"
+
+2.8.  Blocks
+
+   Blocks are sets of commands enclosed within curly braces and supplied
+   as the final argument to a command.  Such a command is a control
+   structure: when executed it has control over the number of times the
+   commands in the block are executed.
+
+   With the commands supplied in this memo, there are no loops.  The
+   control structures supplied--if, elsif, and else--run a block either
+   once or not at all.
+
+2.9.  Commands
+
+   Sieve scripts are sequences of commands.  Commands can take any of
+   the tokens above as arguments, and arguments may be either tagged or
+   positional arguments.  Not all commands take all arguments.
+
+   There are three kinds of commands: test commands, action commands,
+   and control commands.
+
+   The simplest is an action command.  An action command is an
+   identifier followed by zero or more arguments, terminated by a
+   semicolon.  Action commands do not take tests or blocks as arguments.
+   The actions referenced in this document are:
+
+    - keep, to save the message in the default location
+    - fileinto, to save the message in a specific mailbox
+    - redirect, to forward the message to another address
+    - discard, to silently throw away the message
+
+
+
+
+
+
+Guenther & Showalter        Standards Track                    [Page 17]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+   A control command is a command that affects the parsing or the flow
+   of execution of the Sieve script in some way.  A control structure is
+   a control command that ends with a block instead of a semicolon.
+
+   A test command is used as part of a control command.  It is used to
+   specify whether or not the block of code given to the control command
+   is executed.
+
+2.10.  Evaluation
+
+2.10.1.  Action Interaction
+
+   Some actions cannot be used with other actions because the result
+   would be absurd.  These restrictions are noted throughout this memo.
+
+   Extension actions MUST state how they interact with actions defined
+   in this specification.
+
+2.10.2.  Implicit Keep
+
+   Previous experience with filtering systems suggests that cases tend
+   to be missed in scripts.  To prevent errors, Sieve has an "implicit
+   keep".
+
+   An implicit keep is a keep action (see section 4.3) performed in
+   absence of any action that cancels the implicit keep.
+
+   An implicit keep is performed if a message is not written to a
+   mailbox, redirected to a new address, or explicitly thrown out.  That
+   is, if a fileinto, a keep, a redirect, or a discard is performed, an
+   implicit keep is not.
+
+   Some actions may be defined to not cancel the implicit keep.  These
+   actions may not directly affect the delivery of a message, and are
+   used for their side effects.  None of the actions specified in this
+   document meet that criteria, but extension actions may.
+
+   For instance, with any of the short messages offered above, the
+   following script produces no actions.
+
+   Example:  if size :over 500K { discard; }
+
+   As a result, the implicit keep is taken.
+
+
+
+
+
+
+
+
+Guenther & Showalter        Standards Track                    [Page 18]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+2.10.3.  Message Uniqueness in a Mailbox
+
+   Implementations SHOULD NOT deliver a message to the same mailbox more
+   than once, even if a script explicitly asks for a message to be
+   written to a mailbox twice.
+
+   The test for equality of two messages is implementation-defined.
+
+   If a script asks for a message to be written to a mailbox twice, it
+   MUST NOT be treated as an error.
+
+2.10.4.  Limits on Numbers of Actions
+
+   Site policy MAY limit the number of actions taken and MAY impose
+   restrictions on which actions can be used together.  In the event
+   that a script hits a policy limit on the number of actions taken for
+   a particular message, an error occurs.
+
+   Implementations MUST allow at least one keep or one fileinto.  If
+   fileinto is not implemented, implementations MUST allow at least one
+   keep.
+
+2.10.5.  Extensions and Optional Features
+
+   Because of the differing capabilities of many mail systems, several
+   features of this specification are optional.  Before any of these
+   extensions can be executed, they must be declared with the "require"
+   action.
+
+   If an extension is not enabled with "require", implementations MUST
+   treat it as if they did not support it at all.  This protects scripts
+   from having their behavior altered by extensions that the script
+   author might not have even been aware of.
+
+   Implementations MUST NOT execute any Sieve script test or command
+   subsequent to "require" if one of the required extensions is
+   unavailable.
+
+      Note: The reason for this restriction is that prior experiences
+      with languages such as LISP and Tcl suggest that this is a
+      workable way of noting that a given script uses an extension.
+
+   Extensions that define actions MUST state how they interact with
+   actions discussed in the base specification.
+
+
+
+
+
+
+
+Guenther & Showalter        Standards Track                    [Page 19]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+2.10.6.  Errors
+
+   In any programming language, there are compile-time and run-time
+   errors.
+
+   Compile-time errors are ones in syntax that are detectable if a
+   syntax check is done.
+
+   Run-time errors are not detectable until the script is run.  This
+   includes transient failures like disk full conditions, but also
+   includes issues like invalid combinations of actions.
+
+   When an error occurs in a Sieve script, all processing stops.
+
+   Implementations MAY choose to do a full parse, then evaluate the
+   script, then do all actions.  Implementations might even go so far as
+   to ensure that execution is atomic (either all actions are executed
+   or none are executed).
+
+   Other implementations may choose to parse and run at the same time.
+   Such implementations are simpler, but have issues with partial
+   failure (some actions happen, others don't).
+
+   Implementations MUST perform syntactic, semantic, and run-time checks
+   on code that is actually executed.  Implementations MAY perform those
+   checks or any part of them on code that is not reached during
+   execution.
+
+   When an error happens, implementations MUST notify the user that an
+   error occurred and which actions (if any) were taken, and do an
+   implicit keep.
+
+2.10.7.  Limits on Execution
+
+   Implementations may limit certain constructs.  However, this
+   specification places a lower bound on some of these limits.
+
+   Implementations MUST support fifteen levels of nested blocks.
+
+   Implementations MUST support fifteen levels of nested test lists.
+
+
+
+
+
+
+
+
+
+
+
+Guenther & Showalter        Standards Track                    [Page 20]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+3.  Control Commands
+
+   Control structures are needed to allow for multiple and conditional
+   actions.
+
+3.1.  Control if
+
+   There are three pieces to if: "if", "elsif", and "else".  Each is
+   actually a separate command in terms of the grammar.  However, an
+   elsif or else MUST only follow an if or elsif.  An error occurs if
+   these conditions are not met.
+
+   Usage:   if <test1: test> <block1: block>
+
+   Usage:   elsif <test2: test> <block2: block>
+
+   Usage:   else <block3: block>
+
+   The semantics are similar to those of any of the many other
+   programming languages these control structures appear in.  When the
+   interpreter sees an "if", it evaluates the test associated with it.
+   If the test is true, it executes the block associated with it.
+
+   If the test of the "if" is false, it evaluates the test of the first
+   "elsif" (if any).  If the test of "elsif" is true, it runs the
+   elsif's block.  An elsif may be followed by an elsif, in which case,
+   the interpreter repeats this process until it runs out of elsifs.
+
+   When the interpreter runs out of elsifs, there may be an "else" case.
+   If there is, and none of the if or elsif tests were true, the
+   interpreter runs the else's block.
+
+   This provides a way of performing exactly one of the blocks in the
+   chain.
+
+   In the following example, both messages A and B are dropped.
+
+   Example:  require "fileinto";
+             if header :contains "from" "coyote" {
+                discard;
+             } elsif header :contains ["subject"] ["$$$"] {
+                discard;
+             } else {
+                fileinto "INBOX";
+             }
+
+
+
+
+
+
+Guenther & Showalter        Standards Track                    [Page 21]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+   When the script below is run over message A, it redirects the message
+   to acm@example.com; message B, to postmaster@example.com; any other
+   message is redirected to field@example.com.
+
+   Example:  if header :contains ["From"] ["coyote"] {
+                redirect "acm@example.com";
+             } elsif header :contains "Subject" "$$$" {
+                redirect "postmaster@example.com";
+             } else {
+                redirect "field@example.com";
+             }
+
+   Note that this definition prohibits the "... else if ..." sequence
+   used by C.  This is intentional, because this construct produces a
+   shift-reduce conflict.
+
+3.2.  Control require
+
+   Usage:   require <capabilities: string-list>
+
+   The require action notes that a script makes use of a certain
+   extension.  Such a declaration is required to use the extension, as
+   discussed in section 2.10.5.  Multiple capabilities can be declared
+   with a single require.
+
+   The require command, if present, MUST be used before anything other
+   than a require can be used.  An error occurs if a require appears
+   after a command other than require.
+
+   Example:  require ["fileinto", "reject"];
+
+   Example:  require "fileinto";
+             require "vacation";
+
+3.3.  Control stop
+
+   Usage:   stop
+
+   The "stop" action ends all processing.  If the implicit keep has not
+   been cancelled, then it is taken.
+
+
+
+
+
+
+
+
+
+
+
+Guenther & Showalter        Standards Track                    [Page 22]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+4.  Action Commands
+
+   This document supplies four actions that may be taken on a message:
+   keep, fileinto, redirect, and discard.
+
+   Implementations MUST support the "keep", "discard", and "redirect"
+   actions.
+
+   Implementations SHOULD support "fileinto".
+
+   Implementations MAY limit the number of certain actions taken (see
+   section 2.10.4).
+
+4.1.  Action fileinto
+
+   Usage:   fileinto <mailbox: string>
+
+   The "fileinto" action delivers the message into the specified
+   mailbox.  Implementations SHOULD support fileinto, but in some
+   environments this may be impossible.  Implementations MAY place
+   restrictions on mailbox names; use of an invalid mailbox name MAY be
+   treated as an error or result in delivery to an implementation-
+   defined mailbox.  If the specified mailbox doesn't exist, the
+   implementation MAY treat it as an error, create the mailbox, or
+   deliver the message to an implementation-defined mailbox.  If the
+   implementation uses a different encoding scheme than UTF-8 for
+   mailbox names, it SHOULD reencode the mailbox name from UTF-8 to its
+   encoding scheme.  For example, the Internet Message Access Protocol
+   [IMAP] uses modified UTF-7, such that a mailbox argument of "odds &
+   ends" would appear in IMAP as "odds &- ends".
+
+   The capability string for use with the require command is "fileinto".
+
+   In the following script, message A is filed into mailbox
+   "INBOX.harassment".
+
+   Example:  require "fileinto";
+             if header :contains ["from"] "coyote" {
+                fileinto "INBOX.harassment";
+             }
+
+4.2.  Action redirect
+
+   Usage:   redirect <address: string>
+
+   The "redirect" action is used to send the message to another user at
+   a supplied address, as a mail forwarding feature does.  The
+   "redirect" action makes no changes to the message body or existing
+
+
+
+Guenther & Showalter        Standards Track                    [Page 23]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+   headers, but it may add new headers.  In particular, existing
+   Received headers MUST be preserved and the count of Received headers
+   in the outgoing message MUST be larger than the same count on the
+   message as received by the implementation.  (An implementation that
+   adds a Received header before processing the message does not need to
+   add another when redirecting.)
+
+   The message is sent back out with the address from the redirect
+   command as an envelope recipient.  Implementations MAY combine
+   separate redirects for a given message into a single submission with
+   multiple envelope recipients.  (This is not a Mail User Agent (MUA)-
+   style forward, which creates a new message with a different sender
+   and message ID, wrapping the old message in a new one.)
+
+   The envelope sender address on the outgoing message is chosen by the
+   sieve implementation.  It MAY be copied from the message being
+   processed.  However, if the message being processed has an empty
+   envelope sender address the outgoing message MUST also have an empty
+   envelope sender address.  This last requirement is imposed to prevent
+   loops in the case where a message is redirected to an invalid address
+   when then returns a delivery status notification that also ends up
+   being redirected to the same invalid address.
+
+   A simple script can be used for redirecting all mail:
+
+   Example:  redirect "bart@example.com";
+
+   Implementations MUST take measures to implement loop control,
+   possibly including adding headers to the message or counting Received
+   headers as specified in section 6.2 of [SMTP].  If an implementation
+   detects a loop, it causes an error.
+
+   Implementations MUST provide means of limiting the number of
+   redirects a Sieve script can perform.  See section 10 for more
+   details.
+
+   Implementations MAY ignore a redirect action silently due to policy
+   reasons.  For example, an implementation MAY choose not to redirect
+   to an address that is known to be undeliverable.  Any ignored
+   redirect MUST NOT cancel the implicit keep.
+
+4.3.  Action keep
+
+   Usage:   keep
+
+   The "keep" action is whatever action is taken in lieu of all other
+   actions, if no filtering happens at all; generally, this simply means
+   to file the message into the user's main mailbox.  This command
+
+
+
+Guenther & Showalter        Standards Track                    [Page 24]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+   provides a way to execute this action without needing to know the
+   name of the user's main mailbox, providing a way to call it without
+   needing to understand the user's setup or the underlying mail system.
+
+   For instance, in an implementation where the IMAP server is running
+   scripts on behalf of the user at time of delivery, a keep command is
+   equivalent to a fileinto "INBOX".
+
+   Example:  if size :under 1M { keep; } else { discard; }
+
+   Note that the above script is identical to the one below.
+
+   Example:  if not size :under 1M { discard; }
+
+4.4.  Action discard
+
+   Usage:   discard
+
+   Discard is used to silently throw away the message.  It does so by
+   simply canceling the implicit keep.  If discard is used with other
+   actions, the other actions still happen.  Discard is compatible with
+   all other actions.  (For instance, fileinto+discard is equivalent to
+   fileinto.)
+
+   Discard MUST be silent; that is, it MUST NOT return a non-delivery
+   notification of any kind ([DSN], [MDN], or otherwise).
+
+   In the following script, any mail from "idiot@example.com" is thrown
+   out.
+
+   Example:  if header :contains ["from"] ["idiot@example.com"] {
+                discard;
+             }
+
+   While an important part of this language, "discard" has the potential
+   to create serious problems for users: Students who leave themselves
+   logged in to an unattended machine in a public computer lab may find
+   their script changed to just "discard".  In order to protect users in
+   this situation (along with similar situations), implementations MAY
+   keep messages destroyed by a script for an indefinite period, and MAY
+   disallow scripts that throw out all mail.
+
+
+
+
+
+
+
+
+
+
+Guenther & Showalter        Standards Track                    [Page 25]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+5.  Test Commands
+
+   Tests are used in conditionals to decide which part(s) of the
+   conditional to execute.
+
+   Implementations MUST support these tests: "address", "allof",
+   "anyof", "exists", "false", "header", "not", "size", and "true".
+
+   Implementations SHOULD support the "envelope" test.
+
+5.1.  Test address
+
+   Usage:   address [COMPARATOR] [ADDRESS-PART] [MATCH-TYPE]
+            <header-list: string-list> <key-list: string-list>
+
+   The "address" test matches Internet addresses in structured headers
+   that contain addresses.  It returns true if any header contains any
+   key in the specified part of the address, as modified by the
+   comparator and the match keyword.  Whether there are other addresses
+   present in the header doesn't affect this test; this test does not
+   provide any way to determine whether an address is the only address
+   in a header.
+
+   Like envelope and header, this test returns true if any combination
+   of the header-list and key-list arguments match and returns false
+   otherwise.
+
+   Internet email addresses [IMAIL] have the somewhat awkward
+   characteristic that the local-part to the left of the at-sign is
+   considered case sensitive, and the domain-part to the right of the
+   at-sign is case insensitive.  The "address" command does not deal
+   with this itself, but provides the ADDRESS-PART argument for allowing
+   users to deal with it.
+
+   The address primitive never acts on the phrase part of an email
+   address or on comments within that address.  It also never acts on
+   group names, although it does act on the addresses within the group
+   construct.
+
+   Implementations MUST restrict the address test to headers that
+   contain addresses, but MUST include at least From, To, Cc, Bcc,
+   Sender, Resent-From, and Resent-To, and it SHOULD include any other
+   header that utilizes an "address-list" structured header body.
+
+   Example:  if address :is :all "from" "tim@example.com" {
+                discard;
+             }
+
+
+
+
+Guenther & Showalter        Standards Track                    [Page 26]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+5.2.  Test allof
+
+   Usage:   allof <tests: test-list>
+
+   The "allof" test performs a logical AND on the tests supplied to it.
+
+   Example:  allof (false, false)  =>   false
+             allof (false, true)   =>   false
+             allof (true,  true)   =>   true
+
+   The allof test takes as its argument a test-list.
+
+5.3.  Test anyof
+
+   Usage:   anyof <tests: test-list>
+
+   The "anyof" test performs a logical OR on the tests supplied to it.
+
+   Example:  anyof (false, false)  =>   false
+             anyof (false, true)   =>   true
+             anyof (true,  true)   =>   true
+
+5.4.  Test envelope
+
+   Usage:   envelope [COMPARATOR] [ADDRESS-PART] [MATCH-TYPE]
+            <envelope-part: string-list> <key-list: string-list>
+
+   The "envelope" test is true if the specified part of the [SMTP] (or
+   equivalent) envelope matches the specified key.  This specification
+   defines the interpretation of the (case insensitive) "from" and "to"
+   envelope-parts.  Additional envelope-parts may be defined by other
+   extensions; implementations SHOULD consider unknown envelope parts an
+   error.
+
+   If one of the envelope-part strings is (case insensitive) "from",
+   then matching occurs against the FROM address used in the SMTP MAIL
+   command.  The null reverse-path is matched against as the empty
+   string, regardless of the ADDRESS-PART argument specified.
+
+   If one of the envelope-part strings is (case insensitive) "to", then
+   matching occurs against the TO address used in the SMTP RCPT command
+   that resulted in this message getting delivered to this user.  Note
+   that only the most recent TO is available, and only the one relevant
+   to this user.
+
+   The envelope-part is a string list and may contain more than one
+   parameter, in which case all of the strings specified in the key-list
+   are matched against all parts given in the envelope-part list.
+
+
+
+Guenther & Showalter        Standards Track                    [Page 27]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+   Like address and header, this test returns true if any combination of
+   the envelope-part list and key-list arguments match and returns false
+   otherwise.
+
+   All tests against envelopes MUST drop source routes.
+
+   If the SMTP transaction involved several RCPT commands, only the data
+   from the RCPT command that caused delivery to this user is available
+   in the "to" part of the envelope.
+
+   If a protocol other than SMTP is used for message transport,
+   implementations are expected to adapt this command appropriately.
+
+   The envelope command is optional.  Implementations SHOULD support it,
+   but the necessary information may not be available in all cases.  The
+   capability string for use with the require command is "envelope".
+
+   Example:  require "envelope";
+             if envelope :all :is "from" "tim@example.com" {
+                discard;
+             }
+
+5.5.  Test exists
+
+   Usage:   exists <header-names: string-list>
+
+   The "exists" test is true if the headers listed in the header-names
+   argument exist within the message.  All of the headers must exist or
+   the test is false.
+
+   The following example throws out mail that doesn't have a From header
+   and a Date header.
+
+   Example:  if not exists ["From","Date"] {
+                discard;
+             }
+
+5.6.  Test false
+
+   Usage:   false
+
+   The "false" test always evaluates to false.
+
+
+
+
+
+
+
+
+
+Guenther & Showalter        Standards Track                    [Page 28]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+5.7.  Test header
+
+   Usage:   header [COMPARATOR] [MATCH-TYPE]
+            <header-names: string-list> <key-list: string-list>
+
+   The "header" test evaluates to true if the value of any of the named
+   headers, ignoring leading and trailing whitespace, matches any key.
+   The type of match is specified by the optional match argument, which
+   defaults to ":is" if not specified, as specified in section 2.6.
+
+   Like address and envelope, this test returns true if any combination
+   of the header-names list and key-list arguments match and returns
+   false otherwise.
+
+   If a header listed in the header-names argument exists, it contains
+   the empty key ("").  However, if the named header is not present, it
+   does not match any key, including the empty key.  So if a message
+   contained the header
+
+           X-Caffeine: C8H10N4O2
+
+   these tests on that header evaluate as follows:
+
+           header :is ["X-Caffeine"] [""]         => false
+           header :contains ["X-Caffeine"] [""]   => true
+
+   Testing whether a given header is either absent or doesn't contain
+   any non-whitespace characters can be done using a negated "header"
+   test:
+
+           not header :matches "Cc" "?*"
+
+5.8.  Test not
+
+   Usage:   not <test1: test>
+
+   The "not" test takes some other test as an argument, and yields the
+   opposite result.  "not false" evaluates to "true" and "not true"
+   evaluates to "false".
+
+5.9.  Test size
+
+   Usage:   size <":over" / ":under"> <limit: number>
+
+   The "size" test deals with the size of a message.  It takes either a
+   tagged argument of ":over" or ":under", followed by a number
+   representing the size of the message.
+
+
+
+
+Guenther & Showalter        Standards Track                    [Page 29]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+   If the argument is ":over", and the size of the message is greater
+   than the number provided, the test is true; otherwise, it is false.
+
+   If the argument is ":under", and the size of the message is less than
+   the number provided, the test is true; otherwise, it is false.
+
+   Exactly one of ":over" or ":under" must be specified, and anything
+   else is an error.
+
+   The size of a message is defined to be the number of octets in the
+   [IMAIL] representation of the message.
+
+   Note that for a message that is exactly 4,000 octets, the message is
+   neither ":over" nor ":under" 4000 octets.
+
+5.10.  Test true
+
+   Usage:   true
+
+   The "true" test always evaluates to true.
+
+6.  Extensibility
+
+   New control commands, actions, and tests can be added to the
+   language.  Sites must make these features known to their users; this
+   document does not define a way to discover the list of extensions
+   supported by the server.
+
+   Any extensions to this language MUST define a capability string that
+   uniquely identifies that extension.  Capability string are case-
+   sensitive; for example, "foo" and "FOO" are different capabilities.
+   If a new version of an extension changes the functionality of a
+   previously defined extension, it MUST use a different name.
+   Extensions may register a set of related capabilities by registering
+   just a unique prefix for them.  The "comparator-" prefix is an
+   example of this.  The prefix MUST end with a "-" and MUST NOT overlap
+   any existing registrations.
+
+   In a situation where there is a script submission protocol and an
+   extension advertisement mechanism aware of the details of this
+   language, scripts submitted can be checked against the mail server to
+   prevent use of an extension that the server does not support.
+
+   Extensions MUST state how they interact with constraints defined in
+   section 2.10, e.g., whether they cancel the implicit keep, and which
+   actions they are compatible and incompatible with.  Extensions MUST
+   NOT change the behavior of the "require" control command or alter the
+   interpretation of the argument to the "require" control.
+
+
+
+Guenther & Showalter        Standards Track                    [Page 30]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+   Extensions that can submit new email messages or otherwise generate
+   new protocol requests MUST consider loop suppression, at least to
+   document any security considerations.
+
+6.1.  Capability String
+
+   Capability strings are typically short strings describing what
+   capabilities are supported by the server.
+
+   Capability strings beginning with "vnd." represent vendor-defined
+   extensions.  Such extensions are not defined by Internet standards or
+   RFCs, but are still registered with IANA in order to prevent
+   conflicts.  Extensions starting with "vnd." SHOULD be followed by the
+   name of the vendor and product, such as "vnd.acme.rocket-sled".
+
+   The following capability strings are defined by this document:
+
+   encoded-character The string "encoded-character" indicates that the
+               implementation supports the interpretation of
+               "${hex:...}" and "${unicode:...}" in strings.
+
+   envelope    The string "envelope" indicates that the implementation
+               supports the "envelope" command.
+
+   fileinto    The string "fileinto" indicates that the implementation
+               supports the "fileinto" command.
+
+   comparator- The string "comparator-elbonia" is provided if the
+               implementation supports the "elbonia" comparator.
+               Therefore, all implementations have at least the
+               "comparator-i;octet" and "comparator-i;ascii-casemap"
+               capabilities.  However, these comparators may be used
+               without being declared with require.
+
+6.2.  IANA Considerations
+
+   In order to provide a standard set of extensions, a registry is
+   maintained by IANA.  This registry contains both vendor-controlled
+   capability names (beginning with "vnd.") and IETF-controlled
+   capability names.  Vendor-controlled capability names may be
+   registered on a first-come, first-served basis, by applying to IANA
+   with the form in the following section.  Registration of capability
+   prefixes that do not begin with "vnd." REQUIRES a standards track or
+   IESG-approved experimental RFC.
+
+   Extensions designed for interoperable use SHOULD use IETF-controlled
+   capability names.
+
+
+
+
+Guenther & Showalter        Standards Track                    [Page 31]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+6.2.1.  Template for Capability Registrations
+
+   The following template is to be used for registering new Sieve
+   extensions with IANA.
+
+   To: iana@iana.org
+   Subject: Registration of new Sieve extension
+
+   Capability name: [the string for use in the 'require' statement]
+   Description:     [a brief description of what the extension adds
+                     or changes]
+   RFC number:      [for extensions published as RFCs]
+   Contact address: [email and/or physical address to contact for
+                     additional information]
+
+6.2.2.  Handling of Existing Capability Registrations
+
+   In order to bring the existing capability registrations in line with
+   the new template, IANA has modified each as follows:
+
+   1. The "capability name" and "capability arguments" fields have been
+      eliminated
+   2. The "capability keyword" field have been renamed to "Capability
+      name"
+   3. An empty "Description" field has been added
+   4. The "Standards Track/IESG-approved experimental RFC number" field
+      has been renamed to "RFC number"
+   5. The "Person and email address to contact for further information"
+      field should be renamed to "Contact address"
+
+6.2.3.  Initial Capability Registrations
+
+   This RFC updates the following entries in the IANA registry for Sieve
+   extensions.
+
+   Capability name: encoded-character
+   Description:     changes the interpretation of strings to allow
+                    arbitrary octets and Unicode characters to be
+                    represented using US-ASCII
+   RFC number:      RFC 5228 (Sieve base spec)
+   Contact address: The Sieve discussion list <ietf-mta-filters@imc.org>
+
+   Capability name: fileinto
+   Description:     adds the 'fileinto' action for delivering to a
+                    mailbox other than the default
+   RFC number:      RFC 5228 (Sieve base spec)
+   Contact address: The Sieve discussion list <ietf-mta-filters@imc.org>
+
+
+
+
+Guenther & Showalter        Standards Track                    [Page 32]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+   Capability name: envelope
+   Description:     adds the 'envelope' test for testing the message
+                    transport sender and recipient address
+   RFC number:      RFC 5228 (Sieve base spec)
+   Contact address: The Sieve discussion list <ietf-mta-filters@imc.org>
+
+   Capability name: comparator-* (anything starting with "comparator-")
+   Description:     adds the indicated comparator for use with the
+                    :comparator argument
+   RFC number:      RFC 5228 (Sieve base spec) and [COLLATION]
+   Contact address: The Sieve discussion list <ietf-mta-filters@imc.org>
+
+6.3.  Capability Transport
+
+   A method of advertising which capabilities an implementation supports
+   is difficult due to the wide range of possible implementations.  Such
+   a mechanism, however, should have the property that the
+   implementation can advertise the complete set of extensions that it
+   supports.
+
+7.  Transmission
+
+   The [MIME] type for a Sieve script is "application/sieve".
+
+   The registration of this type for RFC 2048 requirements is updated as
+   follows:
+
+    Subject: Registration of MIME media type application/sieve
+
+    MIME media type name: application
+    MIME subtype name: sieve
+    Required parameters: none
+    Optional parameters: none
+    Encoding considerations: Most Sieve scripts will be textual,
+       written in UTF-8.  When non-7bit characters are used,
+       quoted-printable is appropriate for transport systems
+       that require 7bit encoding.
+    Security considerations: Discussed in section 10 of this RFC.
+    Interoperability considerations: Discussed in section 2.10.5
+       of this RFC.
+    Published specification: this RFC.
+    Applications that use this media type: sieve-enabled mail
+      servers and clients
+    Additional information:
+      Magic number(s):
+      File extension(s): .siv .sieve
+      Macintosh File Type Code(s):
+
+
+
+
+Guenther & Showalter        Standards Track                    [Page 33]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+    Person & email address to contact for further information:
+       See the discussion list at ietf-mta-filters@imc.org.
+    Intended usage:
+       COMMON
+    Author/Change controller:
+       The SIEVE WG, delegated by the IESG.
+
+8.  Parsing
+
+   The Sieve grammar is separated into tokens and a separate grammar as
+   most programming languages are.  Additional rules are supplied here
+   for common arguments to various language facilities.
+
+8.1.  Lexical Tokens
+
+   Sieve scripts are encoded in UTF-8.  The following assumes a valid
+   UTF-8 encoding; special characters in Sieve scripts are all US-ASCII.
+
+   The following are tokens in Sieve:
+
+           - identifiers
+           - tags
+           - numbers
+           - quoted strings
+           - multi-line strings
+           - other separators
+
+   Identifiers, tags, and numbers are case-insensitive, while quoted
+   strings and multi-line strings are case-sensitive.
+
+   Blanks, horizontal tabs, CRLFs, and comments ("whitespace") are
+   ignored except as they separate tokens.  Some whitespace is required
+   to separate otherwise adjacent tokens and in specific places in the
+   multi-line strings.  CR and LF can only appear in CRLF pairs.
+
+   The other separators are single individual characters and are
+   mentioned explicitly in the grammar.
+
+   The lexical structure of sieve is defined in the following grammar
+   (as described in [ABNF]):
+
+   bracket-comment    = "/*" *not-star 1*STAR
+                        *(not-star-slash *not-star 1*STAR) "/"
+                          ; No */ allowed inside a comment.
+                          ; (No * is allowed unless it is the last
+                          ; character, or unless it is followed by a
+                          ; character that isn't a slash.)
+
+
+
+
+Guenther & Showalter        Standards Track                    [Page 34]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+   comment            = bracket-comment / hash-comment
+
+   hash-comment       = "#" *octet-not-crlf CRLF
+
+   identifier         = (ALPHA / "_") *(ALPHA / DIGIT / "_")
+
+   multi-line         = "text:" *(SP / HTAB) (hash-comment / CRLF)
+                        *(multiline-literal / multiline-dotstart)
+                        "." CRLF
+
+   multiline-literal  = [ octet-not-period *octet-not-crlf ] CRLF
+
+   multiline-dotstart = "." 1*octet-not-crlf CRLF
+                          ; A line containing only "." ends the
+                          ; multi-line.  Remove a leading '.' if
+                          ; followed by another '.'.
+
+   not-star           = CRLF / %x01-09 / %x0B-0C / %x0E-29 / %x2B-FF
+                          ; either a CRLF pair, OR a single octet
+                          ; other than NUL, CR, LF, or star
+
+   not-star-slash     = CRLF / %x01-09 / %x0B-0C / %x0E-29 / %x2B-2E /
+                        %x30-FF
+                          ; either a CRLF pair, OR a single octet
+                          ; other than NUL, CR, LF, star, or slash
+
+   number             = 1*DIGIT [ QUANTIFIER ]
+
+   octet-not-crlf     = %x01-09 / %x0B-0C / %x0E-FF
+                          ; a single octet other than NUL, CR, or LF
+
+   octet-not-period   = %x01-09 / %x0B-0C / %x0E-2D / %x2F-FF
+                          ; a single octet other than NUL,
+                          ; CR, LF, or period
+
+   octet-not-qspecial = %x01-09 / %x0B-0C / %x0E-21 / %x23-5B / %x5D-FF
+                          ; a single octet other than NUL,
+                          ; CR, LF, double-quote, or backslash
+
+   QUANTIFIER         = "K" / "M" / "G"
+
+   quoted-other       = "\" octet-not-qspecial
+                          ; represents just the octet-no-qspecial
+                          ; character.  SHOULD NOT be used
+
+   quoted-safe        = CRLF / octet-not-qspecial
+                          ; either a CRLF pair, OR a single octet other
+                          ; than NUL, CR, LF, double-quote, or backslash
+
+
+
+Guenther & Showalter        Standards Track                    [Page 35]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+   quoted-special     = "\" (DQUOTE / "\")
+                          ; represents just a double-quote or backslash
+
+   quoted-string      = DQUOTE quoted-text DQUOTE
+
+   quoted-text        = *(quoted-safe / quoted-special / quoted-other)
+
+   STAR               = "*"
+
+   tag                = ":" identifier
+
+   white-space        = 1*(SP / CRLF / HTAB) / comment
+
+8.2.  Grammar
+
+   The following is the grammar of Sieve after it has been lexically
+   interpreted.  No whitespace or comments appear below.  The start
+   symbol is "start".
+
+   argument     = string-list / number / tag
+
+   arguments    = *argument [ test / test-list ]
+
+   block        = "{" commands "}"
+
+   command      = identifier arguments (";" / block)
+
+   commands     = *command
+
+   start        = commands
+
+   string       = quoted-string / multi-line
+
+   string-list  = "[" string *("," string) "]" / string
+                    ; if there is only a single string, the brackets
+                    ; are optional
+
+   test         = identifier arguments
+
+   test-list    = "(" test *("," test) ")"
+
+8.3.  Statement Elements
+
+   These elements are collected from the "Syntax" sections elsewhere in
+   this document, and are provided here in [ABNF] syntax so that they
+   can be modified by extensions.
+
+   ADDRESS-PART = ":localpart" / ":domain" / ":all"
+
+
+
+Guenther & Showalter        Standards Track                    [Page 36]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+   COMPARATOR   = ":comparator" string
+
+   MATCH-TYPE   = ":is" / ":contains" / ":matches"
+
+9.  Extended Example
+
+   The following is an extended example of a Sieve script.  Note that it
+   does not make use of the implicit keep.
+
+    #
+    # Example Sieve Filter
+    # Declare any optional features or extension used by the script
+    #
+    require ["fileinto"];
+
+    #
+    # Handle messages from known mailing lists
+    # Move messages from IETF filter discussion list to filter mailbox
+    #
+    if header :is "Sender" "owner-ietf-mta-filters@imc.org"
+            {
+            fileinto "filter";  # move to "filter" mailbox
+            }
+    #
+    # Keep all messages to or from people in my company
+    #
+    elsif address :DOMAIN :is ["From", "To"] "example.com"
+            {
+            keep;               # keep in "In" mailbox
+            }
+
+    #
+    # Try and catch unsolicited email.  If a message is not to me,
+    # or it contains a subject known to be spam, file it away.
+    #
+    elsif anyof (NOT address :all :contains
+                   ["To", "Cc", "Bcc"] "me@example.com",
+                 header :matches "subject"
+                   ["*make*money*fast*", "*university*dipl*mas*"])
+            {
+            fileinto "spam";   # move to "spam" mailbox
+            }
+    else
+            {
+            # Move all other (non-company) mail to "personal"
+            # mailbox.
+            fileinto "personal";
+            }
+
+
+
+Guenther & Showalter        Standards Track                    [Page 37]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+10.  Security Considerations
+
+   Users must get their mail.  It is imperative that whatever
+   implementations use to store the user-defined filtering scripts
+   protect them from unauthorized modification, to preserve the
+   integrity of the mail system.  An attacker who can modify a script
+   can cause mail to be discarded, rejected, or forwarded to an
+   unauthorized recipient.  In addition, it's possible that Sieve
+   scripts might expose private information, such as mailbox names, or
+   email addresses of favored (or disfavored) correspondents.  Because
+   of that, scripts SHOULD also be protected from unauthorized
+   retrieval.
+
+   Several commands, such as "discard", "redirect", and "fileinto",
+   allow for actions to be taken that are potentially very dangerous.
+
+   Use of the "redirect" command to generate notifications may easily
+   overwhelm the target address, especially if it was not designed to
+   handle large messages.
+
+   Allowing a single script to redirect to multiple destinations can be
+   used as a means of amplifying the number of messages in an attack.
+   Moreover, if loop detection is not properly implemented, it may be
+   possible to set up exponentially growing message loops.  Accordingly,
+   Sieve implementations:
+
+   (1) MUST implement facilities to detect and break message loops.  See
+       section 6.2 of [SMTP] for additional information on basic loop
+       detection strategies.
+
+   (2) MUST provide the means for administrators to limit the ability of
+       users to abuse redirect.  In particular, it MUST be possible to
+       limit the number of redirects a script can perform.
+       Additionally, if no use cases exist for using redirect to
+       multiple destinations, this limit SHOULD be set to 1.  Additional
+       limits, such as the ability to restrict redirect to local users,
+       MAY also be implemented.
+
+   (3) MUST provide facilities to log use of redirect in order to
+       facilitate tracking down abuse.
+
+   (4) MAY use script analysis to determine whether or not a given
+       script can be executed safely.  While the Sieve language is
+       sufficiently complex that full analysis of all possible scripts
+       is computationally infeasible, the majority of real-world scripts
+       are amenable to analysis.  For example, an implementation might
+
+
+
+
+
+Guenther & Showalter        Standards Track                    [Page 38]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+       allow scripts that it has determined are safe to run unhindered,
+       block scripts that are potentially problematic, and subject
+       unclassifiable scripts to additional auditing and logging.
+
+   Allowing redirects at all may not be appropriate in situations where
+   email accounts are freely available and/or not trackable to a human
+   who can be held accountable for creating message bombs or other
+   abuse.
+
+   As with any filter on a message stream, if the Sieve implementation
+   and the mail agents 'behind' Sieve in the message stream differ in
+   their interpretation of the messages, it may be possible for an
+   attacker to subvert the filter.  Of particular note are differences
+   in the interpretation of malformed messages (e.g., missing or extra
+   syntax characters) or those that exhibit corner cases (e.g., NUL
+   octets encoded via [MIME3]).
+
+11.  Acknowledgments
+
+   This document has been revised in part based on comments and
+   discussions that took place on and off the SIEVE mailing list.
+   Thanks to Sharon Chisholm, Cyrus Daboo, Ned Freed, Arnt Gulbrandsen,
+   Michael Haardt, Kjetil Torgrim Homme, Barry Leiba, Mark E. Mallett,
+   Alexey Melnikov, Eric Rescorla, Rob Siemborski, and Nigel Swinson for
+   reviews and suggestions.
+
+12.  Normative References
+
+   [ABNF]      Crocker, D., Ed., and P. Overell, "Augmented BNF for
+               Syntax Specifications: ABNF", RFC 4234, October 2005.
+
+   [COLLATION] Newman, C., Duerst, M., and A. Gulbrandsen, "Internet
+               Application Protocol Collation Registry", RFC 4790, March
+               2007.
+
+   [IMAIL]     Resnick, P., Ed., "Internet Message Format", RFC 2822,
+               April 2001.
+
+   [KEYWORDS]  Bradner, S., "Key words for use in RFCs to Indicate
+               Requirement Levels", BCP 14, RFC 2119, March 1997.
+
+   [MIME]      Freed, N. and N. Borenstein, "Multipurpose Internet Mail
+               Extensions (MIME) Part One: Format of Internet Message
+               Bodies", RFC 2045, November 1996.
+
+   [MIME3]     Moore, K., "MIME (Multipurpose Internet Mail Extensions)
+               Part Three: Message Header Extensions for Non-ASCII
+               Text", RFC 2047, November 1996.
+
+
+
+Guenther & Showalter        Standards Track                    [Page 39]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+   [SMTP]      Klensin, J., Ed., "Simple Mail Transfer Protocol", RFC
+               2821, April 2001.
+
+   [UTF-8]     Yergeau, F., "UTF-8, a transformation format of ISO
+               10646", STD 63, RFC 3629, November 2003.
+
+13.  Informative References
+
+   [BINARY-SI] "Standard IEC 60027-2: Letter symbols to be used in
+               electrical technology - Part 2: Telecommunications and
+               electronics", January 1999.
+
+   [DSN]       Moore, K. and G. Vaudreuil, "An Extensible Message Format
+               for Delivery Status Notifications", RFC 3464, January
+               2003.
+
+   [FLAMES]    Borenstein, N, and C. Thyberg, "Power, Ease of Use, and
+               Cooperative Work in a Practical Multimedia Message
+               System", Int. J.  of Man-Machine Studies, April, 1991.
+               Reprinted in Computer-Supported Cooperative Work and
+               Groupware, Saul Greenberg, editor, Harcourt Brace
+               Jovanovich, 1991.  Reprinted in Readings in Groupware and
+               Computer-Supported Cooperative Work, Ronald Baecker,
+               editor, Morgan Kaufmann, 1993.
+
+   [IMAP]      Crispin, M., "Internet Message Access Protocol - version
+               4rev1", RFC 3501, March 2003.
+
+   [MDN]       Hansen, T., Ed., and G. Vaudreuil, Ed., "Message
+               Disposition Notification", RFC 3798, May 2004.
+
+   [RFC3028]   Showalter, T., "Sieve: A Mail Filtering Language", RFC
+               3028, January 2001.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Guenther & Showalter        Standards Track                    [Page 40]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+14.  Changes from RFC 3028
+
+   This following list is a summary of the changes that have been made
+   in the Sieve language base specification from [RFC3028].
+
+    1. Removed ban on tests having side-effects
+    2. Removed reject extension (will be specified in a separate RFC)
+    3. Clarified description of comparators to match [COLLATION], the
+       new base specification for them
+    4. Require stripping of leading and trailing whitespace in "header"
+       test
+    5. Clarified or tightened handling of many minor items, including:
+       - invalid [MIME3] encoding
+       - invalid addresses in headers
+       - invalid header field names in tests
+       - 'undefined' comparator result
+       - unknown envelope parts
+       - null return-path in "envelope" test
+    6. Capability strings are case-sensitive
+    7. Clarified that fileinto should reencode non-ASCII mailbox
+       names to match the mailstore's conventions
+    8. Errors in the ABNF were corrected
+    9. The references were updated and split into normative and
+       informative
+   10. Added encoded-character capability and deprecated (but did not
+       remove) use of arbitrary binary octets in Sieve scripts.
+   11. Updated IANA registration template, and added IANA
+       considerations to permit capability prefix registrations.
+   12. Added .sieve as a valid extension for Sieve scripts.
+
+Editors' Addresses
+
+   Philip Guenther
+   Sendmail, Inc.
+   6425 Christie St. Ste 400
+   Emeryville, CA 94608
+   EMail: guenther@sendmail.com
+
+   Tim Showalter
+   EMail: tjs@psaux.com
+
+
+
+
+
+
+
+
+
+
+
+Guenther & Showalter        Standards Track                    [Page 41]
+
+RFC 5228           Sieve: An Email Filtering Language       January 2008
+
+
+Full Copyright Statement
+
+   Copyright (C) The IETF Trust (2008).
+
+   This document is subject to the rights, licenses and restrictions
+   contained in BCP 78, and except as set forth therein, the authors
+   retain all their rights.
+
+   This document and the information contained herein are provided on an
+   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
+   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
+   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
+   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
+
+Intellectual Property
+
+   The IETF takes no position regarding the validity or scope of any
+   Intellectual Property Rights or other rights that might be claimed to
+   pertain to the implementation or use of the technology described in
+   this document or the extent to which any license under such rights
+   might or might not be available; nor does it represent that it has
+   made any independent effort to identify any such rights.  Information
+   on the procedures with respect to rights in RFC documents can be
+   found in BCP 78 and BCP 79.
+
+   Copies of IPR disclosures made to the IETF Secretariat and any
+   assurances of licenses to be made available, or the result of an
+   attempt made to obtain a general license or permission for the use of
+   such proprietary rights by implementers or users of this
+   specification can be obtained from the IETF on-line IPR repository at
+   http://www.ietf.org/ipr.
+
+   The IETF invites any interested party to bring to its attention any
+   copyrights, patents or patent applications, or other proprietary
+   rights that may cover technology that may be required to implement
+   this standard.  Please address the information to the IETF at
+   ietf-ipr@ietf.org.
+
+
+
+
+
+
+
+
+
+
+
+
+Guenther & Showalter        Standards Track                    [Page 42]
+
diff -urN dovecot-1.2.4/dovecot-libsieve/doc/rfc/subaddress.rfc5233.txt dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/subaddress.rfc5233.txt
--- dovecot-1.2.4/dovecot-libsieve/doc/rfc/subaddress.rfc5233.txt	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/subaddress.rfc5233.txt	2008-08-25 10:25:08.000000000 +0200
@@ -0,0 +1,395 @@
+
+
+
+
+
+
+Network Working Group                                       K. Murchison
+Request for Comments: 5233                    Carnegie Mellon University
+Obsoletes: 3598                                             January 2008
+Category: Standards Track
+
+
+              Sieve Email Filtering: Subaddress Extension
+
+Status of This Memo
+
+   This document specifies an Internet standards track protocol for the
+   Internet community, and requests discussion and suggestions for
+   improvements.  Please refer to the current edition of the "Internet
+   Official Protocol Standards" (STD 1) for the standardization state
+   and status of this protocol.  Distribution of this memo is unlimited.
+
+Abstract
+
+   On email systems that allow for 'subaddressing' or 'detailed
+   addressing' (e.g., "ken+sieve@example.org"), it is sometimes
+   desirable to make comparisons against these sub-parts of addresses.
+   This document defines an extension to the Sieve Email Filtering
+   Language that allows users to compare against the user and detail
+   sub-parts of an address.
+
+Table of Contents
+
+   1. Introduction ....................................................2
+   2. Conventions Used in This Document ...............................2
+   3. Capability Identifier ...........................................2
+   4. Subaddress Comparisons ..........................................2
+   5. IANA Considerations .............................................5
+   6. Security Considerations .........................................5
+   7. Normative References ............................................5
+   Appendix A. Acknowledgments ........................................6
+   Appendix B. Changes since RFC 3598 .................................6
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Murchison                   Standards Track                     [Page 1]
+
+RFC 5233              Sieve: Subaddress Extension           January 2008
+
+
+1.  Introduction
+
+   Subaddressing is the practice of augmenting the local-part of an
+   [RFC2822] address with some 'detail' information in order to give
+   some extra meaning to that address.  One common way of encoding
+   'detail' information into the local-part is to add a 'separator
+   character sequence', such as "+", to form a boundary between the
+   'user' (original local-part) and 'detail' sub-parts of the address,
+   much like the "@" character forms the boundary between the local-part
+   and domain.
+
+   Typical uses of subaddressing might be:
+
+   o  A message addressed to "ken+sieve@example.org" is delivered into a
+      mailbox called "sieve" belonging to the user "ken".
+
+   o  A message addressed to "5551212#123@example.com" is delivered to
+      the voice mailbox number "123" at phone number "5551212".
+
+   This document describes an extension to the Sieve language defined by
+   [RFC5228] for comparing against the 'user' and 'detail' sub-parts of
+   an address.
+
+2.  Conventions Used in This Document
+
+   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
+   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
+   document are to be interpreted as described in [RFC2119].
+
+3.  Capability Identifier
+
+   The capability string associated with the extension defined in this
+   document is "subaddress".
+
+4.  Subaddress Comparisons
+
+   Test commands that act exclusively on addresses may take the optional
+   tagged arguments ":user" and ":detail" to specify what sub-part of
+   the local-part of the address will be acted upon.
+
+      NOTE: In most cases, the envelope "to" address is the preferred
+      address to examine for subaddress information when the desire is
+      to sort messages based on how they were addressed so as to get to
+      a specific recipient.  The envelope address is, after all, the
+      reason a given message is being processed by a given sieve script
+      for a given user.  This is particularly true when mailing lists,
+
+
+
+
+
+Murchison                   Standards Track                     [Page 2]
+
+RFC 5233              Sieve: Subaddress Extension           January 2008
+
+
+      aliases, and 'virtual domains' are involved since the envelope may
+      be the only source of detail information for the specific
+      recipient.
+
+      NOTE: Because the encoding of detailed addresses are site and/or
+      implementation specific, using the subaddress extension on foreign
+      addresses (such as the envelope "from" address or originator
+      header fields) may lead to inconsistent or incorrect results.
+
+   The ":user" argument specifies the user sub-part of the local-part of
+   an address.  If the address is not encoded to contain a detail sub-
+   part, then ":user" specifies the entire left side of the address
+   (equivalent to ":localpart").
+
+   The ":detail" argument specifies the detail sub-part of the local-
+   part of an address.  If the address is not encoded to contain a
+   detail sub-part, then the address fails to match any of the specified
+   keys.  If a zero-length string is encoded as the detail sub-part,
+   then ":detail" resolves to the empty value ("").
+
+      NOTE: If the encoding method used for detailed addresses utilizes
+      a separator character sequence, and the separator character
+      sequence occurs more than once in the local-part, then the logic
+      used to split the address is implementation-defined and is usually
+      dependent on the format used by the encompassing mail system.
+
+   Implementations MUST make sure that the encoding method used for
+   detailed addresses matches that which is used and/or allowed by the
+   encompassing mail system, otherwise unexpected results might occur.
+   Note that the mechanisms used to define and/or query the encoding
+   method used by the mail system are outside the scope of this
+   document.
+
+   The ":user" and ":detail" address parts are subject to the same rules
+   and restrictions as the standard address parts defined in [RFC5228],
+   Section 2.7.4.
+
+   For convenience, the "ADDRESS-PART" syntax element defined in
+   [RFC5228], Section 2.7.4, is augmented here as follows:
+
+         ADDRESS-PART  =/  ":user" / ":detail"
+
+   A diagram showing the ADDRESS-PARTs of an email address where the
+   detail information follows a separator character sequence of "+" is
+   shown below:
+
+
+
+
+
+
+Murchison                   Standards Track                     [Page 3]
+
+RFC 5233              Sieve: Subaddress Extension           January 2008
+
+
+          :user "+" :detail  "@" :domain
+         \-----------------/
+             :local-part
+
+   A diagram showing the ADDRESS-PARTs of a email address where the
+   detail information precedes a separator character sequence of "--" is
+   shown below:
+
+          :detail "--" :user  "@" :domain
+         \------------------/
+             :local-part
+
+   Example (where the detail information follows "+"):
+
+      require ["envelope", "subaddress", "fileinto"];
+
+      # In this example the same user account receives mail for both
+      # "ken@example.com" and "postmaster@example.com"
+
+      # File all messages to postmaster into a single mailbox,
+      # ignoring the :detail part.
+      if envelope :user "to" "postmaster" {
+          fileinto "inbox.postmaster";
+          stop;
+      }
+
+      # File mailing list messages (subscribed as "ken+mta-filters").
+      if envelope :detail "to" "mta-filters" {
+          fileinto "inbox.ietf-mta-filters";
+      }
+
+      # Redirect all mail sent to "ken+foo".
+      if envelope :detail "to" "foo" {
+          redirect "ken@example.net";
+      }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Murchison                   Standards Track                     [Page 4]
+
+RFC 5233              Sieve: Subaddress Extension           January 2008
+
+
+5.  IANA Considerations
+
+   The following template specifies the IANA registration of the
+   subaddress Sieve extension specified in this document.  This
+   registration replaces that from RFC 3598:
+
+   To: iana@iana.org
+   Subject: Registration of new Sieve extension
+
+   Capability name: subaddress
+   Description:     Adds the ':user' and ':detail' address parts
+                    for use with the address and envelope tests
+   RFC number:      RFC 5233
+   Contact address: The Sieve discussion list <ietf-mta-filters@imc.org>
+
+   This information has been added to the list of Sieve extensions given
+   on http://www.iana.org/assignments/sieve-extensions.
+
+6.  Security Considerations
+
+   Security considerations are discussed in [RFC5228].  It is believed
+   that this extension does not introduce any additional security
+   concerns.
+
+7.  Normative References
+
+   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
+              Requirement Levels", BCP 14, RFC 2119, March 1997.
+
+   [RFC2822]  Resnick, P., "Internet Message Format", RFC 2822, April
+              2001.
+
+   [RFC5228]  Guenther, P., Ed., and T. Showalter, Ed., "Sieve: An Email
+              Filtering Language", RFC 5228, January 2008.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Murchison                   Standards Track                     [Page 5]
+
+RFC 5233              Sieve: Subaddress Extension           January 2008
+
+
+Appendix A.  Acknowledgments
+
+   Thanks to Tim Showalter, Alexey Melnikov, Michael Salmon, Randall
+   Gellens, Philip Guenther, Jutta Degener, Michael Haardt, Ned Freed,
+   Mark Mallett, and Barry Leiba for their help with this document.
+
+Appendix B.  Changes since RFC 3598
+
+   o  Discussion of how the user and detail information is encoded now
+      uses generic language.
+
+   o  Added note detailing that this extension is most useful when used
+      on the envelope "to" address.
+
+   o  Added note detailing that this extension isn't very useful on
+      foreign addresses (envelope "from" or originator header fields).
+
+   o  Fixed envelope test example to only use "to" address.
+
+   o  Replaced ":user" example with one that doesn't produce unexpected
+      behavior.
+
+   o  Refer to the zero-length string ("") as "empty" instead of "null"
+      (per RFC 5228).
+
+   o  Use only RFC 2606 domains in examples.
+
+   o  Miscellaneous editorial changes.
+
+Author's Address
+
+   Kenneth Murchison
+   Carnegie Mellon University
+   5000 Forbes Avenue
+   Cyert Hall 285
+   Pittsburgh, PA  15213
+   USA
+
+   Phone: +1 412 268 2638
+   EMail: murch@andrew.cmu.edu
+
+
+
+
+
+
+
+
+
+
+
+Murchison                   Standards Track                     [Page 6]
+
+RFC 5233              Sieve: Subaddress Extension           January 2008
+
+
+Full Copyright Statement
+
+   Copyright (C) The IETF Trust (2008).
+
+   This document is subject to the rights, licenses and restrictions
+   contained in BCP 78, and except as set forth therein, the authors
+   retain all their rights.
+
+   This document and the information contained herein are provided on an
+   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
+   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
+   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
+   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
+
+Intellectual Property
+
+   The IETF takes no position regarding the validity or scope of any
+   Intellectual Property Rights or other rights that might be claimed to
+   pertain to the implementation or use of the technology described in
+   this document or the extent to which any license under such rights
+   might or might not be available; nor does it represent that it has
+   made any independent effort to identify any such rights.  Information
+   on the procedures with respect to rights in RFC documents can be
+   found in BCP 78 and BCP 79.
+
+   Copies of IPR disclosures made to the IETF Secretariat and any
+   assurances of licenses to be made available, or the result of an
+   attempt made to obtain a general license or permission for the use of
+   such proprietary rights by implementers or users of this
+   specification can be obtained from the IETF on-line IPR repository at
+   http://www.ietf.org/ipr.
+
+   The IETF invites any interested party to bring to its attention any
+   copyrights, patents or patent applications, or other proprietary
+   rights that may cover technology that may be required to implement
+   this standard.  Please address the information to the IETF at
+   ietf-ipr@ietf.org.
+
+
+
+
+
+
+
+
+
+
+
+
+Murchison                   Standards Track                     [Page 7]
+
diff -urN dovecot-1.2.4/dovecot-libsieve/doc/rfc/uri.rfc3986.txt dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/uri.rfc3986.txt
--- dovecot-1.2.4/dovecot-libsieve/doc/rfc/uri.rfc3986.txt	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/uri.rfc3986.txt	2008-11-28 22:33:49.000000000 +0100
@@ -0,0 +1,3419 @@
+
+
+
+
+
+
+Network Working Group                                     T. Berners-Lee
+Request for Comments: 3986                                       W3C/MIT
+STD: 66                                                      R. Fielding
+Updates: 1738                                               Day Software
+Obsoletes: 2732, 2396, 1808                                  L. Masinter
+Category: Standards Track                                  Adobe Systems
+                                                            January 2005
+
+
+           Uniform Resource Identifier (URI): Generic Syntax
+
+Status of This Memo
+
+   This document specifies an Internet standards track protocol for the
+   Internet community, and requests discussion and suggestions for
+   improvements.  Please refer to the current edition of the "Internet
+   Official Protocol Standards" (STD 1) for the standardization state
+   and status of this protocol.  Distribution of this memo is unlimited.
+
+Copyright Notice
+
+   Copyright (C) The Internet Society (2005).
+
+Abstract
+
+   A Uniform Resource Identifier (URI) is a compact sequence of
+   characters that identifies an abstract or physical resource.  This
+   specification defines the generic URI syntax and a process for
+   resolving URI references that might be in relative form, along with
+   guidelines and security considerations for the use of URIs on the
+   Internet.  The URI syntax defines a grammar that is a superset of all
+   valid URIs, allowing an implementation to parse the common components
+   of a URI reference without knowing the scheme-specific requirements
+   of every possible identifier.  This specification does not define a
+   generative grammar for URIs; that task is performed by the individual
+   specifications of each URI scheme.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                     [Page 1]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+Table of Contents
+
+   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4
+       1.1.  Overview of URIs . . . . . . . . . . . . . . . . . . . .  4
+             1.1.1.  Generic Syntax . . . . . . . . . . . . . . . . .  6
+             1.1.2.  Examples . . . . . . . . . . . . . . . . . . . .  7
+             1.1.3.  URI, URL, and URN  . . . . . . . . . . . . . . .  7
+       1.2.  Design Considerations  . . . . . . . . . . . . . . . . .  8
+             1.2.1.  Transcription  . . . . . . . . . . . . . . . . .  8
+             1.2.2.  Separating Identification from Interaction . . .  9
+             1.2.3.  Hierarchical Identifiers . . . . . . . . . . . . 10
+       1.3.  Syntax Notation  . . . . . . . . . . . . . . . . . . . . 11
+   2.  Characters . . . . . . . . . . . . . . . . . . . . . . . . . . 11
+       2.1.  Percent-Encoding . . . . . . . . . . . . . . . . . . . . 12
+       2.2.  Reserved Characters  . . . . . . . . . . . . . . . . . . 12
+       2.3.  Unreserved Characters  . . . . . . . . . . . . . . . . . 13
+       2.4.  When to Encode or Decode . . . . . . . . . . . . . . . . 14
+       2.5.  Identifying Data . . . . . . . . . . . . . . . . . . . . 14
+   3.  Syntax Components  . . . . . . . . . . . . . . . . . . . . . . 16
+       3.1.  Scheme . . . . . . . . . . . . . . . . . . . . . . . . . 17
+       3.2.  Authority  . . . . . . . . . . . . . . . . . . . . . . . 17
+             3.2.1.  User Information . . . . . . . . . . . . . . . . 18
+             3.2.2.  Host . . . . . . . . . . . . . . . . . . . . . . 18
+             3.2.3.  Port . . . . . . . . . . . . . . . . . . . . . . 22
+       3.3.  Path . . . . . . . . . . . . . . . . . . . . . . . . . . 22
+       3.4.  Query  . . . . . . . . . . . . . . . . . . . . . . . . . 23
+       3.5.  Fragment . . . . . . . . . . . . . . . . . . . . . . . . 24
+   4.  Usage  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
+       4.1.  URI Reference  . . . . . . . . . . . . . . . . . . . . . 25
+       4.2.  Relative Reference . . . . . . . . . . . . . . . . . . . 26
+       4.3.  Absolute URI . . . . . . . . . . . . . . . . . . . . . . 27
+       4.4.  Same-Document Reference  . . . . . . . . . . . . . . . . 27
+       4.5.  Suffix Reference . . . . . . . . . . . . . . . . . . . . 27
+   5.  Reference Resolution . . . . . . . . . . . . . . . . . . . . . 28
+       5.1.  Establishing a Base URI  . . . . . . . . . . . . . . . . 28
+             5.1.1.  Base URI Embedded in Content . . . . . . . . . . 29
+             5.1.2.  Base URI from the Encapsulating Entity . . . . . 29
+             5.1.3.  Base URI from the Retrieval URI  . . . . . . . . 30
+             5.1.4.  Default Base URI . . . . . . . . . . . . . . . . 30
+       5.2.  Relative Resolution  . . . . . . . . . . . . . . . . . . 30
+             5.2.1.  Pre-parse the Base URI . . . . . . . . . . . . . 31
+             5.2.2.  Transform References . . . . . . . . . . . . . . 31
+             5.2.3.  Merge Paths  . . . . . . . . . . . . . . . . . . 32
+             5.2.4.  Remove Dot Segments  . . . . . . . . . . . . . . 33
+       5.3.  Component Recomposition  . . . . . . . . . . . . . . . . 35
+       5.4.  Reference Resolution Examples  . . . . . . . . . . . . . 35
+             5.4.1.  Normal Examples  . . . . . . . . . . . . . . . . 36
+             5.4.2.  Abnormal Examples  . . . . . . . . . . . . . . . 36
+
+
+
+Berners-Lee, et al.         Standards Track                     [Page 2]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   6.  Normalization and Comparison . . . . . . . . . . . . . . . . . 38
+       6.1.  Equivalence  . . . . . . . . . . . . . . . . . . . . . . 38
+       6.2.  Comparison Ladder  . . . . . . . . . . . . . . . . . . . 39
+             6.2.1.  Simple String Comparison . . . . . . . . . . . . 39
+             6.2.2.  Syntax-Based Normalization . . . . . . . . . . . 40
+             6.2.3.  Scheme-Based Normalization . . . . . . . . . . . 41
+             6.2.4.  Protocol-Based Normalization . . . . . . . . . . 42
+   7.  Security Considerations  . . . . . . . . . . . . . . . . . . . 43
+       7.1.  Reliability and Consistency  . . . . . . . . . . . . . . 43
+       7.2.  Malicious Construction . . . . . . . . . . . . . . . . . 43
+       7.3.  Back-End Transcoding . . . . . . . . . . . . . . . . . . 44
+       7.4.  Rare IP Address Formats  . . . . . . . . . . . . . . . . 45
+       7.5.  Sensitive Information  . . . . . . . . . . . . . . . . . 45
+       7.6.  Semantic Attacks . . . . . . . . . . . . . . . . . . . . 45
+   8.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 46
+   9.  Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 46
+   10. References . . . . . . . . . . . . . . . . . . . . . . . . . . 46
+       10.1. Normative References . . . . . . . . . . . . . . . . . . 46
+       10.2. Informative References . . . . . . . . . . . . . . . . . 47
+   A.  Collected ABNF for URI . . . . . . . . . . . . . . . . . . . . 49
+   B.  Parsing a URI Reference with a Regular Expression  . . . . . . 50
+   C.  Delimiting a URI in Context  . . . . . . . . . . . . . . . . . 51
+   D.  Changes from RFC 2396  . . . . . . . . . . . . . . . . . . . . 53
+       D.1.  Additions  . . . . . . . . . . . . . . . . . . . . . . . 53
+       D.2.  Modifications  . . . . . . . . . . . . . . . . . . . . . 53
+   Index  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
+   Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . . . 60
+   Full Copyright Statement . . . . . . . . . . . . . . . . . . . . . 61
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                     [Page 3]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+1.  Introduction
+
+   A Uniform Resource Identifier (URI) provides a simple and extensible
+   means for identifying a resource.  This specification of URI syntax
+   and semantics is derived from concepts introduced by the World Wide
+   Web global information initiative, whose use of these identifiers
+   dates from 1990 and is described in "Universal Resource Identifiers
+   in WWW" [RFC1630].  The syntax is designed to meet the
+   recommendations laid out in "Functional Recommendations for Internet
+   Resource Locators" [RFC1736] and "Functional Requirements for Uniform
+   Resource Names" [RFC1737].
+
+   This document obsoletes [RFC2396], which merged "Uniform Resource
+   Locators" [RFC1738] and "Relative Uniform Resource Locators"
+   [RFC1808] in order to define a single, generic syntax for all URIs.
+   It obsoletes [RFC2732], which introduced syntax for an IPv6 address.
+   It excludes portions of RFC 1738 that defined the specific syntax of
+   individual URI schemes; those portions will be updated as separate
+   documents.  The process for registration of new URI schemes is
+   defined separately by [BCP35].  Advice for designers of new URI
+   schemes can be found in [RFC2718].  All significant changes from RFC
+   2396 are noted in Appendix D.
+
+   This specification uses the terms "character" and "coded character
+   set" in accordance with the definitions provided in [BCP19], and
+   "character encoding" in place of what [BCP19] refers to as a
+   "charset".
+
+1.1.  Overview of URIs
+
+   URIs are characterized as follows:
+
+   Uniform
+
+      Uniformity provides several benefits.  It allows different types
+      of resource identifiers to be used in the same context, even when
+      the mechanisms used to access those resources may differ.  It
+      allows uniform semantic interpretation of common syntactic
+      conventions across different types of resource identifiers.  It
+      allows introduction of new types of resource identifiers without
+      interfering with the way that existing identifiers are used.  It
+      allows the identifiers to be reused in many different contexts,
+      thus permitting new applications or protocols to leverage a pre-
+      existing, large, and widely used set of resource identifiers.
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                     [Page 4]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   Resource
+
+      This specification does not limit the scope of what might be a
+      resource; rather, the term "resource" is used in a general sense
+      for whatever might be identified by a URI.  Familiar examples
+      include an electronic document, an image, a source of information
+      with a consistent purpose (e.g., "today's weather report for Los
+      Angeles"), a service (e.g., an HTTP-to-SMS gateway), and a
+      collection of other resources.  A resource is not necessarily
+      accessible via the Internet; e.g., human beings, corporations, and
+      bound books in a library can also be resources.  Likewise,
+      abstract concepts can be resources, such as the operators and
+      operands of a mathematical equation, the types of a relationship
+      (e.g., "parent" or "employee"), or numeric values (e.g., zero,
+      one, and infinity).
+
+   Identifier
+
+      An identifier embodies the information required to distinguish
+      what is being identified from all other things within its scope of
+      identification.  Our use of the terms "identify" and "identifying"
+      refer to this purpose of distinguishing one resource from all
+      other resources, regardless of how that purpose is accomplished
+      (e.g., by name, address, or context).  These terms should not be
+      mistaken as an assumption that an identifier defines or embodies
+      the identity of what is referenced, though that may be the case
+      for some identifiers.  Nor should it be assumed that a system
+      using URIs will access the resource identified: in many cases,
+      URIs are used to denote resources without any intention that they
+      be accessed.  Likewise, the "one" resource identified might not be
+      singular in nature (e.g., a resource might be a named set or a
+      mapping that varies over time).
+
+   A URI is an identifier consisting of a sequence of characters
+   matching the syntax rule named <URI> in Section 3.  It enables
+   uniform identification of resources via a separately defined
+   extensible set of naming schemes (Section 3.1).  How that
+   identification is accomplished, assigned, or enabled is delegated to
+   each scheme specification.
+
+   This specification does not place any limits on the nature of a
+   resource, the reasons why an application might seek to refer to a
+   resource, or the kinds of systems that might use URIs for the sake of
+   identifying resources.  This specification does not require that a
+   URI persists in identifying the same resource over time, though that
+   is a common goal of all URI schemes.  Nevertheless, nothing in this
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                     [Page 5]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   specification prevents an application from limiting itself to
+   particular types of resources, or to a subset of URIs that maintains
+   characteristics desired by that application.
+
+   URIs have a global scope and are interpreted consistently regardless
+   of context, though the result of that interpretation may be in
+   relation to the end-user's context.  For example, "http://localhost/"
+   has the same interpretation for every user of that reference, even
+   though the network interface corresponding to "localhost" may be
+   different for each end-user: interpretation is independent of access.
+   However, an action made on the basis of that reference will take
+   place in relation to the end-user's context, which implies that an
+   action intended to refer to a globally unique thing must use a URI
+   that distinguishes that resource from all other things.  URIs that
+   identify in relation to the end-user's local context should only be
+   used when the context itself is a defining aspect of the resource,
+   such as when an on-line help manual refers to a file on the end-
+   user's file system (e.g., "file:///etc/hosts").
+
+1.1.1.  Generic Syntax
+
+   Each URI begins with a scheme name, as defined in Section 3.1, that
+   refers to a specification for assigning identifiers within that
+   scheme.  As such, the URI syntax is a federated and extensible naming
+   system wherein each scheme's specification may further restrict the
+   syntax and semantics of identifiers using that scheme.
+
+   This specification defines those elements of the URI syntax that are
+   required of all URI schemes or are common to many URI schemes.  It
+   thus defines the syntax and semantics needed to implement a scheme-
+   independent parsing mechanism for URI references, by which the
+   scheme-dependent handling of a URI can be postponed until the
+   scheme-dependent semantics are needed.  Likewise, protocols and data
+   formats that make use of URI references can refer to this
+   specification as a definition for the range of syntax allowed for all
+   URIs, including those schemes that have yet to be defined.  This
+   decouples the evolution of identification schemes from the evolution
+   of protocols, data formats, and implementations that make use of
+   URIs.
+
+   A parser of the generic URI syntax can parse any URI reference into
+   its major components.  Once the scheme is determined, further
+   scheme-specific parsing can be performed on the components.  In other
+   words, the URI generic syntax is a superset of the syntax of all URI
+   schemes.
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                     [Page 6]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+1.1.2.  Examples
+
+   The following example URIs illustrate several URI schemes and
+   variations in their common syntax components:
+
+      ftp://ftp.is.co.za/rfc/rfc1808.txt
+
+      http://www.ietf.org/rfc/rfc2396.txt
+
+      ldap://[2001:db8::7]/c=GB?objectClass?one
+
+      mailto:John.Doe@example.com
+
+      news:comp.infosystems.www.servers.unix
+
+      tel:+1-816-555-1212
+
+      telnet://192.0.2.16:80/
+
+      urn:oasis:names:specification:docbook:dtd:xml:4.1.2
+
+
+1.1.3.  URI, URL, and URN
+
+   A URI can be further classified as a locator, a name, or both.  The
+   term "Uniform Resource Locator" (URL) refers to the subset of URIs
+   that, in addition to identifying a resource, provide a means of
+   locating the resource by describing its primary access mechanism
+   (e.g., its network "location").  The term "Uniform Resource Name"
+   (URN) has been used historically to refer to both URIs under the
+   "urn" scheme [RFC2141], which are required to remain globally unique
+   and persistent even when the resource ceases to exist or becomes
+   unavailable, and to any other URI with the properties of a name.
+
+   An individual scheme does not have to be classified as being just one
+   of "name" or "locator".  Instances of URIs from any given scheme may
+   have the characteristics of names or locators or both, often
+   depending on the persistence and care in the assignment of
+   identifiers by the naming authority, rather than on any quality of
+   the scheme.  Future specifications and related documentation should
+   use the general term "URI" rather than the more restrictive terms
+   "URL" and "URN" [RFC3305].
+
+
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                     [Page 7]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+1.2.  Design Considerations
+
+1.2.1.  Transcription
+
+   The URI syntax has been designed with global transcription as one of
+   its main considerations.  A URI is a sequence of characters from a
+   very limited set: the letters of the basic Latin alphabet, digits,
+   and a few special characters.  A URI may be represented in a variety
+   of ways; e.g., ink on paper, pixels on a screen, or a sequence of
+   character encoding octets.  The interpretation of a URI depends only
+   on the characters used and not on how those characters are
+   represented in a network protocol.
+
+   The goal of transcription can be described by a simple scenario.
+   Imagine two colleagues, Sam and Kim, sitting in a pub at an
+   international conference and exchanging research ideas.  Sam asks Kim
+   for a location to get more information, so Kim writes the URI for the
+   research site on a napkin.  Upon returning home, Sam takes out the
+   napkin and types the URI into a computer, which then retrieves the
+   information to which Kim referred.
+
+   There are several design considerations revealed by the scenario:
+
+   o  A URI is a sequence of characters that is not always represented
+      as a sequence of octets.
+
+   o  A URI might be transcribed from a non-network source and thus
+      should consist of characters that are most likely able to be
+      entered into a computer, within the constraints imposed by
+      keyboards (and related input devices) across languages and
+      locales.
+
+   o  A URI often has to be remembered by people, and it is easier for
+      people to remember a URI when it consists of meaningful or
+      familiar components.
+
+   These design considerations are not always in alignment.  For
+   example, it is often the case that the most meaningful name for a URI
+   component would require characters that cannot be typed into some
+   systems.  The ability to transcribe a resource identifier from one
+   medium to another has been considered more important than having a
+   URI consist of the most meaningful of components.
+
+   In local or regional contexts and with improving technology, users
+   might benefit from being able to use a wider range of characters;
+   such use is not defined by this specification.  Percent-encoded
+   octets (Section 2.1) may be used within a URI to represent characters
+   outside the range of the US-ASCII coded character set if this
+
+
+
+Berners-Lee, et al.         Standards Track                     [Page 8]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   representation is allowed by the scheme or by the protocol element in
+   which the URI is referenced.  Such a definition should specify the
+   character encoding used to map those characters to octets prior to
+   being percent-encoded for the URI.
+
+1.2.2.  Separating Identification from Interaction
+
+   A common misunderstanding of URIs is that they are only used to refer
+   to accessible resources.  The URI itself only provides
+   identification; access to the resource is neither guaranteed nor
+   implied by the presence of a URI.  Instead, any operation associated
+   with a URI reference is defined by the protocol element, data format
+   attribute, or natural language text in which it appears.
+
+   Given a URI, a system may attempt to perform a variety of operations
+   on the resource, as might be characterized by words such as "access",
+   "update", "replace", or "find attributes".  Such operations are
+   defined by the protocols that make use of URIs, not by this
+   specification.  However, we do use a few general terms for describing
+   common operations on URIs.  URI "resolution" is the process of
+   determining an access mechanism and the appropriate parameters
+   necessary to dereference a URI; this resolution may require several
+   iterations.  To use that access mechanism to perform an action on the
+   URI's resource is to "dereference" the URI.
+
+   When URIs are used within information retrieval systems to identify
+   sources of information, the most common form of URI dereference is
+   "retrieval": making use of a URI in order to retrieve a
+   representation of its associated resource.  A "representation" is a
+   sequence of octets, along with representation metadata describing
+   those octets, that constitutes a record of the state of the resource
+   at the time when the representation is generated.  Retrieval is
+   achieved by a process that might include using the URI as a cache key
+   to check for a locally cached representation, resolution of the URI
+   to determine an appropriate access mechanism (if any), and
+   dereference of the URI for the sake of applying a retrieval
+   operation.  Depending on the protocols used to perform the retrieval,
+   additional information might be supplied about the resource (resource
+   metadata) and its relation to other resources.
+
+   URI references in information retrieval systems are designed to be
+   late-binding: the result of an access is generally determined when it
+   is accessed and may vary over time or due to other aspects of the
+   interaction.  These references are created in order to be used in the
+   future: what is being identified is not some specific result that was
+   obtained in the past, but rather some characteristic that is expected
+   to be true for future results.  In such cases, the resource referred
+   to by the URI is actually a sameness of characteristics as observed
+
+
+
+Berners-Lee, et al.         Standards Track                     [Page 9]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   over time, perhaps elucidated by additional comments or assertions
+   made by the resource provider.
+
+   Although many URI schemes are named after protocols, this does not
+   imply that use of these URIs will result in access to the resource
+   via the named protocol.  URIs are often used simply for the sake of
+   identification.  Even when a URI is used to retrieve a representation
+   of a resource, that access might be through gateways, proxies,
+   caches, and name resolution services that are independent of the
+   protocol associated with the scheme name.  The resolution of some
+   URIs may require the use of more than one protocol (e.g., both DNS
+   and HTTP are typically used to access an "http" URI's origin server
+   when a representation isn't found in a local cache).
+
+1.2.3.  Hierarchical Identifiers
+
+   The URI syntax is organized hierarchically, with components listed in
+   order of decreasing significance from left to right.  For some URI
+   schemes, the visible hierarchy is limited to the scheme itself:
+   everything after the scheme component delimiter (":") is considered
+   opaque to URI processing.  Other URI schemes make the hierarchy
+   explicit and visible to generic parsing algorithms.
+
+   The generic syntax uses the slash ("/"), question mark ("?"), and
+   number sign ("#") characters to delimit components that are
+   significant to the generic parser's hierarchical interpretation of an
+   identifier.  In addition to aiding the readability of such
+   identifiers through the consistent use of familiar syntax, this
+   uniform representation of hierarchy across naming schemes allows
+   scheme-independent references to be made relative to that hierarchy.
+
+   It is often the case that a group or "tree" of documents has been
+   constructed to serve a common purpose, wherein the vast majority of
+   URI references in these documents point to resources within the tree
+   rather than outside it.  Similarly, documents located at a particular
+   site are much more likely to refer to other resources at that site
+   than to resources at remote sites.  Relative referencing of URIs
+   allows document trees to be partially independent of their location
+   and access scheme.  For instance, it is possible for a single set of
+   hypertext documents to be simultaneously accessible and traversable
+   via each of the "file", "http", and "ftp" schemes if the documents
+   refer to each other with relative references.  Furthermore, such
+   document trees can be moved, as a whole, without changing any of the
+   relative references.
+
+   A relative reference (Section 4.2) refers to a resource by describing
+   the difference within a hierarchical name space between the reference
+   context and the target URI.  The reference resolution algorithm,
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 10]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   presented in Section 5, defines how such a reference is transformed
+   to the target URI.  As relative references can only be used within
+   the context of a hierarchical URI, designers of new URI schemes
+   should use a syntax consistent with the generic syntax's hierarchical
+   components unless there are compelling reasons to forbid relative
+   referencing within that scheme.
+
+      NOTE: Previous specifications used the terms "partial URI" and
+      "relative URI" to denote a relative reference to a URI.  As some
+      readers misunderstood those terms to mean that relative URIs are a
+      subset of URIs rather than a method of referencing URIs, this
+      specification simply refers to them as relative references.
+
+   All URI references are parsed by generic syntax parsers when used.
+   However, because hierarchical processing has no effect on an absolute
+   URI used in a reference unless it contains one or more dot-segments
+   (complete path segments of "." or "..", as described in Section 3.3),
+   URI scheme specifications can define opaque identifiers by
+   disallowing use of slash characters, question mark characters, and
+   the URIs "scheme:." and "scheme:..".
+
+1.3.  Syntax Notation
+
+   This specification uses the Augmented Backus-Naur Form (ABNF)
+   notation of [RFC2234], including the following core ABNF syntax rules
+   defined by that specification: ALPHA (letters), CR (carriage return),
+   DIGIT (decimal digits), DQUOTE (double quote), HEXDIG (hexadecimal
+   digits), LF (line feed), and SP (space).  The complete URI syntax is
+   collected in Appendix A.
+
+2.  Characters
+
+   The URI syntax provides a method of encoding data, presumably for the
+   sake of identifying a resource, as a sequence of characters.  The URI
+   characters are, in turn, frequently encoded as octets for transport
+   or presentation.  This specification does not mandate any particular
+   character encoding for mapping between URI characters and the octets
+   used to store or transmit those characters.  When a URI appears in a
+   protocol element, the character encoding is defined by that protocol;
+   without such a definition, a URI is assumed to be in the same
+   character encoding as the surrounding text.
+
+   The ABNF notation defines its terminal values to be non-negative
+   integers (codepoints) based on the US-ASCII coded character set
+   [ASCII].  Because a URI is a sequence of characters, we must invert
+   that relation in order to understand the URI syntax.  Therefore, the
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 11]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   integer values used by the ABNF must be mapped back to their
+   corresponding characters via US-ASCII in order to complete the syntax
+   rules.
+
+   A URI is composed from a limited set of characters consisting of
+   digits, letters, and a few graphic symbols.  A reserved subset of
+   those characters may be used to delimit syntax components within a
+   URI while the remaining characters, including both the unreserved set
+   and those reserved characters not acting as delimiters, define each
+   component's identifying data.
+
+2.1.  Percent-Encoding
+
+   A percent-encoding mechanism is used to represent a data octet in a
+   component when that octet's corresponding character is outside the
+   allowed set or is being used as a delimiter of, or within, the
+   component.  A percent-encoded octet is encoded as a character
+   triplet, consisting of the percent character "%" followed by the two
+   hexadecimal digits representing that octet's numeric value.  For
+   example, "%20" is the percent-encoding for the binary octet
+   "00100000" (ABNF: %x20), which in US-ASCII corresponds to the space
+   character (SP).  Section 2.4 describes when percent-encoding and
+   decoding is applied.
+
+      pct-encoded = "%" HEXDIG HEXDIG
+
+   The uppercase hexadecimal digits 'A' through 'F' are equivalent to
+   the lowercase digits 'a' through 'f', respectively.  If two URIs
+   differ only in the case of hexadecimal digits used in percent-encoded
+   octets, they are equivalent.  For consistency, URI producers and
+   normalizers should use uppercase hexadecimal digits for all percent-
+   encodings.
+
+2.2.  Reserved Characters
+
+   URIs include components and subcomponents that are delimited by
+   characters in the "reserved" set.  These characters are called
+   "reserved" because they may (or may not) be defined as delimiters by
+   the generic syntax, by each scheme-specific syntax, or by the
+   implementation-specific syntax of a URI's dereferencing algorithm.
+   If data for a URI component would conflict with a reserved
+   character's purpose as a delimiter, then the conflicting data must be
+   percent-encoded before the URI is formed.
+
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 12]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+      reserved    = gen-delims / sub-delims
+
+      gen-delims  = ":" / "/" / "?" / "#" / "[" / "]" / "@"
+
+      sub-delims  = "!" / "$" / "&" / "'" / "(" / ")"
+                  / "*" / "+" / "," / ";" / "="
+
+   The purpose of reserved characters is to provide a set of delimiting
+   characters that are distinguishable from other data within a URI.
+   URIs that differ in the replacement of a reserved character with its
+   corresponding percent-encoded octet are not equivalent.  Percent-
+   encoding a reserved character, or decoding a percent-encoded octet
+   that corresponds to a reserved character, will change how the URI is
+   interpreted by most applications.  Thus, characters in the reserved
+   set are protected from normalization and are therefore safe to be
+   used by scheme-specific and producer-specific algorithms for
+   delimiting data subcomponents within a URI.
+
+   A subset of the reserved characters (gen-delims) is used as
+   delimiters of the generic URI components described in Section 3.  A
+   component's ABNF syntax rule will not use the reserved or gen-delims
+   rule names directly; instead, each syntax rule lists the characters
+   allowed within that component (i.e., not delimiting it), and any of
+   those characters that are also in the reserved set are "reserved" for
+   use as subcomponent delimiters within the component.  Only the most
+   common subcomponents are defined by this specification; other
+   subcomponents may be defined by a URI scheme's specification, or by
+   the implementation-specific syntax of a URI's dereferencing
+   algorithm, provided that such subcomponents are delimited by
+   characters in the reserved set allowed within that component.
+
+   URI producing applications should percent-encode data octets that
+   correspond to characters in the reserved set unless these characters
+   are specifically allowed by the URI scheme to represent data in that
+   component.  If a reserved character is found in a URI component and
+   no delimiting role is known for that character, then it must be
+   interpreted as representing the data octet corresponding to that
+   character's encoding in US-ASCII.
+
+2.3.  Unreserved Characters
+
+   Characters that are allowed in a URI but do not have a reserved
+   purpose are called unreserved.  These include uppercase and lowercase
+   letters, decimal digits, hyphen, period, underscore, and tilde.
+
+      unreserved  = ALPHA / DIGIT / "-" / "." / "_" / "~"
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 13]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   URIs that differ in the replacement of an unreserved character with
+   its corresponding percent-encoded US-ASCII octet are equivalent: they
+   identify the same resource.  However, URI comparison implementations
+   do not always perform normalization prior to comparison (see Section
+   6).  For consistency, percent-encoded octets in the ranges of ALPHA
+   (%41-%5A and %61-%7A), DIGIT (%30-%39), hyphen (%2D), period (%2E),
+   underscore (%5F), or tilde (%7E) should not be created by URI
+   producers and, when found in a URI, should be decoded to their
+   corresponding unreserved characters by URI normalizers.
+
+2.4.  When to Encode or Decode
+
+   Under normal circumstances, the only time when octets within a URI
+   are percent-encoded is during the process of producing the URI from
+   its component parts.  This is when an implementation determines which
+   of the reserved characters are to be used as subcomponent delimiters
+   and which can be safely used as data.  Once produced, a URI is always
+   in its percent-encoded form.
+
+   When a URI is dereferenced, the components and subcomponents
+   significant to the scheme-specific dereferencing process (if any)
+   must be parsed and separated before the percent-encoded octets within
+   those components can be safely decoded, as otherwise the data may be
+   mistaken for component delimiters.  The only exception is for
+   percent-encoded octets corresponding to characters in the unreserved
+   set, which can be decoded at any time.  For example, the octet
+   corresponding to the tilde ("~") character is often encoded as "%7E"
+   by older URI processing implementations; the "%7E" can be replaced by
+   "~" without changing its interpretation.
+
+   Because the percent ("%") character serves as the indicator for
+   percent-encoded octets, it must be percent-encoded as "%25" for that
+   octet to be used as data within a URI.  Implementations must not
+   percent-encode or decode the same string more than once, as decoding
+   an already decoded string might lead to misinterpreting a percent
+   data octet as the beginning of a percent-encoding, or vice versa in
+   the case of percent-encoding an already percent-encoded string.
+
+2.5.  Identifying Data
+
+   URI characters provide identifying data for each of the URI
+   components, serving as an external interface for identification
+   between systems.  Although the presence and nature of the URI
+   production interface is hidden from clients that use its URIs (and is
+   thus beyond the scope of the interoperability requirements defined by
+   this specification), it is a frequent source of confusion and errors
+   in the interpretation of URI character issues.  Implementers have to
+   be aware that there are multiple character encodings involved in the
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 14]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   production and transmission of URIs: local name and data encoding,
+   public interface encoding, URI character encoding, data format
+   encoding, and protocol encoding.
+
+   Local names, such as file system names, are stored with a local
+   character encoding.  URI producing applications (e.g., origin
+   servers) will typically use the local encoding as the basis for
+   producing meaningful names.  The URI producer will transform the
+   local encoding to one that is suitable for a public interface and
+   then transform the public interface encoding into the restricted set
+   of URI characters (reserved, unreserved, and percent-encodings).
+   Those characters are, in turn, encoded as octets to be used as a
+   reference within a data format (e.g., a document charset), and such
+   data formats are often subsequently encoded for transmission over
+   Internet protocols.
+
+   For most systems, an unreserved character appearing within a URI
+   component is interpreted as representing the data octet corresponding
+   to that character's encoding in US-ASCII.  Consumers of URIs assume
+   that the letter "X" corresponds to the octet "01011000", and even
+   when that assumption is incorrect, there is no harm in making it.  A
+   system that internally provides identifiers in the form of a
+   different character encoding, such as EBCDIC, will generally perform
+   character translation of textual identifiers to UTF-8 [STD63] (or
+   some other superset of the US-ASCII character encoding) at an
+   internal interface, thereby providing more meaningful identifiers
+   than those resulting from simply percent-encoding the original
+   octets.
+
+   For example, consider an information service that provides data,
+   stored locally using an EBCDIC-based file system, to clients on the
+   Internet through an HTTP server.  When an author creates a file with
+   the name "Laguna Beach" on that file system, the "http" URI
+   corresponding to that resource is expected to contain the meaningful
+   string "Laguna%20Beach".  If, however, that server produces URIs by
+   using an overly simplistic raw octet mapping, then the result would
+   be a URI containing "%D3%81%87%A4%95%81@%C2%85%81%83%88".  An
+   internal transcoding interface fixes this problem by transcoding the
+   local name to a superset of US-ASCII prior to producing the URI.
+   Naturally, proper interpretation of an incoming URI on such an
+   interface requires that percent-encoded octets be decoded (e.g.,
+   "%20" to SP) before the reverse transcoding is applied to obtain the
+   local name.
+
+   In some cases, the internal interface between a URI component and the
+   identifying data that it has been crafted to represent is much less
+   direct than a character encoding translation.  For example, portions
+   of a URI might reflect a query on non-ASCII data, or numeric
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 15]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   coordinates on a map.  Likewise, a URI scheme may define components
+   with additional encoding requirements that are applied prior to
+   forming the component and producing the URI.
+
+   When a new URI scheme defines a component that represents textual
+   data consisting of characters from the Universal Character Set [UCS],
+   the data should first be encoded as octets according to the UTF-8
+   character encoding [STD63]; then only those octets that do not
+   correspond to characters in the unreserved set should be percent-
+   encoded.  For example, the character A would be represented as "A",
+   the character LATIN CAPITAL LETTER A WITH GRAVE would be represented
+   as "%C3%80", and the character KATAKANA LETTER A would be represented
+   as "%E3%82%A2".
+
+3.  Syntax Components
+
+   The generic URI syntax consists of a hierarchical sequence of
+   components referred to as the scheme, authority, path, query, and
+   fragment.
+
+      URI         = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
+
+      hier-part   = "//" authority path-abempty
+                  / path-absolute
+                  / path-rootless
+                  / path-empty
+
+   The scheme and path components are required, though the path may be
+   empty (no characters).  When authority is present, the path must
+   either be empty or begin with a slash ("/") character.  When
+   authority is not present, the path cannot begin with two slash
+   characters ("//").  These restrictions result in five different ABNF
+   rules for a path (Section 3.3), only one of which will match any
+   given URI reference.
+
+   The following are two example URIs and their component parts:
+
+         foo://example.com:8042/over/there?name=ferret#nose
+         \_/   \______________/\_________/ \_________/ \__/
+          |           |            |            |        |
+       scheme     authority       path        query   fragment
+          |   _____________________|__
+         / \ /                        \
+         urn:example:animal:ferret:nose
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 16]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+3.1.  Scheme
+
+   Each URI begins with a scheme name that refers to a specification for
+   assigning identifiers within that scheme.  As such, the URI syntax is
+   a federated and extensible naming system wherein each scheme's
+   specification may further restrict the syntax and semantics of
+   identifiers using that scheme.
+
+   Scheme names consist of a sequence of characters beginning with a
+   letter and followed by any combination of letters, digits, plus
+   ("+"), period ("."), or hyphen ("-").  Although schemes are case-
+   insensitive, the canonical form is lowercase and documents that
+   specify schemes must do so with lowercase letters.  An implementation
+   should accept uppercase letters as equivalent to lowercase in scheme
+   names (e.g., allow "HTTP" as well as "http") for the sake of
+   robustness but should only produce lowercase scheme names for
+   consistency.
+
+      scheme      = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
+
+   Individual schemes are not specified by this document.  The process
+   for registration of new URI schemes is defined separately by [BCP35].
+   The scheme registry maintains the mapping between scheme names and
+   their specifications.  Advice for designers of new URI schemes can be
+   found in [RFC2718].  URI scheme specifications must define their own
+   syntax so that all strings matching their scheme-specific syntax will
+   also match the <absolute-URI> grammar, as described in Section 4.3.
+
+   When presented with a URI that violates one or more scheme-specific
+   restrictions, the scheme-specific resolution process should flag the
+   reference as an error rather than ignore the unused parts; doing so
+   reduces the number of equivalent URIs and helps detect abuses of the
+   generic syntax, which might indicate that the URI has been
+   constructed to mislead the user (Section 7.6).
+
+3.2.  Authority
+
+   Many URI schemes include a hierarchical element for a naming
+   authority so that governance of the name space defined by the
+   remainder of the URI is delegated to that authority (which may, in
+   turn, delegate it further).  The generic syntax provides a common
+   means for distinguishing an authority based on a registered name or
+   server address, along with optional port and user information.
+
+   The authority component is preceded by a double slash ("//") and is
+   terminated by the next slash ("/"), question mark ("?"), or number
+   sign ("#") character, or by the end of the URI.
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 17]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+      authority   = [ userinfo "@" ] host [ ":" port ]
+
+   URI producers and normalizers should omit the ":" delimiter that
+   separates host from port if the port component is empty.  Some
+   schemes do not allow the userinfo and/or port subcomponents.
+
+   If a URI contains an authority component, then the path component
+   must either be empty or begin with a slash ("/") character.  Non-
+   validating parsers (those that merely separate a URI reference into
+   its major components) will often ignore the subcomponent structure of
+   authority, treating it as an opaque string from the double-slash to
+   the first terminating delimiter, until such time as the URI is
+   dereferenced.
+
+3.2.1.  User Information
+
+   The userinfo subcomponent may consist of a user name and, optionally,
+   scheme-specific information about how to gain authorization to access
+   the resource.  The user information, if present, is followed by a
+   commercial at-sign ("@") that delimits it from the host.
+
+      userinfo    = *( unreserved / pct-encoded / sub-delims / ":" )
+
+   Use of the format "user:password" in the userinfo field is
+   deprecated.  Applications should not render as clear text any data
+   after the first colon (":") character found within a userinfo
+   subcomponent unless the data after the colon is the empty string
+   (indicating no password).  Applications may choose to ignore or
+   reject such data when it is received as part of a reference and
+   should reject the storage of such data in unencrypted form.  The
+   passing of authentication information in clear text has proven to be
+   a security risk in almost every case where it has been used.
+
+   Applications that render a URI for the sake of user feedback, such as
+   in graphical hypertext browsing, should render userinfo in a way that
+   is distinguished from the rest of a URI, when feasible.  Such
+   rendering will assist the user in cases where the userinfo has been
+   misleadingly crafted to look like a trusted domain name
+   (Section 7.6).
+
+3.2.2.  Host
+
+   The host subcomponent of authority is identified by an IP literal
+   encapsulated within square brackets, an IPv4 address in dotted-
+   decimal form, or a registered name.  The host subcomponent is case-
+   insensitive.  The presence of a host subcomponent within a URI does
+   not imply that the scheme requires access to the given host on the
+   Internet.  In many cases, the host syntax is used only for the sake
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 18]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   of reusing the existing registration process created and deployed for
+   DNS, thus obtaining a globally unique name without the cost of
+   deploying another registry.  However, such use comes with its own
+   costs: domain name ownership may change over time for reasons not
+   anticipated by the URI producer.  In other cases, the data within the
+   host component identifies a registered name that has nothing to do
+   with an Internet host.  We use the name "host" for the ABNF rule
+   because that is its most common purpose, not its only purpose.
+
+      host        = IP-literal / IPv4address / reg-name
+
+   The syntax rule for host is ambiguous because it does not completely
+   distinguish between an IPv4address and a reg-name.  In order to
+   disambiguate the syntax, we apply the "first-match-wins" algorithm:
+   If host matches the rule for IPv4address, then it should be
+   considered an IPv4 address literal and not a reg-name.  Although host
+   is case-insensitive, producers and normalizers should use lowercase
+   for registered names and hexadecimal addresses for the sake of
+   uniformity, while only using uppercase letters for percent-encodings.
+
+   A host identified by an Internet Protocol literal address, version 6
+   [RFC3513] or later, is distinguished by enclosing the IP literal
+   within square brackets ("[" and "]").  This is the only place where
+   square bracket characters are allowed in the URI syntax.  In
+   anticipation of future, as-yet-undefined IP literal address formats,
+   an implementation may use an optional version flag to indicate such a
+   format explicitly rather than rely on heuristic determination.
+
+      IP-literal = "[" ( IPv6address / IPvFuture  ) "]"
+
+      IPvFuture  = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )
+
+   The version flag does not indicate the IP version; rather, it
+   indicates future versions of the literal format.  As such,
+   implementations must not provide the version flag for the existing
+   IPv4 and IPv6 literal address forms described below.  If a URI
+   containing an IP-literal that starts with "v" (case-insensitive),
+   indicating that the version flag is present, is dereferenced by an
+   application that does not know the meaning of that version flag, then
+   the application should return an appropriate error for "address
+   mechanism not supported".
+
+   A host identified by an IPv6 literal address is represented inside
+   the square brackets without a preceding version flag.  The ABNF
+   provided here is a translation of the text definition of an IPv6
+   literal address provided in [RFC3513].  This syntax does not support
+   IPv6 scoped addressing zone identifiers.
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 19]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   A 128-bit IPv6 address is divided into eight 16-bit pieces.  Each
+   piece is represented numerically in case-insensitive hexadecimal,
+   using one to four hexadecimal digits (leading zeroes are permitted).
+   The eight encoded pieces are given most-significant first, separated
+   by colon characters.  Optionally, the least-significant two pieces
+   may instead be represented in IPv4 address textual format.  A
+   sequence of one or more consecutive zero-valued 16-bit pieces within
+   the address may be elided, omitting all their digits and leaving
+   exactly two consecutive colons in their place to mark the elision.
+
+      IPv6address =                            6( h16 ":" ) ls32
+                  /                       "::" 5( h16 ":" ) ls32
+                  / [               h16 ] "::" 4( h16 ":" ) ls32
+                  / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
+                  / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
+                  / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
+                  / [ *4( h16 ":" ) h16 ] "::"              ls32
+                  / [ *5( h16 ":" ) h16 ] "::"              h16
+                  / [ *6( h16 ":" ) h16 ] "::"
+
+      ls32        = ( h16 ":" h16 ) / IPv4address
+                  ; least-significant 32 bits of address
+
+      h16         = 1*4HEXDIG
+                  ; 16 bits of address represented in hexadecimal
+
+   A host identified by an IPv4 literal address is represented in
+   dotted-decimal notation (a sequence of four decimal numbers in the
+   range 0 to 255, separated by "."), as described in [RFC1123] by
+   reference to [RFC0952].  Note that other forms of dotted notation may
+   be interpreted on some platforms, as described in Section 7.4, but
+   only the dotted-decimal form of four octets is allowed by this
+   grammar.
+
+      IPv4address = dec-octet "." dec-octet "." dec-octet "." dec-octet
+
+      dec-octet   = DIGIT                 ; 0-9
+                  / %x31-39 DIGIT         ; 10-99
+                  / "1" 2DIGIT            ; 100-199
+                  / "2" %x30-34 DIGIT     ; 200-249
+                  / "25" %x30-35          ; 250-255
+
+   A host identified by a registered name is a sequence of characters
+   usually intended for lookup within a locally defined host or service
+   name registry, though the URI's scheme-specific semantics may require
+   that a specific registry (or fixed name table) be used instead.  The
+   most common name registry mechanism is the Domain Name System (DNS).
+   A registered name intended for lookup in the DNS uses the syntax
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 20]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   defined in Section 3.5 of [RFC1034] and Section 2.1 of [RFC1123].
+   Such a name consists of a sequence of domain labels separated by ".",
+   each domain label starting and ending with an alphanumeric character
+   and possibly also containing "-" characters.  The rightmost domain
+   label of a fully qualified domain name in DNS may be followed by a
+   single "." and should be if it is necessary to distinguish between
+   the complete domain name and some local domain.
+
+      reg-name    = *( unreserved / pct-encoded / sub-delims )
+
+   If the URI scheme defines a default for host, then that default
+   applies when the host subcomponent is undefined or when the
+   registered name is empty (zero length).  For example, the "file" URI
+   scheme is defined so that no authority, an empty host, and
+   "localhost" all mean the end-user's machine, whereas the "http"
+   scheme considers a missing authority or empty host invalid.
+
+   This specification does not mandate a particular registered name
+   lookup technology and therefore does not restrict the syntax of reg-
+   name beyond what is necessary for interoperability.  Instead, it
+   delegates the issue of registered name syntax conformance to the
+   operating system of each application performing URI resolution, and
+   that operating system decides what it will allow for the purpose of
+   host identification.  A URI resolution implementation might use DNS,
+   host tables, yellow pages, NetInfo, WINS, or any other system for
+   lookup of registered names.  However, a globally scoped naming
+   system, such as DNS fully qualified domain names, is necessary for
+   URIs intended to have global scope.  URI producers should use names
+   that conform to the DNS syntax, even when use of DNS is not
+   immediately apparent, and should limit these names to no more than
+   255 characters in length.
+
+   The reg-name syntax allows percent-encoded octets in order to
+   represent non-ASCII registered names in a uniform way that is
+   independent of the underlying name resolution technology.  Non-ASCII
+   characters must first be encoded according to UTF-8 [STD63], and then
+   each octet of the corresponding UTF-8 sequence must be percent-
+   encoded to be represented as URI characters.  URI producing
+   applications must not use percent-encoding in host unless it is used
+   to represent a UTF-8 character sequence.  When a non-ASCII registered
+   name represents an internationalized domain name intended for
+   resolution via the DNS, the name must be transformed to the IDNA
+   encoding [RFC3490] prior to name lookup.  URI producers should
+   provide these registered names in the IDNA encoding, rather than a
+   percent-encoding, if they wish to maximize interoperability with
+   legacy URI resolvers.
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 21]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+3.2.3.  Port
+
+   The port subcomponent of authority is designated by an optional port
+   number in decimal following the host and delimited from it by a
+   single colon (":") character.
+
+      port        = *DIGIT
+
+   A scheme may define a default port.  For example, the "http" scheme
+   defines a default port of "80", corresponding to its reserved TCP
+   port number.  The type of port designated by the port number (e.g.,
+   TCP, UDP, SCTP) is defined by the URI scheme.  URI producers and
+   normalizers should omit the port component and its ":" delimiter if
+   port is empty or if its value would be the same as that of the
+   scheme's default.
+
+3.3.  Path
+
+   The path component contains data, usually organized in hierarchical
+   form, that, along with data in the non-hierarchical query component
+   (Section 3.4), serves to identify a resource within the scope of the
+   URI's scheme and naming authority (if any).  The path is terminated
+   by the first question mark ("?") or number sign ("#") character, or
+   by the end of the URI.
+
+   If a URI contains an authority component, then the path component
+   must either be empty or begin with a slash ("/") character.  If a URI
+   does not contain an authority component, then the path cannot begin
+   with two slash characters ("//").  In addition, a URI reference
+   (Section 4.1) may be a relative-path reference, in which case the
+   first path segment cannot contain a colon (":") character.  The ABNF
+   requires five separate rules to disambiguate these cases, only one of
+   which will match the path substring within a given URI reference.  We
+   use the generic term "path component" to describe the URI substring
+   matched by the parser to one of these rules.
+
+      path          = path-abempty    ; begins with "/" or is empty
+                    / path-absolute   ; begins with "/" but not "//"
+                    / path-noscheme   ; begins with a non-colon segment
+                    / path-rootless   ; begins with a segment
+                    / path-empty      ; zero characters
+
+      path-abempty  = *( "/" segment )
+      path-absolute = "/" [ segment-nz *( "/" segment ) ]
+      path-noscheme = segment-nz-nc *( "/" segment )
+      path-rootless = segment-nz *( "/" segment )
+      path-empty    = 0<pchar>
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 22]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+      segment       = *pchar
+      segment-nz    = 1*pchar
+      segment-nz-nc = 1*( unreserved / pct-encoded / sub-delims / "@" )
+                    ; non-zero-length segment without any colon ":"
+
+      pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
+
+   A path consists of a sequence of path segments separated by a slash
+   ("/") character.  A path is always defined for a URI, though the
+   defined path may be empty (zero length).  Use of the slash character
+   to indicate hierarchy is only required when a URI will be used as the
+   context for relative references.  For example, the URI
+   <mailto:fred@example.com> has a path of "fred@example.com", whereas
+   the URI <foo://info.example.com?fred> has an empty path.
+
+   The path segments "." and "..", also known as dot-segments, are
+   defined for relative reference within the path name hierarchy.  They
+   are intended for use at the beginning of a relative-path reference
+   (Section 4.2) to indicate relative position within the hierarchical
+   tree of names.  This is similar to their role within some operating
+   systems' file directory structures to indicate the current directory
+   and parent directory, respectively.  However, unlike in a file
+   system, these dot-segments are only interpreted within the URI path
+   hierarchy and are removed as part of the resolution process (Section
+   5.2).
+
+   Aside from dot-segments in hierarchical paths, a path segment is
+   considered opaque by the generic syntax.  URI producing applications
+   often use the reserved characters allowed in a segment to delimit
+   scheme-specific or dereference-handler-specific subcomponents.  For
+   example, the semicolon (";") and equals ("=") reserved characters are
+   often used to delimit parameters and parameter values applicable to
+   that segment.  The comma (",") reserved character is often used for
+   similar purposes.  For example, one URI producer might use a segment
+   such as "name;v=1.1" to indicate a reference to version 1.1 of
+   "name", whereas another might use a segment such as "name,1.1" to
+   indicate the same.  Parameter types may be defined by scheme-specific
+   semantics, but in most cases the syntax of a parameter is specific to
+   the implementation of the URI's dereferencing algorithm.
+
+3.4.  Query
+
+   The query component contains non-hierarchical data that, along with
+   data in the path component (Section 3.3), serves to identify a
+   resource within the scope of the URI's scheme and naming authority
+   (if any).  The query component is indicated by the first question
+   mark ("?") character and terminated by a number sign ("#") character
+   or by the end of the URI.
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 23]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+      query       = *( pchar / "/" / "?" )
+
+   The characters slash ("/") and question mark ("?") may represent data
+   within the query component.  Beware that some older, erroneous
+   implementations may not handle such data correctly when it is used as
+   the base URI for relative references (Section 5.1), apparently
+   because they fail to distinguish query data from path data when
+   looking for hierarchical separators.  However, as query components
+   are often used to carry identifying information in the form of
+   "key=value" pairs and one frequently used value is a reference to
+   another URI, it is sometimes better for usability to avoid percent-
+   encoding those characters.
+
+3.5.  Fragment
+
+   The fragment identifier component of a URI allows indirect
+   identification of a secondary resource by reference to a primary
+   resource and additional identifying information.  The identified
+   secondary resource may be some portion or subset of the primary
+   resource, some view on representations of the primary resource, or
+   some other resource defined or described by those representations.  A
+   fragment identifier component is indicated by the presence of a
+   number sign ("#") character and terminated by the end of the URI.
+
+      fragment    = *( pchar / "/" / "?" )
+
+   The semantics of a fragment identifier are defined by the set of
+   representations that might result from a retrieval action on the
+   primary resource.  The fragment's format and resolution is therefore
+   dependent on the media type [RFC2046] of a potentially retrieved
+   representation, even though such a retrieval is only performed if the
+   URI is dereferenced.  If no such representation exists, then the
+   semantics of the fragment are considered unknown and are effectively
+   unconstrained.  Fragment identifier semantics are independent of the
+   URI scheme and thus cannot be redefined by scheme specifications.
+
+   Individual media types may define their own restrictions on or
+   structures within the fragment identifier syntax for specifying
+   different types of subsets, views, or external references that are
+   identifiable as secondary resources by that media type.  If the
+   primary resource has multiple representations, as is often the case
+   for resources whose representation is selected based on attributes of
+   the retrieval request (a.k.a., content negotiation), then whatever is
+   identified by the fragment should be consistent across all of those
+   representations.  Each representation should either define the
+   fragment so that it corresponds to the same secondary resource,
+   regardless of how it is represented, or should leave the fragment
+   undefined (i.e., not found).
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 24]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   As with any URI, use of a fragment identifier component does not
+   imply that a retrieval action will take place.  A URI with a fragment
+   identifier may be used to refer to the secondary resource without any
+   implication that the primary resource is accessible or will ever be
+   accessed.
+
+   Fragment identifiers have a special role in information retrieval
+   systems as the primary form of client-side indirect referencing,
+   allowing an author to specifically identify aspects of an existing
+   resource that are only indirectly provided by the resource owner.  As
+   such, the fragment identifier is not used in the scheme-specific
+   processing of a URI; instead, the fragment identifier is separated
+   from the rest of the URI prior to a dereference, and thus the
+   identifying information within the fragment itself is dereferenced
+   solely by the user agent, regardless of the URI scheme.  Although
+   this separate handling is often perceived to be a loss of
+   information, particularly for accurate redirection of references as
+   resources move over time, it also serves to prevent information
+   providers from denying reference authors the right to refer to
+   information within a resource selectively.  Indirect referencing also
+   provides additional flexibility and extensibility to systems that use
+   URIs, as new media types are easier to define and deploy than new
+   schemes of identification.
+
+   The characters slash ("/") and question mark ("?") are allowed to
+   represent data within the fragment identifier.  Beware that some
+   older, erroneous implementations may not handle this data correctly
+   when it is used as the base URI for relative references (Section
+   5.1).
+
+4.  Usage
+
+   When applications make reference to a URI, they do not always use the
+   full form of reference defined by the "URI" syntax rule.  To save
+   space and take advantage of hierarchical locality, many Internet
+   protocol elements and media type formats allow an abbreviation of a
+   URI, whereas others restrict the syntax to a particular form of URI.
+   We define the most common forms of reference syntax in this
+   specification because they impact and depend upon the design of the
+   generic syntax, requiring a uniform parsing algorithm in order to be
+   interpreted consistently.
+
+4.1.  URI Reference
+
+   URI-reference is used to denote the most common usage of a resource
+   identifier.
+
+      URI-reference = URI / relative-ref
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 25]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   A URI-reference is either a URI or a relative reference.  If the
+   URI-reference's prefix does not match the syntax of a scheme followed
+   by its colon separator, then the URI-reference is a relative
+   reference.
+
+   A URI-reference is typically parsed first into the five URI
+   components, in order to determine what components are present and
+   whether the reference is relative.  Then, each component is parsed
+   for its subparts and their validation.  The ABNF of URI-reference,
+   along with the "first-match-wins" disambiguation rule, is sufficient
+   to define a validating parser for the generic syntax.  Readers
+   familiar with regular expressions should see Appendix B for an
+   example of a non-validating URI-reference parser that will take any
+   given string and extract the URI components.
+
+4.2.  Relative Reference
+
+   A relative reference takes advantage of the hierarchical syntax
+   (Section 1.2.3) to express a URI reference relative to the name space
+   of another hierarchical URI.
+
+      relative-ref  = relative-part [ "?" query ] [ "#" fragment ]
+
+      relative-part = "//" authority path-abempty
+                    / path-absolute
+                    / path-noscheme
+                    / path-empty
+
+   The URI referred to by a relative reference, also known as the target
+   URI, is obtained by applying the reference resolution algorithm of
+   Section 5.
+
+   A relative reference that begins with two slash characters is termed
+   a network-path reference; such references are rarely used.  A
+   relative reference that begins with a single slash character is
+   termed an absolute-path reference.  A relative reference that does
+   not begin with a slash character is termed a relative-path reference.
+
+   A path segment that contains a colon character (e.g., "this:that")
+   cannot be used as the first segment of a relative-path reference, as
+   it would be mistaken for a scheme name.  Such a segment must be
+   preceded by a dot-segment (e.g., "./this:that") to make a relative-
+   path reference.
+
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 26]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+4.3.  Absolute URI
+
+   Some protocol elements allow only the absolute form of a URI without
+   a fragment identifier.  For example, defining a base URI for later
+   use by relative references calls for an absolute-URI syntax rule that
+   does not allow a fragment.
+
+      absolute-URI  = scheme ":" hier-part [ "?" query ]
+
+   URI scheme specifications must define their own syntax so that all
+   strings matching their scheme-specific syntax will also match the
+   <absolute-URI> grammar.  Scheme specifications will not define
+   fragment identifier syntax or usage, regardless of its applicability
+   to resources identifiable via that scheme, as fragment identification
+   is orthogonal to scheme definition.  However, scheme specifications
+   are encouraged to include a wide range of examples, including
+   examples that show use of the scheme's URIs with fragment identifiers
+   when such usage is appropriate.
+
+4.4.  Same-Document Reference
+
+   When a URI reference refers to a URI that is, aside from its fragment
+   component (if any), identical to the base URI (Section 5.1), that
+   reference is called a "same-document" reference.  The most frequent
+   examples of same-document references are relative references that are
+   empty or include only the number sign ("#") separator followed by a
+   fragment identifier.
+
+   When a same-document reference is dereferenced for a retrieval
+   action, the target of that reference is defined to be within the same
+   entity (representation, document, or message) as the reference;
+   therefore, a dereference should not result in a new retrieval action.
+
+   Normalization of the base and target URIs prior to their comparison,
+   as described in Sections 6.2.2 and 6.2.3, is allowed but rarely
+   performed in practice.  Normalization may increase the set of same-
+   document references, which may be of benefit to some caching
+   applications.  As such, reference authors should not assume that a
+   slightly different, though equivalent, reference URI will (or will
+   not) be interpreted as a same-document reference by any given
+   application.
+
+4.5.  Suffix Reference
+
+   The URI syntax is designed for unambiguous reference to resources and
+   extensibility via the URI scheme.  However, as URI identification and
+   usage have become commonplace, traditional media (television, radio,
+   newspapers, billboards, etc.) have increasingly used a suffix of the
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 27]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   URI as a reference, consisting of only the authority and path
+   portions of the URI, such as
+
+      www.w3.org/Addressing/
+
+   or simply a DNS registered name on its own.  Such references are
+   primarily intended for human interpretation rather than for machines,
+   with the assumption that context-based heuristics are sufficient to
+   complete the URI (e.g., most registered names beginning with "www"
+   are likely to have a URI prefix of "http://").  Although there is no
+   standard set of heuristics for disambiguating a URI suffix, many
+   client implementations allow them to be entered by the user and
+   heuristically resolved.
+
+   Although this practice of using suffix references is common, it
+   should be avoided whenever possible and should never be used in
+   situations where long-term references are expected.  The heuristics
+   noted above will change over time, particularly when a new URI scheme
+   becomes popular, and are often incorrect when used out of context.
+   Furthermore, they can lead to security issues along the lines of
+   those described in [RFC1535].
+
+   As a URI suffix has the same syntax as a relative-path reference, a
+   suffix reference cannot be used in contexts where a relative
+   reference is expected.  As a result, suffix references are limited to
+   places where there is no defined base URI, such as dialog boxes and
+   off-line advertisements.
+
+5.  Reference Resolution
+
+   This section defines the process of resolving a URI reference within
+   a context that allows relative references so that the result is a
+   string matching the <URI> syntax rule of Section 3.
+
+5.1.  Establishing a Base URI
+
+   The term "relative" implies that a "base URI" exists against which
+   the relative reference is applied.  Aside from fragment-only
+   references (Section 4.4), relative references are only usable when a
+   base URI is known.  A base URI must be established by the parser
+   prior to parsing URI references that might be relative.  A base URI
+   must conform to the <absolute-URI> syntax rule (Section 4.3).  If the
+   base URI is obtained from a URI reference, then that reference must
+   be converted to absolute form and stripped of any fragment component
+   prior to its use as a base URI.
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 28]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   The base URI of a reference can be established in one of four ways,
+   discussed below in order of precedence.  The order of precedence can
+   be thought of in terms of layers, where the innermost defined base
+   URI has the highest precedence.  This can be visualized graphically
+   as follows:
+
+         .----------------------------------------------------------.
+         |  .----------------------------------------------------.  |
+         |  |  .----------------------------------------------.  |  |
+         |  |  |  .----------------------------------------.  |  |  |
+         |  |  |  |  .----------------------------------.  |  |  |  |
+         |  |  |  |  |       <relative-reference>       |  |  |  |  |
+         |  |  |  |  `----------------------------------'  |  |  |  |
+         |  |  |  | (5.1.1) Base URI embedded in content   |  |  |  |
+         |  |  |  `----------------------------------------'  |  |  |
+         |  |  | (5.1.2) Base URI of the encapsulating entity |  |  |
+         |  |  |         (message, representation, or none)   |  |  |
+         |  |  `----------------------------------------------'  |  |
+         |  | (5.1.3) URI used to retrieve the entity            |  |
+         |  `----------------------------------------------------'  |
+         | (5.1.4) Default Base URI (application-dependent)         |
+         `----------------------------------------------------------'
+
+5.1.1.  Base URI Embedded in Content
+
+   Within certain media types, a base URI for relative references can be
+   embedded within the content itself so that it can be readily obtained
+   by a parser.  This can be useful for descriptive documents, such as
+   tables of contents, which may be transmitted to others through
+   protocols other than their usual retrieval context (e.g., email or
+   USENET news).
+
+   It is beyond the scope of this specification to specify how, for each
+   media type, a base URI can be embedded.  The appropriate syntax, when
+   available, is described by the data format specification associated
+   with each media type.
+
+5.1.2.  Base URI from the Encapsulating Entity
+
+   If no base URI is embedded, the base URI is defined by the
+   representation's retrieval context.  For a document that is enclosed
+   within another entity, such as a message or archive, the retrieval
+   context is that entity.  Thus, the default base URI of a
+   representation is the base URI of the entity in which the
+   representation is encapsulated.
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 29]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   A mechanism for embedding a base URI within MIME container types
+   (e.g., the message and multipart types) is defined by MHTML
+   [RFC2557].  Protocols that do not use the MIME message header syntax,
+   but that do allow some form of tagged metadata to be included within
+   messages, may define their own syntax for defining a base URI as part
+   of a message.
+
+5.1.3.  Base URI from the Retrieval URI
+
+   If no base URI is embedded and the representation is not encapsulated
+   within some other entity, then, if a URI was used to retrieve the
+   representation, that URI shall be considered the base URI.  Note that
+   if the retrieval was the result of a redirected request, the last URI
+   used (i.e., the URI that resulted in the actual retrieval of the
+   representation) is the base URI.
+
+5.1.4.  Default Base URI
+
+   If none of the conditions described above apply, then the base URI is
+   defined by the context of the application.  As this definition is
+   necessarily application-dependent, failing to define a base URI by
+   using one of the other methods may result in the same content being
+   interpreted differently by different types of applications.
+
+   A sender of a representation containing relative references is
+   responsible for ensuring that a base URI for those references can be
+   established.  Aside from fragment-only references, relative
+   references can only be used reliably in situations where the base URI
+   is well defined.
+
+5.2.  Relative Resolution
+
+   This section describes an algorithm for converting a URI reference
+   that might be relative to a given base URI into the parsed components
+   of the reference's target.  The components can then be recomposed, as
+   described in Section 5.3, to form the target URI.  This algorithm
+   provides definitive results that can be used to test the output of
+   other implementations.  Applications may implement relative reference
+   resolution by using some other algorithm, provided that the results
+   match what would be given by this one.
+
+
+
+
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 30]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+5.2.1.  Pre-parse the Base URI
+
+   The base URI (Base) is established according to the procedure of
+   Section 5.1 and parsed into the five main components described in
+   Section 3.  Note that only the scheme component is required to be
+   present in a base URI; the other components may be empty or
+   undefined.  A component is undefined if its associated delimiter does
+   not appear in the URI reference; the path component is never
+   undefined, though it may be empty.
+
+   Normalization of the base URI, as described in Sections 6.2.2 and
+   6.2.3, is optional.  A URI reference must be transformed to its
+   target URI before it can be normalized.
+
+5.2.2.  Transform References
+
+   For each URI reference (R), the following pseudocode describes an
+   algorithm for transforming R into its target URI (T):
+
+      -- The URI reference is parsed into the five URI components
+      --
+      (R.scheme, R.authority, R.path, R.query, R.fragment) = parse(R);
+
+      -- A non-strict parser may ignore a scheme in the reference
+      -- if it is identical to the base URI's scheme.
+      --
+      if ((not strict) and (R.scheme == Base.scheme)) then
+         undefine(R.scheme);
+      endif;
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 31]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+      if defined(R.scheme) then
+         T.scheme    = R.scheme;
+         T.authority = R.authority;
+         T.path      = remove_dot_segments(R.path);
+         T.query     = R.query;
+      else
+         if defined(R.authority) then
+            T.authority = R.authority;
+            T.path      = remove_dot_segments(R.path);
+            T.query     = R.query;
+         else
+            if (R.path == "") then
+               T.path = Base.path;
+               if defined(R.query) then
+                  T.query = R.query;
+               else
+                  T.query = Base.query;
+               endif;
+            else
+               if (R.path starts-with "/") then
+                  T.path = remove_dot_segments(R.path);
+               else
+                  T.path = merge(Base.path, R.path);
+                  T.path = remove_dot_segments(T.path);
+               endif;
+               T.query = R.query;
+            endif;
+            T.authority = Base.authority;
+         endif;
+         T.scheme = Base.scheme;
+      endif;
+
+      T.fragment = R.fragment;
+
+5.2.3.  Merge Paths
+
+   The pseudocode above refers to a "merge" routine for merging a
+   relative-path reference with the path of the base URI.  This is
+   accomplished as follows:
+
+   o  If the base URI has a defined authority component and an empty
+      path, then return a string consisting of "/" concatenated with the
+      reference's path; otherwise,
+
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 32]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   o  return a string consisting of the reference's path component
+      appended to all but the last segment of the base URI's path (i.e.,
+      excluding any characters after the right-most "/" in the base URI
+      path, or excluding the entire base URI path if it does not contain
+      any "/" characters).
+
+5.2.4.  Remove Dot Segments
+
+   The pseudocode also refers to a "remove_dot_segments" routine for
+   interpreting and removing the special "." and ".." complete path
+   segments from a referenced path.  This is done after the path is
+   extracted from a reference, whether or not the path was relative, in
+   order to remove any invalid or extraneous dot-segments prior to
+   forming the target URI.  Although there are many ways to accomplish
+   this removal process, we describe a simple method using two string
+   buffers.
+
+   1.  The input buffer is initialized with the now-appended path
+       components and the output buffer is initialized to the empty
+       string.
+
+   2.  While the input buffer is not empty, loop as follows:
+
+       A.  If the input buffer begins with a prefix of "../" or "./",
+           then remove that prefix from the input buffer; otherwise,
+
+       B.  if the input buffer begins with a prefix of "/./" or "/.",
+           where "." is a complete path segment, then replace that
+           prefix with "/" in the input buffer; otherwise,
+
+       C.  if the input buffer begins with a prefix of "/../" or "/..",
+           where ".." is a complete path segment, then replace that
+           prefix with "/" in the input buffer and remove the last
+           segment and its preceding "/" (if any) from the output
+           buffer; otherwise,
+
+       D.  if the input buffer consists only of "." or "..", then remove
+           that from the input buffer; otherwise,
+
+       E.  move the first path segment in the input buffer to the end of
+           the output buffer, including the initial "/" character (if
+           any) and any subsequent characters up to, but not including,
+           the next "/" character or the end of the input buffer.
+
+   3.  Finally, the output buffer is returned as the result of
+       remove_dot_segments.
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 33]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   Note that dot-segments are intended for use in URI references to
+   express an identifier relative to the hierarchy of names in the base
+   URI.  The remove_dot_segments algorithm respects that hierarchy by
+   removing extra dot-segments rather than treat them as an error or
+   leaving them to be misinterpreted by dereference implementations.
+
+   The following illustrates how the above steps are applied for two
+   examples of merged paths, showing the state of the two buffers after
+   each step.
+
+      STEP   OUTPUT BUFFER         INPUT BUFFER
+
+       1 :                         /a/b/c/./../../g
+       2E:   /a                    /b/c/./../../g
+       2E:   /a/b                  /c/./../../g
+       2E:   /a/b/c                /./../../g
+       2B:   /a/b/c                /../../g
+       2C:   /a/b                  /../g
+       2C:   /a                    /g
+       2E:   /a/g
+
+      STEP   OUTPUT BUFFER         INPUT BUFFER
+
+       1 :                         mid/content=5/../6
+       2E:   mid                   /content=5/../6
+       2E:   mid/content=5         /../6
+       2C:   mid                   /6
+       2E:   mid/6
+
+   Some applications may find it more efficient to implement the
+   remove_dot_segments algorithm by using two segment stacks rather than
+   strings.
+
+      Note: Beware that some older, erroneous implementations will fail
+      to separate a reference's query component from its path component
+      prior to merging the base and reference paths, resulting in an
+      interoperability failure if the query component contains the
+      strings "/../" or "/./".
+
+
+
+
+
+
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 34]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+5.3.  Component Recomposition
+
+   Parsed URI components can be recomposed to obtain the corresponding
+   URI reference string.  Using pseudocode, this would be:
+
+      result = ""
+
+      if defined(scheme) then
+         append scheme to result;
+         append ":" to result;
+      endif;
+
+      if defined(authority) then
+         append "//" to result;
+         append authority to result;
+      endif;
+
+      append path to result;
+
+      if defined(query) then
+         append "?" to result;
+         append query to result;
+      endif;
+
+      if defined(fragment) then
+         append "#" to result;
+         append fragment to result;
+      endif;
+
+      return result;
+
+   Note that we are careful to preserve the distinction between a
+   component that is undefined, meaning that its separator was not
+   present in the reference, and a component that is empty, meaning that
+   the separator was present and was immediately followed by the next
+   component separator or the end of the reference.
+
+5.4.  Reference Resolution Examples
+
+   Within a representation with a well defined base URI of
+
+      http://a/b/c/d;p?q
+
+   a relative reference is transformed to its target URI as follows.
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 35]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+5.4.1.  Normal Examples
+
+      "g:h"           =  "g:h"
+      "g"             =  "http://a/b/c/g"
+      "./g"           =  "http://a/b/c/g"
+      "g/"            =  "http://a/b/c/g/"
+      "/g"            =  "http://a/g"
+      "//g"           =  "http://g"
+      "?y"            =  "http://a/b/c/d;p?y"
+      "g?y"           =  "http://a/b/c/g?y"
+      "#s"            =  "http://a/b/c/d;p?q#s"
+      "g#s"           =  "http://a/b/c/g#s"
+      "g?y#s"         =  "http://a/b/c/g?y#s"
+      ";x"            =  "http://a/b/c/;x"
+      "g;x"           =  "http://a/b/c/g;x"
+      "g;x?y#s"       =  "http://a/b/c/g;x?y#s"
+      ""              =  "http://a/b/c/d;p?q"
+      "."             =  "http://a/b/c/"
+      "./"            =  "http://a/b/c/"
+      ".."            =  "http://a/b/"
+      "../"           =  "http://a/b/"
+      "../g"          =  "http://a/b/g"
+      "../.."         =  "http://a/"
+      "../../"        =  "http://a/"
+      "../../g"       =  "http://a/g"
+
+5.4.2.  Abnormal Examples
+
+   Although the following abnormal examples are unlikely to occur in
+   normal practice, all URI parsers should be capable of resolving them
+   consistently.  Each example uses the same base as that above.
+
+   Parsers must be careful in handling cases where there are more ".."
+   segments in a relative-path reference than there are hierarchical
+   levels in the base URI's path.  Note that the ".." syntax cannot be
+   used to change the authority component of a URI.
+
+      "../../../g"    =  "http://a/g"
+      "../../../../g" =  "http://a/g"
+
+
+
+
+
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 36]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   Similarly, parsers must remove the dot-segments "." and ".." when
+   they are complete components of a path, but not when they are only
+   part of a segment.
+
+      "/./g"          =  "http://a/g"
+      "/../g"         =  "http://a/g"
+      "g."            =  "http://a/b/c/g."
+      ".g"            =  "http://a/b/c/.g"
+      "g.."           =  "http://a/b/c/g.."
+      "..g"           =  "http://a/b/c/..g"
+
+   Less likely are cases where the relative reference uses unnecessary
+   or nonsensical forms of the "." and ".." complete path segments.
+
+      "./../g"        =  "http://a/b/g"
+      "./g/."         =  "http://a/b/c/g/"
+      "g/./h"         =  "http://a/b/c/g/h"
+      "g/../h"        =  "http://a/b/c/h"
+      "g;x=1/./y"     =  "http://a/b/c/g;x=1/y"
+      "g;x=1/../y"    =  "http://a/b/c/y"
+
+   Some applications fail to separate the reference's query and/or
+   fragment components from the path component before merging it with
+   the base path and removing dot-segments.  This error is rarely
+   noticed, as typical usage of a fragment never includes the hierarchy
+   ("/") character and the query component is not normally used within
+   relative references.
+
+      "g?y/./x"       =  "http://a/b/c/g?y/./x"
+      "g?y/../x"      =  "http://a/b/c/g?y/../x"
+      "g#s/./x"       =  "http://a/b/c/g#s/./x"
+      "g#s/../x"      =  "http://a/b/c/g#s/../x"
+
+   Some parsers allow the scheme name to be present in a relative
+   reference if it is the same as the base URI scheme.  This is
+   considered to be a loophole in prior specifications of partial URI
+   [RFC1630].  Its use should be avoided but is allowed for backward
+   compatibility.
+
+      "http:g"        =  "http:g"         ; for strict parsers
+                      /  "http://a/b/c/g" ; for backward compatibility
+
+
+
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 37]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+6.  Normalization and Comparison
+
+   One of the most common operations on URIs is simple comparison:
+   determining whether two URIs are equivalent without using the URIs to
+   access their respective resource(s).  A comparison is performed every
+   time a response cache is accessed, a browser checks its history to
+   color a link, or an XML parser processes tags within a namespace.
+   Extensive normalization prior to comparison of URIs is often used by
+   spiders and indexing engines to prune a search space or to reduce
+   duplication of request actions and response storage.
+
+   URI comparison is performed for some particular purpose.  Protocols
+   or implementations that compare URIs for different purposes will
+   often be subject to differing design trade-offs in regards to how
+   much effort should be spent in reducing aliased identifiers.  This
+   section describes various methods that may be used to compare URIs,
+   the trade-offs between them, and the types of applications that might
+   use them.
+
+6.1.  Equivalence
+
+   Because URIs exist to identify resources, presumably they should be
+   considered equivalent when they identify the same resource.  However,
+   this definition of equivalence is not of much practical use, as there
+   is no way for an implementation to compare two resources unless it
+   has full knowledge or control of them.  For this reason,
+   determination of equivalence or difference of URIs is based on string
+   comparison, perhaps augmented by reference to additional rules
+   provided by URI scheme definitions.  We use the terms "different" and
+   "equivalent" to describe the possible outcomes of such comparisons,
+   but there are many application-dependent versions of equivalence.
+
+   Even though it is possible to determine that two URIs are equivalent,
+   URI comparison is not sufficient to determine whether two URIs
+   identify different resources.  For example, an owner of two different
+   domain names could decide to serve the same resource from both,
+   resulting in two different URIs.  Therefore, comparison methods are
+   designed to minimize false negatives while strictly avoiding false
+   positives.
+
+   In testing for equivalence, applications should not directly compare
+   relative references; the references should be converted to their
+   respective target URIs before comparison.  When URIs are compared to
+   select (or avoid) a network action, such as retrieval of a
+   representation, fragment components (if any) should be excluded from
+   the comparison.
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 38]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+6.2.  Comparison Ladder
+
+   A variety of methods are used in practice to test URI equivalence.
+   These methods fall into a range, distinguished by the amount of
+   processing required and the degree to which the probability of false
+   negatives is reduced.  As noted above, false negatives cannot be
+   eliminated.  In practice, their probability can be reduced, but this
+   reduction requires more processing and is not cost-effective for all
+   applications.
+
+   If this range of comparison practices is considered as a ladder, the
+   following discussion will climb the ladder, starting with practices
+   that are cheap but have a relatively higher chance of producing false
+   negatives, and proceeding to those that have higher computational
+   cost and lower risk of false negatives.
+
+6.2.1.  Simple String Comparison
+
+   If two URIs, when considered as character strings, are identical,
+   then it is safe to conclude that they are equivalent.  This type of
+   equivalence test has very low computational cost and is in wide use
+   in a variety of applications, particularly in the domain of parsing.
+
+   Testing strings for equivalence requires some basic precautions.
+   This procedure is often referred to as "bit-for-bit" or
+   "byte-for-byte" comparison, which is potentially misleading.  Testing
+   strings for equality is normally based on pair comparison of the
+   characters that make up the strings, starting from the first and
+   proceeding until both strings are exhausted and all characters are
+   found to be equal, until a pair of characters compares unequal, or
+   until one of the strings is exhausted before the other.
+
+   This character comparison requires that each pair of characters be
+   put in comparable form.  For example, should one URI be stored in a
+   byte array in EBCDIC encoding and the second in a Java String object
+   (UTF-16), bit-for-bit comparisons applied naively will produce
+   errors.  It is better to speak of equality on a character-for-
+   character basis rather than on a byte-for-byte or bit-for-bit basis.
+   In practical terms, character-by-character comparisons should be done
+   codepoint-by-codepoint after conversion to a common character
+   encoding.
+
+   False negatives are caused by the production and use of URI aliases.
+   Unnecessary aliases can be reduced, regardless of the comparison
+   method, by consistently providing URI references in an already-
+   normalized form (i.e., a form identical to what would be produced
+   after normalization is applied, as described below).
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 39]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   Protocols and data formats often limit some URI comparisons to simple
+   string comparison, based on the theory that people and
+   implementations will, in their own best interest, be consistent in
+   providing URI references, or at least consistent enough to negate any
+   efficiency that might be obtained from further normalization.
+
+6.2.2.  Syntax-Based Normalization
+
+   Implementations may use logic based on the definitions provided by
+   this specification to reduce the probability of false negatives.
+   This processing is moderately higher in cost than character-for-
+   character string comparison.  For example, an application using this
+   approach could reasonably consider the following two URIs equivalent:
+
+      example://a/b/c/%7Bfoo%7D
+      eXAMPLE://a/./b/../b/%63/%7bfoo%7d
+
+   Web user agents, such as browsers, typically apply this type of URI
+   normalization when determining whether a cached response is
+   available.  Syntax-based normalization includes such techniques as
+   case normalization, percent-encoding normalization, and removal of
+   dot-segments.
+
+6.2.2.1.  Case Normalization
+
+   For all URIs, the hexadecimal digits within a percent-encoding
+   triplet (e.g., "%3a" versus "%3A") are case-insensitive and therefore
+   should be normalized to use uppercase letters for the digits A-F.
+
+   When a URI uses components of the generic syntax, the component
+   syntax equivalence rules always apply; namely, that the scheme and
+   host are case-insensitive and therefore should be normalized to
+   lowercase.  For example, the URI <HTTP://www.EXAMPLE.com/> is
+   equivalent to <http://www.example.com/>.  The other generic syntax
+   components are assumed to be case-sensitive unless specifically
+   defined otherwise by the scheme (see Section 6.2.3).
+
+6.2.2.2.  Percent-Encoding Normalization
+
+   The percent-encoding mechanism (Section 2.1) is a frequent source of
+   variance among otherwise identical URIs.  In addition to the case
+   normalization issue noted above, some URI producers percent-encode
+   octets that do not require percent-encoding, resulting in URIs that
+   are equivalent to their non-encoded counterparts.  These URIs should
+   be normalized by decoding any percent-encoded octet that corresponds
+   to an unreserved character, as described in Section 2.3.
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 40]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+6.2.2.3.  Path Segment Normalization
+
+   The complete path segments "." and ".." are intended only for use
+   within relative references (Section 4.1) and are removed as part of
+   the reference resolution process (Section 5.2).  However, some
+   deployed implementations incorrectly assume that reference resolution
+   is not necessary when the reference is already a URI and thus fail to
+   remove dot-segments when they occur in non-relative paths.  URI
+   normalizers should remove dot-segments by applying the
+   remove_dot_segments algorithm to the path, as described in
+   Section 5.2.4.
+
+6.2.3.  Scheme-Based Normalization
+
+   The syntax and semantics of URIs vary from scheme to scheme, as
+   described by the defining specification for each scheme.
+   Implementations may use scheme-specific rules, at further processing
+   cost, to reduce the probability of false negatives.  For example,
+   because the "http" scheme makes use of an authority component, has a
+   default port of "80", and defines an empty path to be equivalent to
+   "/", the following four URIs are equivalent:
+
+      http://example.com
+      http://example.com/
+      http://example.com:/
+      http://example.com:80/
+
+   In general, a URI that uses the generic syntax for authority with an
+   empty path should be normalized to a path of "/".  Likewise, an
+   explicit ":port", for which the port is empty or the default for the
+   scheme, is equivalent to one where the port and its ":" delimiter are
+   elided and thus should be removed by scheme-based normalization.  For
+   example, the second URI above is the normal form for the "http"
+   scheme.
+
+   Another case where normalization varies by scheme is in the handling
+   of an empty authority component or empty host subcomponent.  For many
+   scheme specifications, an empty authority or host is considered an
+   error; for others, it is considered equivalent to "localhost" or the
+   end-user's host.  When a scheme defines a default for authority and a
+   URI reference to that default is desired, the reference should be
+   normalized to an empty authority for the sake of uniformity, brevity,
+   and internationalization.  If, however, either the userinfo or port
+   subcomponents are non-empty, then the host should be given explicitly
+   even if it matches the default.
+
+   Normalization should not remove delimiters when their associated
+   component is empty unless licensed to do so by the scheme
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 41]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   specification.  For example, the URI "http://example.com/?" cannot be
+   assumed to be equivalent to any of the examples above.  Likewise, the
+   presence or absence of delimiters within a userinfo subcomponent is
+   usually significant to its interpretation.  The fragment component is
+   not subject to any scheme-based normalization; thus, two URIs that
+   differ only by the suffix "#" are considered different regardless of
+   the scheme.
+
+   Some schemes define additional subcomponents that consist of case-
+   insensitive data, giving an implicit license to normalizers to
+   convert this data to a common case (e.g., all lowercase).  For
+   example, URI schemes that define a subcomponent of path to contain an
+   Internet hostname, such as the "mailto" URI scheme, cause that
+   subcomponent to be case-insensitive and thus subject to case
+   normalization (e.g., "mailto:Joe@Example.COM" is equivalent to
+   "mailto:Joe@example.com", even though the generic syntax considers
+   the path component to be case-sensitive).
+
+   Other scheme-specific normalizations are possible.
+
+6.2.4.  Protocol-Based Normalization
+
+   Substantial effort to reduce the incidence of false negatives is
+   often cost-effective for web spiders.  Therefore, they implement even
+   more aggressive techniques in URI comparison.  For example, if they
+   observe that a URI such as
+
+      http://example.com/data
+
+   redirects to a URI differing only in the trailing slash
+
+      http://example.com/data/
+
+   they will likely regard the two as equivalent in the future.  This
+   kind of technique is only appropriate when equivalence is clearly
+   indicated by both the result of accessing the resources and the
+   common conventions of their scheme's dereference algorithm (in this
+   case, use of redirection by HTTP origin servers to avoid problems
+   with relative references).
+
+
+
+
+
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 42]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+7.  Security Considerations
+
+   A URI does not in itself pose a security threat.  However, as URIs
+   are often used to provide a compact set of instructions for access to
+   network resources, care must be taken to properly interpret the data
+   within a URI, to prevent that data from causing unintended access,
+   and to avoid including data that should not be revealed in plain
+   text.
+
+7.1.  Reliability and Consistency
+
+   There is no guarantee that once a URI has been used to retrieve
+   information, the same information will be retrievable by that URI in
+   the future.  Nor is there any guarantee that the information
+   retrievable via that URI in the future will be observably similar to
+   that retrieved in the past.  The URI syntax does not constrain how a
+   given scheme or authority apportions its namespace or maintains it
+   over time.  Such guarantees can only be obtained from the person(s)
+   controlling that namespace and the resource in question.  A specific
+   URI scheme may define additional semantics, such as name persistence,
+   if those semantics are required of all naming authorities for that
+   scheme.
+
+7.2.  Malicious Construction
+
+   It is sometimes possible to construct a URI so that an attempt to
+   perform a seemingly harmless, idempotent operation, such as the
+   retrieval of a representation, will in fact cause a possibly damaging
+   remote operation.  The unsafe URI is typically constructed by
+   specifying a port number other than that reserved for the network
+   protocol in question.  The client unwittingly contacts a site running
+   a different protocol service, and data within the URI contains
+   instructions that, when interpreted according to this other protocol,
+   cause an unexpected operation.  A frequent example of such abuse has
+   been the use of a protocol-based scheme with a port component of
+   "25", thereby fooling user agent software into sending an unintended
+   or impersonating message via an SMTP server.
+
+   Applications should prevent dereference of a URI that specifies a TCP
+   port number within the "well-known port" range (0 - 1023) unless the
+   protocol being used to dereference that URI is compatible with the
+   protocol expected on that well-known port.  Although IANA maintains a
+   registry of well-known ports, applications should make such
+   restrictions user-configurable to avoid preventing the deployment of
+   new services.
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 43]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   When a URI contains percent-encoded octets that match the delimiters
+   for a given resolution or dereference protocol (for example, CR and
+   LF characters for the TELNET protocol), these percent-encodings must
+   not be decoded before transmission across that protocol.  Transfer of
+   the percent-encoding, which might violate the protocol, is less
+   harmful than allowing decoded octets to be interpreted as additional
+   operations or parameters, perhaps triggering an unexpected and
+   possibly harmful remote operation.
+
+7.3.  Back-End Transcoding
+
+   When a URI is dereferenced, the data within it is often parsed by
+   both the user agent and one or more servers.  In HTTP, for example, a
+   typical user agent will parse a URI into its five major components,
+   access the authority's server, and send it the data within the
+   authority, path, and query components.  A typical server will take
+   that information, parse the path into segments and the query into
+   key/value pairs, and then invoke implementation-specific handlers to
+   respond to the request.  As a result, a common security concern for
+   server implementations that handle a URI, either as a whole or split
+   into separate components, is proper interpretation of the octet data
+   represented by the characters and percent-encodings within that URI.
+
+   Percent-encoded octets must be decoded at some point during the
+   dereference process.  Applications must split the URI into its
+   components and subcomponents prior to decoding the octets, as
+   otherwise the decoded octets might be mistaken for delimiters.
+   Security checks of the data within a URI should be applied after
+   decoding the octets.  Note, however, that the "%00" percent-encoding
+   (NUL) may require special handling and should be rejected if the
+   application is not expecting to receive raw data within a component.
+
+   Special care should be taken when the URI path interpretation process
+   involves the use of a back-end file system or related system
+   functions.  File systems typically assign an operational meaning to
+   special characters, such as the "/", "\", ":", "[", and "]"
+   characters, and to special device names like ".", "..", "...", "aux",
+   "lpt", etc.  In some cases, merely testing for the existence of such
+   a name will cause the operating system to pause or invoke unrelated
+   system calls, leading to significant security concerns regarding
+   denial of service and unintended data transfer.  It would be
+   impossible for this specification to list all such significant
+   characters and device names.  Implementers should research the
+   reserved names and characters for the types of storage device that
+   may be attached to their applications and restrict the use of data
+   obtained from URI components accordingly.
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 44]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+7.4.  Rare IP Address Formats
+
+   Although the URI syntax for IPv4address only allows the common
+   dotted-decimal form of IPv4 address literal, many implementations
+   that process URIs make use of platform-dependent system routines,
+   such as gethostbyname() and inet_aton(), to translate the string
+   literal to an actual IP address.  Unfortunately, such system routines
+   often allow and process a much larger set of formats than those
+   described in Section 3.2.2.
+
+   For example, many implementations allow dotted forms of three
+   numbers, wherein the last part is interpreted as a 16-bit quantity
+   and placed in the right-most two bytes of the network address (e.g.,
+   a Class B network).  Likewise, a dotted form of two numbers means
+   that the last part is interpreted as a 24-bit quantity and placed in
+   the right-most three bytes of the network address (Class A), and a
+   single number (without dots) is interpreted as a 32-bit quantity and
+   stored directly in the network address.  Adding further to the
+   confusion, some implementations allow each dotted part to be
+   interpreted as decimal, octal, or hexadecimal, as specified in the C
+   language (i.e., a leading 0x or 0X implies hexadecimal; a leading 0
+   implies octal; otherwise, the number is interpreted as decimal).
+
+   These additional IP address formats are not allowed in the URI syntax
+   due to differences between platform implementations.  However, they
+   can become a security concern if an application attempts to filter
+   access to resources based on the IP address in string literal format.
+   If this filtering is performed, literals should be converted to
+   numeric form and filtered based on the numeric value, and not on a
+   prefix or suffix of the string form.
+
+7.5.  Sensitive Information
+
+   URI producers should not provide a URI that contains a username or
+   password that is intended to be secret.  URIs are frequently
+   displayed by browsers, stored in clear text bookmarks, and logged by
+   user agent history and intermediary applications (proxies).  A
+   password appearing within the userinfo component is deprecated and
+   should be considered an error (or simply ignored) except in those
+   rare cases where the 'password' parameter is intended to be public.
+
+7.6.  Semantic Attacks
+
+   Because the userinfo subcomponent is rarely used and appears before
+   the host in the authority component, it can be used to construct a
+   URI intended to mislead a human user by appearing to identify one
+   (trusted) naming authority while actually identifying a different
+   authority hidden behind the noise.  For example
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 45]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+      ftp://cnn.example.com&story=breaking_news@10.0.0.1/top_story.htm
+
+   might lead a human user to assume that the host is 'cnn.example.com',
+   whereas it is actually '10.0.0.1'.  Note that a misleading userinfo
+   subcomponent could be much longer than the example above.
+
+   A misleading URI, such as that above, is an attack on the user's
+   preconceived notions about the meaning of a URI rather than an attack
+   on the software itself.  User agents may be able to reduce the impact
+   of such attacks by distinguishing the various components of the URI
+   when they are rendered, such as by using a different color or tone to
+   render userinfo if any is present, though there is no panacea.  More
+   information on URI-based semantic attacks can be found in [Siedzik].
+
+8.  IANA Considerations
+
+   URI scheme names, as defined by <scheme> in Section 3.1, form a
+   registered namespace that is managed by IANA according to the
+   procedures defined in [BCP35].  No IANA actions are required by this
+   document.
+
+9.  Acknowledgements
+
+   This specification is derived from RFC 2396 [RFC2396], RFC 1808
+   [RFC1808], and RFC 1738 [RFC1738]; the acknowledgements in those
+   documents still apply.  It also incorporates the update (with
+   corrections) for IPv6 literals in the host syntax, as defined by
+   Robert M. Hinden, Brian E. Carpenter, and Larry Masinter in
+   [RFC2732].  In addition, contributions by Gisle Aas, Reese Anschultz,
+   Daniel Barclay, Tim Bray, Mike Brown, Rob Cameron, Jeremy Carroll,
+   Dan Connolly, Adam M. Costello, John Cowan, Jason Diamond, Martin
+   Duerst, Stefan Eissing, Clive D.W. Feather, Al Gilman, Tony Hammond,
+   Elliotte Harold, Pat Hayes, Henry Holtzman, Ian B. Jacobs, Michael
+   Kay, John C. Klensin, Graham Klyne, Dan Kohn, Bruce Lilly, Andrew
+   Main, Dave McAlpin, Ira McDonald, Michael Mealling, Ray Merkert,
+   Stephen Pollei, Julian Reschke, Tomas Rokicki, Miles Sabin, Kai
+   Schaetzl, Mark Thomson, Ronald Tschalaer, Norm Walsh, Marc Warne,
+   Stuart Williams, and Henry Zongaro are gratefully acknowledged.
+
+10.  References
+
+10.1.  Normative References
+
+   [ASCII]    American National Standards Institute, "Coded Character
+              Set -- 7-bit American Standard Code for Information
+              Interchange", ANSI X3.4, 1986.
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 46]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   [RFC2234]  Crocker, D. and P. Overell, "Augmented BNF for Syntax
+              Specifications: ABNF", RFC 2234, November 1997.
+
+   [STD63]    Yergeau, F., "UTF-8, a transformation format of
+              ISO 10646", STD 63, RFC 3629, November 2003.
+
+   [UCS]      International Organization for Standardization,
+              "Information Technology - Universal Multiple-Octet Coded
+              Character Set (UCS)", ISO/IEC 10646:2003, December 2003.
+
+10.2.  Informative References
+
+   [BCP19]    Freed, N. and J. Postel, "IANA Charset Registration
+              Procedures", BCP 19, RFC 2978, October 2000.
+
+   [BCP35]    Petke, R. and I. King, "Registration Procedures for URL
+              Scheme Names", BCP 35, RFC 2717, November 1999.
+
+   [RFC0952]  Harrenstien, K., Stahl, M., and E. Feinler, "DoD Internet
+              host table specification", RFC 952, October 1985.
+
+   [RFC1034]  Mockapetris, P., "Domain names - concepts and facilities",
+              STD 13, RFC 1034, November 1987.
+
+   [RFC1123]  Braden, R., "Requirements for Internet Hosts - Application
+              and Support", STD 3, RFC 1123, October 1989.
+
+   [RFC1535]  Gavron, E., "A Security Problem and Proposed Correction
+              With Widely Deployed DNS Software", RFC 1535,
+              October 1993.
+
+   [RFC1630]  Berners-Lee, T., "Universal Resource Identifiers in WWW: A
+              Unifying Syntax for the Expression of Names and Addresses
+              of Objects on the Network as used in the World-Wide Web",
+              RFC 1630, June 1994.
+
+   [RFC1736]  Kunze, J., "Functional Recommendations for Internet
+              Resource Locators", RFC 1736, February 1995.
+
+   [RFC1737]  Sollins, K. and L. Masinter, "Functional Requirements for
+              Uniform Resource Names", RFC 1737, December 1994.
+
+   [RFC1738]  Berners-Lee, T., Masinter, L., and M. McCahill, "Uniform
+              Resource Locators (URL)", RFC 1738, December 1994.
+
+   [RFC1808]  Fielding, R., "Relative Uniform Resource Locators",
+              RFC 1808, June 1995.
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 47]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   [RFC2046]  Freed, N. and N. Borenstein, "Multipurpose Internet Mail
+              Extensions (MIME) Part Two: Media Types", RFC 2046,
+              November 1996.
+
+   [RFC2141]  Moats, R., "URN Syntax", RFC 2141, May 1997.
+
+   [RFC2396]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
+              Resource Identifiers (URI): Generic Syntax", RFC 2396,
+              August 1998.
+
+   [RFC2518]  Goland, Y., Whitehead, E., Faizi, A., Carter, S., and D.
+              Jensen, "HTTP Extensions for Distributed Authoring --
+              WEBDAV", RFC 2518, February 1999.
+
+   [RFC2557]  Palme, J., Hopmann, A., and N. Shelness, "MIME
+              Encapsulation of Aggregate Documents, such as HTML
+              (MHTML)", RFC 2557, March 1999.
+
+   [RFC2718]  Masinter, L., Alvestrand, H., Zigmond, D., and R. Petke,
+              "Guidelines for new URL Schemes", RFC 2718, November 1999.
+
+   [RFC2732]  Hinden, R., Carpenter, B., and L. Masinter, "Format for
+              Literal IPv6 Addresses in URL's", RFC 2732, December 1999.
+
+   [RFC3305]  Mealling, M. and R. Denenberg, "Report from the Joint
+              W3C/IETF URI Planning Interest Group: Uniform Resource
+              Identifiers (URIs), URLs, and Uniform Resource Names
+              (URNs): Clarifications and Recommendations", RFC 3305,
+              August 2002.
+
+   [RFC3490]  Faltstrom, P., Hoffman, P., and A. Costello,
+              "Internationalizing Domain Names in Applications (IDNA)",
+              RFC 3490, March 2003.
+
+   [RFC3513]  Hinden, R. and S. Deering, "Internet Protocol Version 6
+              (IPv6) Addressing Architecture", RFC 3513, April 2003.
+
+   [Siedzik]  Siedzik, R., "Semantic Attacks: What's in a URL?",
+              April 2001, <http://www.giac.org/practical/gsec/
+              Richard_Siedzik_GSEC.pdf>.
+
+
+
+
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 48]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+Appendix A.  Collected ABNF for URI
+
+   URI           = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
+
+   hier-part     = "//" authority path-abempty
+                 / path-absolute
+                 / path-rootless
+                 / path-empty
+
+   URI-reference = URI / relative-ref
+
+   absolute-URI  = scheme ":" hier-part [ "?" query ]
+
+   relative-ref  = relative-part [ "?" query ] [ "#" fragment ]
+
+   relative-part = "//" authority path-abempty
+                 / path-absolute
+                 / path-noscheme
+                 / path-empty
+
+   scheme        = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
+
+   authority     = [ userinfo "@" ] host [ ":" port ]
+   userinfo      = *( unreserved / pct-encoded / sub-delims / ":" )
+   host          = IP-literal / IPv4address / reg-name
+   port          = *DIGIT
+
+   IP-literal    = "[" ( IPv6address / IPvFuture  ) "]"
+
+   IPvFuture     = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )
+
+   IPv6address   =                            6( h16 ":" ) ls32
+                 /                       "::" 5( h16 ":" ) ls32
+                 / [               h16 ] "::" 4( h16 ":" ) ls32
+                 / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
+                 / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
+                 / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
+                 / [ *4( h16 ":" ) h16 ] "::"              ls32
+                 / [ *5( h16 ":" ) h16 ] "::"              h16
+                 / [ *6( h16 ":" ) h16 ] "::"
+
+   h16           = 1*4HEXDIG
+   ls32          = ( h16 ":" h16 ) / IPv4address
+   IPv4address   = dec-octet "." dec-octet "." dec-octet "." dec-octet
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 49]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   dec-octet     = DIGIT                 ; 0-9
+                 / %x31-39 DIGIT         ; 10-99
+                 / "1" 2DIGIT            ; 100-199
+                 / "2" %x30-34 DIGIT     ; 200-249
+                 / "25" %x30-35          ; 250-255
+
+   reg-name      = *( unreserved / pct-encoded / sub-delims )
+
+   path          = path-abempty    ; begins with "/" or is empty
+                 / path-absolute   ; begins with "/" but not "//"
+                 / path-noscheme   ; begins with a non-colon segment
+                 / path-rootless   ; begins with a segment
+                 / path-empty      ; zero characters
+
+   path-abempty  = *( "/" segment )
+   path-absolute = "/" [ segment-nz *( "/" segment ) ]
+   path-noscheme = segment-nz-nc *( "/" segment )
+   path-rootless = segment-nz *( "/" segment )
+   path-empty    = 0<pchar>
+
+   segment       = *pchar
+   segment-nz    = 1*pchar
+   segment-nz-nc = 1*( unreserved / pct-encoded / sub-delims / "@" )
+                 ; non-zero-length segment without any colon ":"
+
+   pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
+
+   query         = *( pchar / "/" / "?" )
+
+   fragment      = *( pchar / "/" / "?" )
+
+   pct-encoded   = "%" HEXDIG HEXDIG
+
+   unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
+   reserved      = gen-delims / sub-delims
+   gen-delims    = ":" / "/" / "?" / "#" / "[" / "]" / "@"
+   sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
+                 / "*" / "+" / "," / ";" / "="
+
+Appendix B.  Parsing a URI Reference with a Regular Expression
+
+   As the "first-match-wins" algorithm is identical to the "greedy"
+   disambiguation method used by POSIX regular expressions, it is
+   natural and commonplace to use a regular expression for parsing the
+   potential five components of a URI reference.
+
+   The following line is the regular expression for breaking-down a
+   well-formed URI reference into its components.
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 50]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+      ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?
+       12            3  4          5       6  7        8 9
+
+   The numbers in the second line above are only to assist readability;
+   they indicate the reference points for each subexpression (i.e., each
+   paired parenthesis).  We refer to the value matched for subexpression
+   <n> as $<n>.  For example, matching the above expression to
+
+      http://www.ics.uci.edu/pub/ietf/uri/#Related
+
+   results in the following subexpression matches:
+
+      $1 = http:
+      $2 = http
+      $3 = //www.ics.uci.edu
+      $4 = www.ics.uci.edu
+      $5 = /pub/ietf/uri/
+      $6 = <undefined>
+      $7 = <undefined>
+      $8 = #Related
+      $9 = Related
+
+   where <undefined> indicates that the component is not present, as is
+   the case for the query component in the above example.  Therefore, we
+   can determine the value of the five components as
+
+      scheme    = $2
+      authority = $4
+      path      = $5
+      query     = $7
+      fragment  = $9
+
+   Going in the opposite direction, we can recreate a URI reference from
+   its components by using the algorithm of Section 5.3.
+
+Appendix C.  Delimiting a URI in Context
+
+   URIs are often transmitted through formats that do not provide a
+   clear context for their interpretation.  For example, there are many
+   occasions when a URI is included in plain text; examples include text
+   sent in email, USENET news, and on printed paper.  In such cases, it
+   is important to be able to delimit the URI from the rest of the text,
+   and in particular from punctuation marks that might be mistaken for
+   part of the URI.
+
+   In practice, URIs are delimited in a variety of ways, but usually
+   within double-quotes "http://example.com/", angle brackets
+   <http://example.com/>, or just by using whitespace:
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 51]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+      http://example.com/
+
+   These wrappers do not form part of the URI.
+
+   In some cases, extra whitespace (spaces, line-breaks, tabs, etc.) may
+   have to be added to break a long URI across lines.  The whitespace
+   should be ignored when the URI is extracted.
+
+   No whitespace should be introduced after a hyphen ("-") character.
+   Because some typesetters and printers may (erroneously) introduce a
+   hyphen at the end of line when breaking it, the interpreter of a URI
+   containing a line break immediately after a hyphen should ignore all
+   whitespace around the line break and should be aware that the hyphen
+   may or may not actually be part of the URI.
+
+   Using <> angle brackets around each URI is especially recommended as
+   a delimiting style for a reference that contains embedded whitespace.
+
+   The prefix "URL:" (with or without a trailing space) was formerly
+   recommended as a way to help distinguish a URI from other bracketed
+   designators, though it is not commonly used in practice and is no
+   longer recommended.
+
+   For robustness, software that accepts user-typed URI should attempt
+   to recognize and strip both delimiters and embedded whitespace.
+
+   For example, the text
+
+      Yes, Jim, I found it under "http://www.w3.org/Addressing/",
+      but you can probably pick it up from <ftp://foo.example.
+      com/rfc/>.  Note the warning in <http://www.ics.uci.edu/pub/
+      ietf/uri/historical.html#WARNING>.
+
+   contains the URI references
+
+      http://www.w3.org/Addressing/
+      ftp://foo.example.com/rfc/
+      http://www.ics.uci.edu/pub/ietf/uri/historical.html#WARNING
+
+
+
+
+
+
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 52]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+Appendix D.  Changes from RFC 2396
+
+D.1.  Additions
+
+   An ABNF rule for URI has been introduced to correspond to one common
+   usage of the term: an absolute URI with optional fragment.
+
+   IPv6 (and later) literals have been added to the list of possible
+   identifiers for the host portion of an authority component, as
+   described by [RFC2732], with the addition of "[" and "]" to the
+   reserved set and a version flag to anticipate future versions of IP
+   literals.  Square brackets are now specified as reserved within the
+   authority component and are not allowed outside their use as
+   delimiters for an IP literal within host.  In order to make this
+   change without changing the technical definition of the path, query,
+   and fragment components, those rules were redefined to directly
+   specify the characters allowed.
+
+   As [RFC2732] defers to [RFC3513] for definition of an IPv6 literal
+   address, which, unfortunately, lacks an ABNF description of
+   IPv6address, we created a new ABNF rule for IPv6address that matches
+   the text representations defined by Section 2.2 of [RFC3513].
+   Likewise, the definition of IPv4address has been improved in order to
+   limit each decimal octet to the range 0-255.
+
+   Section 6, on URI normalization and comparison, has been completely
+   rewritten and extended by using input from Tim Bray and discussion
+   within the W3C Technical Architecture Group.
+
+D.2.  Modifications
+
+   The ad-hoc BNF syntax of RFC 2396 has been replaced with the ABNF of
+   [RFC2234].  This change required all rule names that formerly
+   included underscore characters to be renamed with a dash instead.  In
+   addition, a number of syntax rules have been eliminated or simplified
+   to make the overall grammar more comprehensible.  Specifications that
+   refer to the obsolete grammar rules may be understood by replacing
+   those rules according to the following table:
+
+
+
+
+
+
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 53]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   +----------------+--------------------------------------------------+
+   | obsolete rule  | translation                                      |
+   +----------------+--------------------------------------------------+
+   | absoluteURI    | absolute-URI                                     |
+   | relativeURI    | relative-part [ "?" query ]                      |
+   | hier_part      | ( "//" authority path-abempty /                  |
+   |                | path-absolute ) [ "?" query ]                    |
+   |                |                                                  |
+   | opaque_part    | path-rootless [ "?" query ]                      |
+   | net_path       | "//" authority path-abempty                      |
+   | abs_path       | path-absolute                                    |
+   | rel_path       | path-rootless                                    |
+   | rel_segment    | segment-nz-nc                                    |
+   | reg_name       | reg-name                                         |
+   | server         | authority                                        |
+   | hostport       | host [ ":" port ]                                |
+   | hostname       | reg-name                                         |
+   | path_segments  | path-abempty                                     |
+   | param          | *<pchar excluding ";">                           |
+   |                |                                                  |
+   | uric           | unreserved / pct-encoded / ";" / "?" / ":"       |
+   |                |  / "@" / "&" / "=" / "+" / "$" / "," / "/"       |
+   |                |                                                  |
+   | uric_no_slash  | unreserved / pct-encoded / ";" / "?" / ":"       |
+   |                |  / "@" / "&" / "=" / "+" / "$" / ","             |
+   |                |                                                  |
+   | mark           | "-" / "_" / "." / "!" / "~" / "*" / "'"          |
+   |                |  / "(" / ")"                                     |
+   |                |                                                  |
+   | escaped        | pct-encoded                                      |
+   | hex            | HEXDIG                                           |
+   | alphanum       | ALPHA / DIGIT                                    |
+   +----------------+--------------------------------------------------+
+
+   Use of the above obsolete rules for the definition of scheme-specific
+   syntax is deprecated.
+
+   Section 2, on characters, has been rewritten to explain what
+   characters are reserved, when they are reserved, and why they are
+   reserved, even when they are not used as delimiters by the generic
+   syntax.  The mark characters that are typically unsafe to decode,
+   including the exclamation mark ("!"), asterisk ("*"), single-quote
+   ("'"), and open and close parentheses ("(" and ")"), have been moved
+   to the reserved set in order to clarify the distinction between
+   reserved and unreserved and, hopefully, to answer the most common
+   question of scheme designers.  Likewise, the section on
+   percent-encoded characters has been rewritten, and URI normalizers
+   are now given license to decode any percent-encoded octets
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 54]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   corresponding to unreserved characters.  In general, the terms
+   "escaped" and "unescaped" have been replaced with "percent-encoded"
+   and "decoded", respectively, to reduce confusion with other forms of
+   escape mechanisms.
+
+   The ABNF for URI and URI-reference has been redesigned to make them
+   more friendly to LALR parsers and to reduce complexity.  As a result,
+   the layout form of syntax description has been removed, along with
+   the uric, uric_no_slash, opaque_part, net_path, abs_path, rel_path,
+   path_segments, rel_segment, and mark rules.  All references to
+   "opaque" URIs have been replaced with a better description of how the
+   path component may be opaque to hierarchy.  The relativeURI rule has
+   been replaced with relative-ref to avoid unnecessary confusion over
+   whether they are a subset of URI.  The ambiguity regarding the
+   parsing of URI-reference as a URI or a relative-ref with a colon in
+   the first segment has been eliminated through the use of five
+   separate path matching rules.
+
+   The fragment identifier has been moved back into the section on
+   generic syntax components and within the URI and relative-ref rules,
+   though it remains excluded from absolute-URI.  The number sign ("#")
+   character has been moved back to the reserved set as a result of
+   reintegrating the fragment syntax.
+
+   The ABNF has been corrected to allow the path component to be empty.
+   This also allows an absolute-URI to consist of nothing after the
+   "scheme:", as is present in practice with the "dav:" namespace
+   [RFC2518] and with the "about:" scheme used internally by many WWW
+   browser implementations.  The ambiguity regarding the boundary
+   between authority and path has been eliminated through the use of
+   five separate path matching rules.
+
+   Registry-based naming authorities that use the generic syntax are now
+   defined within the host rule.  This change allows current
+   implementations, where whatever name provided is simply fed to the
+   local name resolution mechanism, to be consistent with the
+   specification.  It also removes the need to re-specify DNS name
+   formats here.  Furthermore, it allows the host component to contain
+   percent-encoded octets, which is necessary to enable
+   internationalized domain names to be provided in URIs, processed in
+   their native character encodings at the application layers above URI
+   processing, and passed to an IDNA library as a registered name in the
+   UTF-8 character encoding.  The server, hostport, hostname,
+   domainlabel, toplabel, and alphanum rules have been removed.
+
+   The resolving relative references algorithm of [RFC2396] has been
+   rewritten with pseudocode for this revision to improve clarity and
+   fix the following issues:
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 55]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   o  [RFC2396] section 5.2, step 6a, failed to account for a base URI
+      with no path.
+
+   o  Restored the behavior of [RFC1808] where, if the reference
+      contains an empty path and a defined query component, the target
+      URI inherits the base URI's path component.
+
+   o  The determination of whether a URI reference is a same-document
+      reference has been decoupled from the URI parser, simplifying the
+      URI processing interface within applications in a way consistent
+      with the internal architecture of deployed URI processing
+      implementations.  The determination is now based on comparison to
+      the base URI after transforming a reference to absolute form,
+      rather than on the format of the reference itself.  This change
+      may result in more references being considered "same-document"
+      under this specification than there would be under the rules given
+      in RFC 2396, especially when normalization is used to reduce
+      aliases.  However, it does not change the status of existing
+      same-document references.
+
+   o  Separated the path merge routine into two routines: merge, for
+      describing combination of the base URI path with a relative-path
+      reference, and remove_dot_segments, for describing how to remove
+      the special "." and ".." segments from a composed path.  The
+      remove_dot_segments algorithm is now applied to all URI reference
+      paths in order to match common implementations and to improve the
+      normalization of URIs in practice.  This change only impacts the
+      parsing of abnormal references and same-scheme references wherein
+      the base URI has a non-hierarchical path.
+
+Index
+
+   A
+      ABNF  11
+      absolute  27
+      absolute-path  26
+      absolute-URI  27
+      access  9
+      authority  17, 18
+
+   B
+      base URI  28
+
+   C
+      character encoding  4
+      character  4
+      characters  8, 11
+      coded character set  4
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 56]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   D
+      dec-octet  20
+      dereference  9
+      dot-segments  23
+
+   F
+      fragment  16, 24
+
+   G
+      gen-delims  13
+      generic syntax  6
+
+   H
+      h16  20
+      hier-part  16
+      hierarchical  10
+      host  18
+
+   I
+      identifier  5
+      IP-literal  19
+      IPv4  20
+      IPv4address  19, 20
+      IPv6  19
+      IPv6address  19, 20
+      IPvFuture  19
+
+   L
+      locator  7
+      ls32  20
+
+   M
+      merge  32
+
+   N
+      name  7
+      network-path  26
+
+   P
+      path  16, 22, 26
+         path-abempty  22
+         path-absolute  22
+         path-empty  22
+         path-noscheme  22
+         path-rootless  22
+      path-abempty  16, 22, 26
+      path-absolute  16, 22, 26
+      path-empty  16, 22, 26
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 57]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+      path-rootless  16, 22
+      pchar  23
+      pct-encoded  12
+      percent-encoding  12
+      port  22
+
+   Q
+      query  16, 23
+
+   R
+      reg-name  21
+      registered name  20
+      relative  10, 28
+      relative-path  26
+      relative-ref  26
+      remove_dot_segments  33
+      representation  9
+      reserved  12
+      resolution  9, 28
+      resource  5
+      retrieval  9
+
+   S
+      same-document  27
+      sameness  9
+      scheme  16, 17
+      segment  22, 23
+         segment-nz  23
+         segment-nz-nc  23
+      sub-delims  13
+      suffix  27
+
+   T
+      transcription  8
+
+   U
+      uniform  4
+      unreserved  13
+      URI grammar
+         absolute-URI  27
+         ALPHA  11
+         authority  18
+         CR  11
+         dec-octet  20
+         DIGIT  11
+         DQUOTE  11
+         fragment  24
+         gen-delims  13
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 58]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+         h16  20
+         HEXDIG  11
+         hier-part  16
+         host  19
+         IP-literal  19
+         IPv4address  20
+         IPv6address  20
+         IPvFuture  19
+         LF  11
+         ls32  20
+         OCTET  11
+         path  22
+         path-abempty  22
+         path-absolute  22
+         path-empty  22
+         path-noscheme  22
+         path-rootless  22
+         pchar  23
+         pct-encoded  12
+         port  22
+         query  24
+         reg-name  21
+         relative-ref  26
+         reserved  13
+         scheme  17
+         segment  23
+         segment-nz  23
+         segment-nz-nc  23
+         SP  11
+         sub-delims  13
+         unreserved  13
+         URI  16
+         URI-reference  25
+         userinfo  18
+      URI  16
+      URI-reference  25
+      URL  7
+      URN  7
+      userinfo  18
+
+
+
+
+
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 59]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+Authors' Addresses
+
+   Tim Berners-Lee
+   World Wide Web Consortium
+   Massachusetts Institute of Technology
+   77 Massachusetts Avenue
+   Cambridge, MA  02139
+   USA
+
+   Phone: +1-617-253-5702
+   Fax:   +1-617-258-5999
+   EMail: timbl@w3.org
+   URI:   http://www.w3.org/People/Berners-Lee/
+
+
+   Roy T. Fielding
+   Day Software
+   5251 California Ave., Suite 110
+   Irvine, CA  92617
+   USA
+
+   Phone: +1-949-679-2960
+   Fax:   +1-949-679-2972
+   EMail: fielding@gbiv.com
+   URI:   http://roy.gbiv.com/
+
+
+   Larry Masinter
+   Adobe Systems Incorporated
+   345 Park Ave
+   San Jose, CA  95110
+   USA
+
+   Phone: +1-408-536-3024
+   EMail: LMM@acm.org
+   URI:   http://larry.masinter.net/
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 60]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+Full Copyright Statement
+
+   Copyright (C) The Internet Society (2005).
+
+   This document is subject to the rights, licenses and restrictions
+   contained in BCP 78, and except as set forth therein, the authors
+   retain all their rights.
+
+   This document and the information contained herein are provided on an
+   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
+   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET
+   ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,
+   INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
+   INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
+
+Intellectual Property
+
+   The IETF takes no position regarding the validity or scope of any
+   Intellectual Property Rights or other rights that might be claimed to
+   pertain to the implementation or use of the technology described in
+   this document or the extent to which any license under such rights
+   might or might not be available; nor does it represent that it has
+   made any independent effort to identify any such rights.  Information
+   on the IETF's procedures with respect to rights in IETF Documents can
+   be found in BCP 78 and BCP 79.
+
+   Copies of IPR disclosures made to the IETF Secretariat and any
+   assurances of licenses to be made available, or the result of an
+   attempt made to obtain a general license or permission for the use of
+   such proprietary rights by implementers or users of this
+   specification can be obtained from the IETF on-line IPR repository at
+   http://www.ietf.org/ipr.
+
+   The IETF invites any interested party to bring to its attention any
+   copyrights, patents or patent applications, or other proprietary
+   rights that may cover technology that may be required to implement
+   this standard.  Please address the information to the IETF at ietf-
+   ipr@ietf.org.
+
+
+Acknowledgement
+
+   Funding for the RFC Editor function is currently provided by the
+   Internet Society.
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 61]
+
diff -urN dovecot-1.2.4/dovecot-libsieve/doc/rfc/utf-8.rfc3629.txt dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/utf-8.rfc3629.txt
--- dovecot-1.2.4/dovecot-libsieve/doc/rfc/utf-8.rfc3629.txt	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/utf-8.rfc3629.txt	2008-07-18 12:11:28.000000000 +0200
@@ -0,0 +1,787 @@
+
+
+
+
+
+
+Network Working Group                                         F. Yergeau
+Request for Comments: 3629                             Alis Technologies
+STD: 63                                                    November 2003
+Obsoletes: 2279
+Category: Standards Track
+
+
+              UTF-8, a transformation format of ISO 10646
+
+Status of this Memo
+
+   This document specifies an Internet standards track protocol for the
+   Internet community, and requests discussion and suggestions for
+   improvements.  Please refer to the current edition of the "Internet
+   Official Protocol Standards" (STD 1) for the standardization state
+   and status of this protocol.  Distribution of this memo is unlimited.
+
+Copyright Notice
+
+   Copyright (C) The Internet Society (2003).  All Rights Reserved.
+
+Abstract
+
+   ISO/IEC 10646-1 defines a large character set called the Universal
+   Character Set (UCS) which encompasses most of the world's writing
+   systems.  The originally proposed encodings of the UCS, however, were
+   not compatible with many current applications and protocols, and this
+   has led to the development of UTF-8, the object of this memo.  UTF-8
+   has the characteristic of preserving the full US-ASCII range,
+   providing compatibility with file systems, parsers and other software
+   that rely on US-ASCII values but are transparent to other values.
+   This memo obsoletes and replaces RFC 2279.
+
+Table of Contents
+
+   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  2
+   2.  Notational conventions . . . . . . . . . . . . . . . . . . . .  3
+   3.  UTF-8 definition . . . . . . . . . . . . . . . . . . . . . . .  4
+   4.  Syntax of UTF-8 Byte Sequences . . . . . . . . . . . . . . . .  5
+   5.  Versions of the standards  . . . . . . . . . . . . . . . . . .  6
+   6.  Byte order mark (BOM)  . . . . . . . . . . . . . . . . . . . .  6
+   7.  Examples . . . . . . . . . . . . . . . . . . . . . . . . . . .  8
+   8.  MIME registration  . . . . . . . . . . . . . . . . . . . . . .  9
+   9.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 10
+   10. Security Considerations  . . . . . . . . . . . . . . . . . . . 10
+   11. Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 11
+   12. Changes from RFC 2279  . . . . . . . . . . . . . . . . . . . . 11
+   13. Normative References . . . . . . . . . . . . . . . . . . . . . 12
+
+
+
+Yergeau                     Standards Track                     [Page 1]
+
+RFC 3629                         UTF-8                     November 2003
+
+
+   14. Informative References . . . . . . . . . . . . . . . . . . . . 12
+   15. URI's  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
+   16. Intellectual Property Statement  . . . . . . . . . . . . . . . 13
+   17. Author's Address . . . . . . . . . . . . . . . . . . . . . . . 13
+   18. Full Copyright Statement . . . . . . . . . . . . . . . . . . . 14
+
+1. Introduction
+
+   ISO/IEC 10646 [ISO.10646] defines a large character set called the
+   Universal Character Set (UCS), which encompasses most of the world's
+   writing systems.  The same set of characters is defined by the
+   Unicode standard [UNICODE], which further defines additional
+   character properties and other application details of great interest
+   to implementers.  Up to the present time, changes in Unicode and
+   amendments and additions to ISO/IEC 10646 have tracked each other, so
+   that the character repertoires and code point assignments have
+   remained in sync.  The relevant standardization committees have
+   committed to maintain this very useful synchronism.
+
+   ISO/IEC 10646 and Unicode define several encoding forms of their
+   common repertoire: UTF-8, UCS-2, UTF-16, UCS-4 and UTF-32.  In an
+   encoding form, each character is represented as one or more encoding
+   units.  All standard UCS encoding forms except UTF-8 have an encoding
+   unit larger than one octet, making them hard to use in many current
+   applications and protocols that assume 8 or even 7 bit characters.
+
+   UTF-8, the object of this memo, has a one-octet encoding unit.  It
+   uses all bits of an octet, but has the quality of preserving the full
+   US-ASCII [US-ASCII] range: US-ASCII characters are encoded in one
+   octet having the normal US-ASCII value, and any octet with such a
+   value can only stand for a US-ASCII character, and nothing else.
+
+   UTF-8 encodes UCS characters as a varying number of octets, where the
+   number of octets, and the value of each, depend on the integer value
+   assigned to the character in ISO/IEC 10646 (the character number,
+   a.k.a. code position, code point or Unicode scalar value).  This
+   encoding form has the following characteristics (all values are in
+   hexadecimal):
+
+   o  Character numbers from U+0000 to U+007F (US-ASCII repertoire)
+      correspond to octets 00 to 7F (7 bit US-ASCII values).  A direct
+      consequence is that a plain ASCII string is also a valid UTF-8
+      string.
+
+
+
+
+
+
+
+
+Yergeau                     Standards Track                     [Page 2]
+
+RFC 3629                         UTF-8                     November 2003
+
+
+   o  US-ASCII octet values do not appear otherwise in a UTF-8 encoded
+      character stream.  This provides compatibility with file systems
+      or other software (e.g., the printf() function in C libraries)
+      that parse based on US-ASCII values but are transparent to other
+      values.
+
+   o  Round-trip conversion is easy between UTF-8 and other encoding
+      forms.
+
+   o  The first octet of a multi-octet sequence indicates the number of
+      octets in the sequence.
+
+   o  The octet values C0, C1, F5 to FF never appear.
+
+   o  Character boundaries are easily found from anywhere in an octet
+      stream.
+
+   o  The byte-value lexicographic sorting order of UTF-8 strings is the
+      same as if ordered by character numbers.  Of course this is of
+      limited interest since a sort order based on character numbers is
+      almost never culturally valid.
+
+   o  The Boyer-Moore fast search algorithm can be used with UTF-8 data.
+
+   o  UTF-8 strings can be fairly reliably recognized as such by a
+      simple algorithm, i.e., the probability that a string of
+      characters in any other encoding appears as valid UTF-8 is low,
+      diminishing with increasing string length.
+
+   UTF-8 was devised in September 1992 by Ken Thompson, guided by design
+   criteria specified by Rob Pike, with the objective of defining a UCS
+   transformation format usable in the Plan9 operating system in a non-
+   disruptive manner.  Thompson's design was stewarded through
+   standardization by the X/Open Joint Internationalization Group XOJIG
+   (see [FSS_UTF]), bearing the names FSS-UTF (variant FSS/UTF), UTF-2
+   and finally UTF-8 along the way.
+
+2.  Notational conventions
+
+   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
+   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
+   document are to be interpreted as described in [RFC2119].
+
+   UCS characters are designated by the U+HHHH notation, where HHHH is a
+   string of from 4 to 6 hexadecimal digits representing the character
+   number in ISO/IEC 10646.
+
+
+
+
+
+Yergeau                     Standards Track                     [Page 3]
+
+RFC 3629                         UTF-8                     November 2003
+
+
+3.  UTF-8 definition
+
+   UTF-8 is defined by the Unicode Standard [UNICODE].  Descriptions and
+   formulae can also be found in Annex D of ISO/IEC 10646-1 [ISO.10646]
+
+   In UTF-8, characters from the U+0000..U+10FFFF range (the UTF-16
+   accessible range) are encoded using sequences of 1 to 4 octets.  The
+   only octet of a "sequence" of one has the higher-order bit set to 0,
+   the remaining 7 bits being used to encode the character number.  In a
+   sequence of n octets, n>1, the initial octet has the n higher-order
+   bits set to 1, followed by a bit set to 0.  The remaining bit(s) of
+   that octet contain bits from the number of the character to be
+   encoded.  The following octet(s) all have the higher-order bit set to
+   1 and the following bit set to 0, leaving 6 bits in each to contain
+   bits from the character to be encoded.
+
+   The table below summarizes the format of these different octet types.
+   The letter x indicates bits available for encoding bits of the
+   character number.
+
+   Char. number range  |        UTF-8 octet sequence
+      (hexadecimal)    |              (binary)
+   --------------------+---------------------------------------------
+   0000 0000-0000 007F | 0xxxxxxx
+   0000 0080-0000 07FF | 110xxxxx 10xxxxxx
+   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
+   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
+
+   Encoding a character to UTF-8 proceeds as follows:
+
+   1.  Determine the number of octets required from the character number
+       and the first column of the table above.  It is important to note
+       that the rows of the table are mutually exclusive, i.e., there is
+       only one valid way to encode a given character.
+
+   2.  Prepare the high-order bits of the octets as per the second
+       column of the table.
+
+   3.  Fill in the bits marked x from the bits of the character number,
+       expressed in binary.  Start by putting the lowest-order bit of
+       the character number in the lowest-order position of the last
+       octet of the sequence, then put the next higher-order bit of the
+       character number in the next higher-order position of that octet,
+       etc.  When the x bits of the last octet are filled in, move on to
+       the next to last octet, then to the preceding one, etc. until all
+       x bits are filled in.
+
+
+
+
+
+Yergeau                     Standards Track                     [Page 4]
+
+RFC 3629                         UTF-8                     November 2003
+
+
+   The definition of UTF-8 prohibits encoding character numbers between
+   U+D800 and U+DFFF, which are reserved for use with the UTF-16
+   encoding form (as surrogate pairs) and do not directly represent
+   characters.  When encoding in UTF-8 from UTF-16 data, it is necessary
+   to first decode the UTF-16 data to obtain character numbers, which
+   are then encoded in UTF-8 as described above.  This contrasts with
+   CESU-8 [CESU-8], which is a UTF-8-like encoding that is not meant for
+   use on the Internet.  CESU-8 operates similarly to UTF-8 but encodes
+   the UTF-16 code values (16-bit quantities) instead of the character
+   number (code point).  This leads to different results for character
+   numbers above 0xFFFF; the CESU-8 encoding of those characters is NOT
+   valid UTF-8.
+
+   Decoding a UTF-8 character proceeds as follows:
+
+   1.  Initialize a binary number with all bits set to 0.  Up to 21 bits
+       may be needed.
+
+   2.  Determine which bits encode the character number from the number
+       of octets in the sequence and the second column of the table
+       above (the bits marked x).
+
+   3.  Distribute the bits from the sequence to the binary number, first
+       the lower-order bits from the last octet of the sequence and
+       proceeding to the left until no x bits are left.  The binary
+       number is now equal to the character number.
+
+   Implementations of the decoding algorithm above MUST protect against
+   decoding invalid sequences.  For instance, a naive implementation may
+   decode the overlong UTF-8 sequence C0 80 into the character U+0000,
+   or the surrogate pair ED A1 8C ED BE B4 into U+233B4.  Decoding
+   invalid sequences may have security consequences or cause other
+   problems.  See Security Considerations (Section 10) below.
+
+4.  Syntax of UTF-8 Byte Sequences
+
+   For the convenience of implementors using ABNF, a definition of UTF-8
+   in ABNF syntax is given here.
+
+   A UTF-8 string is a sequence of octets representing a sequence of UCS
+   characters.  An octet sequence is valid UTF-8 only if it matches the
+   following syntax, which is derived from the rules for encoding UTF-8
+   and is expressed in the ABNF of [RFC2234].
+
+   UTF8-octets = *( UTF8-char )
+   UTF8-char   = UTF8-1 / UTF8-2 / UTF8-3 / UTF8-4
+   UTF8-1      = %x00-7F
+   UTF8-2      = %xC2-DF UTF8-tail
+
+
+
+Yergeau                     Standards Track                     [Page 5]
+
+RFC 3629                         UTF-8                     November 2003
+
+
+   UTF8-3      = %xE0 %xA0-BF UTF8-tail / %xE1-EC 2( UTF8-tail ) /
+                 %xED %x80-9F UTF8-tail / %xEE-EF 2( UTF8-tail )
+   UTF8-4      = %xF0 %x90-BF 2( UTF8-tail ) / %xF1-F3 3( UTF8-tail ) /
+                 %xF4 %x80-8F 2( UTF8-tail )
+   UTF8-tail   = %x80-BF
+
+   NOTE -- The authoritative definition of UTF-8 is in [UNICODE].  This
+   grammar is believed to describe the same thing Unicode describes, but
+   does not claim to be authoritative.  Implementors are urged to rely
+   on the authoritative source, rather than on this ABNF.
+
+5.  Versions of the standards
+
+   ISO/IEC 10646 is updated from time to time by publication of
+   amendments and additional parts; similarly, new versions of the
+   Unicode standard are published over time.  Each new version obsoletes
+   and replaces the previous one, but implementations, and more
+   significantly data, are not updated instantly.
+
+   In general, the changes amount to adding new characters, which does
+   not pose particular problems with old data.  In 1996, Amendment 5 to
+   the 1993 edition of ISO/IEC 10646 and Unicode 2.0 moved and expanded
+   the Korean Hangul block, thereby making any previous data containing
+   Hangul characters invalid under the new version.  Unicode 2.0 has the
+   same difference from Unicode 1.1.  The justification for allowing
+   such an incompatible change was that there were no major
+   implementations and no significant amounts of data containing Hangul.
+   The incident has been dubbed the "Korean mess", and the relevant
+   committees have pledged to never, ever again make such an
+   incompatible change (see Unicode Consortium Policies [1]).
+
+   New versions, and in particular any incompatible changes, have
+   consequences regarding MIME charset labels, to be discussed in MIME
+   registration (Section 8).
+
+6.  Byte order mark (BOM)
+
+   The UCS character U+FEFF "ZERO WIDTH NO-BREAK SPACE" is also known
+   informally as "BYTE ORDER MARK" (abbreviated "BOM").  This character
+   can be used as a genuine "ZERO WIDTH NO-BREAK SPACE" within text, but
+   the BOM name hints at a second possible usage of the character:  to
+   prepend a U+FEFF character to a stream of UCS characters as a
+   "signature".  A receiver of such a serialized stream may then use the
+   initial character as a hint that the stream consists of UCS
+   characters and also to recognize which UCS encoding is involved and,
+   with encodings having a multi-octet encoding unit, as a way to
+
+
+
+
+
+Yergeau                     Standards Track                     [Page 6]
+
+RFC 3629                         UTF-8                     November 2003
+
+
+   recognize the serialization order of the octets.  UTF-8 having a
+   single-octet encoding unit, this last function is useless and the BOM
+   will always appear as the octet sequence EF BB BF.
+
+   It is important to understand that the character U+FEFF appearing at
+   any position other than the beginning of a stream MUST be interpreted
+   with the semantics for the zero-width non-breaking space, and MUST
+   NOT be interpreted as a signature.  When interpreted as a signature,
+   the Unicode standard suggests than an initial U+FEFF character may be
+   stripped before processing the text.  Such stripping is necessary in
+   some cases (e.g., when concatenating two strings, because otherwise
+   the resulting string may contain an unintended "ZERO WIDTH NO-BREAK
+   SPACE" at the connection point), but might affect an external process
+   at a different layer (such as a digital signature or a count of the
+   characters) that is relying on the presence of all characters in the
+   stream.  It is therefore RECOMMENDED to avoid stripping an initial
+   U+FEFF interpreted as a signature without a good reason, to ignore it
+   instead of stripping it when appropriate (such as for display) and to
+   strip it only when really necessary.
+
+   U+FEFF in the first position of a stream MAY be interpreted as a
+   zero-width non-breaking space, and is not always a signature.  In an
+   attempt at diminishing this uncertainty, Unicode 3.2 adds a new
+   character, U+2060 "WORD JOINER", with exactly the same semantics and
+   usage as U+FEFF except for the signature function, and strongly
+   recommends its exclusive use for expressing word-joining semantics.
+   Eventually, following this recommendation will make it all but
+   certain that any initial U+FEFF is a signature, not an intended "ZERO
+   WIDTH NO-BREAK SPACE".
+
+   In the meantime, the uncertainty unfortunately remains and may affect
+   Internet protocols.  Protocol specifications MAY restrict usage of
+   U+FEFF as a signature in order to reduce or eliminate the potential
+   ill effects of this uncertainty.  In the interest of striking a
+   balance between the advantages (reduction of uncertainty) and
+   drawbacks (loss of the signature function) of such restrictions, it
+   is useful to distinguish a few cases:
+
+   o  A protocol SHOULD forbid use of U+FEFF as a signature for those
+      textual protocol elements that the protocol mandates to be always
+      UTF-8, the signature function being totally useless in those
+      cases.
+
+   o  A protocol SHOULD also forbid use of U+FEFF as a signature for
+      those textual protocol elements for which the protocol provides
+      character encoding identification mechanisms, when it is expected
+      that implementations of the protocol will be in a position to
+      always use the mechanisms properly.  This will be the case when
+
+
+
+Yergeau                     Standards Track                     [Page 7]
+
+RFC 3629                         UTF-8                     November 2003
+
+
+      the protocol elements are maintained tightly under the control of
+      the implementation from the time of their creation to the time of
+      their (properly labeled) transmission.
+
+   o  A protocol SHOULD NOT forbid use of U+FEFF as a signature for
+      those textual protocol elements for which the protocol does not
+      provide character encoding identification mechanisms, when a ban
+      would be unenforceable, or when it is expected that
+      implementations of the protocol will not be in a position to
+      always use the mechanisms properly.  The latter two cases are
+      likely to occur with larger protocol elements such as MIME
+      entities, especially when implementations of the protocol will
+      obtain such entities from file systems, from protocols that do not
+      have encoding identification mechanisms for payloads (such as FTP)
+      or from other protocols that do not guarantee proper
+      identification of character encoding (such as HTTP).
+
+   When a protocol forbids use of U+FEFF as a signature for a certain
+   protocol element, then any initial U+FEFF in that protocol element
+   MUST be interpreted as a "ZERO WIDTH NO-BREAK SPACE".  When a
+   protocol does NOT forbid use of U+FEFF as a signature for a certain
+   protocol element, then implementations SHOULD be prepared to handle a
+   signature in that element and react appropriately: using the
+   signature to identify the character encoding as necessary and
+   stripping or ignoring the signature as appropriate.
+
+7.  Examples
+
+   The character sequence U+0041 U+2262 U+0391 U+002E "A<NOT IDENTICAL
+   TO><ALPHA>." is encoded in UTF-8 as follows:
+
+       --+--------+-----+--
+       41 E2 89 A2 CE 91 2E
+       --+--------+-----+--
+
+   The character sequence U+D55C U+AD6D U+C5B4 (Korean "hangugeo",
+   meaning "the Korean language") is encoded in UTF-8 as follows:
+
+       --------+--------+--------
+       ED 95 9C EA B5 AD EC 96 B4
+       --------+--------+--------
+
+   The character sequence U+65E5 U+672C U+8A9E (Japanese "nihongo",
+   meaning "the Japanese language") is encoded in UTF-8 as follows:
+
+       --------+--------+--------
+       E6 97 A5 E6 9C AC E8 AA 9E
+       --------+--------+--------
+
+
+
+Yergeau                     Standards Track                     [Page 8]
+
+RFC 3629                         UTF-8                     November 2003
+
+
+   The character U+233B4 (a Chinese character meaning 'stump of tree'),
+   prepended with a UTF-8 BOM, is encoded in UTF-8 as follows:
+
+       --------+-----------
+       EF BB BF F0 A3 8E B4
+       --------+-----------
+
+8.  MIME registration
+
+   This memo serves as the basis for registration of the MIME charset
+   parameter for UTF-8, according to [RFC2978].  The charset parameter
+   value is "UTF-8".  This string labels media types containing text
+   consisting of characters from the repertoire of ISO/IEC 10646
+   including all amendments at least up to amendment 5 of the 1993
+   edition (Korean block), encoded to a sequence of octets using the
+   encoding scheme outlined above.  UTF-8 is suitable for use in MIME
+   content types under the "text" top-level type.
+
+   It is noteworthy that the label "UTF-8" does not contain a version
+   identification, referring generically to ISO/IEC 10646.  This is
+   intentional, the rationale being as follows:
+
+   A MIME charset label is designed to give just the information needed
+   to interpret a sequence of bytes received on the wire into a sequence
+   of characters, nothing more (see [RFC2045], section 2.2).  As long as
+   a character set standard does not change incompatibly, version
+   numbers serve no purpose, because one gains nothing by learning from
+   the tag that newly assigned characters may be received that one
+   doesn't know about.  The tag itself doesn't teach anything about the
+   new characters, which are going to be received anyway.
+
+   Hence, as long as the standards evolve compatibly, the apparent
+   advantage of having labels that identify the versions is only that,
+   apparent.  But there is a disadvantage to such version-dependent
+   labels: when an older application receives data accompanied by a
+   newer, unknown label, it may fail to recognize the label and be
+   completely unable to deal with the data, whereas a generic, known
+   label would have triggered mostly correct processing of the data,
+   which may well not contain any new characters.
+
+   Now the "Korean mess" (ISO/IEC 10646 amendment 5) is an incompatible
+   change, in principle contradicting the appropriateness of a version
+   independent MIME charset label as described above.  But the
+   compatibility problem can only appear with data containing Korean
+   Hangul characters encoded according to Unicode 1.1 (or equivalently
+   ISO/IEC 10646 before amendment 5), and there is arguably no such data
+   to worry about, this being the very reason the incompatible change
+   was deemed acceptable.
+
+
+
+Yergeau                     Standards Track                     [Page 9]
+
+RFC 3629                         UTF-8                     November 2003
+
+
+   In practice, then, a version-independent label is warranted, provided
+   the label is understood to refer to all versions after Amendment 5,
+   and provided no incompatible change actually occurs.  Should
+   incompatible changes occur in a later version of ISO/IEC 10646, the
+   MIME charset label defined here will stay aligned with the previous
+   version until and unless the IETF specifically decides otherwise.
+
+9.  IANA Considerations
+
+   The entry for UTF-8 in the IANA charset registry has been updated to
+   point to this memo.
+
+10.  Security Considerations
+
+   Implementers of UTF-8 need to consider the security aspects of how
+   they handle illegal UTF-8 sequences.  It is conceivable that in some
+   circumstances an attacker would be able to exploit an incautious
+   UTF-8 parser by sending it an octet sequence that is not permitted by
+   the UTF-8 syntax.
+
+   A particularly subtle form of this attack can be carried out against
+   a parser which performs security-critical validity checks against the
+   UTF-8 encoded form of its input, but interprets certain illegal octet
+   sequences as characters.  For example, a parser might prohibit the
+   NUL character when encoded as the single-octet sequence 00, but
+   erroneously allow the illegal two-octet sequence C0 80 and interpret
+   it as a NUL character.  Another example might be a parser which
+   prohibits the octet sequence 2F 2E 2E 2F ("/../"), yet permits the
+   illegal octet sequence 2F C0 AE 2E 2F.  This last exploit has
+   actually been used in a widespread virus attacking Web servers in
+   2001; thus, the security threat is very real.
+
+   Another security issue occurs when encoding to UTF-8: the ISO/IEC
+   10646 description of UTF-8 allows encoding character numbers up to
+   U+7FFFFFFF, yielding sequences of up to 6 bytes.  There is therefore
+   a risk of buffer overflow if the range of character numbers is not
+   explicitly limited to U+10FFFF or if buffer sizing doesn't take into
+   account the possibility of 5- and 6-byte sequences.
+
+   Security may also be impacted by a characteristic of several
+   character encodings, including UTF-8: the "same thing" (as far as a
+   user can tell) can be represented by several distinct character
+   sequences.  For instance, an e with acute accent can be represented
+   by the precomposed U+00E9 E ACUTE character or by the canonically
+   equivalent sequence U+0065 U+0301 (E + COMBINING ACUTE).  Even though
+   UTF-8 provides a single byte sequence for each character sequence,
+   the existence of multiple character sequences for "the same thing"
+   may have security consequences whenever string matching, indexing,
+
+
+
+Yergeau                     Standards Track                    [Page 10]
+
+RFC 3629                         UTF-8                     November 2003
+
+
+   searching, sorting, regular expression matching and selection are
+   involved.  An example would be string matching of an identifier
+   appearing in a credential and in access control list entries.  This
+   issue is amenable to solutions based on Unicode Normalization Forms,
+   see [UAX15].
+
+11.  Acknowledgements
+
+   The following have participated in the drafting and discussion of
+   this memo: James E. Agenbroad, Harald Alvestrand, Andries Brouwer,
+   Mark Davis, Martin J. Duerst, Patrick Faltstrom, Ned Freed, David
+   Goldsmith, Tony Hansen, Edwin F. Hart, Paul Hoffman, David Hopwood,
+   Simon Josefsson, Kent Karlsson, Dan Kohn, Markus Kuhn, Michael Kung,
+   Alain LaBonte, Ira McDonald, Alexey Melnikov, MURATA Makoto, John
+   Gardiner Myers, Chris Newman, Dan Oscarsson, Roozbeh Pournader,
+   Murray Sargent, Markus Scherer, Keld Simonsen, Arnold Winkler,
+   Kenneth Whistler and Misha Wolf.
+
+12.  Changes from RFC 2279
+
+   o  Restricted the range of characters to 0000-10FFFF (the UTF-16
+      accessible range).
+
+   o  Made Unicode the source of the normative definition of UTF-8,
+      keeping ISO/IEC 10646 as the reference for characters.
+
+   o  Straightened out terminology.  UTF-8 now described in terms of an
+      encoding form of the character number.  UCS-2 and UCS-4 almost
+      disappeared.
+
+   o  Turned the note warning against decoding of invalid sequences into
+      a normative MUST NOT.
+
+   o  Added a new section about the UTF-8 BOM, with advice for
+      protocols.
+
+   o  Removed suggested UNICODE-1-1-UTF-8 MIME charset registration.
+
+   o  Added an ABNF syntax for valid UTF-8 octet sequences
+
+   o  Expanded Security Considerations section, in particular impact of
+      Unicode normalization
+
+
+
+
+
+
+
+
+
+Yergeau                     Standards Track                    [Page 11]
+
+RFC 3629                         UTF-8                     November 2003
+
+
+13.  Normative References
+
+   [RFC2119]   Bradner, S., "Key words for use in RFCs to Indicate
+               Requirement Levels", BCP 14, RFC 2119, March 1997.
+
+   [ISO.10646] International Organization for Standardization,
+               "Information Technology - Universal Multiple-octet coded
+               Character Set (UCS)", ISO/IEC Standard 10646,  comprised
+               of ISO/IEC 10646-1:2000, "Information technology --
+               Universal Multiple-Octet Coded Character Set (UCS) --
+               Part 1: Architecture and Basic Multilingual Plane",
+               ISO/IEC 10646-2:2001, "Information technology --
+               Universal Multiple-Octet Coded Character Set (UCS) --
+               Part 2:  Supplementary Planes" and ISO/IEC 10646-
+               1:2000/Amd 1:2002, "Mathematical symbols and other
+               characters".
+
+   [UNICODE]   The Unicode Consortium, "The Unicode Standard -- Version
+               4.0",  defined by The Unicode Standard, Version 4.0
+               (Boston, MA, Addison-Wesley, 2003.  ISBN 0-321-18578-1),
+               April 2003, <http://www.unicode.org/unicode/standard/
+               versions/enumeratedversions.html#Unicode_4_0_0>.
+
+14.  Informative References
+
+   [CESU-8]    Phipps, T., "Unicode Technical Report #26: Compatibility
+               Encoding Scheme for UTF-16: 8-Bit (CESU-8)", UTR 26,
+               April 2002,
+               <http://www.unicode.org/unicode/reports/tr26/>.
+
+   [FSS_UTF]   X/Open Company Ltd., "X/Open Preliminary Specification --
+               File System Safe UCS Transformation Format (FSS-UTF)",
+               May 1993, <http://wwwold.dkuug.dk/jtc1/sc22/wg20/docs/
+               N193-FSS-UTF.pdf>.
+
+   [RFC2045]   Freed, N. and N. Borenstein, "Multipurpose Internet Mail
+               Extensions (MIME) Part One: Format of Internet Message
+               Bodies", RFC 2045, November 1996.
+
+   [RFC2234]   Crocker, D. and P. Overell, "Augmented BNF for Syntax
+               Specifications: ABNF", RFC 2234, November 1997.
+
+   [RFC2978]   Freed, N. and J. Postel, "IANA Charset Registration
+               Procedures", BCP 19, RFC 2978, October 2000.
+
+
+
+
+
+
+
+Yergeau                     Standards Track                    [Page 12]
+
+RFC 3629                         UTF-8                     November 2003
+
+
+   [UAX15]     Davis, M. and M. Duerst, "Unicode Standard Annex #15:
+               Unicode Normalization Forms",  An integral part of The
+               Unicode Standard, Version 4.0.0, April 2003, <http://
+               www.unicode.org/unicode/reports/tr15>.
+
+   [US-ASCII]  American National Standards Institute, "Coded Character
+               Set - 7-bit American Standard Code for Information
+               Interchange", ANSI X3.4, 1986.
+
+15.  URIs
+
+   [1]  <http://www.unicode.org/unicode/standard/policies.html>
+
+16.  Intellectual Property Statement
+
+   The IETF takes no position regarding the validity or scope of any
+   intellectual property or other rights that might be claimed to
+   pertain to the implementation or use of the technology described in
+   this document or the extent to which any license under such rights
+   might or might not be available; neither does it represent that it
+   has made any effort to identify any such rights.  Information on the
+   IETF's procedures with respect to rights in standards-track and
+   standards-related documentation can be found in BCP-11.  Copies of
+   claims of rights made available for publication and any assurances of
+   licenses to be made available, or the result of an attempt made to
+   obtain a general license or permission for the use of such
+   proprietary rights by implementors or users of this specification can
+   be obtained from the IETF Secretariat.
+
+   The IETF invites any interested party to bring to its attention any
+   copyrights, patents or patent applications, or other proprietary
+   rights which may cover technology that may be required to practice
+   this standard.  Please address the information to the IETF Executive
+   Director.
+
+17.  Author's Address
+
+   Francois Yergeau
+   Alis Technologies
+   100, boul. Alexis-Nihon, bureau 600
+   Montreal, QC  H4M 2P2
+   Canada
+
+   Phone: +1 514 747 2547
+   Fax:   +1 514 747 2561
+   EMail: fyergeau@alis.com
+
+
+
+
+
+Yergeau                     Standards Track                    [Page 13]
+
+RFC 3629                         UTF-8                     November 2003
+
+
+18.  Full Copyright Statement
+
+   Copyright (C) The Internet Society (2003).  All Rights Reserved.
+
+   This document and translations of it may be copied and furnished to
+   others, and derivative works that comment on or otherwise explain it
+   or assist in its implementation may be prepared, copied, published
+   and distributed, in whole or in part, without restriction of any
+   kind, provided that the above copyright notice and this paragraph are
+   included on all such copies and derivative works.  However, this
+   document itself may not be modified in any way, such as by removing
+   the copyright notice or references to the Internet Society or other
+   Internet organizations, except as needed for the purpose of
+   developing Internet standards in which case the procedures for
+   copyrights defined in the Internet Standards process must be
+   followed, or as required to translate it into languages other than
+   English.
+
+   The limited permissions granted above are perpetual and will not be
+   revoked by the Internet Society or its successors or assignees.
+
+   This document and the information contained herein is provided on an
+   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
+   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
+   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
+   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
+   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
+
+Acknowledgement
+
+   Funding for the RFC Editor function is currently provided by the
+   Internet Society.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Yergeau                     Standards Track                    [Page 14]
+
diff -urN dovecot-1.2.4/dovecot-libsieve/doc/rfc/vacation.rfc5230.txt dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/vacation.rfc5230.txt
--- dovecot-1.2.4/dovecot-libsieve/doc/rfc/vacation.rfc5230.txt	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/vacation.rfc5230.txt	2008-01-04 23:12:31.000000000 +0100
@@ -0,0 +1,899 @@
+
+
+
+
+
+
+Network Working Group                                       T. Showalter
+Request for Comments: 5230
+Category: Standards Track                                  N. Freed, Ed.
+                                                        Sun Microsystems
+                                                            January 2008
+
+
+               Sieve Email Filtering: Vacation Extension
+
+Status of This Memo
+
+   This document specifies an Internet standards track protocol for the
+   Internet community, and requests discussion and suggestions for
+   improvements.  Please refer to the current edition of the "Internet
+   Official Protocol Standards" (STD 1) for the standardization state
+   and status of this protocol.  Distribution of this memo is unlimited.
+
+Abstract
+
+   This document describes an extension to the Sieve email filtering
+   language for an autoresponder similar to that of the Unix "vacation"
+   command for replying to messages.  Various safety features are
+   included to prevent problems such as message loops.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Showalter & Freed           Standards Track                     [Page 1]
+
+RFC 5230               Sieve: Vacation Extension            January 2008
+
+
+Table of Contents
+
+   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3
+   2.  Conventions Used in This Document  . . . . . . . . . . . . . .  3
+   3.  Capability Identifier  . . . . . . . . . . . . . . . . . . . .  3
+   4.  Vacation Action  . . . . . . . . . . . . . . . . . . . . . . .  3
+     4.1.  Days Parameter . . . . . . . . . . . . . . . . . . . . . .  3
+     4.2.  Previous Response Tracking . . . . . . . . . . . . . . . .  4
+     4.3.  Subject and From Parameters  . . . . . . . . . . . . . . .  6
+     4.4.  MIME Parameter . . . . . . . . . . . . . . . . . . . . . .  6
+     4.5.  Address Parameter and Limiting Replies to Personal
+           Messages . . . . . . . . . . . . . . . . . . . . . . . . .  7
+     4.6.  Restricting Replies to Automated Processes and Mailing
+           Lists  . . . . . . . . . . . . . . . . . . . . . . . . . .  8
+     4.7.  Interaction with Other Sieve Actions . . . . . . . . . . .  8
+     4.8.  Examples . . . . . . . . . . . . . . . . . . . . . . . . .  9
+   5.  Response Message Generation  . . . . . . . . . . . . . . . . .  9
+     5.1.  SMTP MAIL FROM Address . . . . . . . . . . . . . . . . . .  9
+     5.2.  Date . . . . . . . . . . . . . . . . . . . . . . . . . . .  9
+     5.3.  Subject  . . . . . . . . . . . . . . . . . . . . . . . . . 10
+     5.4.  From . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
+     5.5.  To . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
+     5.6.  Auto-Submitted . . . . . . . . . . . . . . . . . . . . . . 10
+     5.7.  Message Body . . . . . . . . . . . . . . . . . . . . . . . 10
+     5.8.  In-Reply-To and References . . . . . . . . . . . . . . . . 10
+   6.  Relationship to Recommendations for Automatic Responses to
+       Electronic Mail  . . . . . . . . . . . . . . . . . . . . . . . 11
+   7.  Internationalization Considerations  . . . . . . . . . . . . . 11
+   8.  Security Considerations  . . . . . . . . . . . . . . . . . . . 12
+   9.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 12
+   10. References . . . . . . . . . . . . . . . . . . . . . . . . . . 13
+     10.1. Normative References . . . . . . . . . . . . . . . . . . . 13
+     10.2. Informative References . . . . . . . . . . . . . . . . . . 13
+   Appendix A.  Acknowledgements  . . . . . . . . . . . . . . . . . . 15
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Showalter & Freed           Standards Track                     [Page 2]
+
+RFC 5230               Sieve: Vacation Extension            January 2008
+
+
+1.  Introduction
+
+   This document defines an extension to the Sieve language defined in
+   [RFC5228] for notification that messages to a particular recipient
+   will not be answered immediately.
+
+2.  Conventions Used in This Document
+
+   Conventions for notations are as in [RFC5228] section 1.1.
+
+   The key words "MUST", "MUST NOT", "SHOULD", "SHOULD NOT", "REQUIRED",
+   and "MAY" in this document are to be interpreted as defined in
+   [RFC2119].
+
+3.  Capability Identifier
+
+   Sieve implementations that implement vacation have an identifier of
+   "vacation" for use with the capability mechanism.
+
+4.  Vacation Action
+
+   Usage:   vacation [":days" number] [":subject" string]
+                     [":from" string] [":addresses" string-list]
+                     [":mime"] [":handle" string] <reason: string>
+
+   The "vacation" action implements a vacation autoresponder similar to
+   the vacation command available under many versions of Unix.  Its
+   purpose is to provide correspondents with notification that the user
+   is away for an extended period of time and that they should not
+   expect quick responses.
+
+   "Vacation" is used to respond to a message with another message.
+   Vacation's messages are always addressed to the Return-Path address
+   (that is, the envelope from address) of the message being responded
+   to.
+
+4.1.  Days Parameter
+
+   The ":days" argument is used to specify the period in which addresses
+   are kept and are not responded to, and is always specified in days.
+   The minimum value used for this parameter is normally 1.  Sites MAY
+   define a different minimum value as long as the minimum is greater
+   than 0.  Sites MAY also define a maximum days value, which MUST be
+   greater than 7, and SHOULD be greater than 30.
+
+   If ":days" is omitted, the default value is either 7 or the minimum
+   value (as defined above), whichever is greater.
+
+
+
+
+Showalter & Freed           Standards Track                     [Page 3]
+
+RFC 5230               Sieve: Vacation Extension            January 2008
+
+
+   If the parameter given to ":days" is less than the minimum value,
+   then the minimum value is used instead.
+
+   If ":days" exceeds the site-defined maximum, the site-defined maximum
+   is used instead.
+
+4.2.  Previous Response Tracking
+
+   "Vacation" keeps track of all the responses it has sent to each
+   address in some period (as specified by the :days optional argument).
+   If vacation has not previously sent the response to this address
+   within the given time period, it sends the "reason" argument to the
+   SMTP MAIL FROM address [RFC2821] of the message that is being
+   responded to.  (The SMTP MAIL FROM address should be available in the
+   Return-path: header field if Sieve processing occurs after final
+   delivery.)
+
+   Tracking is not just per address, but must also take the vacation
+   response itself into account.  A script writer might, for example,
+   have a vacation action that will send a general notice only once in
+   any two-week period.  However, even if a sender has received this
+   general notice, it may be important to send a specific notice when a
+   message about something timely or something specific has been
+   detected.
+
+   A particular vacation response can be identified in one of two ways.
+   The first way is via an explicit :handle argument, which attaches a
+   name to the response.  All vacation statements that use the same
+   handle will be considered the same response for tracking purposes.
+
+   The second way is via a synthesis of the :subject, :from, :mime, and
+   reason vacation command arguments.  All vacation actions that do not
+   contain an explicit handle and that use an identical combination of
+   these arguments are considered the same for tracking purposes.
+
+   For instance, if coyote@desert.example.org sends mail to
+   roadrunner@acme.example.com twice, once with the subject "Cyrus bug"
+   and once with the subject "come over for dinner", and
+   roadrunner@acme.example.com has the script shown below,
+   coyote@desert.example.org would receive two responses, one with the
+   first message, one with the second.
+
+   require "vacation";
+   if header :contains "subject" "cyrus" {
+       vacation "I'm out -- send mail to cyrus-bugs";
+   } else {
+       vacation "I'm out -- call me at +1 304 555 0123";
+   }
+
+
+
+Showalter & Freed           Standards Track                     [Page 4]
+
+RFC 5230               Sieve: Vacation Extension            January 2008
+
+
+   In the above example, coyote@desert.example.org gets the second
+   message despite having gotten the first one because separate vacation
+   responses have been triggered.  This behavior is REQUIRED.
+
+   There is one important exception to this rule, however.  If the Sieve
+   variables extension [RFC5229] is used, the arguments MUST NOT have
+   undergone variable expansion prior to their use in response tracking.
+   This is so that examples like the following script will only generate
+   a single response to each incoming message with a different subject
+   line.
+
+   require ["vacation", "variables"];
+   if header :matches "subject" "*" {
+       vacation :subject "Automatic response to: ${1}"
+                "I'm away -- send mail to foo in my absence";
+   }
+
+   As noted above, the optional ":handle" parameter can be used to tell
+   the Sieve interpreter to treat two vacation actions with different
+   arguments as the same command for purposes of response tracking.  The
+   argument to ":handle" is a string that identifies the type of
+   response being sent.  For instance, if tweety@cage.example.org sends
+   mail to spike@doghouse.example.com twice, one with the subject
+   "lunch?" and once with the subject "dinner?", and
+   spike@doghouse.example.com has the script shown below,
+   tweety@cage.example.org will only receive a single response.  (Which
+   response is sent depends on the order in which the messages are
+   processed.)
+
+   require "vacation";
+   if header :contains "subject" "lunch" {
+       vacation :handle "ran-away" "I'm out and can't meet for lunch";
+   } else {
+       vacation :handle "ran-away" "I'm out";
+   }
+
+   NOTE: One way to implement the necessary mechanism here is to store a
+   hash of either the current handle and the recipient address or, if no
+   handle is provided, a hash of the vacation action parameters
+   specifying the message content and the recipient address.  If a
+   script is changed, implementations MAY reset the records of who has
+   been responded to and when they have been responded to.
+
+   IMPLEMENTATION NOTE: Care must be taken in constructing a hash of
+   vacation action parameters.  In particular, since most parameters are
+   optional, it is important not to let the same string used as the
+   value for different parameters produce the same hash value.  One
+
+
+
+
+Showalter & Freed           Standards Track                     [Page 5]
+
+RFC 5230               Sieve: Vacation Extension            January 2008
+
+
+   possible way to accomplish this is to apply the hash to a series of
+   counted or null terminated strings, one for each possible parameter
+   in particular order.
+
+   Implementations are free to limit the number of remembered responses;
+   however, the limit MUST NOT be less than 1000.  When limiting the
+   number of tracked responses, implementations SHOULD discard the
+   oldest ones first.
+
+4.3.  Subject and From Parameters
+
+   The ":subject" parameter specifies a subject line to attach to any
+   vacation response that is generated.  UTF-8 characters can be used in
+   the string argument; implementations MUST convert the string to
+   [RFC2047] encoded words if and only if non-ASCII characters are
+   present.  Implementations MUST generate an appropriate default
+   subject line as specified below if no :subject parameter is
+   specified.
+
+   A ":from" parameter may be used to specify an alternate address to
+   use in the From field of vacation messages.  The string must specify
+   a valid [RFC2822] mailbox-list.  Implementations SHOULD check the
+   syntax and generate an error when a syntactically invalid ":from"
+   parameter is specified.  Implementations MAY also impose restrictions
+   on what addresses can specified in a ":from" parameter; it is
+   suggested that values that fail such a validity check simply be
+   ignored rather than cause the vacation action to fail.
+
+4.4.  MIME Parameter
+
+   The ":mime" parameter, if supplied, specifies that the reason string
+   is, in fact, a MIME entity as defined in [RFC2045] section 2.4,
+   including both MIME headers and content.
+
+   If the optional :mime parameter is not supplied, the reason string is
+   considered a UTF-8 string.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Showalter & Freed           Standards Track                     [Page 6]
+
+RFC 5230               Sieve: Vacation Extension            January 2008
+
+
+   require "vacation";
+   vacation :mime text:
+   Content-Type: multipart/alternative; boundary=foo
+
+   --foo
+
+   I'm at the beach relaxing.  Mmmm, surf...
+
+   --foo
+   Content-Type: text/html; charset=us-ascii
+
+   <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"
+    "http://www.w3.org/TR/REC-html40/strict.dtd">
+   <HTML><HEAD><TITLE>How to relax</TITLE>
+   <BASE HREF="http://home.example.com/pictures/"></HEAD>
+   <BODY><P>I'm at the <A HREF="beach.gif">beach</A> relaxing.
+   Mmmm, <A HREF="ocean.gif">surf</A>...
+   </BODY></HTML>
+
+   --foo--
+   .
+
+4.5.  Address Parameter and Limiting Replies to Personal Messages
+
+   "Vacation" MUST NOT respond to a message unless the recipient user's
+   email address is in a "To", "Cc", "Bcc", "Resent-To", "Resent-Cc", or
+   "Resent-Bcc" line of the original message.  An email address is
+   considered to belong to the recipient if it is one of:
+
+   1.  an email address known by the implementation to be associated
+       with the recipient,
+
+   2.  the final envelope recipient address if it's available to the
+       implementation, or
+
+   3.  an address specified by the script writer via the ":addresses"
+       argument described in the next paragraph.
+
+   Users can supply additional mail addresses that are theirs with the
+   ":addresses" argument, which takes a string-list listing additional
+   addresses that a user might have.  These addresses are considered to
+   belong to the recipient user in addition to the addresses known to
+   the implementation.
+
+
+
+
+
+
+
+
+Showalter & Freed           Standards Track                     [Page 7]
+
+RFC 5230               Sieve: Vacation Extension            January 2008
+
+
+4.6.  Restricting Replies to Automated Processes and Mailing Lists
+
+   Implementations MAY refuse to send a vacation response to a message
+   that contains any header or content that makes it appear that a
+   response would not be appropriate.
+
+   Implementations MUST have a list of addresses that "vacation" MUST
+   NOT send mail to.  However, the contents of this list are
+   implementation defined.  The purpose of this list is to stop mail
+   from going to addresses used by system daemons that would not care if
+   the user is actually reading her mail.
+
+   Implementations are encouraged, however, to include well-known
+   addresses like "MAILER-DAEMON", "LISTSERV", "majordomo", and other
+   addresses typically used only by automated systems.  Additionally,
+   addresses ending in "-request" or beginning in "owner-", i.e.,
+   reserved for mailing list software, are also suggested.
+
+   Implementors may take guidance from [RFC2142], but should be careful.
+   Some addresses, like "POSTMASTER", are generally actually managed by
+   people, and people do care if the user is going to be unavailable.
+
+   Implementations SHOULD NOT respond to any message that contains a
+   "List-Id" [RFC2919], "List-Help", "List-Subscribe", "List-
+   Unsubscribe", "List-Post", "List-Owner", or "List-Archive" [RFC2369]
+   header field.
+
+   Implementations SHOULD NOT respond to any message that has an "Auto-
+   submitted" header field with a value other than "no".  This header
+   field is described in [RFC3834].
+
+4.7.  Interaction with Other Sieve Actions
+
+   Vacation does not affect Sieve's implicit keep action.
+
+   Vacation can only be executed once per script.  A script MUST fail
+   with an appropriate error if it attempts to execute two or more
+   vacation actions.
+
+   Implementations MUST NOT consider vacation used with discard, keep,
+   fileinto, or redirect an error.  The vacation action is incompatible
+   with the Sieve reject and refuse actions [REJECT].
+
+
+
+
+
+
+
+
+
+Showalter & Freed           Standards Track                     [Page 8]
+
+RFC 5230               Sieve: Vacation Extension            January 2008
+
+
+4.8.  Examples
+
+   Here is a simple use of vacation.
+
+   require "vacation";
+   vacation :days 23 :addresses ["tjs@example.edu",
+                                 "ts4z@landru.example.edu"]
+   "I'm away until October 19.
+   If it's an emergency, call 911, I guess." ;
+
+   By mingling vacation with other rules, users can do something more
+   selective.
+
+   require "vacation";
+   if header :contains "from" "boss@example.edu" {
+       redirect "pleeb@isp.example.org";
+   } else {
+       vacation "Sorry, I'm away, I'll read your
+   message when I get around to it.";
+   }
+
+5.  Response Message Generation
+
+   This section details the requirements for the generated response
+   message.
+
+   It is worth noting that the input message and arguments may be in
+   UTF-8, and that implementations MUST deal with UTF-8 input, although
+   implementations MAY transcode to other character sets as regional
+   taste dictates.  When :mime is used, the reason argument also
+   contains MIME header information.  The headers must conform to MIME
+   conventions; in particular, 8bit text is not allowed.
+   Implementations SHOULD reject vacation :mime actions containing 8bit
+   header material.
+
+5.1.  SMTP MAIL FROM Address
+
+   The SMTP MAIL FROM address of the message envelope SHOULD be set to
+   <>.  NOTIFY=NEVER SHOULD also be set in the RCPT TO line during the
+   SMTP transaction if the NOTARY SMTP extension [RFC3461] is available.
+
+5.2.  Date
+
+   The Date field SHOULD be set to the date and time when the vacation
+   response was generated.  Note that this may not be the same as the
+   time the message was delivered to the user.
+
+
+
+
+
+Showalter & Freed           Standards Track                     [Page 9]
+
+RFC 5230               Sieve: Vacation Extension            January 2008
+
+
+5.3.  Subject
+
+   Users can specify the Subject of the reply with the ":subject"
+   parameter.  If the :subject parameter is not supplied, then the
+   subject is generated as follows: The subject is set to the characters
+   "Auto: " followed by the original subject.  An appropriate fixed
+   Subject, such as "Automated reply", SHOULD be used in the event that
+   :subject isn't specified and the original message doesn't contain a
+   Subject field.
+
+5.4.  From
+
+   Unless explicitly overridden with a :from parameter, the From field
+   SHOULD be set to the address of the owner of the Sieve script.
+
+5.5.  To
+
+   The To field SHOULD be set to the address of the recipient of the
+   response.
+
+5.6.  Auto-Submitted
+
+   An Auto-Submitted field with a value of "auto-replied" SHOULD be
+   included in the message header of any vacation message sent.
+
+5.7.  Message Body
+
+   The body of the message is taken from the reason string in the
+   vacation command.
+
+5.8.  In-Reply-To and References
+
+   Replies MUST have the In-Reply-To field set to the Message-ID of the
+   original message, and the References field SHOULD be updated with the
+   Message-ID of the original message.
+
+   If the original message lacks a Message-ID, an In-Reply-To need not
+   be generated, and References need not be changed.
+
+   Section 3.6.4 of [RFC2822] provides a complete description of how
+   References fields should be generated.
+
+
+
+
+
+
+
+
+
+
+Showalter & Freed           Standards Track                    [Page 10]
+
+RFC 5230               Sieve: Vacation Extension            January 2008
+
+
+6.  Relationship to Recommendations for Automatic Responses to
+    Electronic Mail
+
+   The vacation extension implements a "Personal Responder" in the
+   terminology defined in [RFC3834].  Care has been taken in this
+   specification to comply with the recommendations of [RFC3834]
+   regarding how personal responders should behave.
+
+7.  Internationalization Considerations
+
+   Internationalization capabilities provided by the base Sieve language
+   are discussed in [RFC5228].  However, the vacation extension is the
+   first Sieve extension to be defined that is capable of creating
+   entirely new messages.  This section deals with internationalization
+   issues raised by the use of the vacation extension.
+
+   Vacation messages are normally written using the UTF-8 charset,
+   allowing text to be written in most of the world's languages.
+   Additionally, the :mime parameter allows specification of arbitrary
+   MIME content.  In particular, this makes it possible to use
+   multipart/alternative objects to specify vacation responses in
+   multiple languages simultaneously.
+
+   The Sieve language itself allows a vacation response to be selected
+   based on the content of the original message.  For example, the
+   Accept-Language or Content-Language header fields [RFC3282] could be
+   checked and used to select appropriate text:
+
+   require "vacation";
+   if header :contains ["accept-language", "content-language"] "en"
+   {
+       vacation "I am away this week.";
+   } else {
+       vacation "Estoy ausente esta semana.";
+   }
+
+   Note that this rather simplistic test of the field values fails to
+   take the structure of the fields into account and hence could be
+   fooled by some more complex field values.  A more elaborate test
+   could be used to deal with this problem.
+
+   The approach of explicitly coding language selection criteria in
+   scripts is preferred because in many cases language selection issues
+   are conflated with other selection issues.  For example, it may be
+   appropriate to use informal text in one language for vacation
+   responses sent to a fellow employee while using more formal text in a
+   different language in a response sent to a total stranger outside the
+   company:
+
+
+
+Showalter & Freed           Standards Track                    [Page 11]
+
+RFC 5230               Sieve: Vacation Extension            January 2008
+
+
+   require "vacation";
+   if address :matches "from" "*@ourdivision.example.com"
+   {
+       vacation :subject "Gone fishing"
+                "Having lots of fun! Back in a day or two!";
+   } else {
+       vacation :subject "Je suis parti cette semaine"
+                "Je lirai votre message quand je retourne.";
+   }
+
+   IMPLEMENTATION NOTE: A graphical Sieve generation interface could in
+   principle be used to hide the complexity of specifying response
+   selection criteria from end users.  Figuring out the right set of
+   options to present in a graphical interface is likely a nontrivial
+   proposition, but this is more because of the need to employ a variety
+   of criteria to select different sorts of responses to send to
+   different classes of people than because of the issues involved in
+   selecting a response in an appropriate language.
+
+8.  Security Considerations
+
+   It is critical that implementations correctly implement the behavior
+   and restrictions described throughout this document.  Replies MUST
+   NOT be sent out in response to messages not sent directly to the
+   user, and replies MUST NOT be sent out more often than the :days
+   argument states unless the script changes.
+
+   If mail is forwarded from a site that uses subaddressing, it may be
+   impossible to list all recipient addresses with ":addresses".
+
+   Security issues associated with mail auto-responders are fully
+   discussed in the security considerations section of [RFC3834].  This
+   document is believed not to introduce any additional security
+   considerations in this general area.
+
+9.  IANA Considerations
+
+   The following template specifies the IANA registration of the
+   vacation Sieve extension specified in this document:
+
+   To: iana@iana.org
+   Subject: Registration of new Sieve extension
+
+   Capability name: vacation
+   Description:     adds an action for generating an auto-reply saying
+                    that the original message will not be read or
+                    answered immediately
+   RFC number:      RFC 5230
+
+
+
+Showalter & Freed           Standards Track                    [Page 12]
+
+RFC 5230               Sieve: Vacation Extension            January 2008
+
+
+   Contact address: The Sieve discussion list <ietf-mta-filters@imc.org>
+
+   This information has been added to the list of Sieve extensions given
+   on http://www.iana.org/assignments/sieve-extensions.
+
+10.  References
+
+10.1.  Normative References
+
+   [RFC2045]  Freed, N. and N. Borenstein, "Multipurpose Internet Mail
+              Extensions (MIME) Part One: Format of Internet Message
+              Bodies", RFC 2045, November 1996.
+
+   [RFC2047]  Moore, K., "MIME (Multipurpose Internet Mail Extensions)
+              Part Three: Message Header Extensions for Non-ASCII Text",
+              RFC 2047, November 1996.
+
+   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
+              Requirement Levels", BCP 14, RFC 2119, March 1997.
+
+   [RFC2822]  Resnick, P., "Internet Message Format", RFC 2822,
+              April 2001.
+
+   [RFC3461]  Moore, K., "Simple Mail Transfer Protocol (SMTP) Service
+              Extension for Delivery Status Notifications (DSNs)",
+              RFC 3461, January 2003.
+
+   [RFC3834]  Moore, K., "Recommendations for Automatic Responses to
+              Electronic Mail", RFC 3834, August 2004.
+
+   [RFC5228]  Guenther, P., Ed. and T. Showalter, Ed., "Sieve: An Email
+              Filtering Language", RFC 5228, January 2008.
+
+   [RFC5229]  Homme, K., "Sieve Email Filtering: Variables Extension",
+              RFC 5229, January 2008.
+
+10.2.  Informative References
+
+   [REJECT]   Stone, A., Elvey, M., and A. Melnikov, "Sieve Email
+              Filtering: Reject Extension", Work in Progress,
+              October 2007.
+
+   [RFC2142]  Crocker, D., "MAILBOX NAMES FOR COMMON SERVICES, ROLES AND
+              FUNCTIONS", RFC 2142, May 1997.
+
+   [RFC2369]  Neufeld, G. and J. Baer, "The Use of URLs as Meta-Syntax
+              for Core Mail List Commands and their Transport through
+              Message Header Fields", RFC 2369, July 1998.
+
+
+
+Showalter & Freed           Standards Track                    [Page 13]
+
+RFC 5230               Sieve: Vacation Extension            January 2008
+
+
+   [RFC2821]  Klensin, J., "Simple Mail Transfer Protocol", RFC 2821,
+              April 2001.
+
+   [RFC2919]  Chandhok, R. and G. Wenger, "List-Id: A Structured Field
+              and Namespace for the Identification of Mailing Lists",
+              RFC 2919, March 2001.
+
+   [RFC3282]  Alvestrand, H., "Content Language Headers", RFC 3282,
+              May 2002.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Showalter & Freed           Standards Track                    [Page 14]
+
+RFC 5230               Sieve: Vacation Extension            January 2008
+
+
+Appendix A.  Acknowledgements
+
+   This extension is obviously inspired by Eric Allman's vacation
+   program under Unix.  The authors owe a great deal to Carnegie Mellon
+   University, Cyrus Daboo, Lawrence Greenfield, Michael Haardt, Kjetil
+   Torgrim Homme, Arnt Gulbrandsen, Mark Mallett, Alexey Melnikov,
+   Jeffrey Hutzelman, Philip Guenther, and many others whose names have
+   been lost during the inexcusably long gestation period of this
+   document.
+
+Authors' Addresses
+
+   Tim Showalter
+
+   EMail: tjs@psaux.com
+
+
+   Ned Freed (editor)
+   Sun Microsystems
+   3401 Centrelake Drive, Suite 410
+   Ontario, CA  92761-1205
+   USA
+
+   Phone: +1 909 457 4293
+   EMail: ned.freed@mrochek.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Showalter & Freed           Standards Track                    [Page 15]
+
+RFC 5230               Sieve: Vacation Extension            January 2008
+
+
+Full Copyright Statement
+
+   Copyright (C) The IETF Trust (2008).
+
+   This document is subject to the rights, licenses and restrictions
+   contained in BCP 78, and except as set forth therein, the authors
+   retain all their rights.
+
+   This document and the information contained herein are provided on an
+   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
+   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
+   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
+   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
+
+Intellectual Property
+
+   The IETF takes no position regarding the validity or scope of any
+   Intellectual Property Rights or other rights that might be claimed to
+   pertain to the implementation or use of the technology described in
+   this document or the extent to which any license under such rights
+   might or might not be available; nor does it represent that it has
+   made any independent effort to identify any such rights.  Information
+   on the procedures with respect to rights in RFC documents can be
+   found in BCP 78 and BCP 79.
+
+   Copies of IPR disclosures made to the IETF Secretariat and any
+   assurances of licenses to be made available, or the result of an
+   attempt made to obtain a general license or permission for the use of
+   such proprietary rights by implementers or users of this
+   specification can be obtained from the IETF on-line IPR repository at
+   http://www.ietf.org/ipr.
+
+   The IETF invites any interested party to bring to its attention any
+   copyrights, patents or patent applications, or other proprietary
+   rights that may cover technology that may be required to implement
+   this standard.  Please address the information to the IETF at
+   ietf-ipr@ietf.org.
+
+
+
+
+
+
+
+
+
+
+
+
+Showalter & Freed           Standards Track                    [Page 16]
+
diff -urN dovecot-1.2.4/dovecot-libsieve/doc/rfc/variables.rfc5229.txt dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/variables.rfc5229.txt
--- dovecot-1.2.4/dovecot-libsieve/doc/rfc/variables.rfc5229.txt	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/doc/rfc/variables.rfc5229.txt	2008-07-30 15:17:37.000000000 +0200
@@ -0,0 +1,619 @@
+
+
+
+
+
+
+Network Working Group                                           K. Homme
+Request for Comments: 5229                            University of Oslo
+Updates: 5228                                               January 2008
+Category: Standards Track
+
+
+               Sieve Email Filtering: Variables Extension
+
+Status of This Memo
+
+   This document specifies an Internet standards track protocol for the
+   Internet community, and requests discussion and suggestions for
+   improvements.  Please refer to the current edition of the "Internet
+   Official Protocol Standards" (STD 1) for the standardization state
+   and status of this protocol.  Distribution of this memo is unlimited.
+
+Abstract
+
+   In advanced mail filtering rule sets, it is useful to keep state or
+   configuration details across rules.  This document updates the Sieve
+   filtering language (RFC 5228) with an extension to support variables.
+   The extension changes the interpretation of strings, adds an action
+   to store data in variables, and supplies a new test so that the value
+   of a string can be examined.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Homme                       Standards Track                     [Page 1]
+
+RFC 5229               Sieve: Variables Extension           January 2008
+
+
+1.  Introduction
+
+   This is an extension to the Sieve language defined by [SIEVE].  It
+   adds support for storing and referencing named data.  The mechanisms
+   detailed in this document will only apply to Sieve scripts that
+   include a require clause for the "variables" extension.  The require
+   clauses themselves are not affected by this extension.
+
+   Conventions for notations are as in [SIEVE] section 1.1, including
+   use of [KEYWORDS] and [ABNF].  The grammar builds on the grammar of
+   [SIEVE].  In this document, "character" means a character from the
+   ISO 10646 coded character set [ISO10646], which may consist of
+   multiple octets coded in [UTF-8], and "variable" is a named reference
+   to data stored or read back using the mechanisms of this extension.
+
+2.  Capability Identifier
+
+   The capability string associated with the extension defined in this
+   document is "variables".
+
+3.  Interpretation of Strings
+
+   This extension changes the semantics of quoted-string, multi-line-
+   literal and multi-line-dotstuff found in [SIEVE] to enable the
+   inclusion of the value of variables.
+
+   When a string is evaluated, substrings matching variable-ref SHALL be
+   replaced by the value of variable-name.  Only one pass through the
+   string SHALL be done.  Variable names are case insensitive, so "foo"
+   and "FOO" refer to the same variable.  Unknown variables are replaced
+   by the empty string.
+
+      variable-ref        =  "${" [namespace] variable-name "}"
+      namespace           =  identifier "." *sub-namespace
+      sub-namespace       =  variable-name "."
+      variable-name       =  num-variable / identifier
+      num-variable        =  1*DIGIT
+
+   Examples:
+      "&%${}!"     => unchanged, as the empty string is an illegal
+                      identifier
+      "${doh!}"    => unchanged, as "!" is illegal in identifiers
+
+      The variable "company" holds the value "ACME".  No other variables
+      are set.
+
+      "${full}"         => the empty string
+      "${company}"      => "ACME"
+
+
+
+Homme                       Standards Track                     [Page 2]
+
+RFC 5229               Sieve: Variables Extension           January 2008
+
+
+      "${BAD${Company}" => "${BADACME"
+      "${President, ${Company} Inc.}"
+                        => "${President, ACME Inc.}"
+
+   The expanded string MUST use the variable values that are current
+   when control reaches the statement the string is part of.
+
+   Strings where no variable substitutions take place are referred to as
+   constant strings.  Future extensions may specify that passing non-
+   constant strings as arguments to its actions or tests is an error.
+
+   Namespaces are meant for future extensions that make internal state
+   available through variables.  These variables SHOULD be put in a
+   namespace whose first component is the same as its capability string.
+   Such extensions SHOULD state which, if any, of the variables in its
+   namespace are modifiable with the "set" action.
+
+   References to namespaces without a prior require statement for the
+   relevant extension MUST cause an error.
+
+   Tests or actions in future extensions may need to access the
+   unexpanded version of the string argument and, e.g., do the expansion
+   after setting variables in its namespace.  The design of the
+   implementation should allow this.
+
+3.1.  Quoting and Encoded Characters
+
+   The semantics of quoting using backslash are not changed: backslash
+   quoting is resolved before doing variable substitution.  Similarly,
+   encoded character processing (see Section 2.4.2.4 of [SIEVE]) is
+   performed before doing variable substitution, but after quoting.
+
+   Examples:
+      "${fo\o}"  => ${foo}  => the expansion of variable foo.
+      "${fo\\o}" => ${fo\o} => illegal identifier => left verbatim.
+      "\${foo}"  => ${foo}  => the expansion of variable foo.
+      "\\${foo}" => \${foo} => a backslash character followed by the
+                               expansion of variable foo.
+
+      If it is required to include a character sequence such as
+      "${beep}" verbatim in a text literal, the user can define a
+      variable to circumvent expansion to the empty string.
+
+   Example:
+      set "dollar" "$";
+      set "text" "regarding ${dollar}{beep}";
+
+
+
+
+
+Homme                       Standards Track                     [Page 3]
+
+RFC 5229               Sieve: Variables Extension           January 2008
+
+
+   Example:
+      require ["encoded-character", "variables"];
+      set "name" "Ethelbert"
+      if header :contains "Subject" "dear${hex:20 24 7b 4e}ame}" {
+          # the test string is "dear Ethelbert"
+      }
+
+3.2.  Match Variables
+
+   A "match variable" has a name consisting only of decimal digits and
+   has no namespace component.
+
+   The decimal value of the match variable name will index the list of
+   matching strings from the most recently evaluated successful match of
+   type ":matches".  The list is empty if no match has been successful.
+
+       Note: Extra leading zeroes are allowed and ignored.
+
+   The list will contain one string for each wildcard ("?" and "*") in
+   the match pattern.  Each string holds the substring from the source
+   value that the corresponding wildcard expands to, possibly the empty
+   string.  The wildcards match as little as possible (non-greedy
+   matching).
+
+   The first string in the list has index 1.  If the index is out of
+   range, the empty string will be substituted.  Index 0 contains the
+   matched part of the source value.
+
+   The interpreter MUST short-circuit tests, i.e., not perform more
+   tests than necessary to find the result.  Evaluation order MUST be
+   left to right.  If a test has two or more list arguments, the
+   implementation is free to choose which to iterate over first.
+
+   An extension describing a new match type (e.g., [REGEX]) MAY specify
+   that match variables are set as a side effect when the match type is
+   used in a script that has enabled the "variables" extension.
+
+   Example:
+
+      require ["fileinto", "variables"];
+
+      if header :matches "List-ID" "*<*@*" {
+          fileinto "INBOX.lists.${2}"; stop;
+      }
+
+
+
+
+
+
+
+Homme                       Standards Track                     [Page 4]
+
+RFC 5229               Sieve: Variables Extension           January 2008
+
+
+      # Imagine the header
+      # Subject: [acme-users] [fwd] version 1.0 is out
+      if header :matches "Subject" "[*] *" {
+          # ${1} will hold "acme-users",
+          # ${2} will hold "[fwd] version 1.0 is out"
+          fileinfo "INBOX.lists.${1}"; stop;
+      }
+
+      # Imagine the header
+      # To: coyote@ACME.Example.COM
+      if address :matches ["To", "Cc"] ["coyote@**.com",
+              "wile@**.com"] {
+          # ${0} is the matching address
+          # ${1} is always the empty string
+          # ${2} is part of the domain name ("ACME.Example")
+          fileinto "INBOX.business.${2}"; stop;
+      } else {
+          # Control wouldn't reach this block if any match was
+          # successful, so no match variables are set at this
+          # point.
+      }
+
+      if anyof (true, address :domain :matches "To" "*.com") {
+          # The second test is never evaluated, so there are
+          # still no match variables set.
+          stop;
+      }
+
+4.  Action set
+
+   Usage:    set [MODIFIER] <name: string> <value: string>
+
+   The "set" action stores the specified value in the variable
+   identified by name.  The name MUST be a constant string and conform
+   to the syntax of variable-name.  Match variables cannot be set.  A
+   namespace cannot be used unless an extension explicitly allows its
+   use in "set".  An invalid name MUST be detected as a syntax error.
+
+   Modifiers are applied on a value before it is stored in the variable.
+   See the next section for details.
+
+   Variables are only visible to the currently running script.  Note:
+   Future extensions may provide different scoping rules for variables.
+
+   Variable names are case insensitive.
+
+
+
+
+
+
+Homme                       Standards Track                     [Page 5]
+
+RFC 5229               Sieve: Variables Extension           January 2008
+
+
+   Example:
+      set "honorific"  "Mr";
+      set "first_name" "Wile";
+      set "last_name"  "Coyote";
+      set "vacation" text:
+      Dear ${HONORIFIC} ${last_name},
+      I'm out, please leave a message after the meep.
+      .
+      ;
+
+   "set" does not affect the implicit keep.  It is compatible with all
+   actions defined in [SIEVE].
+
+4.1.  Modifiers
+
+   Usage:  ":lower" / ":upper" / ":lowerfirst" / ":upperfirst" /
+           ":quotewildcard" / ":length"
+
+   Modifier names are case insensitive.  Unknown modifiers MUST yield a
+   syntax error.  More than one modifier can be specified, in which case
+   they are applied according to this precedence list, largest value
+   first:
+
+                     +--------------------------------+
+                     | Precedence     Modifier        |
+                     +--------------------------------+
+                     |     40         :lower          |
+                     |                :upper          |
+                     +--------------------------------+
+                     |     30         :lowerfirst     |
+                     |                :upperfirst     |
+                     +--------------------------------+
+                     |     20         :quotewildcard  |
+                     +--------------------------------+
+                     |     10         :length         |
+                     +--------------------------------+
+
+   It is an error to use two or more modifiers of the same precedence in
+   a single "set" action.
+
+   Examples:
+      # The value assigned to the variable is printed after the arrow
+      set "a" "juMBlEd lETteRS";             => "juMBlEd lETteRS"
+      set :length "b" "${a}";                => "15"
+      set :lower "b" "${a}";                 => "jumbled letters"
+      set :upperfirst "b" "${a}";            => "JuMBlEd lETteRS"
+      set :upperfirst :lower "b" "${a}";     => "Jumbled letters"
+      set :quotewildcard "b" "Rock*";        => "Rock\*"
+
+
+
+Homme                       Standards Track                     [Page 6]
+
+RFC 5229               Sieve: Variables Extension           January 2008
+
+
+4.1.1.  Modifier ":length"
+
+   The value is the decimal number of characters in the expansion,
+   converted to a string.
+
+4.1.2.  Modifier ":quotewildcard"
+
+   This modifier adds the necessary quoting to ensure that the expanded
+   text will only match a literal occurrence if used as a parameter to
+   :matches.  Every character with special meaning ("*", "?",  and "\")
+   is prefixed with "\" in the expansion.
+
+4.1.3.  Case Modifiers
+
+   These modifiers change the letters of the text from upper to lower
+   case or vice versa.  Characters other than "A"-"Z" and "a"-"z" from
+   US-ASCII are left unchanged.
+
+4.1.3.1.  Modifier ":upper"
+
+   All lower case letters are converted to their upper case
+   counterparts.
+
+4.1.3.2.  Modifier ":lower"
+
+   All upper case letters are converted to their lower case
+   counterparts.
+
+4.1.3.3.  Modifier ":upperfirst"
+
+   The first character of the string is converted to upper case if it is
+   a letter and set in lower case.  The rest of the string is left
+   unchanged.
+
+4.1.3.4.  Modifier ":lowerfirst"
+
+   The first character of the string is converted to lower case if it is
+   a letter and set in upper case.  The rest of the string is left
+   unchanged.
+
+5.  Test string
+
+   Usage:  string [MATCH-TYPE] [COMPARATOR]
+           <source: string-list> <key-list: string-list>
+
+   The "string" test evaluates to true if any of the source strings
+   matches any key.  The type of match defaults to ":is".
+
+
+
+
+Homme                       Standards Track                     [Page 7]
+
+RFC 5229               Sieve: Variables Extension           January 2008
+
+
+   In the "string" test, both source and key-list are taken from the
+   script, not the message, and whitespace stripping MUST NOT be done
+   unless the script explicitly requests this through some future
+   mechanism.
+
+   Example:
+      set "state" "${state} pending";
+      if string :matches " ${state} " "* pending *" {
+          # the above test always succeeds
+      }
+
+   The "relational" extension [RELATIONAL] adds a match type called
+   ":count".  The count of a single string is 0 if it is the empty
+   string, or 1 otherwise.  The count of a string list is the sum of the
+   counts of the member strings.
+
+6.  Implementation Limits
+
+   An implementation of this document MUST support at least 128 distinct
+   variables.  The supported length of variable names MUST be at least
+   32 characters.  Each variable MUST be able to hold at least 4000
+   characters.  Attempts to set the variable to a value larger than what
+   the implementation supports SHOULD be reported as an error at
+   compile-time if possible.  If the attempt is discovered during run-
+   time, the value SHOULD be truncated, and it MUST NOT be treated as an
+   error.
+
+   Match variables ${1} through ${9} MUST be supported.  References to
+   higher indices than those the implementation supports MUST be treated
+   as a syntax error, which SHOULD be discovered at compile-time.
+
+7.  Security Considerations
+
+   When match variables are used, and the author of the script isn't
+   careful, strings can contain arbitrary values controlled by the
+   sender of the mail.
+
+   Since values stored by "set" that exceed implementation limits are
+   silently truncated, it's not appropriate to store large structures
+   with security implications in variables.
+
+   The introduction of variables makes advanced decision making easier
+   to write, but since no looping construct is provided, all Sieve
+   scripts will terminate in an orderly manner.
+
+   Sieve filtering should not be relied on as a security measure against
+   hostile mail messages.  Sieve is designed to do simple, mostly static
+   tests, and is not suitable for use as a spam or virus checker, where
+
+
+
+Homme                       Standards Track                     [Page 8]
+
+RFC 5229               Sieve: Variables Extension           January 2008
+
+
+   the perpetrator has a motivation to vary the format of the mail in
+   order to avoid filtering rules.  See also [SPAMTEST].
+
+8.  IANA Considerations
+
+   The following template specifies the IANA registration of the
+   variables Sieve extension specified in this document:
+
+   To: iana@iana.org
+   Subject: Registration of new Sieve extension
+
+   Capability name: variables
+   Description:     Adds support for variables to the Sieve filtering
+                    language.
+   RFC number:      RFC 5229
+   Contact address: The Sieve discussion list <ietf-mta-filters@imc.org>
+
+9.  Acknowledgments
+
+   Thanks to Cyrus Daboo, Jutta Degener, Ned Freed, Lawrence Greenfield,
+   Jeffrey Hutzelman, Mark E. Mallett, Alexey Melnikov, Peder Stray, and
+   Nigel Swinson for valuable feedback.
+
+10.  References
+
+10.1.  Normative References
+
+   [ABNF]       Crocker, D., Ed., and Overell, P., "Augmented BNF for
+                Syntax Specifications: ABNF", RFC 4234, October 2005.
+
+   [KEYWORDS]   Bradner, S., "Key words for use in RFCs to Indicate
+                Requirement Levels", BCP 14, RFC 2119, March 1997.
+
+   [RELATIONAL] Segmuller, W. and B. Leiba, "Sieve Email Filtering:
+                Relational Extension", RFC 5231, January 2008.
+
+   [SIEVE]      Guenther, P., Ed., and T. Showalter, Ed., "Sieve: An
+                Email Filtering Language", RFC 5228, January 2008.
+
+   [UTF-8]      Yergeau, F., "UTF-8, a transformation format of Unicode
+                and ISO 10646", RFC 3629, November 2003.
+
+10.2.  Informative References
+
+   [ISO10646]   ISO/IEC, "Information Technology - Universal Multiple-
+                Octet Coded Character Set (UCS) - Part 1: Architecture
+                and Basic Multilingual Plane", May 1993, with
+                amendments.
+
+
+
+Homme                       Standards Track                     [Page 9]
+
+RFC 5229               Sieve: Variables Extension           January 2008
+
+
+   [REGEX]      Murchison, K., "Sieve Email Filtering -- Regular
+                Expression Extension", Work in Progress, February 2006.
+
+   [SPAMTEST]   Daboo, C., "Sieve Email Filtering: Spamtest and
+                Virustest Extensions", RFC 5235, January 2008.
+
+Author's Address
+
+   Kjetil T. Homme
+   University of Oslo
+   PO Box 1080
+   0316 Oslo, Norway
+
+   Phone: +47 9366 0091
+   EMail: kjetilho@ifi.uio.no
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Homme                       Standards Track                    [Page 10]
+
+RFC 5229               Sieve: Variables Extension           January 2008
+
+
+Full Copyright Statement
+
+   Copyright (C) The IETF Trust (2008).
+
+   This document is subject to the rights, licenses and restrictions
+   contained in BCP 78, and except as set forth therein, the authors
+   retain all their rights.
+
+   This document and the information contained herein are provided on an
+   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
+   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
+   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
+   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
+
+Intellectual Property
+
+   The IETF takes no position regarding the validity or scope of any
+   Intellectual Property Rights or other rights that might be claimed to
+   pertain to the implementation or use of the technology described in
+   this document or the extent to which any license under such rights
+   might or might not be available; nor does it represent that it has
+   made any independent effort to identify any such rights.  Information
+   on the procedures with respect to rights in RFC documents can be
+   found in BCP 78 and BCP 79.
+
+   Copies of IPR disclosures made to the IETF Secretariat and any
+   assurances of licenses to be made available, or the result of an
+   attempt made to obtain a general license or permission for the use of
+   such proprietary rights by implementers or users of this
+   specification can be obtained from the IETF on-line IPR repository at
+   http://www.ietf.org/ipr.
+
+   The IETF invites any interested party to bring to its attention any
+   copyrights, patents or patent applications, or other proprietary
+   rights that may cover technology that may be required to implement
+   this standard.  Please address the information to the IETF at
+   ietf-ipr@ietf.org.
+
+
+
+
+
+
+
+
+
+
+
+
+Homme                       Standards Track                    [Page 11]
+
diff -urN dovecot-1.2.4/dovecot-libsieve/dsieve-config.h.in dovecot-1.2.4.debian/dovecot-libsieve/dsieve-config.h.in
--- dovecot-1.2.4/dovecot-libsieve/dsieve-config.h.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/dsieve-config.h.in	2009-07-20 23:30:49.000000000 +0200
@@ -0,0 +1,9 @@
+
+/* Define to the full name of this Sieve implementation. */
+#undef SIEVE_NAME
+
+/* Define to the version of this Sieve implementation. */
+#undef SIEVE_VERSION
+
+/* Define to build Sieve unfinished features/extensions. */
+#undef HAVE_SIEVE_UNFINISHED
diff -urN dovecot-1.2.4/dovecot-libsieve/dummy-config.h.in dovecot-1.2.4.debian/dovecot-libsieve/dummy-config.h.in
--- dovecot-1.2.4/dovecot-libsieve/dummy-config.h.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/dummy-config.h.in	2009-08-21 00:55:41.000000000 +0200
@@ -0,0 +1,65 @@
+/* dummy-config.h.in.  Generated from configure.in by autoheader.  */
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#undef HAVE_DLFCN_H
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#undef HAVE_INTTYPES_H
+
+/* Define to 1 if you have the <memory.h> header file. */
+#undef HAVE_MEMORY_H
+
+/* Define to build Sieve unfinished features/extensions. */
+#undef HAVE_SIEVE_UNFINISHED
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#undef HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#undef HAVE_STDLIB_H
+
+/* Define to 1 if you have the <strings.h> header file. */
+#undef HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#undef HAVE_STRING_H
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#undef HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#undef HAVE_SYS_TYPES_H
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#undef HAVE_UNISTD_H
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#undef LT_OBJDIR
+
+/* Define to the address where bug reports for this package should be sent. */
+#undef PACKAGE_BUGREPORT
+
+/* Define to the full name of this package. */
+#undef PACKAGE_NAME
+
+/* Define to the full name and version of this package. */
+#undef PACKAGE_STRING
+
+/* Define to the one symbol short name of this package. */
+#undef PACKAGE_TARNAME
+
+/* Define to the home page for this package. */
+#undef PACKAGE_URL
+
+/* Define to the version of this package. */
+#undef PACKAGE_VERSION
+
+/* Define to the full name of this Sieve implementation. */
+#undef SIEVE_NAME
+
+/* Define to the version of this Sieve implementation. */
+#undef SIEVE_VERSION
+
+/* Define to 1 if you have the ANSI C header files. */
+#undef STDC_HEADERS
diff -urN dovecot-1.2.4/dovecot-libsieve/examples/elvey.sieve dovecot-1.2.4.debian/dovecot-libsieve/examples/elvey.sieve
--- dovecot-1.2.4/dovecot-libsieve/examples/elvey.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/examples/elvey.sieve	2008-10-04 10:41:25.000000000 +0200
@@ -0,0 +1,153 @@
+# Example Sieve Script
+#   Author: Matthew Elvey (Slightly modified to remove syntax and context errors)
+#   URL: http://www.elvey.com/it/sieve/SieveScript.txt
+
+# Initial version completed and put in place 4/1/02 by Matthew Elvey  (firstname@lastname.com ; I've checked and it's not a valid address.); Copyright (C).and.current as of 5/19/2002 
+#Change log:
+#+ spam[:high]; major reordering; +DFC,BugTraq, PB up +Economist, FolderPath corrections 
+#+ redid .0 matches. +Korean + whitelist +@f(useful once I start bouncing mail!)
+#+open mag, simplifications, to fm=spamNOTwhite, Bulk changes, IETF rules, +lst
+#Reword spam bounce.+scalable@ re-correction+++Work+activate Spam Optimization, etc...
+#oops high = 2x threshold, so 2x1 is 2!  Too low. To @fm:bounce.  Added tons of comments.
+require ["fileinto", "reject", "vacation", "envelope", "regex"];
+
+if header :contains "subject" ["un eject", "lastname.com/spamoff.htm agreed to"] {  #I give out "uneject" to people to let them bypass the spam or size filters.
+  keep;
+} elsif header :contains "subject" ["ADV:", "bounceme", "2002 Gov Grants",   #bounceme is useful for testing.
+             "ADV:ADLT", "ADV-ADULT", "ADULT ADVERTISEMENT"] {  #Subject text required by various US State laws
+  reject text: 
+  Hello.  The server content filter/spam detector I use has bounced your message. It appears to be spam. 
+
+  I do not accept spam/UCE (Unsolicited Commercial Email). 
+
+Please ask me how to bypass this filter if your email is not UCE.  In that case, I am sorry about this 
+highly unusual error.  The filter is >99% accurate.
+
+  (This is an automated message; I will not be aware that your message did not get through if I do not hear from you again.)
+
+  -Firstname
+
+  (P.S. You may also override the filter if you accept the terms at http://www.lastname.com/spamoff.htm, 
+         by including "lastname.com/spamoff.htm agreed to." in the subject.)
+.
+   ;
+}
+# LINE 30.
+  elsif size :over 10M {    # (note that the four leading dots get "stuffed" to three)
+
+  reject text:
+   Message NOT delivered!
+   This system normally accepts email that is less than 10MB in size, because that is how I configured it.
+   You may want to put your file on a server and send me the URL.
+   Or, you may request override permission and/or unreject instructions via another (smaller) email.
+   Sorry for the inconvenience.
+
+   Thanks,
+
+.... Firstname
+   (This is an automated message; I will not be aware that your message did not get through if I do not hear from you again.)
+
+   Unsolicited advertising sent to this E-Mail address is expressly prohibited 
+   under USC Title 47, Section 227.  Violators are subject to charge of up to 
+   $1,500 per incident or treble actual costs, whichever is greater.
+.
+  ; 
+#LINE 47.
+} elsif header :contains "From" "Firstname@lastname.com" {	#if I send myself email, leave it in the Inbox.
+  keep;			#next, is the processing for the various mailing lists I'm on.  
+} elsif header :contains ["Sender", "X-Sender", "Mailing-List", "Delivered-To", "List-Post", "Subject", "To", "Cc", "From", "Reply-to", "Received"] "burningman" {
+  fileinto "INBOX.DaBurn";
+} elsif header :contains ["Subject", "From", "Received"] ["E*TRADE", "Datek", "TD Waterhouse", "NetBank"] {
+  fileinto "INBOX.finances.status";
+} elsif header :contains "subject" "\[pacbell" {
+  fileinto "INBOX.pacbell.dslreports";
+} elsif header :contains "From" ["owner-te-wg ", "te-wg ", "iana.org"] {
+  fileinto "INBOX.lst.IETF";
+} elsif header :contains ["Mailing-List", "Subject", "From", "Received"] ["Red Hat", "Double Funk Crunch", "@economist.com", "Open Magazine", "@nytimes.com", "mottimorell", "Harrow Technology Report"] {
+  fileinto "INBOX.lst.interesting";
+} elsif header :contains ["Mailing-List", "Subject", "From", "Received", "X-LinkName"] ["DJDragonfly", "Ebates", "Webmonkey", "DHJ8091@aol.com", "Expedia Fare Tracker", "SoulShine", "Martel and Nabiel", "\[ecc\]"] {
+  fileinto "INBOX.lst.lame";
+} elsif header :contains ["Subject", "From", "To"] ["guru.com", "monster.com", "hotjobs", "dice.com", "linkify.com"] {  #job boards and current clients.
+  fileinto "INBOX.lst.jobs";
+} elsif header :contains "subject" "\[yaba" {
+  fileinto "INBOX.rec.yaba";
+} elsif header :contains ["to", "cc"] "scalable@" {
+  fileinto "INBOX.lst.scalable";
+} elsif header :contains ["Sender", "To", "Return-Path", "Received"] "NTBUGTRAQ@listserv.ntbugtraq.com" {
+  fileinto "INBOX.lst.bugtraq";
+} elsif header :contains "subject" "Wired" {
+  fileinto "INBOX.lst.wired";
+#LINE 72.
+} elsif anyof (header :contains "From" ["postmaster", "daemon", "abuse"], header :contains "Subject" ["warning:", "returned mail", "failure notice", "undelivered mail"] ) {
+keep;		#this one is important - don't want to miss any bounce messages!
+#LINE 77.
+} elsif anyof (header :contains "From" ["and here I put a whitelist of pretty much all the email addresses in my address book - it's several pages..."]) {
+  fileinto "INBOX.white"; 
+# better than keep;
+# LINE 106.
+
+
+} elsif anyof (address :all :is ["To", "CC", "BCC"] "Firstname.lastname@fastmail.fm",    #a couple people send to this, but I have have all their addrs in whitelist so OK.
+           header :matches "X-Spam-score"  ["9.?" , "10.?", "9", "10", "11.?", "12.?" ,"13.?", "14.?", "11", "12","13", "14", "15.?", "16.?", "17.?" ,"18.?", "19.?", "15", "16", "17" ,"18", "19", "2?.?", "2?", "3?.?" , "3?", "40"]) { 		 #"5.?", "6.?", "5", "6" "7.?" , "8.?" , "7", "8"
+  reject text: 
+  Hello.  The server content filter/spam detector I use has bounced your message. It appears to be spam. 
+
+  I do not accept spam/UCE (Unsolicited Commercial Email). 
+
+Please ask me how to bypass this filter if your email is not UCE.  In that case, I am sorry about this 
+highly unusual error.  The filter is >99% accurate.
+
+  (This is an automated message; I will not be aware that your message did not get through if I do not hear from you again.)
+
+  -Firstname
+
+  (P.S. You may also override the filter if you accept the terms at http://www.lastname.com/spamoff.htm, 
+         by including "lastname.com/spamoff.htm agreed to." in the subject.)
+.
+   ;
+#LINE 127.
+ 
+} elsif 
+header :matches "X-Spam" ["spam", "high"] { if					#optimization idea line 1/2
+           header :matches "X-Spam-score" ["5.?", "6.?", "5", "6"] { 
+  fileinto "INBOX.Spam.5-7"; 
+} elsif header :matches "X-Spam-score" ["7.?" , "8.?" , "7", "8"] { 
+  fileinto "INBOX.Spam.7-9"; 
+#} elsif header :matches "X-Spam-score" ["9.?" , "10.?" , "9", "10"] { 	#These lines obsoleted by reject text rule above, but others will find 'em useful!
+#  fileinto "INBOX.Spam.9-11"; 
+#} elsif header :matches "X-Spam-score" ["11.?" , "12.?" ,"13.?" , "14.?", "11" , "12" ,"13" , "14"] { 
+#  fileinto "INBOX.Spam.11-15"; 
+#} elsif header :matches "X-Spam-score" ["15.?" , "16.?" ,"17.?" ,"18.?" , "19.?", "15" , "16" ,"17" ,"18" , "19"] { 
+#  fileinto "INBOX.Spam.15-20"; 
+#} elsif header :matches "X-Spam-score" ["2?.?", "2?" ] {
+#  fileinto "Inbox.Spam.20-30";
+#} elsif header :matches "X-Spam-score" ["3?.?" , "3?", "40"] {
+#fileinto "Inbox.Spam.30-40";
+ }											#optimization idea  line 2/2 
+
+#LINE 149.
+	
+} elsif header:contains ["Content-Type","Subject"] ["ks_c_5601-1987","euc_kr","euc-kr"]{
+  fileinto "Inbox.Spam.kr";								#block Korean; it's prolly spam and I certainly can't read it.
+} elsif header :contains "Received" "yale.edu" {
+  fileinto "INBOX.Yale";								#if it made it past all the filters above, it's probably of interest.
+      } elsif anyof (header :contains "Subject" ["HR 1910", "viagra", "MLM", "               ","	" ], # common in spam.  (prolly redundant to SpamAssassin.)
+      not exists ["From", "Date"], 						#RFC822 violations common in spam.
+      header :contains ["Sender", "X-Sender", "Mailing-List", "X-Apparently-From", "X-Version", "X-Sender-IP", "Received", "Return-Path", "Delivered-To", "List-Post", "Date", "Subject", "To", "Cc", "From", "Reply-to", "X-AntiAbuse", "Content-Type", "Received", "X-LinkName"] ["btamail.net.cn", "@arabia.com" ] ) {               #spam havens.
+  fileinto "INBOX.GreyMail";
+} elsif header :contains ["Precedence", "Priority", "X-Priority", "Mailing-List", "Subject", "From", "Received", "X-LinkName"] ["Bulk", "Newsletter"] {
+  fileinto "INBOX.Bulk Precedence";
+} elsif header :contains ["to", "cc", "Received"] ["IT@lastname.com", "mail.freeservers.com"] {
+  fileinto "INBOX.lastname.IT";
+} elsif header :contains ["To", "CC"] "Firstname@lastname.com" {
+  fileinto "INBOX.lastname.non-BCC";
+}
+#LINE 167.
+#END OF SCRIPT.  Implied 'keep' is part of the Sieve spec.
+
+
+
+
+
+ 
+
Binary files dovecot-1.2.4/dovecot-libsieve/examples/elvey.svbin and dovecot-1.2.4.debian/dovecot-libsieve/examples/elvey.svbin differ
diff -urN dovecot-1.2.4/dovecot-libsieve/examples/jerry.sieve dovecot-1.2.4.debian/dovecot-libsieve/examples/jerry.sieve
--- dovecot-1.2.4/dovecot-libsieve/examples/jerry.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/examples/jerry.sieve	2008-10-04 10:41:25.000000000 +0200
@@ -0,0 +1,224 @@
+# Example Sieve Script
+#   Author: Jerry
+#   URL: http://www.emaildiscussions.com/showthread.php?postid=145322#post145322
+
+require ["fileinto", "reject", "vacation", "regex", "relational",
+"comparator-i;ascii-numeric"];
+
+
+#### BLACKLIST - BOUNCE ANYTHING THAT MATCHES
+#    From individual addresses
+         if header :contains "from"
+         [
+           "username@example.com",
+           "username@example.net"
+         ]
+         { reject "Message bounced by server content filter"; stop; }
+
+#    From domains
+         elsif header :contains "from"
+         [
+           "example.com",
+           "example.net"
+         ]
+         { reject "Message bounced by server content filter"; stop; }
+
+
+
+#### BLACKLIST - DELETE ANYTHING THAT MATCHES
+#    From individual addresses
+         elsif header :contains "from"
+         [
+           "username@example.com",
+           "username@example.net"
+         ]
+         { discard; stop; }
+
+#    From domains
+         elsif header :contains "from"
+         [
+           "example.com",
+           "example.net"
+         ]
+         { discard; stop; }
+
+#    I just added the following section after the joe-job
+#    that we all suffered at the hands of "inbox.com".
+#    The "myusername" is MY username at FastMail.
+#    DISCARDing this mail instead of directing it to a
+#    SPAM folder kept me from going over quota repeatedly.
+
+#    To individual addresses
+         elsif header :contains "to"
+         [
+           "myusername@inbox.com",
+           "myusername@example.net"
+         ]
+         { discard; stop; }
+
+         elsif  allof
+             (
+                 not anyof
+                 (
+#### WHITELIST - KEEP ANYTHING THAT MATCHES
+#    From individual addresses
+                     header :contains "from"
+                     [
+                       "username@example.com",
+                       "username@example.net"
+                     ],
+
+#    From trusted domains
+                     header :contains "from"
+                     [
+                       "example.com",
+                       "example.net"
+                     ],
+
+#    Specific "to" address (mailing lists etc)
+                     header :contains ["to", "cc"]
+                     [
+                       "username@example.com",
+                       "username@example.net"
+                     ],
+
+#    Specific "subject" keywords
+                     header :contains "subject"
+                     [
+                       "code_word_for_friend_#1",
+                       "code_word_for_friend_#2"
+                     ]
+
+                 ),
+                 anyof
+                 (
+
+#    Filter by keywords in subject or from headers
+                     header :contains ["subject", "from"]
+                     [
+                       "adilt", "adult", "advertise", "affordable",
+                       "as seen on tv", "antenna", "alarm",
+                       "background check", "bankrupt", "bargain",
+                       "best price", "bikini", "boost reliability",
+                       "brand new", "breast", "business directory",
+                       "business opportunity", "based business", "best
+                       deal", "bachelor's", "benefits", "cable",
+                       "career", "casino", "celeb", "cheapest", "child
+                       support", "cd-r", "catalog", "classified ad",
+                       "click here", "coed", "classmate", "commerce",
+                       "congratulations", "credit", "cruise", "cds",
+                       "complimentary", "columbia house", "crushlink",
+                       "debt", "detective", "diploma", "directv",
+                       "directtv", "dish", "dream vacation", "deluxe",
+                       "drug", "dvds", "dvd movie", "doubleclick",
+                       "digital tv", "erotic", "exciting new",
+                       "equalamail", "fantastic business", "fat
+                       burning", "financial independence", "finalist",
+                       "for life", "financing", "fitness", "fixed
+                       rate", "four reports", "free!", "free
+                       business", "from home", "funds", "fbi know",
+                       "fortune", "gambl", "getaway", "girls", "great
+                       price", "guaranteed", "get big", "get large",
+                       "giveaway", "hard core", "hardcore", "home
+                       document imaging", "home employment directory",
+                       "homeowner", "home owner", "homeworker", "home
+                       security", "home video", "immediate release",
+                       "information you requested", "income",
+                       "inkjet", "insurance", "interest rate",
+                       "invest", "internet connection", "join price",
+                       "judicial judgment", "just released", "know
+                       your rights", "legal", "license", "loan", "long
+                       distance", "look great", "low interest",
+                       "low-interest", "low rate", "lust", "lbs",
+                       "make money", "market", "master card",
+                       "mastercard", "meg web", "merchant account",
+                       "millionaire", "mini-vacation", "mortgage",
+                       "master's", "magazine", "nasty", "new car",
+                       "nigeria", "nude", "nympho", "naked",
+                       "obligation", "online business", "opportunity",
+                       "pager", "paying too much", "pda", "penis",
+                       "pennies", "pills", "porn", "pounds",
+                       "pre-approved", "prescri", "prscri", "prize",
+                       "prostate", "printer ink", "quote", "refinanc",
+                       "remove fat", "removing fat", "reward",
+                       "sales", "satellite", "saw your site",
+                       "scrambler", "sex", "smoking", "snoring", "some
+                       people succeed", "special invitation", "special
+                       offer", "stock", "saving", "singles", "teen",
+                       "ticket", "tired of", "truth about anyone",
+                       "the best", "ucking", "unbelievable",
+                       "uncensored", "uncollected", "unlimited", "USA
+                       domains", "urgent", "valium", "viagra",
+                       "venture capital", "virgin", "visa", "vitamin",
+                       "waist", "wealth", "webcam", "weight", "win a",
+                       "winner", "win one", "work smarter", "work at
+                       home", "xxx", "younger", "your web site", "your
+                       money", "your date is wait",
+                       "!!!", "$", "%", "10K"
+                     ],
+
+#    Filter when the subject is all uppercase (no lowercase)
+                     header :regex :comparator
+                     "i;octet" "subject" "^[^[:lower:]]+$",
+
+#    Filter using regular expressions on the subject
+                     header :regex    "subject"
+                     [
+                       "start.+business", "live.+auction",
+                       "discover.+card", "pay.+college", "apr$",
+                       "apr[^[:alnum:]]", "adv[^[:alnum:]]",
+                       "free.+(coupon|info|install|money)",
+                       "free.+(phone|sample|test|trial)",
+                       "(buy|sell).+(house|home)"
+                     ],
+
+#    Filter with tracker codes in the subject
+                     header :regex    "subject"
+                     "[[:space:].\-_]{4}#?\[?[[:alnum:]-]+\]?$",
+
+#    Filter spam with no to/from address set
+                     not exists    ["To", "From"],
+
+#    Filter spam not addressed to me
+#        Put here all of your own addresses (and alias) that you expect
+#        mail addressed to.  I found a lot of my spam didn't have my
+#        name in the TO or CC fields at all -- it must have been in the
+#        BCC (which doesn't show in the headers).  I can still get BCC
+#        mail from legitimate sources because everyone in my address
+#        book is on the WHITELIST above.
+
+                     not header :contains ["to", "cc"]
+                     [
+                       "myusername@example.com",
+                       "myusername@example.net"
+                     ]
+
+                 )
+             )
+         { fileinto "INBOX.1_spam"; }
+
+
+
+#### Virus Filter
+         elsif  header :contains ["subject", "from"]
+         [
+           "infected file rejected",
+           "infected file rejected"
+         ]
+         { fileinto "INBOX.1_virus"; }
+
+
+#### Telephone Alerts
+#        Any message that gets this far should not be spam,
+#        and a copy gets sent to my cell-phone as a TEXT message.
+
+         elsif  header :contains ["to", "cc"]
+         [
+           "myusername@example.com",
+           "myaliasname@example.com"
+         ]
+         { redirect "2135551234@mobile.example.net"; keep; }
+
+
+
+# END OF SCRIPT
diff -urN dovecot-1.2.4/dovecot-libsieve/examples/mjohnson.sieve dovecot-1.2.4.debian/dovecot-libsieve/examples/mjohnson.sieve
--- dovecot-1.2.4/dovecot-libsieve/examples/mjohnson.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/examples/mjohnson.sieve	2008-10-04 10:41:25.000000000 +0200
@@ -0,0 +1,421 @@
+# Example Sieve Script
+#  Author: Matthew Johnson
+#  URL: http://wiki.fastmail.fm/index.php?title=MatthewJohnson
+
+##########################################################################
+#######  SIEVE SCRIPT by Matthew Johnson - MRJ Solutions, Inc. ###########
+#######  Email me at mailto:mattjohnson2005@gmail.com ##
+#######  Code Version: 12JUN2004                               ###########
+##########################################################################
+require ["envelope", "fileinto", "reject", "vacation", "regex", "relational",
+         "comparator-i;ascii-numeric"];
+#
+# todo:
+# change to a nested format with
+#   allof()s and nots.
+# add "in address book" check. ex:"header :is :comparator "i;octet" "X-Spam-Known-Sender" "yes""
+# finish reformating lines to <= 75 col (for web edit box)
+#   and delete rulers.
+# Mine Michael Klose script for ideas.
+# Check out the update to the Sieve pages on the Fastmail Wiki.
+#
+
+#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+
+require ["envelope", "fileinto", "reject", "vacation", "regex",
+         "relational", "comparator-i;ascii-numeric"];
+
+
+
+# BLACKLIST - Mails to discard, drop on the floor.
+#   -high spam values except those delivered to me
+#   -Chinese content except for low spam values
+#   -virus rejected notifications
+#   -known spam addresses
+#   -newsletters that refuse my removal requests
+#   -twit-list
+#   -double twit-list
+#   -other
+
+
+#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+
+if  anyof
+    (
+      allof       # combo test one - high spam values except for mail to/from me
+      (
+        # spam score is greater or equal to 14
+        header :value "ge" :comparator "i;ascii-numeric"
+                           ["X-Spam-score"] ["14"],
+        not header :contains "X-Spam-Score" "-",  
+        not header :contains "X-Spam-Score" "0.0",
+        not header :contains ["to","from","cc","bcc","received"]
+           [
+             # do not discard email to me, will file or discard
+             # as spam later if needed
+             "matt@zeta.net",
+             "matthew@bigsc.com",
+             "matthew_johnson@bigsmallcompany.com",
+             "mmm@spend.com",
+             "finger@spend.com",
+             "myyaacct@yahoo.com"
+           ]
+       ), # end allof
+      allof       #combo test two - chinese content except for low spam values
+      (
+        anyof
+        (
+           header :regex "Subject"  "^=\\?(gb|GB)2312\\?",  # Chinese ecoding at subject
+           header :regex "Subject"  "^=\\?big5\\?", # Other kind of  Chinese mail
+
+           # Chinese content type
+           header :contains "Content-Type"
+            [
+             "GB2312",
+             "big5"
+            ]
+        ), #end anyof
+        not anyof
+        (
+           #We have to check the sign and the value separately: ascii-numeric, defined at
+           #header :contains "X-Spam-Score" "-",
+           header :value "lt" :comparator "i;ascii-numeric" "X-Spam-Score" "3"
+         )  #end not anyof
+     ), # end allof - test two
+
+     # single tests
+
+     # discard fastmail virus notifications
+     header :is ["subject"] ["Infected file rejected"],
+
+     # black list, invalid addresses receiving a large amount of spam
+     # or spam bounces,rejected zeta.net accounts.
+     header :contains ["X-Delivered-to"]
+
+                        ["eagleeye@zeta.net","ealgeeye@zeta.net",
+                        "alica.thiele@zeta.net", "2005@theta.com",
+                        "jimlovingu2@zeta.net",
+                        "alpha@zeta.net",
+                        "JoshuaS@zeta.net",
+                        "donnaf@zeta.net",
+                        "pspinks@zeta.net",
+                        "jsherman@zeta.net",
+                        "holly@zeta.net",
+                        "clabarca@zeta.net",
+                        "meghanr@zeta.net",
+                        "rtaylor@zeta.net",
+                        "lboone@zeta.net",
+                        "brower@zeta.net",
+                        "jenj@zeta.net",
+                        "cbackus@zeta.net",
+                        "spengles@zeta.net",
+                        "adams@zeta.net",
+                        "dsmith@zeta.net",
+                        "jwilderman@zeta.net",
+                        "TimF@zeta.net",
+                        "zd@zeta.net",
+                        "louise@zeta.net"]
+
+     # single 'not' tests
+     # ---out for testing---  not header :is :comparator "i;octet" "X-Spam-Known-Sender" "yes"
+    ) # end anyof()
+{
+   discard;
+   stop;
+}
+
+
+#
+# WHITELIST - Keep these mails and put them in the inbox
+#             (some kept getting put in Junk Mail)
+#             Family, Friends, Current Vendors, Customers
+#             Contents of fastmail address book.
+#
+#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+
+if  anyof (  header :contains ["from","to","cc","bcc"]
+                     [ "notification@eBay.com",
+                       "MAILER-DAEMON@zeta.net",
+                       "USPS_Track_Confirm@usps.com",
+                       "credit.services@target.com",
+                       "Comcast_Paydirect@comcast.net",
+                       "mary@zeta.net",
+                       "betty@zeta.net",
+                       "andmanymore@zeta.net"
+                       ],
+            header :is :comparator "i;octet" "X-Spam-Known-Sender" "yes"
+          )
+{
+  fileinto "INBOX";
+  stop;
+}
+
+# redirects
+if header :contains ["to", "cc"] "mary1@zeta.net"
+ {
+  redirect "mary@zeta.net";
+  stop;
+ }
+
+
+#
+#   +Spam filtering by score on 3, 5 and 14(above).
+#
+#
+if  header :value "ge" :comparator "i;ascii-numeric" ["X-Spam-score"] ["5"]  {
+    fileinto "INBOX.Junk Mail.ge5";
+    stop;
+#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+
+} elsif  header :value "ge" :comparator "i;ascii-numeric" ["X-Spam-score"] ["3"]  {
+    fileinto "INBOX.Junk Mail.ge3";
+    stop;
+}
+
+
+# Potential Blacklist, start with soft discard, then migrate to full discard above
+#
+# Blacklist (2nd) During testing, throw into "Junk Mail.discard" until
+#                 ready to discard.
+#
+if anyof
+   (
+    # rejects for accounts across all domains
+    header :contains ["X-Delivered-to"]
+                  [
+                  "drjoe@","VX@",
+                  "alfa@zeta.net",
+                  "media@zeta.net",
+                  "zeta@zeta.net",
+                  "xyz@zeta.net"
+                  ],
+
+    # other criteria - weird message from this account
+    header :contains ["from"] ["Charlie Root"],
+    # mailers that are always sending spam returns to me
+    header :contains ["from"] ["MAILER-DAEMON@aol.com"] ,
+    header :contains ["from"] ["MAILER-DAEMON@otenet.gr"] ,
+
+    # common account names that I don't use in any of my domains and that spammers like
+    header :contains ["X-Delivered-to"]
+                     [ "biz@","sales@","support@", "service@", "reg@",
+                       "registration@", "regisration@", "root@", "webmaster@", "noreply@"
+                     ],
+    # zeta.net common account names to reject
+    header :contains ["X-Delivered-to"] ["info@zeta.net"],
+    # bigsc.com  rejects
+    header :contains ["X-Delivered-to"] ["info@bigsc.com"],
+    # theta.com rejects
+    header :contains ["X-Delivered-to"] ["info@theta.com"],
+    header :contains ["X-Delivered-to"] ["reg@theta.com"]
+#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+
+        # saves for use maybe later
+        #   header :contains ["X-Delivered-to"] ["webmaster@zeta.net"],
+        #   header :contains ["X-Delivered-to"] ["webmaster@theta.com"],
+        #   header :contains ["X-Delivered-to"] ["sales@bs.com"],
+        #   header :contains ["X-Delivered-to"] ["sales@theta.com"],
+        #   header :contains ["X-Delivered-to"] ["sales@bigsc.com"],
+        #   header :contains ["X-Delivered-to"] "root@zeta.net",
+
+   )   #end  anyof() 2nd blacklist
+{
+
+  fileinto "INBOX.Junk Mail.discard";
+  stop;
+}
+
+
+#  +Greylist, move to "INBOX.Junk Mail.greylist"
+#
+#   'Soft' Blacklist  ?Greylist?
+#
+
+#annoying person(s) that send questionable attachments
+#  look at occationally
+if  header :contains "from" "alex@yahoo.com"
+{
+  fileinto "INBOX.Junk Mail.greylist";
+} elsif  header :contains "subject" "MAILER-DAEMON@fastmail.fm"
+                                     #  non-person, but might
+                                     # want to look at it while
+								     # figuring issues
+{
+  fileinto "INBOX.Junk Mail.greylist";
+  stop;
+}
+
+#   +Spammy domains to filter
+#
+# domains that are known to be present in spam
+#
+if  header :contains ["from", "received"] [".ru",".jp", ".kr", ".pt",
+					                     ".pl",".at",".cz",".cn",".lu" ]
+{
+  fileinto "INBOX.Junk Mail.discard";
+  stop;
+}
+
+
+#
+#  Annoying newsletters that won't unsubscribe me, reject
+#
+
+if anyof (
+           #annoying newsletters
+           header :contains ["from"] "VistaPrintNews",               # 2003
+           header :contains ["from"] "newsletter@briantracyintl.com", # 2003
+           header :contains ["from"] "info@yogalist.com",            # 2003
+           header :contains ["from"] "The Angela Larson Real Estate Team",
+           header :contains ["from"] "Brian Tracy"
+         )
+#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+
+{
+   reject "I HAVE TRIED TO UNSUBSCRIBE; I DO NOT WANT YOUR NEWSLETTER; PLEASE UNSUBSCRIBE ME";
+  stop;
+}
+
+
+
+
+#
+# Suspected zeta.net user from/to Zeta Institute, NY - reject
+#
+#
+#
+if    header :contains ["X-Delivered-to","from"]
+          [
+          # aaaaNEW_ENTRIES_ABOVE  ###################################
+          "neville@zeta.net",
+          "animika@zeta.net",
+          "linda@zeta.net",
+          "jerry@zeta.net",
+          "adamS@zeta.net",
+          "lkdamon@zeta.net",
+          "AdamS@zeta.net",
+          "DConnor@zeta.net",
+          "LOUISR@zeta.net",
+
+          # Start of Alpha #############################################
+          "Allanv@zeta.net",
+          "AmberJ@zeta.net",
+          "DANDERSON@zeta.net",
+          "Jonas@zeta.net",
+          "KarenE@zeta.net",
+          "J.R.C.@zeta.net", # check to see if this is working
+          "PMackey@zeta.net",
+
+          "adrienne@zeta.net","alpha@zeta.net","amina@zeta.net",
+          "anamika@zeta.net",
+          "claborca@zeta.net","communications@zeta.net",
+          "cz241@zeta.net",
+          "dee@zeta.net",
+          "ellenb@zeta.net","evis@zeta.net",
+          "frivera@zeta.net",
+          "gblack@zeta.net","gbrown@zeta.net","george@zeta.net","grace@zeta.net",
+          "happygolucky@zeta.net","hsp@zeta.net",
+          "ila@zeta.net",
+          "jacqueline_fenatifa@zeta.net","jlengler@zeta.net",
+          "joel@zeta.net","jolsen@zeta.net", "jsherman@zeta.net",
+          "kronjeklandish@zeta.net","kwilcox@zeta.net","bettyb@zeta.net",
+          "laurie@zeta.net","llmansell@zeta.net",
+          "louise@zeta.net","lzollo@zeta.net",
+          "mcraft@zeta.net","meganB@zeta.net","mwezi@zeta.net",
+          "nanwile@zeta.net",
+          "zetasound@zeta.net",
+          "peter@zeta.net",
+          "randi@zeta.net", "rcbackus@zeta.net", "registration@zeta.net",
+          "registration@omgea.org",
+          "rtaylor@zeta.net",
+          "sdonnarumma@zeta.net","stephanR@zeta.net","suzanne@zeta.net","suzzane@zeta.net",
+          "taryngaughan_dn@zeta.net"
+          # zzzzEND_OF_LIST####
+          ]   #end of Xdelivered-to list for possible zeta institute users
+
+{
+  reject text:
+      ERROR: Your email has not been delivered.
+
+      You have reached the mailer at zeta.net
+
+      Perhaps you want to send to Zeta Institute in DillyDally, NY, USA?
+
+      Use  USER@zeta.net for them
+
+      or try registration@zeta.net
+      Check the website at  http://www.zeta.net/zeta/contact/
+      Call Registration at    1 800 944 1001.
+
+      or use this information:
+
+      Zeta Institute
+      150 River Drive
+      DillyDally, NY 12666
+      Registration: 800-900-0000
+      Ph: 845-200-0000
+      Fax: 845-200-0001
+      registration@zeta.net
+
+      sincerely, POSTMASTER
+.
+;
+  fileinto "Inbox.Junk Mail.ezeta";
+  stop;
+ }
+#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+
+# +Move messages into folders
+#
+# Process other messages into separate folders
+#
+ # newsletters and mail lists
+if  header :contains  ["subject"]
+                      [ "newsletter", "[tc-ieee-", "[icntc",
+                        "JUG News", "Xdesksoftware",
+                        "announcement"   ]
+{
+  fileinto "INBOX.Newsletters";
+} elsif header :contains ["from","subject"] ["Anthony Robbins"] {
+  fileinto "INBOX.Newsletters";
+} elsif  header :contains ["from","subject"] ["MN Entrepreneurs","ME!"]  {
+  fileinto "INBOX.Newsletters";
+} elsif  header :contains ["from","received"] "adc.apple.com" {
+  fileinto "INBOX.Newsletters";
+} elsif  header :contains "from" "wnewadmn@ieee.org" {
+  fileinto "INBOX.Newsletters";
+} elsif  header :contains "from" "@lb.bcentral.com" {  # techworthy@lb.bcentral.com
+  fileinto "INBOX.Newsletters";
+} elsif  header :contains "from" "announcement@netbriefings.com" {  #st paul company
+  fileinto "INBOX.Newsletters";
+} elsif  header :contains "from" "newsletter@eletters.extremetech.com" {  #semi-annoying rag
+  fileinto "INBOX.Newsletters";
+#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+
+# my newsletter throw-away addresses
+} elsif  header :contains "to" ["microcenter@zeta.net","nmha@zeta.net"] {
+  fileinto "INBOX.Newsletters";
+
+#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+
+#
+# Alerts mailbox
+} elsif header :contains ["subject", "from"]
+                         [
+                          "Alert",                         # F-Prot virus alert service, matches:
+                                                           # "FRISK Virus Alert"
+                                                           #     or use s:FRISK Virus Alert:
+                                                           #     or use f:support@f-prot.com
+                          "Payment",                       # Alerts from other payments
+                          "credit.services@target.com",    # Target Card Payments
+                          "notify@quickbase.com"           # Tic Talkers Database changes
+                         ]
+{
+  fileinto "INBOX.Alerts";
+  stop;
+}
+
+# +Announcements from Dave Rolm, forward
+#
+# Perl Announcements from Dave Rolm
+if  header :contains "from" "dave@other.org"
+{
+  fileinto "Inbox";
+  keep;
+}
+#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+
+#######################################################################
+#### END OF SIEVE SCRIPT by Matthew Johnson - MRJ Solutions, Inc. #####
+################ email me at mailto:mattjohnson2005@gmail.com   #
+
diff -urN dovecot-1.2.4/dovecot-libsieve/examples/mklose.sieve dovecot-1.2.4.debian/dovecot-libsieve/examples/mklose.sieve
--- dovecot-1.2.4/dovecot-libsieve/examples/mklose.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/examples/mklose.sieve	2008-10-04 10:41:25.000000000 +0200
@@ -0,0 +1,303 @@
+# Example Sieve Script
+#   Author: Michael Klose
+#   URL: http://wiki.fastmail.fm/index.php?title=MichaelKloseSieveScript
+
+require ["fileinto", "reject", "vacation", "regex", "relational", "comparator-i;ascii-numeric"];
+
+# Experimental
+
+# End experimental
+
+
+
+# ----------------------------------------------
+#    Discard messages (high Spam values)
+# ----------------------------------------------
+
+if anyof
+    (
+     allof
+      (
+       #Spam score > 17?
+       #We have to check the sign and the value separately: ascii-numeric, defined at http://www.ietf.org/rfc/rfc2244.txt, doesn't see minus signs or decimal points ("-" or ".").
+       header :value "ge" :comparator "i;ascii-numeric" "X-Spam-Score" "17",
+       not header :contains "X-Spam-Score" "-",
+
+       not header :contains ["to","cc"]
+        [
+         "@my-domain.de",
+         "myemail@myotherdomain.us",
+         "myotheremail@myotherdomain.us",
+         "myotheremail2@myotherdomain.us"
+         # Do not discard stuff going to me - gets filed into Junk later
+        ],
+       not header :contains "from"
+        [
+         "lockergnome.com",
+         "Excite@info.excite.com" # gets filed into Junk later
+        ]
+
+
+      ),
+     allof
+      (
+       header :contains "X-LinkName" "hotmail", # OR anything from Hotmail with low spam
+       allof
+        (
+         header :value "ge" :comparator "i;ascii-numeric" "X-Spam-Score" "7",
+         not header :contains "X-Spam-Score" "-"
+        )
+      ),
+
+     # Black List
+
+     header :contains "from"
+      [
+       "ahbbcom@cncorn.com",
+       "Darg. B."
+      ],
+
+     # Chinese Encoding at BEGINNING of Subject
+
+     allof
+      (
+       anyof
+        (
+         header :regex "Subject"  "^=\\?(gb|GB)2312\\?",  # Chinese ecoding at subject
+         header :regex "Subject"  "^=\\?big5\\?", # Other kind of Chinese mail
+
+         # Chinese content type
+
+         header :contains "Content-Type"
+          [
+           "GB2312",
+           "big5"
+          ]
+        ),
+       not anyof
+        (
+      #Spam score > -4? <sic> - ascii-numeric ignores the ".9"!.  -Or is this correct?
+       #We have to check the sign and the value separately: ascii-numeric, defined at http://www.ietf.org/rfc/rfc2244.txt, doesn't see minus signs or decimal points ("-" or ".").
+
+         header :contains "X-Spam-Score" "-",
+         header :value "lt" :comparator "i;ascii-numeric" "X-Spam-Score" "4"
+        )
+      )
+    )
+
+{
+
+
+  # discard;
+
+  if header :contains "X-LinkName" "hotmail"
+   { discard; }
+  else
+   { fileinto "INBOX.Junk.Reject"; }
+   # I used to reject this stuff, but I wanted to know what I was rejecting, and this stuck.
+  stop;
+}
+
+
+
+# Addresses that need to be forwarded to a different domain here before spam checking
+# ******************************Michael - I don't understand what you're doing here!  -elvey
+# REPLY: this here is actually used to forward stuff addressed to my sister (using my domain)
+# to her - without using one of the own-domain aliases.
+
+if header :contains ["to", "cc"]
+ [
+  "bla@blabla.de",
+  "bla2@blabla.us",
+  "bla3@blabla.us"
+ ]
+ {
+  redirect "otheremailaddress@something.com";
+  redirect "anotheremailadress@something.com";
+  stop;
+ }
+
+
+# File into a folder before Spam filtering
+
+if header :contains ["to","cc"]
+ [
+  "important@mydomain.us",
+  "important2@mydomain.us"
+ ]
+ {
+  fileinto "Inbox.Important";
+  stop;
+ }
+
+
+
+# -------------------------------------------
+#              Filing rules
+# -------------------------------------------
+
+
+# Pre-SPAM
+
+
+if size :over 750K
+ {
+  fileinto "INBOX.largemail";
+  stop;
+ }
+
+
+if header :contains "from"
+   [
+
+# White list 1 (with SMS notification)
+
+    "Fred Bloggs",
+    "f.bloggs@hotmail.com",
+    "myboss@somecompany.com",
+    "Trisha",
+    "endofauction@ebay.de" # I want to know about end of auctions
+    ]
+ {
+  fileinto "Inbox";
+
+  # Send an SMS
+  redirect "smsgateway@somegateway.de";
+  keep;
+
+  stop;
+ }
+
+  # Advertising I want to receive, which normally ends up in the SPAM filter
+
+  if anyof
+   (
+    header :contains "from"
+
+     [
+
+# Advertising whitelist
+
+      "Mark Libbert",
+      "newsletter@snapfish.dom"
+     ],
+    header :contains "Return-Path" "mailings@gmx.dom"
+   )
+   { fileinto "INBOX.Ads"; }
+  elsif  header :contains "from"
+   [
+    "newsletter@neuseelandhaus.dom",
+    "Lockergnome",
+    "CNET News.com"
+   ]
+   { fileinto "INBOX.Newsletter";
+
+
+
+# Spam protection
+
+
+} elsif anyof
+   (
+
+    #Spam assasin
+    allof
+     (
+      header :value "ge" :comparator "i;ascii-numeric" "X-Spam-Score" "6",
+      not header :contains "X-Spam-Score" "-",
+      not anyof # White list
+       (
+        header :contains "From"         # Whitelist From addresses
+         [
+          "CNN Quick News",
+          "FastMail.FM Support",
+          "lockergnome.com"
+         ]
+       )
+     ),
+
+    # User defined
+
+    # Filter out Femalename1234z12@ spam (base64 encoded)
+    allof
+     (
+      header :regex "From" "alpha:{2,}digit:{2,}alpha:+digit:{2,}@",
+      header :contains "Content-Type" "multipart/mixed"
+     ),
+    # Filter our Spam with invalid headers. You can see this because FM adds
+    # @fastmail.fm to them. For safty, check that mklose@ @michael-klose mkmail@gmx do
+    # not appear
+
+    # Mklose: addition: The only negative side effect I have seen of the condition below
+    # is that it catches the FM newsletters. So far I find them in the spam occasionly
+    # but since they are so few, I have never bothered changing this to not catch them.
+
+    allof
+     (
+      header :contains "To" "@fastmail.fm", # I do not have a fastmail address   # This doesn't catch BCC's; you should be checking the envelop instead.  -elvey
+      not header :contains ["To", "CC", "Reply-To"] ["klose","mkmail@gmx.dom", "chaospower"]
+     )
+   )
+  {
+   fileinto "INBOX.Junk";
+   stop;
+  }
+
+
+# Post Spam-protection
+
+  elsif  header :contains ["to", "cc"] "gpc@gnu.dom" {
+  fileinto "INBOX.GPC";
+} elsif  header :contains ["to", "cc"] "alfs\-discuss@linuxfromscratch.dom" {
+  fileinto "INBOX.LFS-Support.ALFS";
+} elsif  header :contains "subject" "(usagi\-users" {
+  fileinto "INBOX.Usagi";
+} elsif anyof (header :contains "Subject" "\[eplus-de\]", header :contains "Reply-To" "eplus-de") {
+  fileinto "INBOX.E-Plus";
+} elsif  header :contains ["to", "cc"] "lfs\-support@linuxfromscratch.dom" {
+  fileinto "INBOX.LFS-Support";
+} elsif  header :contains ["to", "cc"] "netdev@oss.sgi.dom" {
+  fileinto "INBOX.NetDev";
+} elsif  header :contains ["to", "cc"] "lfs\-dev@linuxfromscratch.dom" {
+  fileinto "INBOX.LFS-DEV";
+} elsif  header :contains "from" "GMX Best Price" {
+  fileinto "INBOX.Werbung";
+} elsif  header :contains "subject" "RHN Errata Alert" {
+  fileinto "INBOX.Notifications";
+} elsif  header :contains "from"
+  [
+   "EmailDiscussions.com Mailer",
+   "help1@dungorm.dom"
+  ] {
+  fileinto "INBOX.Notifications";
+} elsif  header :contains "subject" "\[Gaim\-commits\]" {
+  fileinto "INBOX.Notifications";
+} elsif  header :contains "subject" "\[Bug" {
+  fileinto "INBOX.Notifications.Bugzilla";
+} elsif header :contains "X-LinkName" "hotmail" {
+  fileinto "INBOX.Old Hotmail.new";
+}
+
+
+# -----------------------------------------------------------------------
+#               SMS notifications and forwarding
+# -----------------------------------------------------------------------
+
+if allof
+    (
+     header :contains "to" ["@mydomain1.de","email@mydomain2.us","email2@somedomain"],
+     not header :contains "from"
+      [
+
+# This avoids sending SMS notifications if I am the sender
+
+       "@mydomain1.de",
+       "myotheremail@somedomain.de",
+       "myotheremail@someotherdomain.de"
+      ]
+    )
+ {
+  redirect "smsgateway@somegateway.com";
+  keep;
+ }
+
Binary files dovecot-1.2.4/dovecot-libsieve/examples/mklose.svbin and dovecot-1.2.4.debian/dovecot-libsieve/examples/mklose.svbin differ
diff -urN dovecot-1.2.4/dovecot-libsieve/examples/relational.rfc5231.sieve dovecot-1.2.4.debian/dovecot-libsieve/examples/relational.rfc5231.sieve
--- dovecot-1.2.4/dovecot-libsieve/examples/relational.rfc5231.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/examples/relational.rfc5231.sieve	2008-10-04 10:41:25.000000000 +0200
@@ -0,0 +1,33 @@
+require ["relational", "comparator-i;ascii-numeric", "fileinto"];
+
+if header :value "lt" :comparator "i;ascii-numeric"
+	["x-priority"] ["3"]
+{
+	fileinto "Priority";
+}
+
+elsif address :count "gt" :comparator "i;ascii-numeric"
+	["to"] ["5"]
+{
+	# everything with more than 5 recipients in the "to" field
+	# is considered SPAM
+	fileinto "SPAM";
+}
+
+elsif address :value "gt" :all :comparator "i;ascii-casemap"
+	["from"] ["M"]
+{
+	fileinto "From N-Z";
+} else {
+	fileinto "From A-M";
+}
+
+if allof ( 
+	address :count "eq" :comparator "i;ascii-numeric"
+		["to", "cc"] ["1"] ,
+	address :all :comparator "i;ascii-casemap"
+		["to", "cc"] ["me@foo.example.com"] )
+{
+	fileinto "Only me";
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/examples/rfc3028.sieve dovecot-1.2.4.debian/dovecot-libsieve/examples/rfc3028.sieve
--- dovecot-1.2.4/dovecot-libsieve/examples/rfc3028.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/examples/rfc3028.sieve	2008-10-04 10:41:25.000000000 +0200
@@ -0,0 +1,58 @@
+#
+# Example Sieve Filter
+# Declare any optional features or extension used by the script
+#
+require ["fileinto", "reject"];
+
+#
+# Reject any large messages (note that the four leading dots get
+# "stuffed" to three)
+#
+if size :over 1M
+    {
+    reject text:
+Please do not send me large attachments.
+Put your file on a server and send me the URL.
+Thank you.
+.... Fred
+.
+;
+    stop;
+    }
+#
+
+# Handle messages from known mailing lists
+# Move messages from IETF filter discussion list to filter folder
+#
+if header :is "Sender" "owner-ietf-mta-filters@imc.org"
+    {
+    fileinto "filter";  # move to "filter" folder
+    }
+#
+# Keep all messages to or from people in my company
+#
+elsif address :domain :is ["From", "To"] "example.com"
+    {
+    keep;               # keep in "In" folder
+    }
+
+#
+# Try and catch unsolicited email.  If a message is not to me,
+# or it contains a subject known to be spam, file it away.
+#
+elsif anyof (not address :all :contains
+         ["To", "Cc", "Bcc"] "me@example.com",
+     header :matches "subject"
+         ["*make*money*fast*", "*university*dipl*mas*"])
+    {
+    # If message header does not contain my address,
+    # it's from a list.
+    fileinto "spam";   # move to "spam" folder
+    }
+ else
+    {
+    # Move all other (non-company) mail to "personal"
+    # folder.
+    fileinto "personal";
+    }
+
diff -urN dovecot-1.2.4/dovecot-libsieve/examples/sanjay.sieve dovecot-1.2.4.debian/dovecot-libsieve/examples/sanjay.sieve
--- dovecot-1.2.4/dovecot-libsieve/examples/sanjay.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/examples/sanjay.sieve	2008-10-04 10:41:25.000000000 +0200
@@ -0,0 +1,171 @@
+# Example Sieve Script
+#   Author: SanjaySheth
+#   URL: http://wiki.fastmail.fm/index.php?title=SanjaySieveSpamFilter
+
+require "fileinto";
+
+if anyof (
+
+      # Blacklisted sender domains
+      header :contains ["from", "Received", "X-Sender", "Sender",
+                        "To","CC","Subject","X-Mail-from"]
+             [ "123greetings", "allfreewebsite.com",
+               "new-fields.com","atlasrewards","azogle.com",
+               "bannerport.net","bettingextreme.com","bigemailoffers.com",
+               "BlingMail.com",
+               "beyondoffers.net", ".biz ", ".biz]",
+               "cavalrymail.com","ciol.com","citywire.co.uk",
+               "cosmicclick.com",
+               "consumergamblingreport","creativemailoffers.com","creativeoffers.com",
+               "daily-promotions.com",
+               "dailypromo.","dailypromotions.",
+               "dandyoffers","dlbdirect",
+               "e54.org",  "email-specials.net","email-ware.com","emailoffersondemand",
+               "emailbargain.com","emailofferz","emailrewardz","etoll.net","emailvalues.com",
+               "evaluemarketing.com","exitrequest.com",
+               "fantastic-bargain.com","fpsamplesmail.com","freelotto",
+               "findtv.com", "freddysfabulousfinds.com",
+               "genuinerewards.com",
+               "hotdailydeal.com","hulamediamail","hy-e.net",
+               "inboxbargains.com","idealemail.com",
+               "jackpot.com","jpmailer.com",
+               "lolita","lund.com.br",
+               "mafgroup.com","mailasia.com","mailtonic.net","migada.com","ms83.com",
+               "nationaloffers.com","nexdeals.com ",
+               "offercatch.com","offermagnet.com","offerservice.net","offertime.com",
+               "offersdaily.net","optnetwork.net",
+               "ombramarketing.com","on-line-offers.com","outblaze.com",
+               "permissionpass","primetimedirect.net","productsontheweb.net",
+               "rapid-e.net","recessionspecials", "redmoss","remit2india",
+               "sampleoffers.com","savingsmansion.com","sendoutmail.com","simpleoffers.com",
+               "specialdailydeals4u.com","Select-Point.net",
+               "speedyvalues.com","sportsoffers","sporttime.info","suntekglobal.com",
+               "superstorespecials.com", "synapseconnect","sunsetterawnings.com",
+               "thefreesamplenews","truemail.net",
+               "ub-kool","ultimatesports.info","uniquemailoffers","utopiad.com",
+               "unixlovers.net",
+               "valuesdirect","virtualoffers.net",
+               "wagerzine", "webdpoffrz",
+               "yestshirt.com",
+               "z-offer.com", "zipido.com"
+             ],
+
+      # Blacklisted ip subnets due to excessive spam from them
+      header :contains "Received"
+             [ "[4.63.221.224",
+               "[24.244.141.112",
+               "[61.171.253.177",
+               "[63.123.149.", "[63.209.206.", "(63.233.30.73", "[63.251.200.",
+               "[64.41.183.","[64.49.250.", "[64.57.188.", "[64.57.221.",
+               "[64.62.204.",
+               "[64.70.17.", "[64.70.44.", "[64.70.53.",
+               "[64.39.27.6", "[64.39.27.7","[64.191.25.","[64.191.36.",
+               "[64.191.9.",
+               "[64.125.181.", "[64.191.123.", "[64.191.23.", "[64.239.182.",
+               "[65.211.3.",
+               "[66.46.150.", "[66.62.162.", "[66.118.170.", "[66.129.124.",
+               "[66.205.217.", "[66.216.111.", "[66.239.204.",
+               "[67.86.69.",
+               "[80.34.206.", "[80.80.98.",
+               "[81.72.233.13",
+               "[128.242.120.",
+               "[157.238.18",
+               "[168.234.195.18]",
+               "[193.253.198.57",
+               "[194.25.83.1",
+               "[200.24.129.", "[200.161.203.",
+               "[202.164.182.76]","[202.57.69.116",
+               "[203.19.220.","[203.22.104.","[203.22.105.",
+               "[204.188.52.",
+               "[205.153.154.203",
+               "[206.26.195.", "[206.154.33.","[206.169.178",
+               "[207.142.3.",
+               "[208.46.5.","[208.187.",
+               "[209.164.27.","[209.236.",
+               "[210.90.75.129]",
+               "[211.101.138.199","[211.185.7.125]","[211.239.231.",
+               "[212.240.95.",
+               "[213.47.250.139", "[213.225.61.",
+               "[216.22.79.","[216.39.115.","[216.99.240.",
+               "[216.126.32.", "[216.187.123.","[217.36.124.53",
+               "[218.145.25","[218.52.71.103","[218.158.136.115",
+               "[218.160.42.74", "[218.242.112.4]"
+             ],
+
+      # Blacklisted SpamAssassin flags
+      header :contains ["SPAM", "X-Spam-hits"]
+             ["ADDRESSES_ON_CD","ACT_NOW","ADULT_SITE", "ALL_CAP_PORN",
+              "AMATEUR_PORN", "AS_SEEN_ON",
+              "BAD_CREDIT", "BALANCE_FOR_LONG_20K", "BARELY_LEGAL", "BEEN_TURNED_DOWN",
+              "BANG_GUARANTEE", "BANG_MONEY","BASE64_ENC_TEXT",
+              "BAYES_99","BAYES_90",
+              "BE_BOSS", "BEST_PORN", "BULK_EMAIL",
+              "CASINO", "CONSOLIDATE_DEBT", "COPY_ACCURATELY", "COPY_DVD",
+              "DIET", "DO_IT_TODAY","DOMAIN_4U2",
+              "EMAIL_MARKETING","EMAIL_ROT13", "EXPECT_TO_EARN","EARN_MONEY",
+              "FIND_ANYTHING", "FORGED_AOL_RCVD",
+              "FORGED_HOTMAIL_RCVD", "FORGED_YAHOO_RCVD",
+              "FORGED_RCVD_TRAIL", "FORGED_JUNO_RCVD",
+              "FORGED_MUA_",
+              "FREE_MONEY","FREE_PORN",
+              "GENTLE_FEROCITY", "GET_PAID", "GUARANTEED_STUFF", "GUARANTEED_100_PERCENT",
+              "HAIR_LOSS", "HIDDEN_ASSETS", "HGH,", "HOME_EMPLOYMENT","HOT_NASTY","HTTP_ESCAPED_HOST",
+              "HTTP_USERNAME_USED","HTML_FONT_INVISIBLE",
+              "IMPOTENCE","INVALID_MSGID","INVESTMENT",
+              "LESBIAN","LIVE_PORN","LOSE_POUNDS",
+              "MARKETING_PARTNERS", "MORTGAGE_OBFU", "MORTGAGE_RATES",
+              "NIGERIAN_SCAM", "NIGERIAN_TRANSACTION_1", "NIGERIAN_BODY", "NUMERIC_HTTP_ADDR",
+              "NO_MX_FOR_FROM","NO_DNS_FOR_FROM",
+              "OBFUSCATING_COMMENT", "ONLINE_PHARMACY",
+              "PENIS_ENLARGE",
+              "PREST_NON_ACCREDITED", "PURE_PROFIT","PORN_4",
+              "RCVD_IN_DSBL", "RCVD_IN_OSIRUSOFT_COM","RCVD_IN_BL_SPAMCOP_NET", "RCVD_IN_SBL",
+              "RCVD_IN_MULTIHOP_DSBL", "RCVD_IN_RELAYS_ORDB_ORG", "RCVD_IN_UNCONFIRMED_DSBL",
+              "RCVD_FAKE_HELO_DOTCOM", "RCVD_IN_RFCI", "RCVD_IN_NJABL","RCVD_IN_SORBS",
+              "REFINANCE", "REVERSE_AGING",
+              "SAVE_ON_INSURANCE","SPAM_REDIRECTOR", "STOCK_ALERT", "STOCK_PICK", "STRONG_BUY",
+              "SEE_FOR_YOURSELF", "SUPPLIES_LIMITED",
+              "THE_BEST_RATE","TONER",
+              "UNSECURED_CREDIT",
+              "VACATION_SCAM", "VIAGRA", "VJESTIKA",
+              "WHILE_SUPPLIES", "WORK_AT_HOME",
+              "X_OSIRU_DUL", "X_OSIRU_SPAMWARE_SITE", "X_OSIRU_SPAM_SRC"
+             ],
+
+
+      # Blacklisted subjects
+
+      header :contains ["From","Subject"]
+             [" penis ",
+              "ADV:", "adult dvd", "adult movie", "adultdirect", "adultemail",
+              "background check", "bankrupt", "boobs", "business opportunity","big@boss.com",
+              "casino", "cash guarantee",
+              "debt free", "diet bread", "ebay secrets", "erection",
+              "financial freedom", "free credit",
+              "gambl", "gov grants", "jackpot",
+              "life insurance", "lottery", "lotto",
+              "mortgage", "nude", "OTCBB",
+              "penis", "porn", "promotion", "proven System",
+              " rape ",
+              " sex ", "skin resurfacing", "special offer",
+              "ultimate software", "viagra", "V1AGRA", "vivatrim",
+              "win money","work from home", "xxx"
+             ],
+
+      # often spam emails to multiple addresses with same name & different domain
+      header :matches ["To","CC"]
+             ["*fastmail*fastmail*fastmail*fastmail*fastmail*"],
+
+      # Almost all emails from these domains is spam (at least for me)
+      header :contains ["from", "received"]
+                       [".ru ",".jp ", ".kr ", ".pt ",".pl ",".at ",".cz ",
+                        ".ru>",".jp>", ".kr>", ".pt>", ".pl>",".at>",".cz>"],
+
+      # Really high SpamAssassin scores (15.0+)
+      header :matches ["X-Spam-score","X-Remote-Spam-score"] [
+          "1?.?", "2?.?", "3?.?", "4?.?", "5?.?", "6?.?"     # 10.0 to 69.9
+      ]
+) {
+      fileinto "INBOX.Spam.discard";
+      stop;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/examples/sieve_examples.sieve dovecot-1.2.4.debian/dovecot-libsieve/examples/sieve_examples.sieve
--- dovecot-1.2.4/dovecot-libsieve/examples/sieve_examples.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/examples/sieve_examples.sieve	2008-10-04 10:41:25.000000000 +0200
@@ -0,0 +1,73 @@
+# Example Sieve Script
+#   Author: unknown
+#   URL: http://wiki.fastmail.fm/index.php?title=MoreSieveExamples
+
+require ["fileinto", "reject"];
+
+###BYPASSES###
+
+if anyof (
+              header :contains ["From"] "friend1",
+              header :contains ["From"] "friend12",
+              header :contains ["From"] "friend3",
+              header :contains ["From"] "friendsdomanin",
+              header :contains ["Subject"] "elephant"  ##a safeword
+         )
+             {
+                   fileinto "INBOX";
+                   stop;
+             }
+
+###BIG MESSAGE PROTECTION
+if size :over 5000K {
+         reject "Message over 5MB size limit.  Please contact me before sending this.";
+}
+
+##SPAM FILTERING##
+if header :contains ["X-Spam"] "high" {
+      discard;
+      stop;
+}
+if header :contains ["X-Spam-Flag"] "HIGH" {
+      discard;
+      stop;
+}
+if header :contains ["X-Spam"] "spam" {
+      fileinto "INBOX.spam";  #emails forwarded from my unviersity account get SA tagged like this
+      stop;
+}
+if header :contains ["X-Spam-Flag"] "YES" {
+      fileinto "INBOX.spam";
+      stop;
+}
+
+####LOCAL SPAM RULES#######
+if header :contains ["From"]  "bannerport" { discard; stop; }  ##keyword filters for when SA doesn't quite catch them
+if header :contains ["To"]  "MATT NOONE" { discard; stop; }
+###AUTO management rules###
+
+####Student Digest stuff#### ###   Examples of boolean OR rules
+if anyof (
+            header :contains ["X-BeenThere"] "student-digest@list.xxx.edu",
+            header :contains ["X-BeenThere"] "firstyear-digest@list.xxx.edu",
+            header :contains ["X-BeenThere"] "secondyear-digest@list.xxx.edu",
+            header :contains ["X-BeenThere"] "thirdyear-digest@list.xxx.edu",
+            header :contains ["X-BeenThere"] "fourthyear-digest@list.xxx.edu"
+         )
+         {
+            fileinto "INBOX.lists.digests";
+            stop;
+         }
+if allof (   ###A Boolean AND rule
+            header :contains ["From"] "buddy1",
+            header :contains ["To"]   "myotheraddress"
+         )
+         {
+            fileinto "INBOX.scc.annoy";
+            stop;
+         }
+
+#other local rules
+if header :contains ["Subject"]  "helmreich" { fileinto "INBOX.lists.helmreich"; stop; }
+if header :contains ["Subject"]  "helmcomm" { fileinto "INBOX.lists.helmreich"; stop; }
+if header :contains ["Subject"]  "packeteer" { fileinto "INBOX.lists"; stop; }
Binary files dovecot-1.2.4/dovecot-libsieve/examples/sieve_examples.svbin and dovecot-1.2.4.debian/dovecot-libsieve/examples/sieve_examples.svbin differ
diff -urN dovecot-1.2.4/dovecot-libsieve/examples/subaddress.rfc5233.sieve dovecot-1.2.4.debian/dovecot-libsieve/examples/subaddress.rfc5233.sieve
--- dovecot-1.2.4/dovecot-libsieve/examples/subaddress.rfc5233.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/examples/subaddress.rfc5233.sieve	2008-10-04 10:41:25.000000000 +0200
@@ -0,0 +1,23 @@
+require ["envelope", "subaddress", "fileinto"];
+
+# In this example the same user account receives mail for both
+# "ken@example.com" and "postmaster@example.com"
+
+# File all messages to postmaster into a single mailbox,
+# ignoring the :detail part.
+if envelope :user "to" "postmaster" {
+	fileinto "inbox.postmaster";
+	stop;
+}
+
+# File mailing list messages (subscribed as "ken+mta-filters").
+if envelope :detail "to" "mta-filters" {
+	fileinto "inbox.ietf-mta-filters";
+}
+
+# Redirect all mail sent to "ken+foo".
+if envelope :detail "to" "foo" {
+	redirect "ken@example.net";
+}
+
+
Binary files dovecot-1.2.4/dovecot-libsieve/examples/subaddress.rfc5233.svbin and dovecot-1.2.4.debian/dovecot-libsieve/examples/subaddress.rfc5233.svbin differ
diff -urN dovecot-1.2.4/dovecot-libsieve/examples/vacation.sieve dovecot-1.2.4.debian/dovecot-libsieve/examples/vacation.sieve
--- dovecot-1.2.4/dovecot-libsieve/examples/vacation.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/examples/vacation.sieve	2008-10-04 10:41:25.000000000 +0200
@@ -0,0 +1,23 @@
+require ["fileinto","reject", "vacation"];
+if allof (header :contains  "X-Spam-Flag" "YES") 
+{
+    discard ;
+}
+
+elsif allof (header :contains "subject" "<quation>") 
+{
+vacation 
+:addresses "<name@domain.ru>"
+:subject "<Answear>" 
+:mime "MIME-Version: 1.0
+Content-Type: text/html; charset=KOI8-R
+Content-Transfer-Encoding: 7bit
+<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">
+<HTML><HEAD><META http-equiv=Content-Type content=\"text/html; charset=windows-KOI8-R\">
+</HEAD><BODY>123</BODY></HTML>";
+ discard ;
+}
+else 
+{
+     keep;
+}
Binary files dovecot-1.2.4/dovecot-libsieve/examples/vacation.svbin and dovecot-1.2.4.debian/dovecot-libsieve/examples/vacation.svbin differ
diff -urN dovecot-1.2.4/dovecot-libsieve/examples/vivil.sieve dovecot-1.2.4.debian/dovecot-libsieve/examples/vivil.sieve
--- dovecot-1.2.4/dovecot-libsieve/examples/vivil.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/examples/vivil.sieve	2008-10-04 10:41:25.000000000 +0200
@@ -0,0 +1,94 @@
+# Example Sieve Script
+#   Author: Vivil
+#   URL: http://wiki.fastmail.fm/index.php?title=Vivil
+#   Removed unused notify require
+
+# *************************************************************************
+require ["envelope", "fileinto", "reject", "vacation", "regex", "relational", 
+"comparator-i;ascii-numeric"];
+
+
+if size :over 2048K {
+  reject "Message not delivered; size over limit accepted by recipient";
+  stop;  
+}
+
+#because of the use of elsif below, none of the "stop;"'s below are needed, but they're good 'defensive programming'. Only the one above is actually needed.
+
+redirect "login@gmail.dom";
+
+if header :contains ["from","cc"]
+[
+  "from-begin@beginbeginbeginbeginbeginbeginbeginbeginbegin.fr",
+  "sex.com newsletter",
+  "ad@gator.com",
+  "newsletter@takecareof.com",
+  "from-end@endendendendendendendendendendendendendendendend.fr"
+]
+{
+  discard;
+  stop;
+}
+
+elsif header :contains ["from"]
+[
+  "mygirlfriend-who-use-incredimail@foo.dom"
+]
+{
+  fileinto "INBOX.PRIORITY";
+  stop;
+}
+
+#use of "to" field detection next lines is ONLY USEFUL FOR DOMAIN NAME OWNERS if you forward your mail to your fastmail account, some virus/spam send mail to well known addresses as info@willemijns.dom i never use...
+
+elsif header :contains ["to","cc"]
+[
+  "to-begin@beginbeginbeginbeginbeginbeginbeginbeginbegin.fr",
+  "FTPsebastien@willemijns.dom",
+  "info@willemijns.dom",
+  "webmaster@willemijns.dom",
+  "to-end@endendendendendendendendendendendendendendendend.fr"
+]
+{
+  discard;
+  stop;
+}
+
+elsif header :contains ["subject"]
+[
+  "subject-begin@beginbeginbeginbeginbeginbeginbeginbeginbegin.fr",
+  "Undeliverable mail: Registration is accepted",
+  "subject-end@endendendendendendendendendendendendendendendend.fr"
+]
+{
+  discard;
+  stop;
+}
+elsif header :value "ge" :comparator "i;ascii-numeric" ["X-Spam-score"] ["6"]  {
+  fileinto "INBOX.Junk Mail";
+  stop;
+}
+elsif header :contains "from" "reflector@launay.dom" {
+  fileinto "INBOX.TEST";
+  stop;
+}
+elsif header :contains "from" "do-not-reply@franconews.dom" {
+  fileinto "INBOX.TEST";
+  stop;
+}
+elsif header :contains "from" "devnull@news.telefonica.dom" {
+  fileinto "INBOX.TEST";
+  stop;
+}
+elsif header :contains ["to"] ["sebastien@willemijns.dom"] {
+  fileinto "INBOX.PRIORITY";
+  stop;
+}
+elsif header :contains ["to"] ["seb@willemijns.dom"] {
+  fileinto "INBOX.PRIORITY";
+  stop;
+}
+else {
+  fileinto "INBOX";
+}
+# ********************************************************************
Binary files dovecot-1.2.4/dovecot-libsieve/examples/vivil.svbin and dovecot-1.2.4.debian/dovecot-libsieve/examples/vivil.svbin differ
diff -urN dovecot-1.2.4/dovecot-libsieve/INSTALL dovecot-1.2.4.debian/dovecot-libsieve/INSTALL
--- dovecot-1.2.4/dovecot-libsieve/INSTALL	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/INSTALL	2009-07-05 18:23:47.000000000 +0200
@@ -0,0 +1,125 @@
+Compiling
+---------
+
+First of all you'll need to have pre-built Dovecot 1.2 sources available. It's 
+also not a good idea to build the plugin against self-compiled Dovecot sources, 
+but then actually use a prebuilt binary package of Dovecot. That might work if 
+the Dovecot versions are the same, but it's not guaranteed. You can also use 
+installed Dovecot headers to compile this package, but then command line tools 
+like sievec and sieved will not be compiled. This is also true for the test 
+suite. 
+
+This package is compiled and configured as follows:
+
+./configure --with-dovecot=../dovecot-1.2
+make
+sudo make install
+
+The --with-dovecot parameter points to your Dovecot sources or, in case you are 
+compiling against the headers, to the directory where the dovecot-config file is 
+installed.
+
+If you downloaded this package through Mercurial, you need to execute 
+./autogen.sh first to build the automake/autoconf structure. This requires
+autotools and libtool to be installed. 
+
+Configuring
+-----------
+
+Configuration is currently mostly identical to the cmusieve module. However, the 
+name of the module is 'sieve' and not 'cmusieve'. For a detailed description on 
+installing the cmusieve plugin for deliver refer to the dovecot wiki:
+
+http://wiki.dovecot.org/LDA/Sieve
+
+The following options for the plugin section of the Dovecot config file are new
+when compared to the old CMU Sieve:
+
+  sieve_extensions = 
+
+    Use this setting to specify which Sieve language extensions are available 
+    to users. By default, all supported extensions are available, but some 
+    system administrators may want to disable certain Sieve extensions. 
+
+  sieve_before = 
+  sieve_after =
+
+    This Sieve implementation allows executing multiple Sieve scripts 
+    sequentially. These two options are used to specify what scripts need to
+    be executed before and after the user's script (as specified by the sieve
+    option). These settings allow specifying only one path each. However, if 
+    the path leads to a directory, all the Sieve scripts contained therein are 
+    executed. The order of execution is determined by the file names, using 
+    a normal 8bit per-character comparison.
+
+    After one script terminates, the next script is executed if an implicit or 
+    explicit "keep" is in effect. Thus, to end all script execution, a script 
+    must not execute keep and it must cancel the implicit keep, e.g. by
+    executing `discard; stop;'. Keep in mind that `fileinto "INBOX"' is not 
+    the same as a keep action in this context (only for the last script).
+
+    Just as for executing a single script the normal way, this implementation 
+    takes care never to duplicate deliveries, forwards or responses. When 
+    vacation actions are executed multiple times in different scripts, the 
+    usual error is not triggered: the subsequent duplicate vacation actions 
+    are simply discarded.
+
+    Apart from the keep action, all actions triggered in a script in the
+    sequence are executed before continuing to the next script. This means 
+    that when a script in the sequence encounters an error, actions from
+    preceeding scripts are not affected. The sequence is broken however, 
+    meaning that the script execution of the offending script is aborted and
+    no further scripts are executed. An implicit keep is executed in stead.
+
+  sieve_subaddress_sep = +
+
+    This setting specifies what separator is used between the :user and :detail 
+    address parts introduced by the subaddress extension. This may also be a 
+    sequence of characters (e.g. '--'). The current implementation looks for
+    the separator from the left of the localpart and uses the first one 
+    encountered. The :user part is left of the separator and the :detail part 
+    is right. 
+    
+For example:
+
+# ...
+
+protocol lda {
+  postmaster_address = postmaster@example.com
+
+  mail_plugins = sieve
+
+  # ... 
+}
+
+plugin {
+   # The user's own script
+   sieve = ~/.dovecot.sieve
+
+   # Global script if user has none
+   #   If this is omitted, Sieve processing is skipped when the user has no 
+   #   script of his own. This includes multiscript
+   sieve_global_path = /etc/dovecot/sieve.global/default.sieve
+
+   # Scripts executed before the user's script.
+   #   E.g. handling messages marked as dangerous
+   sieve_before = /etc/dovecot/sieve.global/discard-virusses.sieve
+
+   # Scripts executed after the user's script (if keep is still in effect)
+   #   E.g. default mail filing rules.  
+   sieve_after = /etc/dovecot/sieve.d/
+}
+
+Test Suite
+----------
+
+This package includes a test suite to verify the basic processing of the Sieve
+interpreter on your particular platform. Note that the test suite is not 
+available when this package is compiled against the Dovecot headers only. The 
+test suite executes a list of test cases and halts when one of them fails. If it 
+executes all test cases successfully, the test suite finishes. You can execute 
+the test suite using `make test`. 
+
+A failing test case is always a bug and a report is greatly appreciated.
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/install-sh dovecot-1.2.4.debian/dovecot-libsieve/install-sh
--- dovecot-1.2.4/dovecot-libsieve/install-sh	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/install-sh	2008-07-18 12:31:10.000000000 +0200
@@ -0,0 +1,519 @@
+#!/bin/sh
+# install - install a program, script, or datafile
+
+scriptversion=2006-12-25.00
+
+# This originates from X11R5 (mit/util/scripts/install.sh), which was
+# later released in X11R6 (xc/config/util/install.sh) with the
+# following copyright and license.
+#
+# Copyright (C) 1994 X Consortium
+#
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to
+# deal in the Software without restriction, including without limitation the
+# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+# sell copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+#
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+# X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+# AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNEC-
+# TION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+#
+# Except as contained in this notice, the name of the X Consortium shall not
+# be used in advertising or otherwise to promote the sale, use or other deal-
+# ings in this Software without prior written authorization from the X Consor-
+# tium.
+#
+#
+# FSF changes to this file are in the public domain.
+#
+# Calling this script install-sh is preferred over install.sh, to prevent
+# `make' implicit rules from creating a file called install from it
+# when there is no Makefile.
+#
+# This script is compatible with the BSD install script, but was written
+# from scratch.
+
+nl='
+'
+IFS=" ""	$nl"
+
+# set DOITPROG to echo to test this script
+
+# Don't use :- since 4.3BSD and earlier shells don't like it.
+doit=${DOITPROG-}
+if test -z "$doit"; then
+  doit_exec=exec
+else
+  doit_exec=$doit
+fi
+
+# Put in absolute file names if you don't have them in your path;
+# or use environment vars.
+
+chgrpprog=${CHGRPPROG-chgrp}
+chmodprog=${CHMODPROG-chmod}
+chownprog=${CHOWNPROG-chown}
+cmpprog=${CMPPROG-cmp}
+cpprog=${CPPROG-cp}
+mkdirprog=${MKDIRPROG-mkdir}
+mvprog=${MVPROG-mv}
+rmprog=${RMPROG-rm}
+stripprog=${STRIPPROG-strip}
+
+posix_glob='?'
+initialize_posix_glob='
+  test "$posix_glob" != "?" || {
+    if (set -f) 2>/dev/null; then
+      posix_glob=
+    else
+      posix_glob=:
+    fi
+  }
+'
+
+posix_mkdir=
+
+# Desired mode of installed file.
+mode=0755
+
+chgrpcmd=
+chmodcmd=$chmodprog
+chowncmd=
+mvcmd=$mvprog
+rmcmd="$rmprog -f"
+stripcmd=
+
+src=
+dst=
+dir_arg=
+dst_arg=
+
+copy_on_change=false
+no_target_directory=
+
+usage="\
+Usage: $0 [OPTION]... [-T] SRCFILE DSTFILE
+   or: $0 [OPTION]... SRCFILES... DIRECTORY
+   or: $0 [OPTION]... -t DIRECTORY SRCFILES...
+   or: $0 [OPTION]... -d DIRECTORIES...
+
+In the 1st form, copy SRCFILE to DSTFILE.
+In the 2nd and 3rd, copy all SRCFILES to DIRECTORY.
+In the 4th, create DIRECTORIES.
+
+Options:
+     --help     display this help and exit.
+     --version  display version info and exit.
+
+  -c            (ignored)
+  -C            install only if different (preserve the last data modification time)
+  -d            create directories instead of installing files.
+  -g GROUP      $chgrpprog installed files to GROUP.
+  -m MODE       $chmodprog installed files to MODE.
+  -o USER       $chownprog installed files to USER.
+  -s            $stripprog installed files.
+  -t DIRECTORY  install into DIRECTORY.
+  -T            report an error if DSTFILE is a directory.
+
+Environment variables override the default commands:
+  CHGRPPROG CHMODPROG CHOWNPROG CMPPROG CPPROG MKDIRPROG MVPROG
+  RMPROG STRIPPROG
+"
+
+while test $# -ne 0; do
+  case $1 in
+    -c) ;;
+
+    -C) copy_on_change=true;;
+
+    -d) dir_arg=true;;
+
+    -g) chgrpcmd="$chgrpprog $2"
+	shift;;
+
+    --help) echo "$usage"; exit $?;;
+
+    -m) mode=$2
+	case $mode in
+	  *' '* | *'	'* | *'
+'*	  | *'*'* | *'?'* | *'['*)
+	    echo "$0: invalid mode: $mode" >&2
+	    exit 1;;
+	esac
+	shift;;
+
+    -o) chowncmd="$chownprog $2"
+	shift;;
+
+    -s) stripcmd=$stripprog;;
+
+    -t) dst_arg=$2
+	shift;;
+
+    -T) no_target_directory=true;;
+
+    --version) echo "$0 $scriptversion"; exit $?;;
+
+    --)	shift
+	break;;
+
+    -*)	echo "$0: invalid option: $1" >&2
+	exit 1;;
+
+    *)  break;;
+  esac
+  shift
+done
+
+if test $# -ne 0 && test -z "$dir_arg$dst_arg"; then
+  # When -d is used, all remaining arguments are directories to create.
+  # When -t is used, the destination is already specified.
+  # Otherwise, the last argument is the destination.  Remove it from $@.
+  for arg
+  do
+    if test -n "$dst_arg"; then
+      # $@ is not empty: it contains at least $arg.
+      set fnord "$@" "$dst_arg"
+      shift # fnord
+    fi
+    shift # arg
+    dst_arg=$arg
+  done
+fi
+
+if test $# -eq 0; then
+  if test -z "$dir_arg"; then
+    echo "$0: no input file specified." >&2
+    exit 1
+  fi
+  # It's OK to call `install-sh -d' without argument.
+  # This can happen when creating conditional directories.
+  exit 0
+fi
+
+if test -z "$dir_arg"; then
+  trap '(exit $?); exit' 1 2 13 15
+
+  # Set umask so as not to create temps with too-generous modes.
+  # However, 'strip' requires both read and write access to temps.
+  case $mode in
+    # Optimize common cases.
+    *644) cp_umask=133;;
+    *755) cp_umask=22;;
+
+    *[0-7])
+      if test -z "$stripcmd"; then
+	u_plus_rw=
+      else
+	u_plus_rw='% 200'
+      fi
+      cp_umask=`expr '(' 777 - $mode % 1000 ')' $u_plus_rw`;;
+    *)
+      if test -z "$stripcmd"; then
+	u_plus_rw=
+      else
+	u_plus_rw=,u+rw
+      fi
+      cp_umask=$mode$u_plus_rw;;
+  esac
+fi
+
+for src
+do
+  # Protect names starting with `-'.
+  case $src in
+    -*) src=./$src;;
+  esac
+
+  if test -n "$dir_arg"; then
+    dst=$src
+    dstdir=$dst
+    test -d "$dstdir"
+    dstdir_status=$?
+  else
+
+    # Waiting for this to be detected by the "$cpprog $src $dsttmp" command
+    # might cause directories to be created, which would be especially bad
+    # if $src (and thus $dsttmp) contains '*'.
+    if test ! -f "$src" && test ! -d "$src"; then
+      echo "$0: $src does not exist." >&2
+      exit 1
+    fi
+
+    if test -z "$dst_arg"; then
+      echo "$0: no destination specified." >&2
+      exit 1
+    fi
+
+    dst=$dst_arg
+    # Protect names starting with `-'.
+    case $dst in
+      -*) dst=./$dst;;
+    esac
+
+    # If destination is a directory, append the input filename; won't work
+    # if double slashes aren't ignored.
+    if test -d "$dst"; then
+      if test -n "$no_target_directory"; then
+	echo "$0: $dst_arg: Is a directory" >&2
+	exit 1
+      fi
+      dstdir=$dst
+      dst=$dstdir/`basename "$src"`
+      dstdir_status=0
+    else
+      # Prefer dirname, but fall back on a substitute if dirname fails.
+      dstdir=`
+	(dirname "$dst") 2>/dev/null ||
+	expr X"$dst" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	     X"$dst" : 'X\(//\)[^/]' \| \
+	     X"$dst" : 'X\(//\)$' \| \
+	     X"$dst" : 'X\(/\)' \| . 2>/dev/null ||
+	echo X"$dst" |
+	    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+		   s//\1/
+		   q
+		 }
+		 /^X\(\/\/\)[^/].*/{
+		   s//\1/
+		   q
+		 }
+		 /^X\(\/\/\)$/{
+		   s//\1/
+		   q
+		 }
+		 /^X\(\/\).*/{
+		   s//\1/
+		   q
+		 }
+		 s/.*/./; q'
+      `
+
+      test -d "$dstdir"
+      dstdir_status=$?
+    fi
+  fi
+
+  obsolete_mkdir_used=false
+
+  if test $dstdir_status != 0; then
+    case $posix_mkdir in
+      '')
+	# Create intermediate dirs using mode 755 as modified by the umask.
+	# This is like FreeBSD 'install' as of 1997-10-28.
+	umask=`umask`
+	case $stripcmd.$umask in
+	  # Optimize common cases.
+	  *[2367][2367]) mkdir_umask=$umask;;
+	  .*0[02][02] | .[02][02] | .[02]) mkdir_umask=22;;
+
+	  *[0-7])
+	    mkdir_umask=`expr $umask + 22 \
+	      - $umask % 100 % 40 + $umask % 20 \
+	      - $umask % 10 % 4 + $umask % 2
+	    `;;
+	  *) mkdir_umask=$umask,go-w;;
+	esac
+
+	# With -d, create the new directory with the user-specified mode.
+	# Otherwise, rely on $mkdir_umask.
+	if test -n "$dir_arg"; then
+	  mkdir_mode=-m$mode
+	else
+	  mkdir_mode=
+	fi
+
+	posix_mkdir=false
+	case $umask in
+	  *[123567][0-7][0-7])
+	    # POSIX mkdir -p sets u+wx bits regardless of umask, which
+	    # is incompatible with FreeBSD 'install' when (umask & 300) != 0.
+	    ;;
+	  *)
+	    tmpdir=${TMPDIR-/tmp}/ins$RANDOM-$$
+	    trap 'ret=$?; rmdir "$tmpdir/d" "$tmpdir" 2>/dev/null; exit $ret' 0
+
+	    if (umask $mkdir_umask &&
+		exec $mkdirprog $mkdir_mode -p -- "$tmpdir/d") >/dev/null 2>&1
+	    then
+	      if test -z "$dir_arg" || {
+		   # Check for POSIX incompatibilities with -m.
+		   # HP-UX 11.23 and IRIX 6.5 mkdir -m -p sets group- or
+		   # other-writeable bit of parent directory when it shouldn't.
+		   # FreeBSD 6.1 mkdir -m -p sets mode of existing directory.
+		   ls_ld_tmpdir=`ls -ld "$tmpdir"`
+		   case $ls_ld_tmpdir in
+		     d????-?r-*) different_mode=700;;
+		     d????-?--*) different_mode=755;;
+		     *) false;;
+		   esac &&
+		   $mkdirprog -m$different_mode -p -- "$tmpdir" && {
+		     ls_ld_tmpdir_1=`ls -ld "$tmpdir"`
+		     test "$ls_ld_tmpdir" = "$ls_ld_tmpdir_1"
+		   }
+		 }
+	      then posix_mkdir=:
+	      fi
+	      rmdir "$tmpdir/d" "$tmpdir"
+	    else
+	      # Remove any dirs left behind by ancient mkdir implementations.
+	      rmdir ./$mkdir_mode ./-p ./-- 2>/dev/null
+	    fi
+	    trap '' 0;;
+	esac;;
+    esac
+
+    if
+      $posix_mkdir && (
+	umask $mkdir_umask &&
+	$doit_exec $mkdirprog $mkdir_mode -p -- "$dstdir"
+      )
+    then :
+    else
+
+      # The umask is ridiculous, or mkdir does not conform to POSIX,
+      # or it failed possibly due to a race condition.  Create the
+      # directory the slow way, step by step, checking for races as we go.
+
+      case $dstdir in
+	/*) prefix='/';;
+	-*) prefix='./';;
+	*)  prefix='';;
+      esac
+
+      eval "$initialize_posix_glob"
+
+      oIFS=$IFS
+      IFS=/
+      $posix_glob set -f
+      set fnord $dstdir
+      shift
+      $posix_glob set +f
+      IFS=$oIFS
+
+      prefixes=
+
+      for d
+      do
+	test -z "$d" && continue
+
+	prefix=$prefix$d
+	if test -d "$prefix"; then
+	  prefixes=
+	else
+	  if $posix_mkdir; then
+	    (umask=$mkdir_umask &&
+	     $doit_exec $mkdirprog $mkdir_mode -p -- "$dstdir") && break
+	    # Don't fail if two instances are running concurrently.
+	    test -d "$prefix" || exit 1
+	  else
+	    case $prefix in
+	      *\'*) qprefix=`echo "$prefix" | sed "s/'/'\\\\\\\\''/g"`;;
+	      *) qprefix=$prefix;;
+	    esac
+	    prefixes="$prefixes '$qprefix'"
+	  fi
+	fi
+	prefix=$prefix/
+      done
+
+      if test -n "$prefixes"; then
+	# Don't fail if two instances are running concurrently.
+	(umask $mkdir_umask &&
+	 eval "\$doit_exec \$mkdirprog $prefixes") ||
+	  test -d "$dstdir" || exit 1
+	obsolete_mkdir_used=true
+      fi
+    fi
+  fi
+
+  if test -n "$dir_arg"; then
+    { test -z "$chowncmd" || $doit $chowncmd "$dst"; } &&
+    { test -z "$chgrpcmd" || $doit $chgrpcmd "$dst"; } &&
+    { test "$obsolete_mkdir_used$chowncmd$chgrpcmd" = false ||
+      test -z "$chmodcmd" || $doit $chmodcmd $mode "$dst"; } || exit 1
+  else
+
+    # Make a couple of temp file names in the proper directory.
+    dsttmp=$dstdir/_inst.$$_
+    rmtmp=$dstdir/_rm.$$_
+
+    # Trap to clean up those temp files at exit.
+    trap 'ret=$?; rm -f "$dsttmp" "$rmtmp" && exit $ret' 0
+
+    # Copy the file name to the temp name.
+    (umask $cp_umask && $doit_exec $cpprog "$src" "$dsttmp") &&
+
+    # and set any options; do chmod last to preserve setuid bits.
+    #
+    # If any of these fail, we abort the whole thing.  If we want to
+    # ignore errors from any of these, just make sure not to ignore
+    # errors from the above "$doit $cpprog $src $dsttmp" command.
+    #
+    { test -z "$chowncmd" || $doit $chowncmd "$dsttmp"; } &&
+    { test -z "$chgrpcmd" || $doit $chgrpcmd "$dsttmp"; } &&
+    { test -z "$stripcmd" || $doit $stripcmd "$dsttmp"; } &&
+    { test -z "$chmodcmd" || $doit $chmodcmd $mode "$dsttmp"; } &&
+
+    # If -C, don't bother to copy if it wouldn't change the file.
+    if $copy_on_change &&
+       old=`LC_ALL=C ls -dlL "$dst"	2>/dev/null` &&
+       new=`LC_ALL=C ls -dlL "$dsttmp"	2>/dev/null` &&
+
+       eval "$initialize_posix_glob" &&
+       $posix_glob set -f &&
+       set X $old && old=:$2:$4:$5:$6 &&
+       set X $new && new=:$2:$4:$5:$6 &&
+       $posix_glob set +f &&
+
+       test "$old" = "$new" &&
+       $cmpprog "$dst" "$dsttmp" >/dev/null 2>&1
+    then
+      rm -f "$dsttmp"
+    else
+      # Rename the file to the real destination.
+      $doit $mvcmd -f "$dsttmp" "$dst" 2>/dev/null ||
+
+      # The rename failed, perhaps because mv can't rename something else
+      # to itself, or perhaps because mv is so ancient that it does not
+      # support -f.
+      {
+	# Now remove or move aside any old file at destination location.
+	# We try this two ways since rm can't unlink itself on some
+	# systems and the destination file might be busy for other
+	# reasons.  In this case, the final cleanup might fail but the new
+	# file should still install successfully.
+	{
+	  test ! -f "$dst" ||
+	  $doit $rmcmd -f "$dst" 2>/dev/null ||
+	  { $doit $mvcmd -f "$dst" "$rmtmp" 2>/dev/null &&
+	    { $doit $rmcmd -f "$rmtmp" 2>/dev/null; :; }
+	  } ||
+	  { echo "$0: cannot unlink or rename $dst" >&2
+	    (exit 1); exit 1
+	  }
+	} &&
+
+	# Now rename the file to the real destination.
+	$doit $mvcmd "$dsttmp" "$dst"
+      }
+    fi || exit 1
+
+    trap '' 0
+  fi
+done
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "scriptversion="
+# time-stamp-format: "%:y-%02m-%02d.%02H"
+# time-stamp-end: "$"
+# End:
diff -urN dovecot-1.2.4/dovecot-libsieve/ltmain.sh dovecot-1.2.4.debian/dovecot-libsieve/ltmain.sh
--- dovecot-1.2.4/dovecot-libsieve/ltmain.sh	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/ltmain.sh	2009-09-02 07:31:47.000000000 +0200
@@ -0,0 +1,8413 @@
+# Generated from ltmain.m4sh.
+
+# ltmain.sh (GNU libtool) 2.2.6
+# Written by Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996
+
+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005, 2006, 2007 2008 Free Software Foundation, Inc.
+# This is free software; see the source for copying conditions.  There is NO
+# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+# GNU Libtool is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# As a special exception to the GNU General Public License,
+# if you distribute this file as part of a program or library that
+# is built using GNU Libtool, you may include this file under the
+# same distribution terms that you use for the rest of that program.
+#
+# GNU Libtool is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GNU Libtool; see the file COPYING.  If not, a copy
+# can be downloaded from http://www.gnu.org/licenses/gpl.html,
+# or obtained by writing to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+
+# Usage: $progname [OPTION]... [MODE-ARG]...
+#
+# Provide generalized library-building support services.
+#
+#     --config             show all configuration variables
+#     --debug              enable verbose shell tracing
+# -n, --dry-run            display commands without modifying any files
+#     --features           display basic configuration information and exit
+#     --mode=MODE          use operation mode MODE
+#     --preserve-dup-deps  don't remove duplicate dependency libraries
+#     --quiet, --silent    don't print informational messages
+#     --tag=TAG            use configuration variables from tag TAG
+# -v, --verbose            print informational messages (default)
+#     --version            print version information
+# -h, --help               print short or long help message
+#
+# MODE must be one of the following:
+#
+#       clean              remove files from the build directory
+#       compile            compile a source file into a libtool object
+#       execute            automatically set library path, then run a program
+#       finish             complete the installation of libtool libraries
+#       install            install libraries or executables
+#       link               create a library or an executable
+#       uninstall          remove libraries from an installed directory
+#
+# MODE-ARGS vary depending on the MODE.
+# Try `$progname --help --mode=MODE' for a more detailed description of MODE.
+#
+# When reporting a bug, please describe a test case to reproduce it and
+# include the following information:
+#
+#       host-triplet:	$host
+#       shell:		$SHELL
+#       compiler:		$LTCC
+#       compiler flags:		$LTCFLAGS
+#       linker:		$LD (gnu? $with_gnu_ld)
+#       $progname:		(GNU libtool) 2.2.6 Debian-2.2.6a-4
+#       automake:		$automake_version
+#       autoconf:		$autoconf_version
+#
+# Report bugs to <bug-libtool@gnu.org>.
+
+PROGRAM=ltmain.sh
+PACKAGE=libtool
+VERSION="2.2.6 Debian-2.2.6a-4"
+TIMESTAMP=""
+package_revision=1.3012
+
+# Be Bourne compatible
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in *posix*) set -o posix;; esac
+fi
+BIN_SH=xpg4; export BIN_SH # for Tru64
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# NLS nuisances: We save the old values to restore during execute mode.
+# Only set LANG and LC_ALL to C if already set.
+# These must not be set unconditionally because not all systems understand
+# e.g. LANG=C (notably SCO).
+lt_user_locale=
+lt_safe_locale=
+for lt_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES
+do
+  eval "if test \"\${$lt_var+set}\" = set; then
+          save_$lt_var=\$$lt_var
+          $lt_var=C
+	  export $lt_var
+	  lt_user_locale=\"$lt_var=\\\$save_\$lt_var; \$lt_user_locale\"
+	  lt_safe_locale=\"$lt_var=C; \$lt_safe_locale\"
+	fi"
+done
+
+$lt_unset CDPATH
+
+
+
+
+
+: ${CP="cp -f"}
+: ${ECHO="echo"}
+: ${EGREP="/bin/grep -E"}
+: ${FGREP="/bin/grep -F"}
+: ${GREP="/bin/grep"}
+: ${LN_S="ln -s"}
+: ${MAKE="make"}
+: ${MKDIR="mkdir"}
+: ${MV="mv -f"}
+: ${RM="rm -f"}
+: ${SED="/bin/sed"}
+: ${SHELL="${CONFIG_SHELL-/bin/sh}"}
+: ${Xsed="$SED -e 1s/^X//"}
+
+# Global variables:
+EXIT_SUCCESS=0
+EXIT_FAILURE=1
+EXIT_MISMATCH=63  # $? = 63 is used to indicate version mismatch to missing.
+EXIT_SKIP=77	  # $? = 77 is used to indicate a skipped test to automake.
+
+exit_status=$EXIT_SUCCESS
+
+# Make sure IFS has a sensible default
+lt_nl='
+'
+IFS=" 	$lt_nl"
+
+dirname="s,/[^/]*$,,"
+basename="s,^.*/,,"
+
+# func_dirname_and_basename file append nondir_replacement
+# perform func_basename and func_dirname in a single function
+# call:
+#   dirname:  Compute the dirname of FILE.  If nonempty,
+#             add APPEND to the result, otherwise set result
+#             to NONDIR_REPLACEMENT.
+#             value returned in "$func_dirname_result"
+#   basename: Compute filename of FILE.
+#             value retuned in "$func_basename_result"
+# Implementation must be kept synchronized with func_dirname
+# and func_basename. For efficiency, we do not delegate to
+# those functions but instead duplicate the functionality here.
+func_dirname_and_basename ()
+{
+  # Extract subdirectory from the argument.
+  func_dirname_result=`$ECHO "X${1}" | $Xsed -e "$dirname"`
+  if test "X$func_dirname_result" = "X${1}"; then
+    func_dirname_result="${3}"
+  else
+    func_dirname_result="$func_dirname_result${2}"
+  fi
+  func_basename_result=`$ECHO "X${1}" | $Xsed -e "$basename"`
+}
+
+# Generated shell functions inserted here.
+
+# Work around backward compatibility issue on IRIX 6.5. On IRIX 6.4+, sh
+# is ksh but when the shell is invoked as "sh" and the current value of
+# the _XPG environment variable is not equal to 1 (one), the special
+# positional parameter $0, within a function call, is the name of the
+# function.
+progpath="$0"
+
+# The name of this program:
+# In the unlikely event $progname began with a '-', it would play havoc with
+# func_echo (imagine progname=-n), so we prepend ./ in that case:
+func_dirname_and_basename "$progpath"
+progname=$func_basename_result
+case $progname in
+  -*) progname=./$progname ;;
+esac
+
+# Make sure we have an absolute path for reexecution:
+case $progpath in
+  [\\/]*|[A-Za-z]:\\*) ;;
+  *[\\/]*)
+     progdir=$func_dirname_result
+     progdir=`cd "$progdir" && pwd`
+     progpath="$progdir/$progname"
+     ;;
+  *)
+     save_IFS="$IFS"
+     IFS=:
+     for progdir in $PATH; do
+       IFS="$save_IFS"
+       test -x "$progdir/$progname" && break
+     done
+     IFS="$save_IFS"
+     test -n "$progdir" || progdir=`pwd`
+     progpath="$progdir/$progname"
+     ;;
+esac
+
+# Sed substitution that helps us do robust quoting.  It backslashifies
+# metacharacters that are still active within double-quoted strings.
+Xsed="${SED}"' -e 1s/^X//'
+sed_quote_subst='s/\([`"$\\]\)/\\\1/g'
+
+# Same as above, but do not quote variable references.
+double_quote_subst='s/\(["`\\]\)/\\\1/g'
+
+# Re-`\' parameter expansions in output of double_quote_subst that were
+# `\'-ed in input to the same.  If an odd number of `\' preceded a '$'
+# in input to double_quote_subst, that '$' was protected from expansion.
+# Since each input `\' is now two `\'s, look for any number of runs of
+# four `\'s followed by two `\'s and then a '$'.  `\' that '$'.
+bs='\\'
+bs2='\\\\'
+bs4='\\\\\\\\'
+dollar='\$'
+sed_double_backslash="\
+  s/$bs4/&\\
+/g
+  s/^$bs2$dollar/$bs&/
+  s/\\([^$bs]\\)$bs2$dollar/\\1$bs2$bs$dollar/g
+  s/\n//g"
+
+# Standard options:
+opt_dry_run=false
+opt_help=false
+opt_quiet=false
+opt_verbose=false
+opt_warning=:
+
+# func_echo arg...
+# Echo program name prefixed message, along with the current mode
+# name if it has been set yet.
+func_echo ()
+{
+    $ECHO "$progname${mode+: }$mode: $*"
+}
+
+# func_verbose arg...
+# Echo program name prefixed message in verbose mode only.
+func_verbose ()
+{
+    $opt_verbose && func_echo ${1+"$@"}
+
+    # A bug in bash halts the script if the last line of a function
+    # fails when set -e is in force, so we need another command to
+    # work around that:
+    :
+}
+
+# func_error arg...
+# Echo program name prefixed message to standard error.
+func_error ()
+{
+    $ECHO "$progname${mode+: }$mode: "${1+"$@"} 1>&2
+}
+
+# func_warning arg...
+# Echo program name prefixed warning message to standard error.
+func_warning ()
+{
+    $opt_warning && $ECHO "$progname${mode+: }$mode: warning: "${1+"$@"} 1>&2
+
+    # bash bug again:
+    :
+}
+
+# func_fatal_error arg...
+# Echo program name prefixed message to standard error, and exit.
+func_fatal_error ()
+{
+    func_error ${1+"$@"}
+    exit $EXIT_FAILURE
+}
+
+# func_fatal_help arg...
+# Echo program name prefixed message to standard error, followed by
+# a help hint, and exit.
+func_fatal_help ()
+{
+    func_error ${1+"$@"}
+    func_fatal_error "$help"
+}
+help="Try \`$progname --help' for more information."  ## default
+
+
+# func_grep expression filename
+# Check whether EXPRESSION matches any line of FILENAME, without output.
+func_grep ()
+{
+    $GREP "$1" "$2" >/dev/null 2>&1
+}
+
+
+# func_mkdir_p directory-path
+# Make sure the entire path to DIRECTORY-PATH is available.
+func_mkdir_p ()
+{
+    my_directory_path="$1"
+    my_dir_list=
+
+    if test -n "$my_directory_path" && test "$opt_dry_run" != ":"; then
+
+      # Protect directory names starting with `-'
+      case $my_directory_path in
+        -*) my_directory_path="./$my_directory_path" ;;
+      esac
+
+      # While some portion of DIR does not yet exist...
+      while test ! -d "$my_directory_path"; do
+        # ...make a list in topmost first order.  Use a colon delimited
+	# list incase some portion of path contains whitespace.
+        my_dir_list="$my_directory_path:$my_dir_list"
+
+        # If the last portion added has no slash in it, the list is done
+        case $my_directory_path in */*) ;; *) break ;; esac
+
+        # ...otherwise throw away the child directory and loop
+        my_directory_path=`$ECHO "X$my_directory_path" | $Xsed -e "$dirname"`
+      done
+      my_dir_list=`$ECHO "X$my_dir_list" | $Xsed -e 's,:*$,,'`
+
+      save_mkdir_p_IFS="$IFS"; IFS=':'
+      for my_dir in $my_dir_list; do
+	IFS="$save_mkdir_p_IFS"
+        # mkdir can fail with a `File exist' error if two processes
+        # try to create one of the directories concurrently.  Don't
+        # stop in that case!
+        $MKDIR "$my_dir" 2>/dev/null || :
+      done
+      IFS="$save_mkdir_p_IFS"
+
+      # Bail out if we (or some other process) failed to create a directory.
+      test -d "$my_directory_path" || \
+        func_fatal_error "Failed to create \`$1'"
+    fi
+}
+
+
+# func_mktempdir [string]
+# Make a temporary directory that won't clash with other running
+# libtool processes, and avoids race conditions if possible.  If
+# given, STRING is the basename for that directory.
+func_mktempdir ()
+{
+    my_template="${TMPDIR-/tmp}/${1-$progname}"
+
+    if test "$opt_dry_run" = ":"; then
+      # Return a directory name, but don't create it in dry-run mode
+      my_tmpdir="${my_template}-$$"
+    else
+
+      # If mktemp works, use that first and foremost
+      my_tmpdir=`mktemp -d "${my_template}-XXXXXXXX" 2>/dev/null`
+
+      if test ! -d "$my_tmpdir"; then
+        # Failing that, at least try and use $RANDOM to avoid a race
+        my_tmpdir="${my_template}-${RANDOM-0}$$"
+
+        save_mktempdir_umask=`umask`
+        umask 0077
+        $MKDIR "$my_tmpdir"
+        umask $save_mktempdir_umask
+      fi
+
+      # If we're not in dry-run mode, bomb out on failure
+      test -d "$my_tmpdir" || \
+        func_fatal_error "cannot create temporary directory \`$my_tmpdir'"
+    fi
+
+    $ECHO "X$my_tmpdir" | $Xsed
+}
+
+
+# func_quote_for_eval arg
+# Aesthetically quote ARG to be evaled later.
+# This function returns two values: FUNC_QUOTE_FOR_EVAL_RESULT
+# is double-quoted, suitable for a subsequent eval, whereas
+# FUNC_QUOTE_FOR_EVAL_UNQUOTED_RESULT has merely all characters
+# which are still active within double quotes backslashified.
+func_quote_for_eval ()
+{
+    case $1 in
+      *[\\\`\"\$]*)
+	func_quote_for_eval_unquoted_result=`$ECHO "X$1" | $Xsed -e "$sed_quote_subst"` ;;
+      *)
+        func_quote_for_eval_unquoted_result="$1" ;;
+    esac
+
+    case $func_quote_for_eval_unquoted_result in
+      # Double-quote args containing shell metacharacters to delay
+      # word splitting, command substitution and and variable
+      # expansion for a subsequent eval.
+      # Many Bourne shells cannot handle close brackets correctly
+      # in scan sets, so we specify it separately.
+      *[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
+        func_quote_for_eval_result="\"$func_quote_for_eval_unquoted_result\""
+        ;;
+      *)
+        func_quote_for_eval_result="$func_quote_for_eval_unquoted_result"
+    esac
+}
+
+
+# func_quote_for_expand arg
+# Aesthetically quote ARG to be evaled later; same as above,
+# but do not quote variable references.
+func_quote_for_expand ()
+{
+    case $1 in
+      *[\\\`\"]*)
+	my_arg=`$ECHO "X$1" | $Xsed \
+	    -e "$double_quote_subst" -e "$sed_double_backslash"` ;;
+      *)
+        my_arg="$1" ;;
+    esac
+
+    case $my_arg in
+      # Double-quote args containing shell metacharacters to delay
+      # word splitting and command substitution for a subsequent eval.
+      # Many Bourne shells cannot handle close brackets correctly
+      # in scan sets, so we specify it separately.
+      *[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
+        my_arg="\"$my_arg\""
+        ;;
+    esac
+
+    func_quote_for_expand_result="$my_arg"
+}
+
+
+# func_show_eval cmd [fail_exp]
+# Unless opt_silent is true, then output CMD.  Then, if opt_dryrun is
+# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP
+# is given, then evaluate it.
+func_show_eval ()
+{
+    my_cmd="$1"
+    my_fail_exp="${2-:}"
+
+    ${opt_silent-false} || {
+      func_quote_for_expand "$my_cmd"
+      eval "func_echo $func_quote_for_expand_result"
+    }
+
+    if ${opt_dry_run-false}; then :; else
+      eval "$my_cmd"
+      my_status=$?
+      if test "$my_status" -eq 0; then :; else
+	eval "(exit $my_status); $my_fail_exp"
+      fi
+    fi
+}
+
+
+# func_show_eval_locale cmd [fail_exp]
+# Unless opt_silent is true, then output CMD.  Then, if opt_dryrun is
+# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP
+# is given, then evaluate it.  Use the saved locale for evaluation.
+func_show_eval_locale ()
+{
+    my_cmd="$1"
+    my_fail_exp="${2-:}"
+
+    ${opt_silent-false} || {
+      func_quote_for_expand "$my_cmd"
+      eval "func_echo $func_quote_for_expand_result"
+    }
+
+    if ${opt_dry_run-false}; then :; else
+      eval "$lt_user_locale
+	    $my_cmd"
+      my_status=$?
+      eval "$lt_safe_locale"
+      if test "$my_status" -eq 0; then :; else
+	eval "(exit $my_status); $my_fail_exp"
+      fi
+    fi
+}
+
+
+
+
+
+# func_version
+# Echo version message to standard output and exit.
+func_version ()
+{
+    $SED -n '/^# '$PROGRAM' (GNU /,/# warranty; / {
+        s/^# //
+	s/^# *$//
+        s/\((C)\)[ 0-9,-]*\( [1-9][0-9]*\)/\1\2/
+        p
+     }' < "$progpath"
+     exit $?
+}
+
+# func_usage
+# Echo short help message to standard output and exit.
+func_usage ()
+{
+    $SED -n '/^# Usage:/,/# -h/ {
+        s/^# //
+	s/^# *$//
+	s/\$progname/'$progname'/
+	p
+    }' < "$progpath"
+    $ECHO
+    $ECHO "run \`$progname --help | more' for full usage"
+    exit $?
+}
+
+# func_help
+# Echo long help message to standard output and exit.
+func_help ()
+{
+    $SED -n '/^# Usage:/,/# Report bugs to/ {
+        s/^# //
+	s/^# *$//
+	s*\$progname*'$progname'*
+	s*\$host*'"$host"'*
+	s*\$SHELL*'"$SHELL"'*
+	s*\$LTCC*'"$LTCC"'*
+	s*\$LTCFLAGS*'"$LTCFLAGS"'*
+	s*\$LD*'"$LD"'*
+	s/\$with_gnu_ld/'"$with_gnu_ld"'/
+	s/\$automake_version/'"`(automake --version) 2>/dev/null |$SED 1q`"'/
+	s/\$autoconf_version/'"`(autoconf --version) 2>/dev/null |$SED 1q`"'/
+	p
+     }' < "$progpath"
+    exit $?
+}
+
+# func_missing_arg argname
+# Echo program name prefixed message to standard error and set global
+# exit_cmd.
+func_missing_arg ()
+{
+    func_error "missing argument for $1"
+    exit_cmd=exit
+}
+
+exit_cmd=:
+
+
+
+
+
+# Check that we have a working $ECHO.
+if test "X$1" = X--no-reexec; then
+  # Discard the --no-reexec flag, and continue.
+  shift
+elif test "X$1" = X--fallback-echo; then
+  # Avoid inline document here, it may be left over
+  :
+elif test "X`{ $ECHO '\t'; } 2>/dev/null`" = 'X\t'; then
+  # Yippee, $ECHO works!
+  :
+else
+  # Restart under the correct shell, and then maybe $ECHO will work.
+  exec $SHELL "$progpath" --no-reexec ${1+"$@"}
+fi
+
+if test "X$1" = X--fallback-echo; then
+  # used as fallback echo
+  shift
+  cat <<EOF
+$*
+EOF
+  exit $EXIT_SUCCESS
+fi
+
+magic="%%%MAGIC variable%%%"
+magic_exe="%%%MAGIC EXE variable%%%"
+
+# Global variables.
+# $mode is unset
+nonopt=
+execute_dlfiles=
+preserve_args=
+lo2o="s/\\.lo\$/.${objext}/"
+o2lo="s/\\.${objext}\$/.lo/"
+extracted_archives=
+extracted_serial=0
+
+opt_dry_run=false
+opt_duplicate_deps=false
+opt_silent=false
+opt_debug=:
+
+# If this variable is set in any of the actions, the command in it
+# will be execed at the end.  This prevents here-documents from being
+# left over by shells.
+exec_cmd=
+
+# func_fatal_configuration arg...
+# Echo program name prefixed message to standard error, followed by
+# a configuration failure hint, and exit.
+func_fatal_configuration ()
+{
+    func_error ${1+"$@"}
+    func_error "See the $PACKAGE documentation for more information."
+    func_fatal_error "Fatal configuration error."
+}
+
+
+# func_config
+# Display the configuration for all the tags in this script.
+func_config ()
+{
+    re_begincf='^# ### BEGIN LIBTOOL'
+    re_endcf='^# ### END LIBTOOL'
+
+    # Default configuration.
+    $SED "1,/$re_begincf CONFIG/d;/$re_endcf CONFIG/,\$d" < "$progpath"
+
+    # Now print the configurations for the tags.
+    for tagname in $taglist; do
+      $SED -n "/$re_begincf TAG CONFIG: $tagname\$/,/$re_endcf TAG CONFIG: $tagname\$/p" < "$progpath"
+    done
+
+    exit $?
+}
+
+# func_features
+# Display the features supported by this script.
+func_features ()
+{
+    $ECHO "host: $host"
+    if test "$build_libtool_libs" = yes; then
+      $ECHO "enable shared libraries"
+    else
+      $ECHO "disable shared libraries"
+    fi
+    if test "$build_old_libs" = yes; then
+      $ECHO "enable static libraries"
+    else
+      $ECHO "disable static libraries"
+    fi
+
+    exit $?
+}
+
+# func_enable_tag tagname
+# Verify that TAGNAME is valid, and either flag an error and exit, or
+# enable the TAGNAME tag.  We also add TAGNAME to the global $taglist
+# variable here.
+func_enable_tag ()
+{
+  # Global variable:
+  tagname="$1"
+
+  re_begincf="^# ### BEGIN LIBTOOL TAG CONFIG: $tagname\$"
+  re_endcf="^# ### END LIBTOOL TAG CONFIG: $tagname\$"
+  sed_extractcf="/$re_begincf/,/$re_endcf/p"
+
+  # Validate tagname.
+  case $tagname in
+    *[!-_A-Za-z0-9,/]*)
+      func_fatal_error "invalid tag name: $tagname"
+      ;;
+  esac
+
+  # Don't test for the "default" C tag, as we know it's
+  # there but not specially marked.
+  case $tagname in
+    CC) ;;
+    *)
+      if $GREP "$re_begincf" "$progpath" >/dev/null 2>&1; then
+	taglist="$taglist $tagname"
+
+	# Evaluate the configuration.  Be careful to quote the path
+	# and the sed script, to avoid splitting on whitespace, but
+	# also don't use non-portable quotes within backquotes within
+	# quotes we have to do it in 2 steps:
+	extractedcf=`$SED -n -e "$sed_extractcf" < "$progpath"`
+	eval "$extractedcf"
+      else
+	func_error "ignoring unknown tag $tagname"
+      fi
+      ;;
+  esac
+}
+
+# Parse options once, thoroughly.  This comes as soon as possible in
+# the script to make things like `libtool --version' happen quickly.
+{
+
+  # Shorthand for --mode=foo, only valid as the first argument
+  case $1 in
+  clean|clea|cle|cl)
+    shift; set dummy --mode clean ${1+"$@"}; shift
+    ;;
+  compile|compil|compi|comp|com|co|c)
+    shift; set dummy --mode compile ${1+"$@"}; shift
+    ;;
+  execute|execut|execu|exec|exe|ex|e)
+    shift; set dummy --mode execute ${1+"$@"}; shift
+    ;;
+  finish|finis|fini|fin|fi|f)
+    shift; set dummy --mode finish ${1+"$@"}; shift
+    ;;
+  install|instal|insta|inst|ins|in|i)
+    shift; set dummy --mode install ${1+"$@"}; shift
+    ;;
+  link|lin|li|l)
+    shift; set dummy --mode link ${1+"$@"}; shift
+    ;;
+  uninstall|uninstal|uninsta|uninst|unins|unin|uni|un|u)
+    shift; set dummy --mode uninstall ${1+"$@"}; shift
+    ;;
+  esac
+
+  # Parse non-mode specific arguments:
+  while test "$#" -gt 0; do
+    opt="$1"
+    shift
+
+    case $opt in
+      --config)		func_config					;;
+
+      --debug)		preserve_args="$preserve_args $opt"
+			func_echo "enabling shell trace mode"
+			opt_debug='set -x'
+			$opt_debug
+			;;
+
+      -dlopen)		test "$#" -eq 0 && func_missing_arg "$opt" && break
+			execute_dlfiles="$execute_dlfiles $1"
+			shift
+			;;
+
+      --dry-run | -n)	opt_dry_run=:					;;
+      --features)       func_features					;;
+      --finish)		mode="finish"					;;
+
+      --mode)		test "$#" -eq 0 && func_missing_arg "$opt" && break
+			case $1 in
+			  # Valid mode arguments:
+			  clean)	;;
+			  compile)	;;
+			  execute)	;;
+			  finish)	;;
+			  install)	;;
+			  link)		;;
+			  relink)	;;
+			  uninstall)	;;
+
+			  # Catch anything else as an error
+			  *) func_error "invalid argument for $opt"
+			     exit_cmd=exit
+			     break
+			     ;;
+		        esac
+
+			mode="$1"
+			shift
+			;;
+
+      --preserve-dup-deps)
+			opt_duplicate_deps=:				;;
+
+      --quiet|--silent)	preserve_args="$preserve_args $opt"
+			opt_silent=:
+			;;
+
+      --verbose| -v)	preserve_args="$preserve_args $opt"
+			opt_silent=false
+			;;
+
+      --tag)		test "$#" -eq 0 && func_missing_arg "$opt" && break
+			preserve_args="$preserve_args $opt $1"
+			func_enable_tag "$1"	# tagname is set here
+			shift
+			;;
+
+      # Separate optargs to long options:
+      -dlopen=*|--mode=*|--tag=*)
+			func_opt_split "$opt"
+			set dummy "$func_opt_split_opt" "$func_opt_split_arg" ${1+"$@"}
+			shift
+			;;
+
+      -\?|-h)		func_usage					;;
+      --help)		opt_help=:					;;
+      --version)	func_version					;;
+
+      -*)		func_fatal_help "unrecognized option \`$opt'"	;;
+
+      *)		nonopt="$opt"
+			break
+			;;
+    esac
+  done
+
+
+  case $host in
+    *cygwin* | *mingw* | *pw32* | *cegcc*)
+      # don't eliminate duplications in $postdeps and $predeps
+      opt_duplicate_compiler_generated_deps=:
+      ;;
+    *)
+      opt_duplicate_compiler_generated_deps=$opt_duplicate_deps
+      ;;
+  esac
+
+  # Having warned about all mis-specified options, bail out if
+  # anything was wrong.
+  $exit_cmd $EXIT_FAILURE
+}
+
+# func_check_version_match
+# Ensure that we are using m4 macros, and libtool script from the same
+# release of libtool.
+func_check_version_match ()
+{
+  if test "$package_revision" != "$macro_revision"; then
+    if test "$VERSION" != "$macro_version"; then
+      if test -z "$macro_version"; then
+        cat >&2 <<_LT_EOF
+$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the
+$progname: definition of this LT_INIT comes from an older release.
+$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION
+$progname: and run autoconf again.
+_LT_EOF
+      else
+        cat >&2 <<_LT_EOF
+$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the
+$progname: definition of this LT_INIT comes from $PACKAGE $macro_version.
+$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION
+$progname: and run autoconf again.
+_LT_EOF
+      fi
+    else
+      cat >&2 <<_LT_EOF
+$progname: Version mismatch error.  This is $PACKAGE $VERSION, revision $package_revision,
+$progname: but the definition of this LT_INIT comes from revision $macro_revision.
+$progname: You should recreate aclocal.m4 with macros from revision $package_revision
+$progname: of $PACKAGE $VERSION and run autoconf again.
+_LT_EOF
+    fi
+
+    exit $EXIT_MISMATCH
+  fi
+}
+
+
+## ----------- ##
+##    Main.    ##
+## ----------- ##
+
+$opt_help || {
+  # Sanity checks first:
+  func_check_version_match
+
+  if test "$build_libtool_libs" != yes && test "$build_old_libs" != yes; then
+    func_fatal_configuration "not configured to build any kind of library"
+  fi
+
+  test -z "$mode" && func_fatal_error "error: you must specify a MODE."
+
+
+  # Darwin sucks
+  eval std_shrext=\"$shrext_cmds\"
+
+
+  # Only execute mode is allowed to have -dlopen flags.
+  if test -n "$execute_dlfiles" && test "$mode" != execute; then
+    func_error "unrecognized option \`-dlopen'"
+    $ECHO "$help" 1>&2
+    exit $EXIT_FAILURE
+  fi
+
+  # Change the help message to a mode-specific one.
+  generic_help="$help"
+  help="Try \`$progname --help --mode=$mode' for more information."
+}
+
+
+# func_lalib_p file
+# True iff FILE is a libtool `.la' library or `.lo' object file.
+# This function is only a basic sanity check; it will hardly flush out
+# determined imposters.
+func_lalib_p ()
+{
+    test -f "$1" &&
+      $SED -e 4q "$1" 2>/dev/null \
+        | $GREP "^# Generated by .*$PACKAGE" > /dev/null 2>&1
+}
+
+# func_lalib_unsafe_p file
+# True iff FILE is a libtool `.la' library or `.lo' object file.
+# This function implements the same check as func_lalib_p without
+# resorting to external programs.  To this end, it redirects stdin and
+# closes it afterwards, without saving the original file descriptor.
+# As a safety measure, use it only where a negative result would be
+# fatal anyway.  Works if `file' does not exist.
+func_lalib_unsafe_p ()
+{
+    lalib_p=no
+    if test -f "$1" && test -r "$1" && exec 5<&0 <"$1"; then
+	for lalib_p_l in 1 2 3 4
+	do
+	    read lalib_p_line
+	    case "$lalib_p_line" in
+		\#\ Generated\ by\ *$PACKAGE* ) lalib_p=yes; break;;
+	    esac
+	done
+	exec 0<&5 5<&-
+    fi
+    test "$lalib_p" = yes
+}
+
+# func_ltwrapper_script_p file
+# True iff FILE is a libtool wrapper script
+# This function is only a basic sanity check; it will hardly flush out
+# determined imposters.
+func_ltwrapper_script_p ()
+{
+    func_lalib_p "$1"
+}
+
+# func_ltwrapper_executable_p file
+# True iff FILE is a libtool wrapper executable
+# This function is only a basic sanity check; it will hardly flush out
+# determined imposters.
+func_ltwrapper_executable_p ()
+{
+    func_ltwrapper_exec_suffix=
+    case $1 in
+    *.exe) ;;
+    *) func_ltwrapper_exec_suffix=.exe ;;
+    esac
+    $GREP "$magic_exe" "$1$func_ltwrapper_exec_suffix" >/dev/null 2>&1
+}
+
+# func_ltwrapper_scriptname file
+# Assumes file is an ltwrapper_executable
+# uses $file to determine the appropriate filename for a
+# temporary ltwrapper_script.
+func_ltwrapper_scriptname ()
+{
+    func_ltwrapper_scriptname_result=""
+    if func_ltwrapper_executable_p "$1"; then
+	func_dirname_and_basename "$1" "" "."
+	func_stripname '' '.exe' "$func_basename_result"
+	func_ltwrapper_scriptname_result="$func_dirname_result/$objdir/${func_stripname_result}_ltshwrapper"
+    fi
+}
+
+# func_ltwrapper_p file
+# True iff FILE is a libtool wrapper script or wrapper executable
+# This function is only a basic sanity check; it will hardly flush out
+# determined imposters.
+func_ltwrapper_p ()
+{
+    func_ltwrapper_script_p "$1" || func_ltwrapper_executable_p "$1"
+}
+
+
+# func_execute_cmds commands fail_cmd
+# Execute tilde-delimited COMMANDS.
+# If FAIL_CMD is given, eval that upon failure.
+# FAIL_CMD may read-access the current command in variable CMD!
+func_execute_cmds ()
+{
+    $opt_debug
+    save_ifs=$IFS; IFS='~'
+    for cmd in $1; do
+      IFS=$save_ifs
+      eval cmd=\"$cmd\"
+      func_show_eval "$cmd" "${2-:}"
+    done
+    IFS=$save_ifs
+}
+
+
+# func_source file
+# Source FILE, adding directory component if necessary.
+# Note that it is not necessary on cygwin/mingw to append a dot to
+# FILE even if both FILE and FILE.exe exist: automatic-append-.exe
+# behavior happens only for exec(3), not for open(2)!  Also, sourcing
+# `FILE.' does not work on cygwin managed mounts.
+func_source ()
+{
+    $opt_debug
+    case $1 in
+    */* | *\\*)	. "$1" ;;
+    *)		. "./$1" ;;
+    esac
+}
+
+
+# func_infer_tag arg
+# Infer tagged configuration to use if any are available and
+# if one wasn't chosen via the "--tag" command line option.
+# Only attempt this if the compiler in the base compile
+# command doesn't match the default compiler.
+# arg is usually of the form 'gcc ...'
+func_infer_tag ()
+{
+    $opt_debug
+    if test -n "$available_tags" && test -z "$tagname"; then
+      CC_quoted=
+      for arg in $CC; do
+        func_quote_for_eval "$arg"
+	CC_quoted="$CC_quoted $func_quote_for_eval_result"
+      done
+      case $@ in
+      # Blanks in the command may have been stripped by the calling shell,
+      # but not from the CC environment variable when configure was run.
+      " $CC "* | "$CC "* | " `$ECHO $CC` "* | "`$ECHO $CC` "* | " $CC_quoted"* | "$CC_quoted "* | " `$ECHO $CC_quoted` "* | "`$ECHO $CC_quoted` "*) ;;
+      # Blanks at the start of $base_compile will cause this to fail
+      # if we don't check for them as well.
+      *)
+	for z in $available_tags; do
+	  if $GREP "^# ### BEGIN LIBTOOL TAG CONFIG: $z$" < "$progpath" > /dev/null; then
+	    # Evaluate the configuration.
+	    eval "`${SED} -n -e '/^# ### BEGIN LIBTOOL TAG CONFIG: '$z'$/,/^# ### END LIBTOOL TAG CONFIG: '$z'$/p' < $progpath`"
+	    CC_quoted=
+	    for arg in $CC; do
+	      # Double-quote args containing other shell metacharacters.
+	      func_quote_for_eval "$arg"
+	      CC_quoted="$CC_quoted $func_quote_for_eval_result"
+	    done
+	    case "$@ " in
+	      " $CC "* | "$CC "* | " `$ECHO $CC` "* | "`$ECHO $CC` "* | " $CC_quoted"* | "$CC_quoted "* | " `$ECHO $CC_quoted` "* | "`$ECHO $CC_quoted` "*)
+	      # The compiler in the base compile command matches
+	      # the one in the tagged configuration.
+	      # Assume this is the tagged configuration we want.
+	      tagname=$z
+	      break
+	      ;;
+	    esac
+	  fi
+	done
+	# If $tagname still isn't set, then no tagged configuration
+	# was found and let the user know that the "--tag" command
+	# line option must be used.
+	if test -z "$tagname"; then
+	  func_echo "unable to infer tagged configuration"
+	  func_fatal_error "specify a tag with \`--tag'"
+#	else
+#	  func_verbose "using $tagname tagged configuration"
+	fi
+	;;
+      esac
+    fi
+}
+
+
+
+# func_write_libtool_object output_name pic_name nonpic_name
+# Create a libtool object file (analogous to a ".la" file),
+# but don't create it if we're doing a dry run.
+func_write_libtool_object ()
+{
+    write_libobj=${1}
+    if test "$build_libtool_libs" = yes; then
+      write_lobj=\'${2}\'
+    else
+      write_lobj=none
+    fi
+
+    if test "$build_old_libs" = yes; then
+      write_oldobj=\'${3}\'
+    else
+      write_oldobj=none
+    fi
+
+    $opt_dry_run || {
+      cat >${write_libobj}T <<EOF
+# $write_libobj - a libtool object file
+# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION
+#
+# Please DO NOT delete this file!
+# It is necessary for linking the library.
+
+# Name of the PIC object.
+pic_object=$write_lobj
+
+# Name of the non-PIC object
+non_pic_object=$write_oldobj
+
+EOF
+      $MV "${write_libobj}T" "${write_libobj}"
+    }
+}
+
+# func_mode_compile arg...
+func_mode_compile ()
+{
+    $opt_debug
+    # Get the compilation command and the source file.
+    base_compile=
+    srcfile="$nonopt"  #  always keep a non-empty value in "srcfile"
+    suppress_opt=yes
+    suppress_output=
+    arg_mode=normal
+    libobj=
+    later=
+    pie_flag=
+
+    for arg
+    do
+      case $arg_mode in
+      arg  )
+	# do not "continue".  Instead, add this to base_compile
+	lastarg="$arg"
+	arg_mode=normal
+	;;
+
+      target )
+	libobj="$arg"
+	arg_mode=normal
+	continue
+	;;
+
+      normal )
+	# Accept any command-line options.
+	case $arg in
+	-o)
+	  test -n "$libobj" && \
+	    func_fatal_error "you cannot specify \`-o' more than once"
+	  arg_mode=target
+	  continue
+	  ;;
+
+	-pie | -fpie | -fPIE)
+          pie_flag="$pie_flag $arg"
+	  continue
+	  ;;
+
+	-shared | -static | -prefer-pic | -prefer-non-pic)
+	  later="$later $arg"
+	  continue
+	  ;;
+
+	-no-suppress)
+	  suppress_opt=no
+	  continue
+	  ;;
+
+	-Xcompiler)
+	  arg_mode=arg  #  the next one goes into the "base_compile" arg list
+	  continue      #  The current "srcfile" will either be retained or
+	  ;;            #  replaced later.  I would guess that would be a bug.
+
+	-Wc,*)
+	  func_stripname '-Wc,' '' "$arg"
+	  args=$func_stripname_result
+	  lastarg=
+	  save_ifs="$IFS"; IFS=','
+	  for arg in $args; do
+	    IFS="$save_ifs"
+	    func_quote_for_eval "$arg"
+	    lastarg="$lastarg $func_quote_for_eval_result"
+	  done
+	  IFS="$save_ifs"
+	  func_stripname ' ' '' "$lastarg"
+	  lastarg=$func_stripname_result
+
+	  # Add the arguments to base_compile.
+	  base_compile="$base_compile $lastarg"
+	  continue
+	  ;;
+
+	*)
+	  # Accept the current argument as the source file.
+	  # The previous "srcfile" becomes the current argument.
+	  #
+	  lastarg="$srcfile"
+	  srcfile="$arg"
+	  ;;
+	esac  #  case $arg
+	;;
+      esac    #  case $arg_mode
+
+      # Aesthetically quote the previous argument.
+      func_quote_for_eval "$lastarg"
+      base_compile="$base_compile $func_quote_for_eval_result"
+    done # for arg
+
+    case $arg_mode in
+    arg)
+      func_fatal_error "you must specify an argument for -Xcompile"
+      ;;
+    target)
+      func_fatal_error "you must specify a target with \`-o'"
+      ;;
+    *)
+      # Get the name of the library object.
+      test -z "$libobj" && {
+	func_basename "$srcfile"
+	libobj="$func_basename_result"
+      }
+      ;;
+    esac
+
+    # Recognize several different file suffixes.
+    # If the user specifies -o file.o, it is replaced with file.lo
+    case $libobj in
+    *.[cCFSifmso] | \
+    *.ada | *.adb | *.ads | *.asm | \
+    *.c++ | *.cc | *.ii | *.class | *.cpp | *.cxx | \
+    *.[fF][09]? | *.for | *.java | *.obj | *.sx)
+      func_xform "$libobj"
+      libobj=$func_xform_result
+      ;;
+    esac
+
+    case $libobj in
+    *.lo) func_lo2o "$libobj"; obj=$func_lo2o_result ;;
+    *)
+      func_fatal_error "cannot determine name of library object from \`$libobj'"
+      ;;
+    esac
+
+    func_infer_tag $base_compile
+
+    for arg in $later; do
+      case $arg in
+      -shared)
+	test "$build_libtool_libs" != yes && \
+	  func_fatal_configuration "can not build a shared library"
+	build_old_libs=no
+	continue
+	;;
+
+      -static)
+	build_libtool_libs=no
+	build_old_libs=yes
+	continue
+	;;
+
+      -prefer-pic)
+	pic_mode=yes
+	continue
+	;;
+
+      -prefer-non-pic)
+	pic_mode=no
+	continue
+	;;
+      esac
+    done
+
+    func_quote_for_eval "$libobj"
+    test "X$libobj" != "X$func_quote_for_eval_result" \
+      && $ECHO "X$libobj" | $GREP '[]~#^*{};<>?"'"'"'	 &()|`$[]' \
+      && func_warning "libobj name \`$libobj' may not contain shell special characters."
+    func_dirname_and_basename "$obj" "/" ""
+    objname="$func_basename_result"
+    xdir="$func_dirname_result"
+    lobj=${xdir}$objdir/$objname
+
+    test -z "$base_compile" && \
+      func_fatal_help "you must specify a compilation command"
+
+    # Delete any leftover library objects.
+    if test "$build_old_libs" = yes; then
+      removelist="$obj $lobj $libobj ${libobj}T"
+    else
+      removelist="$lobj $libobj ${libobj}T"
+    fi
+
+    # On Cygwin there's no "real" PIC flag so we must build both object types
+    case $host_os in
+    cygwin* | mingw* | pw32* | os2* | cegcc*)
+      pic_mode=default
+      ;;
+    esac
+    if test "$pic_mode" = no && test "$deplibs_check_method" != pass_all; then
+      # non-PIC code in shared libraries is not supported
+      pic_mode=default
+    fi
+
+    # Calculate the filename of the output object if compiler does
+    # not support -o with -c
+    if test "$compiler_c_o" = no; then
+      output_obj=`$ECHO "X$srcfile" | $Xsed -e 's%^.*/%%' -e 's%\.[^.]*$%%'`.${objext}
+      lockfile="$output_obj.lock"
+    else
+      output_obj=
+      need_locks=no
+      lockfile=
+    fi
+
+    # Lock this critical section if it is needed
+    # We use this script file to make the link, it avoids creating a new file
+    if test "$need_locks" = yes; then
+      until $opt_dry_run || ln "$progpath" "$lockfile" 2>/dev/null; do
+	func_echo "Waiting for $lockfile to be removed"
+	sleep 2
+      done
+    elif test "$need_locks" = warn; then
+      if test -f "$lockfile"; then
+	$ECHO "\
+*** ERROR, $lockfile exists and contains:
+`cat $lockfile 2>/dev/null`
+
+This indicates that another process is trying to use the same
+temporary object file, and libtool could not work around it because
+your compiler does not support \`-c' and \`-o' together.  If you
+repeat this compilation, it may succeed, by chance, but you had better
+avoid parallel builds (make -j) in this platform, or get a better
+compiler."
+
+	$opt_dry_run || $RM $removelist
+	exit $EXIT_FAILURE
+      fi
+      removelist="$removelist $output_obj"
+      $ECHO "$srcfile" > "$lockfile"
+    fi
+
+    $opt_dry_run || $RM $removelist
+    removelist="$removelist $lockfile"
+    trap '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE' 1 2 15
+
+    if test -n "$fix_srcfile_path"; then
+      eval srcfile=\"$fix_srcfile_path\"
+    fi
+    func_quote_for_eval "$srcfile"
+    qsrcfile=$func_quote_for_eval_result
+
+    # Only build a PIC object if we are building libtool libraries.
+    if test "$build_libtool_libs" = yes; then
+      # Without this assignment, base_compile gets emptied.
+      fbsd_hideous_sh_bug=$base_compile
+
+      if test "$pic_mode" != no; then
+	command="$base_compile $qsrcfile $pic_flag"
+      else
+	# Don't build PIC code
+	command="$base_compile $qsrcfile"
+      fi
+
+      func_mkdir_p "$xdir$objdir"
+
+      if test -z "$output_obj"; then
+	# Place PIC objects in $objdir
+	command="$command -o $lobj"
+      fi
+
+      func_show_eval_locale "$command"	\
+          'test -n "$output_obj" && $RM $removelist; exit $EXIT_FAILURE'
+
+      if test "$need_locks" = warn &&
+	 test "X`cat $lockfile 2>/dev/null`" != "X$srcfile"; then
+	$ECHO "\
+*** ERROR, $lockfile contains:
+`cat $lockfile 2>/dev/null`
+
+but it should contain:
+$srcfile
+
+This indicates that another process is trying to use the same
+temporary object file, and libtool could not work around it because
+your compiler does not support \`-c' and \`-o' together.  If you
+repeat this compilation, it may succeed, by chance, but you had better
+avoid parallel builds (make -j) in this platform, or get a better
+compiler."
+
+	$opt_dry_run || $RM $removelist
+	exit $EXIT_FAILURE
+      fi
+
+      # Just move the object if needed, then go on to compile the next one
+      if test -n "$output_obj" && test "X$output_obj" != "X$lobj"; then
+	func_show_eval '$MV "$output_obj" "$lobj"' \
+	  'error=$?; $opt_dry_run || $RM $removelist; exit $error'
+      fi
+
+      # Allow error messages only from the first compilation.
+      if test "$suppress_opt" = yes; then
+	suppress_output=' >/dev/null 2>&1'
+      fi
+    fi
+
+    # Only build a position-dependent object if we build old libraries.
+    if test "$build_old_libs" = yes; then
+      if test "$pic_mode" != yes; then
+	# Don't build PIC code
+	command="$base_compile $qsrcfile$pie_flag"
+      else
+	command="$base_compile $qsrcfile $pic_flag"
+      fi
+      if test "$compiler_c_o" = yes; then
+	command="$command -o $obj"
+      fi
+
+      # Suppress compiler output if we already did a PIC compilation.
+      command="$command$suppress_output"
+      func_show_eval_locale "$command" \
+        '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE'
+
+      if test "$need_locks" = warn &&
+	 test "X`cat $lockfile 2>/dev/null`" != "X$srcfile"; then
+	$ECHO "\
+*** ERROR, $lockfile contains:
+`cat $lockfile 2>/dev/null`
+
+but it should contain:
+$srcfile
+
+This indicates that another process is trying to use the same
+temporary object file, and libtool could not work around it because
+your compiler does not support \`-c' and \`-o' together.  If you
+repeat this compilation, it may succeed, by chance, but you had better
+avoid parallel builds (make -j) in this platform, or get a better
+compiler."
+
+	$opt_dry_run || $RM $removelist
+	exit $EXIT_FAILURE
+      fi
+
+      # Just move the object if needed
+      if test -n "$output_obj" && test "X$output_obj" != "X$obj"; then
+	func_show_eval '$MV "$output_obj" "$obj"' \
+	  'error=$?; $opt_dry_run || $RM $removelist; exit $error'
+      fi
+    fi
+
+    $opt_dry_run || {
+      func_write_libtool_object "$libobj" "$objdir/$objname" "$objname"
+
+      # Unlock the critical section if it was locked
+      if test "$need_locks" != no; then
+	removelist=$lockfile
+        $RM "$lockfile"
+      fi
+    }
+
+    exit $EXIT_SUCCESS
+}
+
+$opt_help || {
+test "$mode" = compile && func_mode_compile ${1+"$@"}
+}
+
+func_mode_help ()
+{
+    # We need to display help for each of the modes.
+    case $mode in
+      "")
+        # Generic help is extracted from the usage comments
+        # at the start of this file.
+        func_help
+        ;;
+
+      clean)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=clean RM [RM-OPTION]... FILE...
+
+Remove files from the build directory.
+
+RM is the name of the program to use to delete files associated with each FILE
+(typically \`/bin/rm').  RM-OPTIONS are options (such as \`-f') to be passed
+to RM.
+
+If FILE is a libtool library, object or program, all the files associated
+with it are deleted. Otherwise, only FILE itself is deleted using RM."
+        ;;
+
+      compile)
+      $ECHO \
+"Usage: $progname [OPTION]... --mode=compile COMPILE-COMMAND... SOURCEFILE
+
+Compile a source file into a libtool library object.
+
+This mode accepts the following additional options:
+
+  -o OUTPUT-FILE    set the output file name to OUTPUT-FILE
+  -no-suppress      do not suppress compiler output for multiple passes
+  -prefer-pic       try to building PIC objects only
+  -prefer-non-pic   try to building non-PIC objects only
+  -shared           do not build a \`.o' file suitable for static linking
+  -static           only build a \`.o' file suitable for static linking
+
+COMPILE-COMMAND is a command to be used in creating a \`standard' object file
+from the given SOURCEFILE.
+
+The output file name is determined by removing the directory component from
+SOURCEFILE, then substituting the C source code suffix \`.c' with the
+library object suffix, \`.lo'."
+        ;;
+
+      execute)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=execute COMMAND [ARGS]...
+
+Automatically set library path, then run a program.
+
+This mode accepts the following additional options:
+
+  -dlopen FILE      add the directory containing FILE to the library path
+
+This mode sets the library path environment variable according to \`-dlopen'
+flags.
+
+If any of the ARGS are libtool executable wrappers, then they are translated
+into their corresponding uninstalled binary, and any of their required library
+directories are added to the library path.
+
+Then, COMMAND is executed, with ARGS as arguments."
+        ;;
+
+      finish)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=finish [LIBDIR]...
+
+Complete the installation of libtool libraries.
+
+Each LIBDIR is a directory that contains libtool libraries.
+
+The commands that this mode executes may require superuser privileges.  Use
+the \`--dry-run' option if you just want to see what would be executed."
+        ;;
+
+      install)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=install INSTALL-COMMAND...
+
+Install executables or libraries.
+
+INSTALL-COMMAND is the installation command.  The first component should be
+either the \`install' or \`cp' program.
+
+The following components of INSTALL-COMMAND are treated specially:
+
+  -inst-prefix PREFIX-DIR  Use PREFIX-DIR as a staging area for installation
+
+The rest of the components are interpreted as arguments to that command (only
+BSD-compatible install options are recognized)."
+        ;;
+
+      link)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=link LINK-COMMAND...
+
+Link object files or libraries together to form another library, or to
+create an executable program.
+
+LINK-COMMAND is a command using the C compiler that you would use to create
+a program from several object files.
+
+The following components of LINK-COMMAND are treated specially:
+
+  -all-static       do not do any dynamic linking at all
+  -avoid-version    do not add a version suffix if possible
+  -dlopen FILE      \`-dlpreopen' FILE if it cannot be dlopened at runtime
+  -dlpreopen FILE   link in FILE and add its symbols to lt_preloaded_symbols
+  -export-dynamic   allow symbols from OUTPUT-FILE to be resolved with dlsym(3)
+  -export-symbols SYMFILE
+                    try to export only the symbols listed in SYMFILE
+  -export-symbols-regex REGEX
+                    try to export only the symbols matching REGEX
+  -LLIBDIR          search LIBDIR for required installed libraries
+  -lNAME            OUTPUT-FILE requires the installed library libNAME
+  -module           build a library that can dlopened
+  -no-fast-install  disable the fast-install mode
+  -no-install       link a not-installable executable
+  -no-undefined     declare that a library does not refer to external symbols
+  -o OUTPUT-FILE    create OUTPUT-FILE from the specified objects
+  -objectlist FILE  Use a list of object files found in FILE to specify objects
+  -precious-files-regex REGEX
+                    don't remove output files matching REGEX
+  -release RELEASE  specify package release information
+  -rpath LIBDIR     the created library will eventually be installed in LIBDIR
+  -R[ ]LIBDIR       add LIBDIR to the runtime path of programs and libraries
+  -shared           only do dynamic linking of libtool libraries
+  -shrext SUFFIX    override the standard shared library file extension
+  -static           do not do any dynamic linking of uninstalled libtool libraries
+  -static-libtool-libs
+                    do not do any dynamic linking of libtool libraries
+  -version-info CURRENT[:REVISION[:AGE]]
+                    specify library version info [each variable defaults to 0]
+  -weak LIBNAME     declare that the target provides the LIBNAME interface
+
+All other options (arguments beginning with \`-') are ignored.
+
+Every other argument is treated as a filename.  Files ending in \`.la' are
+treated as uninstalled libtool libraries, other files are standard or library
+object files.
+
+If the OUTPUT-FILE ends in \`.la', then a libtool library is created,
+only library objects (\`.lo' files) may be specified, and \`-rpath' is
+required, except when creating a convenience library.
+
+If OUTPUT-FILE ends in \`.a' or \`.lib', then a standard library is created
+using \`ar' and \`ranlib', or on Windows using \`lib'.
+
+If OUTPUT-FILE ends in \`.lo' or \`.${objext}', then a reloadable object file
+is created, otherwise an executable program is created."
+        ;;
+
+      uninstall)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=uninstall RM [RM-OPTION]... FILE...
+
+Remove libraries from an installation directory.
+
+RM is the name of the program to use to delete files associated with each FILE
+(typically \`/bin/rm').  RM-OPTIONS are options (such as \`-f') to be passed
+to RM.
+
+If FILE is a libtool library, all the files associated with it are deleted.
+Otherwise, only FILE itself is deleted using RM."
+        ;;
+
+      *)
+        func_fatal_help "invalid operation mode \`$mode'"
+        ;;
+    esac
+
+    $ECHO
+    $ECHO "Try \`$progname --help' for more information about other modes."
+
+    exit $?
+}
+
+  # Now that we've collected a possible --mode arg, show help if necessary
+  $opt_help && func_mode_help
+
+
+# func_mode_execute arg...
+func_mode_execute ()
+{
+    $opt_debug
+    # The first argument is the command name.
+    cmd="$nonopt"
+    test -z "$cmd" && \
+      func_fatal_help "you must specify a COMMAND"
+
+    # Handle -dlopen flags immediately.
+    for file in $execute_dlfiles; do
+      test -f "$file" \
+	|| func_fatal_help "\`$file' is not a file"
+
+      dir=
+      case $file in
+      *.la)
+	# Check to see that this really is a libtool archive.
+	func_lalib_unsafe_p "$file" \
+	  || func_fatal_help "\`$lib' is not a valid libtool archive"
+
+	# Read the libtool library.
+	dlname=
+	library_names=
+	func_source "$file"
+
+	# Skip this library if it cannot be dlopened.
+	if test -z "$dlname"; then
+	  # Warn if it was a shared library.
+	  test -n "$library_names" && \
+	    func_warning "\`$file' was not linked with \`-export-dynamic'"
+	  continue
+	fi
+
+	func_dirname "$file" "" "."
+	dir="$func_dirname_result"
+
+	if test -f "$dir/$objdir/$dlname"; then
+	  dir="$dir/$objdir"
+	else
+	  if test ! -f "$dir/$dlname"; then
+	    func_fatal_error "cannot find \`$dlname' in \`$dir' or \`$dir/$objdir'"
+	  fi
+	fi
+	;;
+
+      *.lo)
+	# Just add the directory containing the .lo file.
+	func_dirname "$file" "" "."
+	dir="$func_dirname_result"
+	;;
+
+      *)
+	func_warning "\`-dlopen' is ignored for non-libtool libraries and objects"
+	continue
+	;;
+      esac
+
+      # Get the absolute pathname.
+      absdir=`cd "$dir" && pwd`
+      test -n "$absdir" && dir="$absdir"
+
+      # Now add the directory to shlibpath_var.
+      if eval "test -z \"\$$shlibpath_var\""; then
+	eval "$shlibpath_var=\"\$dir\""
+      else
+	eval "$shlibpath_var=\"\$dir:\$$shlibpath_var\""
+      fi
+    done
+
+    # This variable tells wrapper scripts just to set shlibpath_var
+    # rather than running their programs.
+    libtool_execute_magic="$magic"
+
+    # Check if any of the arguments is a wrapper script.
+    args=
+    for file
+    do
+      case $file in
+      -*) ;;
+      *)
+	# Do a test to see if this is really a libtool program.
+	if func_ltwrapper_script_p "$file"; then
+	  func_source "$file"
+	  # Transform arg to wrapped name.
+	  file="$progdir/$program"
+	elif func_ltwrapper_executable_p "$file"; then
+	  func_ltwrapper_scriptname "$file"
+	  func_source "$func_ltwrapper_scriptname_result"
+	  # Transform arg to wrapped name.
+	  file="$progdir/$program"
+	fi
+	;;
+      esac
+      # Quote arguments (to preserve shell metacharacters).
+      func_quote_for_eval "$file"
+      args="$args $func_quote_for_eval_result"
+    done
+
+    if test "X$opt_dry_run" = Xfalse; then
+      if test -n "$shlibpath_var"; then
+	# Export the shlibpath_var.
+	eval "export $shlibpath_var"
+      fi
+
+      # Restore saved environment variables
+      for lt_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES
+      do
+	eval "if test \"\${save_$lt_var+set}\" = set; then
+                $lt_var=\$save_$lt_var; export $lt_var
+	      else
+		$lt_unset $lt_var
+	      fi"
+      done
+
+      # Now prepare to actually exec the command.
+      exec_cmd="\$cmd$args"
+    else
+      # Display what would be done.
+      if test -n "$shlibpath_var"; then
+	eval "\$ECHO \"\$shlibpath_var=\$$shlibpath_var\""
+	$ECHO "export $shlibpath_var"
+      fi
+      $ECHO "$cmd$args"
+      exit $EXIT_SUCCESS
+    fi
+}
+
+test "$mode" = execute && func_mode_execute ${1+"$@"}
+
+
+# func_mode_finish arg...
+func_mode_finish ()
+{
+    $opt_debug
+    libdirs="$nonopt"
+    admincmds=
+
+    if test -n "$finish_cmds$finish_eval" && test -n "$libdirs"; then
+      for dir
+      do
+	libdirs="$libdirs $dir"
+      done
+
+      for libdir in $libdirs; do
+	if test -n "$finish_cmds"; then
+	  # Do each command in the finish commands.
+	  func_execute_cmds "$finish_cmds" 'admincmds="$admincmds
+'"$cmd"'"'
+	fi
+	if test -n "$finish_eval"; then
+	  # Do the single finish_eval.
+	  eval cmds=\"$finish_eval\"
+	  $opt_dry_run || eval "$cmds" || admincmds="$admincmds
+       $cmds"
+	fi
+      done
+    fi
+
+    # Exit here if they wanted silent mode.
+    $opt_silent && exit $EXIT_SUCCESS
+
+    $ECHO "X----------------------------------------------------------------------" | $Xsed
+    $ECHO "Libraries have been installed in:"
+    for libdir in $libdirs; do
+      $ECHO "   $libdir"
+    done
+    $ECHO
+    $ECHO "If you ever happen to want to link against installed libraries"
+    $ECHO "in a given directory, LIBDIR, you must either use libtool, and"
+    $ECHO "specify the full pathname of the library, or use the \`-LLIBDIR'"
+    $ECHO "flag during linking and do at least one of the following:"
+    if test -n "$shlibpath_var"; then
+      $ECHO "   - add LIBDIR to the \`$shlibpath_var' environment variable"
+      $ECHO "     during execution"
+    fi
+    if test -n "$runpath_var"; then
+      $ECHO "   - add LIBDIR to the \`$runpath_var' environment variable"
+      $ECHO "     during linking"
+    fi
+    if test -n "$hardcode_libdir_flag_spec"; then
+      libdir=LIBDIR
+      eval flag=\"$hardcode_libdir_flag_spec\"
+
+      $ECHO "   - use the \`$flag' linker flag"
+    fi
+    if test -n "$admincmds"; then
+      $ECHO "   - have your system administrator run these commands:$admincmds"
+    fi
+    if test -f /etc/ld.so.conf; then
+      $ECHO "   - have your system administrator add LIBDIR to \`/etc/ld.so.conf'"
+    fi
+    $ECHO
+
+    $ECHO "See any operating system documentation about shared libraries for"
+    case $host in
+      solaris2.[6789]|solaris2.1[0-9])
+        $ECHO "more information, such as the ld(1), crle(1) and ld.so(8) manual"
+	$ECHO "pages."
+	;;
+      *)
+        $ECHO "more information, such as the ld(1) and ld.so(8) manual pages."
+        ;;
+    esac
+    $ECHO "X----------------------------------------------------------------------" | $Xsed
+    exit $EXIT_SUCCESS
+}
+
+test "$mode" = finish && func_mode_finish ${1+"$@"}
+
+
+# func_mode_install arg...
+func_mode_install ()
+{
+    $opt_debug
+    # There may be an optional sh(1) argument at the beginning of
+    # install_prog (especially on Windows NT).
+    if test "$nonopt" = "$SHELL" || test "$nonopt" = /bin/sh ||
+       # Allow the use of GNU shtool's install command.
+       $ECHO "X$nonopt" | $GREP shtool >/dev/null; then
+      # Aesthetically quote it.
+      func_quote_for_eval "$nonopt"
+      install_prog="$func_quote_for_eval_result "
+      arg=$1
+      shift
+    else
+      install_prog=
+      arg=$nonopt
+    fi
+
+    # The real first argument should be the name of the installation program.
+    # Aesthetically quote it.
+    func_quote_for_eval "$arg"
+    install_prog="$install_prog$func_quote_for_eval_result"
+
+    # We need to accept at least all the BSD install flags.
+    dest=
+    files=
+    opts=
+    prev=
+    install_type=
+    isdir=no
+    stripme=
+    for arg
+    do
+      if test -n "$dest"; then
+	files="$files $dest"
+	dest=$arg
+	continue
+      fi
+
+      case $arg in
+      -d) isdir=yes ;;
+      -f)
+	case " $install_prog " in
+	*[\\\ /]cp\ *) ;;
+	*) prev=$arg ;;
+	esac
+	;;
+      -g | -m | -o)
+	prev=$arg
+	;;
+      -s)
+	stripme=" -s"
+	continue
+	;;
+      -*)
+	;;
+      *)
+	# If the previous option needed an argument, then skip it.
+	if test -n "$prev"; then
+	  prev=
+	else
+	  dest=$arg
+	  continue
+	fi
+	;;
+      esac
+
+      # Aesthetically quote the argument.
+      func_quote_for_eval "$arg"
+      install_prog="$install_prog $func_quote_for_eval_result"
+    done
+
+    test -z "$install_prog" && \
+      func_fatal_help "you must specify an install program"
+
+    test -n "$prev" && \
+      func_fatal_help "the \`$prev' option requires an argument"
+
+    if test -z "$files"; then
+      if test -z "$dest"; then
+	func_fatal_help "no file or destination specified"
+      else
+	func_fatal_help "you must specify a destination"
+      fi
+    fi
+
+    # Strip any trailing slash from the destination.
+    func_stripname '' '/' "$dest"
+    dest=$func_stripname_result
+
+    # Check to see that the destination is a directory.
+    test -d "$dest" && isdir=yes
+    if test "$isdir" = yes; then
+      destdir="$dest"
+      destname=
+    else
+      func_dirname_and_basename "$dest" "" "."
+      destdir="$func_dirname_result"
+      destname="$func_basename_result"
+
+      # Not a directory, so check to see that there is only one file specified.
+      set dummy $files; shift
+      test "$#" -gt 1 && \
+	func_fatal_help "\`$dest' is not a directory"
+    fi
+    case $destdir in
+    [\\/]* | [A-Za-z]:[\\/]*) ;;
+    *)
+      for file in $files; do
+	case $file in
+	*.lo) ;;
+	*)
+	  func_fatal_help "\`$destdir' must be an absolute directory name"
+	  ;;
+	esac
+      done
+      ;;
+    esac
+
+    # This variable tells wrapper scripts just to set variables rather
+    # than running their programs.
+    libtool_install_magic="$magic"
+
+    staticlibs=
+    future_libdirs=
+    current_libdirs=
+    for file in $files; do
+
+      # Do each installation.
+      case $file in
+      *.$libext)
+	# Do the static libraries later.
+	staticlibs="$staticlibs $file"
+	;;
+
+      *.la)
+	# Check to see that this really is a libtool archive.
+	func_lalib_unsafe_p "$file" \
+	  || func_fatal_help "\`$file' is not a valid libtool archive"
+
+	library_names=
+	old_library=
+	relink_command=
+	func_source "$file"
+
+	# Add the libdir to current_libdirs if it is the destination.
+	if test "X$destdir" = "X$libdir"; then
+	  case "$current_libdirs " in
+	  *" $libdir "*) ;;
+	  *) current_libdirs="$current_libdirs $libdir" ;;
+	  esac
+	else
+	  # Note the libdir as a future libdir.
+	  case "$future_libdirs " in
+	  *" $libdir "*) ;;
+	  *) future_libdirs="$future_libdirs $libdir" ;;
+	  esac
+	fi
+
+	func_dirname "$file" "/" ""
+	dir="$func_dirname_result"
+	dir="$dir$objdir"
+
+	if test -n "$relink_command"; then
+	  # Determine the prefix the user has applied to our future dir.
+	  inst_prefix_dir=`$ECHO "X$destdir" | $Xsed -e "s%$libdir\$%%"`
+
+	  # Don't allow the user to place us outside of our expected
+	  # location b/c this prevents finding dependent libraries that
+	  # are installed to the same prefix.
+	  # At present, this check doesn't affect windows .dll's that
+	  # are installed into $libdir/../bin (currently, that works fine)
+	  # but it's something to keep an eye on.
+	  test "$inst_prefix_dir" = "$destdir" && \
+	    func_fatal_error "error: cannot install \`$file' to a directory not ending in $libdir"
+
+	  if test -n "$inst_prefix_dir"; then
+	    # Stick the inst_prefix_dir data into the link command.
+	    relink_command=`$ECHO "X$relink_command" | $Xsed -e "s%@inst_prefix_dir@%-inst-prefix-dir $inst_prefix_dir%"`
+	  else
+	    relink_command=`$ECHO "X$relink_command" | $Xsed -e "s%@inst_prefix_dir@%%"`
+	  fi
+
+	  func_warning "relinking \`$file'"
+	  func_show_eval "$relink_command" \
+	    'func_fatal_error "error: relink \`$file'\'' with the above command before installing it"'
+	fi
+
+	# See the names of the shared library.
+	set dummy $library_names; shift
+	if test -n "$1"; then
+	  realname="$1"
+	  shift
+
+	  srcname="$realname"
+	  test -n "$relink_command" && srcname="$realname"T
+
+	  # Install the shared library and build the symlinks.
+	  func_show_eval "$install_prog $dir/$srcname $destdir/$realname" \
+	      'exit $?'
+	  tstripme="$stripme"
+	  case $host_os in
+	  cygwin* | mingw* | pw32* | cegcc*)
+	    case $realname in
+	    *.dll.a)
+	      tstripme=""
+	      ;;
+	    esac
+	    ;;
+	  esac
+	  if test -n "$tstripme" && test -n "$striplib"; then
+	    func_show_eval "$striplib $destdir/$realname" 'exit $?'
+	  fi
+
+	  if test "$#" -gt 0; then
+	    # Delete the old symlinks, and create new ones.
+	    # Try `ln -sf' first, because the `ln' binary might depend on
+	    # the symlink we replace!  Solaris /bin/ln does not understand -f,
+	    # so we also need to try rm && ln -s.
+	    for linkname
+	    do
+	      test "$linkname" != "$realname" \
+		&& func_show_eval "(cd $destdir && { $LN_S -f $realname $linkname || { $RM $linkname && $LN_S $realname $linkname; }; })"
+	    done
+	  fi
+
+	  # Do each command in the postinstall commands.
+	  lib="$destdir/$realname"
+	  func_execute_cmds "$postinstall_cmds" 'exit $?'
+	fi
+
+	# Install the pseudo-library for information purposes.
+	func_basename "$file"
+	name="$func_basename_result"
+	instname="$dir/$name"i
+	func_show_eval "$install_prog $instname $destdir/$name" 'exit $?'
+
+	# Maybe install the static library, too.
+	test -n "$old_library" && staticlibs="$staticlibs $dir/$old_library"
+	;;
+
+      *.lo)
+	# Install (i.e. copy) a libtool object.
+
+	# Figure out destination file name, if it wasn't already specified.
+	if test -n "$destname"; then
+	  destfile="$destdir/$destname"
+	else
+	  func_basename "$file"
+	  destfile="$func_basename_result"
+	  destfile="$destdir/$destfile"
+	fi
+
+	# Deduce the name of the destination old-style object file.
+	case $destfile in
+	*.lo)
+	  func_lo2o "$destfile"
+	  staticdest=$func_lo2o_result
+	  ;;
+	*.$objext)
+	  staticdest="$destfile"
+	  destfile=
+	  ;;
+	*)
+	  func_fatal_help "cannot copy a libtool object to \`$destfile'"
+	  ;;
+	esac
+
+	# Install the libtool object if requested.
+	test -n "$destfile" && \
+	  func_show_eval "$install_prog $file $destfile" 'exit $?'
+
+	# Install the old object if enabled.
+	if test "$build_old_libs" = yes; then
+	  # Deduce the name of the old-style object file.
+	  func_lo2o "$file"
+	  staticobj=$func_lo2o_result
+	  func_show_eval "$install_prog \$staticobj \$staticdest" 'exit $?'
+	fi
+	exit $EXIT_SUCCESS
+	;;
+
+      *)
+	# Figure out destination file name, if it wasn't already specified.
+	if test -n "$destname"; then
+	  destfile="$destdir/$destname"
+	else
+	  func_basename "$file"
+	  destfile="$func_basename_result"
+	  destfile="$destdir/$destfile"
+	fi
+
+	# If the file is missing, and there is a .exe on the end, strip it
+	# because it is most likely a libtool script we actually want to
+	# install
+	stripped_ext=""
+	case $file in
+	  *.exe)
+	    if test ! -f "$file"; then
+	      func_stripname '' '.exe' "$file"
+	      file=$func_stripname_result
+	      stripped_ext=".exe"
+	    fi
+	    ;;
+	esac
+
+	# Do a test to see if this is really a libtool program.
+	case $host in
+	*cygwin* | *mingw*)
+	    if func_ltwrapper_executable_p "$file"; then
+	      func_ltwrapper_scriptname "$file"
+	      wrapper=$func_ltwrapper_scriptname_result
+	    else
+	      func_stripname '' '.exe' "$file"
+	      wrapper=$func_stripname_result
+	    fi
+	    ;;
+	*)
+	    wrapper=$file
+	    ;;
+	esac
+	if func_ltwrapper_script_p "$wrapper"; then
+	  notinst_deplibs=
+	  relink_command=
+
+	  func_source "$wrapper"
+
+	  # Check the variables that should have been set.
+	  test -z "$generated_by_libtool_version" && \
+	    func_fatal_error "invalid libtool wrapper script \`$wrapper'"
+
+	  finalize=yes
+	  for lib in $notinst_deplibs; do
+	    # Check to see that each library is installed.
+	    libdir=
+	    if test -f "$lib"; then
+	      func_source "$lib"
+	    fi
+	    libfile="$libdir/"`$ECHO "X$lib" | $Xsed -e 's%^.*/%%g'` ### testsuite: skip nested quoting test
+	    if test -n "$libdir" && test ! -f "$libfile"; then
+	      func_warning "\`$lib' has not been installed in \`$libdir'"
+	      finalize=no
+	    fi
+	  done
+
+	  relink_command=
+	  func_source "$wrapper"
+
+	  outputname=
+	  if test "$fast_install" = no && test -n "$relink_command"; then
+	    $opt_dry_run || {
+	      if test "$finalize" = yes; then
+	        tmpdir=`func_mktempdir`
+		func_basename "$file$stripped_ext"
+		file="$func_basename_result"
+	        outputname="$tmpdir/$file"
+	        # Replace the output file specification.
+	        relink_command=`$ECHO "X$relink_command" | $Xsed -e 's%@OUTPUT@%'"$outputname"'%g'`
+
+	        $opt_silent || {
+	          func_quote_for_expand "$relink_command"
+		  eval "func_echo $func_quote_for_expand_result"
+	        }
+	        if eval "$relink_command"; then :
+	          else
+		  func_error "error: relink \`$file' with the above command before installing it"
+		  $opt_dry_run || ${RM}r "$tmpdir"
+		  continue
+	        fi
+	        file="$outputname"
+	      else
+	        func_warning "cannot relink \`$file'"
+	      fi
+	    }
+	  else
+	    # Install the binary that we compiled earlier.
+	    file=`$ECHO "X$file$stripped_ext" | $Xsed -e "s%\([^/]*\)$%$objdir/\1%"`
+	  fi
+	fi
+
+	# remove .exe since cygwin /usr/bin/install will append another
+	# one anyway
+	case $install_prog,$host in
+	*/usr/bin/install*,*cygwin*)
+	  case $file:$destfile in
+	  *.exe:*.exe)
+	    # this is ok
+	    ;;
+	  *.exe:*)
+	    destfile=$destfile.exe
+	    ;;
+	  *:*.exe)
+	    func_stripname '' '.exe' "$destfile"
+	    destfile=$func_stripname_result
+	    ;;
+	  esac
+	  ;;
+	esac
+	func_show_eval "$install_prog\$stripme \$file \$destfile" 'exit $?'
+	$opt_dry_run || if test -n "$outputname"; then
+	  ${RM}r "$tmpdir"
+	fi
+	;;
+      esac
+    done
+
+    for file in $staticlibs; do
+      func_basename "$file"
+      name="$func_basename_result"
+
+      # Set up the ranlib parameters.
+      oldlib="$destdir/$name"
+
+      func_show_eval "$install_prog \$file \$oldlib" 'exit $?'
+
+      if test -n "$stripme" && test -n "$old_striplib"; then
+	func_show_eval "$old_striplib $oldlib" 'exit $?'
+      fi
+
+      # Do each command in the postinstall commands.
+      func_execute_cmds "$old_postinstall_cmds" 'exit $?'
+    done
+
+    test -n "$future_libdirs" && \
+      func_warning "remember to run \`$progname --finish$future_libdirs'"
+
+    if test -n "$current_libdirs"; then
+      # Maybe just do a dry run.
+      $opt_dry_run && current_libdirs=" -n$current_libdirs"
+      exec_cmd='$SHELL $progpath $preserve_args --finish$current_libdirs'
+    else
+      exit $EXIT_SUCCESS
+    fi
+}
+
+test "$mode" = install && func_mode_install ${1+"$@"}
+
+
+# func_generate_dlsyms outputname originator pic_p
+# Extract symbols from dlprefiles and create ${outputname}S.o with
+# a dlpreopen symbol table.
+func_generate_dlsyms ()
+{
+    $opt_debug
+    my_outputname="$1"
+    my_originator="$2"
+    my_pic_p="${3-no}"
+    my_prefix=`$ECHO "$my_originator" | sed 's%[^a-zA-Z0-9]%_%g'`
+    my_dlsyms=
+
+    if test -n "$dlfiles$dlprefiles" || test "$dlself" != no; then
+      if test -n "$NM" && test -n "$global_symbol_pipe"; then
+	my_dlsyms="${my_outputname}S.c"
+      else
+	func_error "not configured to extract global symbols from dlpreopened files"
+      fi
+    fi
+
+    if test -n "$my_dlsyms"; then
+      case $my_dlsyms in
+      "") ;;
+      *.c)
+	# Discover the nlist of each of the dlfiles.
+	nlist="$output_objdir/${my_outputname}.nm"
+
+	func_show_eval "$RM $nlist ${nlist}S ${nlist}T"
+
+	# Parse the name list into a source file.
+	func_verbose "creating $output_objdir/$my_dlsyms"
+
+	$opt_dry_run || $ECHO > "$output_objdir/$my_dlsyms" "\
+/* $my_dlsyms - symbol resolution table for \`$my_outputname' dlsym emulation. */
+/* Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION */
+
+#ifdef __cplusplus
+extern \"C\" {
+#endif
+
+/* External symbol declarations for the compiler. */\
+"
+
+	if test "$dlself" = yes; then
+	  func_verbose "generating symbol list for \`$output'"
+
+	  $opt_dry_run || echo ': @PROGRAM@ ' > "$nlist"
+
+	  # Add our own program objects to the symbol list.
+	  progfiles=`$ECHO "X$objs$old_deplibs" | $SP2NL | $Xsed -e "$lo2o" | $NL2SP`
+	  for progfile in $progfiles; do
+	    func_verbose "extracting global C symbols from \`$progfile'"
+	    $opt_dry_run || eval "$NM $progfile | $global_symbol_pipe >> '$nlist'"
+	  done
+
+	  if test -n "$exclude_expsyms"; then
+	    $opt_dry_run || {
+	      eval '$EGREP -v " ($exclude_expsyms)$" "$nlist" > "$nlist"T'
+	      eval '$MV "$nlist"T "$nlist"'
+	    }
+	  fi
+
+	  if test -n "$export_symbols_regex"; then
+	    $opt_dry_run || {
+	      eval '$EGREP -e "$export_symbols_regex" "$nlist" > "$nlist"T'
+	      eval '$MV "$nlist"T "$nlist"'
+	    }
+	  fi
+
+	  # Prepare the list of exported symbols
+	  if test -z "$export_symbols"; then
+	    export_symbols="$output_objdir/$outputname.exp"
+	    $opt_dry_run || {
+	      $RM $export_symbols
+	      eval "${SED} -n -e '/^: @PROGRAM@ $/d' -e 's/^.* \(.*\)$/\1/p' "'< "$nlist" > "$export_symbols"'
+	      case $host in
+	      *cygwin* | *mingw* | *cegcc* )
+                eval "echo EXPORTS "'> "$output_objdir/$outputname.def"'
+                eval 'cat "$export_symbols" >> "$output_objdir/$outputname.def"'
+	        ;;
+	      esac
+	    }
+	  else
+	    $opt_dry_run || {
+	      eval "${SED} -e 's/\([].[*^$]\)/\\\\\1/g' -e 's/^/ /' -e 's/$/$/'"' < "$export_symbols" > "$output_objdir/$outputname.exp"'
+	      eval '$GREP -f "$output_objdir/$outputname.exp" < "$nlist" > "$nlist"T'
+	      eval '$MV "$nlist"T "$nlist"'
+	      case $host in
+	        *cygwin | *mingw* | *cegcc* )
+	          eval "echo EXPORTS "'> "$output_objdir/$outputname.def"'
+	          eval 'cat "$nlist" >> "$output_objdir/$outputname.def"'
+	          ;;
+	      esac
+	    }
+	  fi
+	fi
+
+	for dlprefile in $dlprefiles; do
+	  func_verbose "extracting global C symbols from \`$dlprefile'"
+	  func_basename "$dlprefile"
+	  name="$func_basename_result"
+	  $opt_dry_run || {
+	    eval '$ECHO ": $name " >> "$nlist"'
+	    eval "$NM $dlprefile 2>/dev/null | $global_symbol_pipe >> '$nlist'"
+	  }
+	done
+
+	$opt_dry_run || {
+	  # Make sure we have at least an empty file.
+	  test -f "$nlist" || : > "$nlist"
+
+	  if test -n "$exclude_expsyms"; then
+	    $EGREP -v " ($exclude_expsyms)$" "$nlist" > "$nlist"T
+	    $MV "$nlist"T "$nlist"
+	  fi
+
+	  # Try sorting and uniquifying the output.
+	  if $GREP -v "^: " < "$nlist" |
+	      if sort -k 3 </dev/null >/dev/null 2>&1; then
+		sort -k 3
+	      else
+		sort +2
+	      fi |
+	      uniq > "$nlist"S; then
+	    :
+	  else
+	    $GREP -v "^: " < "$nlist" > "$nlist"S
+	  fi
+
+	  if test -f "$nlist"S; then
+	    eval "$global_symbol_to_cdecl"' < "$nlist"S >> "$output_objdir/$my_dlsyms"'
+	  else
+	    $ECHO '/* NONE */' >> "$output_objdir/$my_dlsyms"
+	  fi
+
+	  $ECHO >> "$output_objdir/$my_dlsyms" "\
+
+/* The mapping between symbol names and symbols.  */
+typedef struct {
+  const char *name;
+  void *address;
+} lt_dlsymlist;
+"
+	  case $host in
+	  *cygwin* | *mingw* | *cegcc* )
+	    $ECHO >> "$output_objdir/$my_dlsyms" "\
+/* DATA imports from DLLs on WIN32 con't be const, because
+   runtime relocations are performed -- see ld's documentation
+   on pseudo-relocs.  */"
+	    lt_dlsym_const= ;;
+	  *osf5*)
+	    echo >> "$output_objdir/$my_dlsyms" "\
+/* This system does not cope well with relocations in const data */"
+	    lt_dlsym_const= ;;
+	  *)
+	    lt_dlsym_const=const ;;
+	  esac
+
+	  $ECHO >> "$output_objdir/$my_dlsyms" "\
+extern $lt_dlsym_const lt_dlsymlist
+lt_${my_prefix}_LTX_preloaded_symbols[];
+$lt_dlsym_const lt_dlsymlist
+lt_${my_prefix}_LTX_preloaded_symbols[] =
+{\
+  { \"$my_originator\", (void *) 0 },"
+
+	  case $need_lib_prefix in
+	  no)
+	    eval "$global_symbol_to_c_name_address" < "$nlist" >> "$output_objdir/$my_dlsyms"
+	    ;;
+	  *)
+	    eval "$global_symbol_to_c_name_address_lib_prefix" < "$nlist" >> "$output_objdir/$my_dlsyms"
+	    ;;
+	  esac
+	  $ECHO >> "$output_objdir/$my_dlsyms" "\
+  {0, (void *) 0}
+};
+
+/* This works around a problem in FreeBSD linker */
+#ifdef FREEBSD_WORKAROUND
+static const void *lt_preloaded_setup() {
+  return lt_${my_prefix}_LTX_preloaded_symbols;
+}
+#endif
+
+#ifdef __cplusplus
+}
+#endif\
+"
+	} # !$opt_dry_run
+
+	pic_flag_for_symtable=
+	case "$compile_command " in
+	*" -static "*) ;;
+	*)
+	  case $host in
+	  # compiling the symbol table file with pic_flag works around
+	  # a FreeBSD bug that causes programs to crash when -lm is
+	  # linked before any other PIC object.  But we must not use
+	  # pic_flag when linking with -static.  The problem exists in
+	  # FreeBSD 2.2.6 and is fixed in FreeBSD 3.1.
+	  *-*-freebsd2*|*-*-freebsd3.0*|*-*-freebsdelf3.0*)
+	    pic_flag_for_symtable=" $pic_flag -DFREEBSD_WORKAROUND" ;;
+	  *-*-hpux*)
+	    pic_flag_for_symtable=" $pic_flag"  ;;
+	  *)
+	    if test "X$my_pic_p" != Xno; then
+	      pic_flag_for_symtable=" $pic_flag"
+	    fi
+	    ;;
+	  esac
+	  ;;
+	esac
+	symtab_cflags=
+	for arg in $LTCFLAGS; do
+	  case $arg in
+	  -pie | -fpie | -fPIE) ;;
+	  *) symtab_cflags="$symtab_cflags $arg" ;;
+	  esac
+	done
+
+	# Now compile the dynamic symbol file.
+	func_show_eval '(cd $output_objdir && $LTCC$symtab_cflags -c$no_builtin_flag$pic_flag_for_symtable "$my_dlsyms")' 'exit $?'
+
+	# Clean up the generated files.
+	func_show_eval '$RM "$output_objdir/$my_dlsyms" "$nlist" "${nlist}S" "${nlist}T"'
+
+	# Transform the symbol file into the correct name.
+	symfileobj="$output_objdir/${my_outputname}S.$objext"
+	case $host in
+	*cygwin* | *mingw* | *cegcc* )
+	  if test -f "$output_objdir/$my_outputname.def"; then
+	    compile_command=`$ECHO "X$compile_command" | $Xsed -e "s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%"`
+	    finalize_command=`$ECHO "X$finalize_command" | $Xsed -e "s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%"`
+	  else
+	    compile_command=`$ECHO "X$compile_command" | $Xsed -e "s%@SYMFILE@%$symfileobj%"`
+	    finalize_command=`$ECHO "X$finalize_command" | $Xsed -e "s%@SYMFILE@%$symfileobj%"`
+	  fi
+	  ;;
+	*)
+	  compile_command=`$ECHO "X$compile_command" | $Xsed -e "s%@SYMFILE@%$symfileobj%"`
+	  finalize_command=`$ECHO "X$finalize_command" | $Xsed -e "s%@SYMFILE@%$symfileobj%"`
+	  ;;
+	esac
+	;;
+      *)
+	func_fatal_error "unknown suffix for \`$my_dlsyms'"
+	;;
+      esac
+    else
+      # We keep going just in case the user didn't refer to
+      # lt_preloaded_symbols.  The linker will fail if global_symbol_pipe
+      # really was required.
+
+      # Nullify the symbol file.
+      compile_command=`$ECHO "X$compile_command" | $Xsed -e "s% @SYMFILE@%%"`
+      finalize_command=`$ECHO "X$finalize_command" | $Xsed -e "s% @SYMFILE@%%"`
+    fi
+}
+
+# func_win32_libid arg
+# return the library type of file 'arg'
+#
+# Need a lot of goo to handle *both* DLLs and import libs
+# Has to be a shell function in order to 'eat' the argument
+# that is supplied when $file_magic_command is called.
+func_win32_libid ()
+{
+  $opt_debug
+  win32_libid_type="unknown"
+  win32_fileres=`file -L $1 2>/dev/null`
+  case $win32_fileres in
+  *ar\ archive\ import\ library*) # definitely import
+    win32_libid_type="x86 archive import"
+    ;;
+  *ar\ archive*) # could be an import, or static
+    if eval $OBJDUMP -f $1 | $SED -e '10q' 2>/dev/null |
+       $EGREP 'file format pe-i386(.*architecture: i386)?' >/dev/null ; then
+      win32_nmres=`eval $NM -f posix -A $1 |
+	$SED -n -e '
+	    1,100{
+		/ I /{
+		    s,.*,import,
+		    p
+		    q
+		}
+	    }'`
+      case $win32_nmres in
+      import*)  win32_libid_type="x86 archive import";;
+      *)        win32_libid_type="x86 archive static";;
+      esac
+    fi
+    ;;
+  *DLL*)
+    win32_libid_type="x86 DLL"
+    ;;
+  *executable*) # but shell scripts are "executable" too...
+    case $win32_fileres in
+    *MS\ Windows\ PE\ Intel*)
+      win32_libid_type="x86 DLL"
+      ;;
+    esac
+    ;;
+  esac
+  $ECHO "$win32_libid_type"
+}
+
+
+
+# func_extract_an_archive dir oldlib
+func_extract_an_archive ()
+{
+    $opt_debug
+    f_ex_an_ar_dir="$1"; shift
+    f_ex_an_ar_oldlib="$1"
+    func_show_eval "(cd \$f_ex_an_ar_dir && $AR x \"\$f_ex_an_ar_oldlib\")" 'exit $?'
+    if ($AR t "$f_ex_an_ar_oldlib" | sort | sort -uc >/dev/null 2>&1); then
+     :
+    else
+      func_fatal_error "object name conflicts in archive: $f_ex_an_ar_dir/$f_ex_an_ar_oldlib"
+    fi
+}
+
+
+# func_extract_archives gentop oldlib ...
+func_extract_archives ()
+{
+    $opt_debug
+    my_gentop="$1"; shift
+    my_oldlibs=${1+"$@"}
+    my_oldobjs=""
+    my_xlib=""
+    my_xabs=""
+    my_xdir=""
+
+    for my_xlib in $my_oldlibs; do
+      # Extract the objects.
+      case $my_xlib in
+	[\\/]* | [A-Za-z]:[\\/]*) my_xabs="$my_xlib" ;;
+	*) my_xabs=`pwd`"/$my_xlib" ;;
+      esac
+      func_basename "$my_xlib"
+      my_xlib="$func_basename_result"
+      my_xlib_u=$my_xlib
+      while :; do
+        case " $extracted_archives " in
+	*" $my_xlib_u "*)
+	  func_arith $extracted_serial + 1
+	  extracted_serial=$func_arith_result
+	  my_xlib_u=lt$extracted_serial-$my_xlib ;;
+	*) break ;;
+	esac
+      done
+      extracted_archives="$extracted_archives $my_xlib_u"
+      my_xdir="$my_gentop/$my_xlib_u"
+
+      func_mkdir_p "$my_xdir"
+
+      case $host in
+      *-darwin*)
+	func_verbose "Extracting $my_xabs"
+	# Do not bother doing anything if just a dry run
+	$opt_dry_run || {
+	  darwin_orig_dir=`pwd`
+	  cd $my_xdir || exit $?
+	  darwin_archive=$my_xabs
+	  darwin_curdir=`pwd`
+	  darwin_base_archive=`basename "$darwin_archive"`
+	  darwin_arches=`$LIPO -info "$darwin_archive" 2>/dev/null | $GREP Architectures 2>/dev/null || true`
+	  if test -n "$darwin_arches"; then
+	    darwin_arches=`$ECHO "$darwin_arches" | $SED -e 's/.*are://'`
+	    darwin_arch=
+	    func_verbose "$darwin_base_archive has multiple architectures $darwin_arches"
+	    for darwin_arch in  $darwin_arches ; do
+	      func_mkdir_p "unfat-$$/${darwin_base_archive}-${darwin_arch}"
+	      $LIPO -thin $darwin_arch -output "unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}" "${darwin_archive}"
+	      cd "unfat-$$/${darwin_base_archive}-${darwin_arch}"
+	      func_extract_an_archive "`pwd`" "${darwin_base_archive}"
+	      cd "$darwin_curdir"
+	      $RM "unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}"
+	    done # $darwin_arches
+            ## Okay now we've a bunch of thin objects, gotta fatten them up :)
+	    darwin_filelist=`find unfat-$$ -type f -name \*.o -print -o -name \*.lo -print | $SED -e "$basename" | sort -u`
+	    darwin_file=
+	    darwin_files=
+	    for darwin_file in $darwin_filelist; do
+	      darwin_files=`find unfat-$$ -name $darwin_file -print | $NL2SP`
+	      $LIPO -create -output "$darwin_file" $darwin_files
+	    done # $darwin_filelist
+	    $RM -rf unfat-$$
+	    cd "$darwin_orig_dir"
+	  else
+	    cd $darwin_orig_dir
+	    func_extract_an_archive "$my_xdir" "$my_xabs"
+	  fi # $darwin_arches
+	} # !$opt_dry_run
+	;;
+      *)
+        func_extract_an_archive "$my_xdir" "$my_xabs"
+	;;
+      esac
+      my_oldobjs="$my_oldobjs "`find $my_xdir -name \*.$objext -print -o -name \*.lo -print | $NL2SP`
+    done
+
+    func_extract_archives_result="$my_oldobjs"
+}
+
+
+
+# func_emit_wrapper_part1 [arg=no]
+#
+# Emit the first part of a libtool wrapper script on stdout.
+# For more information, see the description associated with
+# func_emit_wrapper(), below.
+func_emit_wrapper_part1 ()
+{
+	func_emit_wrapper_part1_arg1=no
+	if test -n "$1" ; then
+	  func_emit_wrapper_part1_arg1=$1
+	fi
+
+	$ECHO "\
+#! $SHELL
+
+# $output - temporary wrapper script for $objdir/$outputname
+# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION
+#
+# The $output program cannot be directly executed until all the libtool
+# libraries that it depends on are installed.
+#
+# This wrapper script should never be moved out of the build directory.
+# If it is, it will not operate correctly.
+
+# Sed substitution that helps us do robust quoting.  It backslashifies
+# metacharacters that are still active within double-quoted strings.
+Xsed='${SED} -e 1s/^X//'
+sed_quote_subst='$sed_quote_subst'
+
+# Be Bourne compatible
+if test -n \"\${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on \${1+\"\$@\"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '\${1+\"\$@\"}'='\"\$@\"'
+  setopt NO_GLOB_SUBST
+else
+  case \`(set -o) 2>/dev/null\` in *posix*) set -o posix;; esac
+fi
+BIN_SH=xpg4; export BIN_SH # for Tru64
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# The HP-UX ksh and POSIX shell print the target directory to stdout
+# if CDPATH is set.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+relink_command=\"$relink_command\"
+
+# This environment variable determines our operation mode.
+if test \"\$libtool_install_magic\" = \"$magic\"; then
+  # install mode needs the following variables:
+  generated_by_libtool_version='$macro_version'
+  notinst_deplibs='$notinst_deplibs'
+else
+  # When we are sourced in execute mode, \$file and \$ECHO are already set.
+  if test \"\$libtool_execute_magic\" != \"$magic\"; then
+    ECHO=\"$qecho\"
+    file=\"\$0\"
+    # Make sure echo works.
+    if test \"X\$1\" = X--no-reexec; then
+      # Discard the --no-reexec flag, and continue.
+      shift
+    elif test \"X\`{ \$ECHO '\t'; } 2>/dev/null\`\" = 'X\t'; then
+      # Yippee, \$ECHO works!
+      :
+    else
+      # Restart under the correct shell, and then maybe \$ECHO will work.
+      exec $SHELL \"\$0\" --no-reexec \${1+\"\$@\"}
+    fi
+  fi\
+"
+	$ECHO "\
+
+  # Find the directory that this script lives in.
+  thisdir=\`\$ECHO \"X\$file\" | \$Xsed -e 's%/[^/]*$%%'\`
+  test \"x\$thisdir\" = \"x\$file\" && thisdir=.
+
+  # Follow symbolic links until we get to the real thisdir.
+  file=\`ls -ld \"\$file\" | ${SED} -n 's/.*-> //p'\`
+  while test -n \"\$file\"; do
+    destdir=\`\$ECHO \"X\$file\" | \$Xsed -e 's%/[^/]*\$%%'\`
+
+    # If there was a directory component, then change thisdir.
+    if test \"x\$destdir\" != \"x\$file\"; then
+      case \"\$destdir\" in
+      [\\\\/]* | [A-Za-z]:[\\\\/]*) thisdir=\"\$destdir\" ;;
+      *) thisdir=\"\$thisdir/\$destdir\" ;;
+      esac
+    fi
+
+    file=\`\$ECHO \"X\$file\" | \$Xsed -e 's%^.*/%%'\`
+    file=\`ls -ld \"\$thisdir/\$file\" | ${SED} -n 's/.*-> //p'\`
+  done
+"
+}
+# end: func_emit_wrapper_part1
+
+# func_emit_wrapper_part2 [arg=no]
+#
+# Emit the second part of a libtool wrapper script on stdout.
+# For more information, see the description associated with
+# func_emit_wrapper(), below.
+func_emit_wrapper_part2 ()
+{
+	func_emit_wrapper_part2_arg1=no
+	if test -n "$1" ; then
+	  func_emit_wrapper_part2_arg1=$1
+	fi
+
+	$ECHO "\
+
+  # Usually 'no', except on cygwin/mingw when embedded into
+  # the cwrapper.
+  WRAPPER_SCRIPT_BELONGS_IN_OBJDIR=$func_emit_wrapper_part2_arg1
+  if test \"\$WRAPPER_SCRIPT_BELONGS_IN_OBJDIR\" = \"yes\"; then
+    # special case for '.'
+    if test \"\$thisdir\" = \".\"; then
+      thisdir=\`pwd\`
+    fi
+    # remove .libs from thisdir
+    case \"\$thisdir\" in
+    *[\\\\/]$objdir ) thisdir=\`\$ECHO \"X\$thisdir\" | \$Xsed -e 's%[\\\\/][^\\\\/]*$%%'\` ;;
+    $objdir )   thisdir=. ;;
+    esac
+  fi
+
+  # Try to get the absolute directory name.
+  absdir=\`cd \"\$thisdir\" && pwd\`
+  test -n \"\$absdir\" && thisdir=\"\$absdir\"
+"
+
+	if test "$fast_install" = yes; then
+	  $ECHO "\
+  program=lt-'$outputname'$exeext
+  progdir=\"\$thisdir/$objdir\"
+
+  if test ! -f \"\$progdir/\$program\" ||
+     { file=\`ls -1dt \"\$progdir/\$program\" \"\$progdir/../\$program\" 2>/dev/null | ${SED} 1q\`; \\
+       test \"X\$file\" != \"X\$progdir/\$program\"; }; then
+
+    file=\"\$\$-\$program\"
+
+    if test ! -d \"\$progdir\"; then
+      $MKDIR \"\$progdir\"
+    else
+      $RM \"\$progdir/\$file\"
+    fi"
+
+	  $ECHO "\
+
+    # relink executable if necessary
+    if test -n \"\$relink_command\"; then
+      if relink_command_output=\`eval \$relink_command 2>&1\`; then :
+      else
+	$ECHO \"\$relink_command_output\" >&2
+	$RM \"\$progdir/\$file\"
+	exit 1
+      fi
+    fi
+
+    $MV \"\$progdir/\$file\" \"\$progdir/\$program\" 2>/dev/null ||
+    { $RM \"\$progdir/\$program\";
+      $MV \"\$progdir/\$file\" \"\$progdir/\$program\"; }
+    $RM \"\$progdir/\$file\"
+  fi"
+	else
+	  $ECHO "\
+  program='$outputname'
+  progdir=\"\$thisdir/$objdir\"
+"
+	fi
+
+	$ECHO "\
+
+  if test -f \"\$progdir/\$program\"; then"
+
+	# Export our shlibpath_var if we have one.
+	if test "$shlibpath_overrides_runpath" = yes && test -n "$shlibpath_var" && test -n "$temp_rpath"; then
+	  $ECHO "\
+    # Add our own library path to $shlibpath_var
+    $shlibpath_var=\"$temp_rpath\$$shlibpath_var\"
+
+    # Some systems cannot cope with colon-terminated $shlibpath_var
+    # The second colon is a workaround for a bug in BeOS R4 sed
+    $shlibpath_var=\`\$ECHO \"X\$$shlibpath_var\" | \$Xsed -e 's/::*\$//'\`
+
+    export $shlibpath_var
+"
+	fi
+
+	# fixup the dll searchpath if we need to.
+	if test -n "$dllsearchpath"; then
+	  $ECHO "\
+    # Add the dll search path components to the executable PATH
+    PATH=$dllsearchpath:\$PATH
+"
+	fi
+
+	$ECHO "\
+    if test \"\$libtool_execute_magic\" != \"$magic\"; then
+      # Run the actual program with our arguments.
+"
+	case $host in
+	# Backslashes separate directories on plain windows
+	*-*-mingw | *-*-os2* | *-cegcc*)
+	  $ECHO "\
+      exec \"\$progdir\\\\\$program\" \${1+\"\$@\"}
+"
+	  ;;
+
+	*)
+	  $ECHO "\
+      exec \"\$progdir/\$program\" \${1+\"\$@\"}
+"
+	  ;;
+	esac
+	$ECHO "\
+      \$ECHO \"\$0: cannot exec \$program \$*\" 1>&2
+      exit 1
+    fi
+  else
+    # The program doesn't exist.
+    \$ECHO \"\$0: error: \\\`\$progdir/\$program' does not exist\" 1>&2
+    \$ECHO \"This script is just a wrapper for \$program.\" 1>&2
+    $ECHO \"See the $PACKAGE documentation for more information.\" 1>&2
+    exit 1
+  fi
+fi\
+"
+}
+# end: func_emit_wrapper_part2
+
+
+# func_emit_wrapper [arg=no]
+#
+# Emit a libtool wrapper script on stdout.
+# Don't directly open a file because we may want to
+# incorporate the script contents within a cygwin/mingw
+# wrapper executable.  Must ONLY be called from within
+# func_mode_link because it depends on a number of variables
+# set therein.
+#
+# ARG is the value that the WRAPPER_SCRIPT_BELONGS_IN_OBJDIR
+# variable will take.  If 'yes', then the emitted script
+# will assume that the directory in which it is stored is
+# the $objdir directory.  This is a cygwin/mingw-specific
+# behavior.
+func_emit_wrapper ()
+{
+	func_emit_wrapper_arg1=no
+	if test -n "$1" ; then
+	  func_emit_wrapper_arg1=$1
+	fi
+
+	# split this up so that func_emit_cwrapperexe_src
+	# can call each part independently.
+	func_emit_wrapper_part1 "${func_emit_wrapper_arg1}"
+	func_emit_wrapper_part2 "${func_emit_wrapper_arg1}"
+}
+
+
+# func_to_host_path arg
+#
+# Convert paths to host format when used with build tools.
+# Intended for use with "native" mingw (where libtool itself
+# is running under the msys shell), or in the following cross-
+# build environments:
+#    $build          $host
+#    mingw (msys)    mingw  [e.g. native]
+#    cygwin          mingw
+#    *nix + wine     mingw
+# where wine is equipped with the `winepath' executable.
+# In the native mingw case, the (msys) shell automatically
+# converts paths for any non-msys applications it launches,
+# but that facility isn't available from inside the cwrapper.
+# Similar accommodations are necessary for $host mingw and
+# $build cygwin.  Calling this function does no harm for other
+# $host/$build combinations not listed above.
+#
+# ARG is the path (on $build) that should be converted to
+# the proper representation for $host. The result is stored
+# in $func_to_host_path_result.
+func_to_host_path ()
+{
+  func_to_host_path_result="$1"
+  if test -n "$1" ; then
+    case $host in
+      *mingw* )
+        lt_sed_naive_backslashify='s|\\\\*|\\|g;s|/|\\|g;s|\\|\\\\|g'
+        case $build in
+          *mingw* ) # actually, msys
+            # awkward: cmd appends spaces to result
+            lt_sed_strip_trailing_spaces="s/[ ]*\$//"
+            func_to_host_path_tmp1=`( cmd //c echo "$1" |\
+              $SED -e "$lt_sed_strip_trailing_spaces" ) 2>/dev/null || echo ""`
+            func_to_host_path_result=`echo "$func_to_host_path_tmp1" |\
+              $SED -e "$lt_sed_naive_backslashify"`
+            ;;
+          *cygwin* )
+            func_to_host_path_tmp1=`cygpath -w "$1"`
+            func_to_host_path_result=`echo "$func_to_host_path_tmp1" |\
+              $SED -e "$lt_sed_naive_backslashify"`
+            ;;
+          * )
+            # Unfortunately, winepath does not exit with a non-zero
+            # error code, so we are forced to check the contents of
+            # stdout. On the other hand, if the command is not
+            # found, the shell will set an exit code of 127 and print
+            # *an error message* to stdout. So we must check for both
+            # error code of zero AND non-empty stdout, which explains
+            # the odd construction:
+            func_to_host_path_tmp1=`winepath -w "$1" 2>/dev/null`
+            if test "$?" -eq 0 && test -n "${func_to_host_path_tmp1}"; then
+              func_to_host_path_result=`echo "$func_to_host_path_tmp1" |\
+                $SED -e "$lt_sed_naive_backslashify"`
+            else
+              # Allow warning below.
+              func_to_host_path_result=""
+            fi
+            ;;
+        esac
+        if test -z "$func_to_host_path_result" ; then
+          func_error "Could not determine host path corresponding to"
+          func_error "  '$1'"
+          func_error "Continuing, but uninstalled executables may not work."
+          # Fallback:
+          func_to_host_path_result="$1"
+        fi
+        ;;
+    esac
+  fi
+}
+# end: func_to_host_path
+
+# func_to_host_pathlist arg
+#
+# Convert pathlists to host format when used with build tools.
+# See func_to_host_path(), above. This function supports the
+# following $build/$host combinations (but does no harm for
+# combinations not listed here):
+#    $build          $host
+#    mingw (msys)    mingw  [e.g. native]
+#    cygwin          mingw
+#    *nix + wine     mingw
+#
+# Path separators are also converted from $build format to
+# $host format. If ARG begins or ends with a path separator
+# character, it is preserved (but converted to $host format)
+# on output.
+#
+# ARG is a pathlist (on $build) that should be converted to
+# the proper representation on $host. The result is stored
+# in $func_to_host_pathlist_result.
+func_to_host_pathlist ()
+{
+  func_to_host_pathlist_result="$1"
+  if test -n "$1" ; then
+    case $host in
+      *mingw* )
+        lt_sed_naive_backslashify='s|\\\\*|\\|g;s|/|\\|g;s|\\|\\\\|g'
+        # Remove leading and trailing path separator characters from
+        # ARG. msys behavior is inconsistent here, cygpath turns them
+        # into '.;' and ';.', and winepath ignores them completely.
+        func_to_host_pathlist_tmp2="$1"
+        # Once set for this call, this variable should not be
+        # reassigned. It is used in tha fallback case.
+        func_to_host_pathlist_tmp1=`echo "$func_to_host_pathlist_tmp2" |\
+          $SED -e 's|^:*||' -e 's|:*$||'`
+        case $build in
+          *mingw* ) # Actually, msys.
+            # Awkward: cmd appends spaces to result.
+            lt_sed_strip_trailing_spaces="s/[ ]*\$//"
+            func_to_host_pathlist_tmp2=`( cmd //c echo "$func_to_host_pathlist_tmp1" |\
+              $SED -e "$lt_sed_strip_trailing_spaces" ) 2>/dev/null || echo ""`
+            func_to_host_pathlist_result=`echo "$func_to_host_pathlist_tmp2" |\
+              $SED -e "$lt_sed_naive_backslashify"`
+            ;;
+          *cygwin* )
+            func_to_host_pathlist_tmp2=`cygpath -w -p "$func_to_host_pathlist_tmp1"`
+            func_to_host_pathlist_result=`echo "$func_to_host_pathlist_tmp2" |\
+              $SED -e "$lt_sed_naive_backslashify"`
+            ;;
+          * )
+            # unfortunately, winepath doesn't convert pathlists
+            func_to_host_pathlist_result=""
+            func_to_host_pathlist_oldIFS=$IFS
+            IFS=:
+            for func_to_host_pathlist_f in $func_to_host_pathlist_tmp1 ; do
+              IFS=$func_to_host_pathlist_oldIFS
+              if test -n "$func_to_host_pathlist_f" ; then
+                func_to_host_path "$func_to_host_pathlist_f"
+                if test -n "$func_to_host_path_result" ; then
+                  if test -z "$func_to_host_pathlist_result" ; then
+                    func_to_host_pathlist_result="$func_to_host_path_result"
+                  else
+                    func_to_host_pathlist_result="$func_to_host_pathlist_result;$func_to_host_path_result"
+                  fi
+                fi
+              fi
+              IFS=:
+            done
+            IFS=$func_to_host_pathlist_oldIFS
+            ;;
+        esac
+        if test -z "$func_to_host_pathlist_result" ; then
+          func_error "Could not determine the host path(s) corresponding to"
+          func_error "  '$1'"
+          func_error "Continuing, but uninstalled executables may not work."
+          # Fallback. This may break if $1 contains DOS-style drive
+          # specifications. The fix is not to complicate the expression
+          # below, but for the user to provide a working wine installation
+          # with winepath so that path translation in the cross-to-mingw
+          # case works properly.
+          lt_replace_pathsep_nix_to_dos="s|:|;|g"
+          func_to_host_pathlist_result=`echo "$func_to_host_pathlist_tmp1" |\
+            $SED -e "$lt_replace_pathsep_nix_to_dos"`
+        fi
+        # Now, add the leading and trailing path separators back
+        case "$1" in
+          :* ) func_to_host_pathlist_result=";$func_to_host_pathlist_result"
+            ;;
+        esac
+        case "$1" in
+          *: ) func_to_host_pathlist_result="$func_to_host_pathlist_result;"
+            ;;
+        esac
+        ;;
+    esac
+  fi
+}
+# end: func_to_host_pathlist
+
+# func_emit_cwrapperexe_src
+# emit the source code for a wrapper executable on stdout
+# Must ONLY be called from within func_mode_link because
+# it depends on a number of variable set therein.
+func_emit_cwrapperexe_src ()
+{
+	cat <<EOF
+
+/* $cwrappersource - temporary wrapper executable for $objdir/$outputname
+   Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION
+
+   The $output program cannot be directly executed until all the libtool
+   libraries that it depends on are installed.
+
+   This wrapper executable should never be moved out of the build directory.
+   If it is, it will not operate correctly.
+
+   Currently, it simply execs the wrapper *script* "$SHELL $output",
+   but could eventually absorb all of the scripts functionality and
+   exec $objdir/$outputname directly.
+*/
+EOF
+	    cat <<"EOF"
+#include <stdio.h>
+#include <stdlib.h>
+#ifdef _MSC_VER
+# include <direct.h>
+# include <process.h>
+# include <io.h>
+# define setmode _setmode
+#else
+# include <unistd.h>
+# include <stdint.h>
+# ifdef __CYGWIN__
+#  include <io.h>
+#  define HAVE_SETENV
+#  ifdef __STRICT_ANSI__
+char *realpath (const char *, char *);
+int putenv (char *);
+int setenv (const char *, const char *, int);
+#  endif
+# endif
+#endif
+#include <malloc.h>
+#include <stdarg.h>
+#include <assert.h>
+#include <string.h>
+#include <ctype.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+
+#if defined(PATH_MAX)
+# define LT_PATHMAX PATH_MAX
+#elif defined(MAXPATHLEN)
+# define LT_PATHMAX MAXPATHLEN
+#else
+# define LT_PATHMAX 1024
+#endif
+
+#ifndef S_IXOTH
+# define S_IXOTH 0
+#endif
+#ifndef S_IXGRP
+# define S_IXGRP 0
+#endif
+
+#ifdef _MSC_VER
+# define S_IXUSR _S_IEXEC
+# define stat _stat
+# ifndef _INTPTR_T_DEFINED
+#  define intptr_t int
+# endif
+#endif
+
+#ifndef DIR_SEPARATOR
+# define DIR_SEPARATOR '/'
+# define PATH_SEPARATOR ':'
+#endif
+
+#if defined (_WIN32) || defined (__MSDOS__) || defined (__DJGPP__) || \
+  defined (__OS2__)
+# define HAVE_DOS_BASED_FILE_SYSTEM
+# define FOPEN_WB "wb"
+# ifndef DIR_SEPARATOR_2
+#  define DIR_SEPARATOR_2 '\\'
+# endif
+# ifndef PATH_SEPARATOR_2
+#  define PATH_SEPARATOR_2 ';'
+# endif
+#endif
+
+#ifndef DIR_SEPARATOR_2
+# define IS_DIR_SEPARATOR(ch) ((ch) == DIR_SEPARATOR)
+#else /* DIR_SEPARATOR_2 */
+# define IS_DIR_SEPARATOR(ch) \
+	(((ch) == DIR_SEPARATOR) || ((ch) == DIR_SEPARATOR_2))
+#endif /* DIR_SEPARATOR_2 */
+
+#ifndef PATH_SEPARATOR_2
+# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR)
+#else /* PATH_SEPARATOR_2 */
+# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR_2)
+#endif /* PATH_SEPARATOR_2 */
+
+#ifdef __CYGWIN__
+# define FOPEN_WB "wb"
+#endif
+
+#ifndef FOPEN_WB
+# define FOPEN_WB "w"
+#endif
+#ifndef _O_BINARY
+# define _O_BINARY 0
+#endif
+
+#define XMALLOC(type, num)      ((type *) xmalloc ((num) * sizeof(type)))
+#define XFREE(stale) do { \
+  if (stale) { free ((void *) stale); stale = 0; } \
+} while (0)
+
+#undef LTWRAPPER_DEBUGPRINTF
+#if defined DEBUGWRAPPER
+# define LTWRAPPER_DEBUGPRINTF(args) ltwrapper_debugprintf args
+static void
+ltwrapper_debugprintf (const char *fmt, ...)
+{
+    va_list args;
+    va_start (args, fmt);
+    (void) vfprintf (stderr, fmt, args);
+    va_end (args);
+}
+#else
+# define LTWRAPPER_DEBUGPRINTF(args)
+#endif
+
+const char *program_name = NULL;
+
+void *xmalloc (size_t num);
+char *xstrdup (const char *string);
+const char *base_name (const char *name);
+char *find_executable (const char *wrapper);
+char *chase_symlinks (const char *pathspec);
+int make_executable (const char *path);
+int check_executable (const char *path);
+char *strendzap (char *str, const char *pat);
+void lt_fatal (const char *message, ...);
+void lt_setenv (const char *name, const char *value);
+char *lt_extend_str (const char *orig_value, const char *add, int to_end);
+void lt_opt_process_env_set (const char *arg);
+void lt_opt_process_env_prepend (const char *arg);
+void lt_opt_process_env_append (const char *arg);
+int lt_split_name_value (const char *arg, char** name, char** value);
+void lt_update_exe_path (const char *name, const char *value);
+void lt_update_lib_path (const char *name, const char *value);
+
+static const char *script_text_part1 =
+EOF
+
+	    func_emit_wrapper_part1 yes |
+	        $SED -e 's/\([\\"]\)/\\\1/g' \
+	             -e 's/^/  "/' -e 's/$/\\n"/'
+	    echo ";"
+	    cat <<EOF
+
+static const char *script_text_part2 =
+EOF
+	    func_emit_wrapper_part2 yes |
+	        $SED -e 's/\([\\"]\)/\\\1/g' \
+	             -e 's/^/  "/' -e 's/$/\\n"/'
+	    echo ";"
+
+	    cat <<EOF
+const char * MAGIC_EXE = "$magic_exe";
+const char * LIB_PATH_VARNAME = "$shlibpath_var";
+EOF
+
+	    if test "$shlibpath_overrides_runpath" = yes && test -n "$shlibpath_var" && test -n "$temp_rpath"; then
+              func_to_host_pathlist "$temp_rpath"
+	      cat <<EOF
+const char * LIB_PATH_VALUE   = "$func_to_host_pathlist_result";
+EOF
+	    else
+	      cat <<"EOF"
+const char * LIB_PATH_VALUE   = "";
+EOF
+	    fi
+
+	    if test -n "$dllsearchpath"; then
+              func_to_host_pathlist "$dllsearchpath:"
+	      cat <<EOF
+const char * EXE_PATH_VARNAME = "PATH";
+const char * EXE_PATH_VALUE   = "$func_to_host_pathlist_result";
+EOF
+	    else
+	      cat <<"EOF"
+const char * EXE_PATH_VARNAME = "";
+const char * EXE_PATH_VALUE   = "";
+EOF
+	    fi
+
+	    if test "$fast_install" = yes; then
+	      cat <<EOF
+const char * TARGET_PROGRAM_NAME = "lt-$outputname"; /* hopefully, no .exe */
+EOF
+	    else
+	      cat <<EOF
+const char * TARGET_PROGRAM_NAME = "$outputname"; /* hopefully, no .exe */
+EOF
+	    fi
+
+
+	    cat <<"EOF"
+
+#define LTWRAPPER_OPTION_PREFIX         "--lt-"
+#define LTWRAPPER_OPTION_PREFIX_LENGTH  5
+
+static const size_t opt_prefix_len         = LTWRAPPER_OPTION_PREFIX_LENGTH;
+static const char *ltwrapper_option_prefix = LTWRAPPER_OPTION_PREFIX;
+
+static const char *dumpscript_opt       = LTWRAPPER_OPTION_PREFIX "dump-script";
+
+static const size_t env_set_opt_len     = LTWRAPPER_OPTION_PREFIX_LENGTH + 7;
+static const char *env_set_opt          = LTWRAPPER_OPTION_PREFIX "env-set";
+  /* argument is putenv-style "foo=bar", value of foo is set to bar */
+
+static const size_t env_prepend_opt_len = LTWRAPPER_OPTION_PREFIX_LENGTH + 11;
+static const char *env_prepend_opt      = LTWRAPPER_OPTION_PREFIX "env-prepend";
+  /* argument is putenv-style "foo=bar", new value of foo is bar${foo} */
+
+static const size_t env_append_opt_len  = LTWRAPPER_OPTION_PREFIX_LENGTH + 10;
+static const char *env_append_opt       = LTWRAPPER_OPTION_PREFIX "env-append";
+  /* argument is putenv-style "foo=bar", new value of foo is ${foo}bar */
+
+int
+main (int argc, char *argv[])
+{
+  char **newargz;
+  int  newargc;
+  char *tmp_pathspec;
+  char *actual_cwrapper_path;
+  char *actual_cwrapper_name;
+  char *target_name;
+  char *lt_argv_zero;
+  intptr_t rval = 127;
+
+  int i;
+
+  program_name = (char *) xstrdup (base_name (argv[0]));
+  LTWRAPPER_DEBUGPRINTF (("(main) argv[0]      : %s\n", argv[0]));
+  LTWRAPPER_DEBUGPRINTF (("(main) program_name : %s\n", program_name));
+
+  /* very simple arg parsing; don't want to rely on getopt */
+  for (i = 1; i < argc; i++)
+    {
+      if (strcmp (argv[i], dumpscript_opt) == 0)
+	{
+EOF
+	    case "$host" in
+	      *mingw* | *cygwin* )
+		# make stdout use "unix" line endings
+		echo "          setmode(1,_O_BINARY);"
+		;;
+	      esac
+
+	    cat <<"EOF"
+	  printf ("%s", script_text_part1);
+	  printf ("%s", script_text_part2);
+	  return 0;
+	}
+    }
+
+  newargz = XMALLOC (char *, argc + 1);
+  tmp_pathspec = find_executable (argv[0]);
+  if (tmp_pathspec == NULL)
+    lt_fatal ("Couldn't find %s", argv[0]);
+  LTWRAPPER_DEBUGPRINTF (("(main) found exe (before symlink chase) at : %s\n",
+			  tmp_pathspec));
+
+  actual_cwrapper_path = chase_symlinks (tmp_pathspec);
+  LTWRAPPER_DEBUGPRINTF (("(main) found exe (after symlink chase) at : %s\n",
+			  actual_cwrapper_path));
+  XFREE (tmp_pathspec);
+
+  actual_cwrapper_name = xstrdup( base_name (actual_cwrapper_path));
+  strendzap (actual_cwrapper_path, actual_cwrapper_name);
+
+  /* wrapper name transforms */
+  strendzap (actual_cwrapper_name, ".exe");
+  tmp_pathspec = lt_extend_str (actual_cwrapper_name, ".exe", 1);
+  XFREE (actual_cwrapper_name);
+  actual_cwrapper_name = tmp_pathspec;
+  tmp_pathspec = 0;
+
+  /* target_name transforms -- use actual target program name; might have lt- prefix */
+  target_name = xstrdup (base_name (TARGET_PROGRAM_NAME));
+  strendzap (target_name, ".exe");
+  tmp_pathspec = lt_extend_str (target_name, ".exe", 1);
+  XFREE (target_name);
+  target_name = tmp_pathspec;
+  tmp_pathspec = 0;
+
+  LTWRAPPER_DEBUGPRINTF (("(main) libtool target name: %s\n",
+			  target_name));
+EOF
+
+	    cat <<EOF
+  newargz[0] =
+    XMALLOC (char, (strlen (actual_cwrapper_path) +
+		    strlen ("$objdir") + 1 + strlen (actual_cwrapper_name) + 1));
+  strcpy (newargz[0], actual_cwrapper_path);
+  strcat (newargz[0], "$objdir");
+  strcat (newargz[0], "/");
+EOF
+
+	    cat <<"EOF"
+  /* stop here, and copy so we don't have to do this twice */
+  tmp_pathspec = xstrdup (newargz[0]);
+
+  /* do NOT want the lt- prefix here, so use actual_cwrapper_name */
+  strcat (newargz[0], actual_cwrapper_name);
+
+  /* DO want the lt- prefix here if it exists, so use target_name */
+  lt_argv_zero = lt_extend_str (tmp_pathspec, target_name, 1);
+  XFREE (tmp_pathspec);
+  tmp_pathspec = NULL;
+EOF
+
+	    case $host_os in
+	      mingw*)
+	    cat <<"EOF"
+  {
+    char* p;
+    while ((p = strchr (newargz[0], '\\')) != NULL)
+      {
+	*p = '/';
+      }
+    while ((p = strchr (lt_argv_zero, '\\')) != NULL)
+      {
+	*p = '/';
+      }
+  }
+EOF
+	    ;;
+	    esac
+
+	    cat <<"EOF"
+  XFREE (target_name);
+  XFREE (actual_cwrapper_path);
+  XFREE (actual_cwrapper_name);
+
+  lt_setenv ("BIN_SH", "xpg4"); /* for Tru64 */
+  lt_setenv ("DUALCASE", "1");  /* for MSK sh */
+  lt_update_lib_path (LIB_PATH_VARNAME, LIB_PATH_VALUE);
+  lt_update_exe_path (EXE_PATH_VARNAME, EXE_PATH_VALUE);
+
+  newargc=0;
+  for (i = 1; i < argc; i++)
+    {
+      if (strncmp (argv[i], env_set_opt, env_set_opt_len) == 0)
+        {
+          if (argv[i][env_set_opt_len] == '=')
+            {
+              const char *p = argv[i] + env_set_opt_len + 1;
+              lt_opt_process_env_set (p);
+            }
+          else if (argv[i][env_set_opt_len] == '\0' && i + 1 < argc)
+            {
+              lt_opt_process_env_set (argv[++i]); /* don't copy */
+            }
+          else
+            lt_fatal ("%s missing required argument", env_set_opt);
+          continue;
+        }
+      if (strncmp (argv[i], env_prepend_opt, env_prepend_opt_len) == 0)
+        {
+          if (argv[i][env_prepend_opt_len] == '=')
+            {
+              const char *p = argv[i] + env_prepend_opt_len + 1;
+              lt_opt_process_env_prepend (p);
+            }
+          else if (argv[i][env_prepend_opt_len] == '\0' && i + 1 < argc)
+            {
+              lt_opt_process_env_prepend (argv[++i]); /* don't copy */
+            }
+          else
+            lt_fatal ("%s missing required argument", env_prepend_opt);
+          continue;
+        }
+      if (strncmp (argv[i], env_append_opt, env_append_opt_len) == 0)
+        {
+          if (argv[i][env_append_opt_len] == '=')
+            {
+              const char *p = argv[i] + env_append_opt_len + 1;
+              lt_opt_process_env_append (p);
+            }
+          else if (argv[i][env_append_opt_len] == '\0' && i + 1 < argc)
+            {
+              lt_opt_process_env_append (argv[++i]); /* don't copy */
+            }
+          else
+            lt_fatal ("%s missing required argument", env_append_opt);
+          continue;
+        }
+      if (strncmp (argv[i], ltwrapper_option_prefix, opt_prefix_len) == 0)
+        {
+          /* however, if there is an option in the LTWRAPPER_OPTION_PREFIX
+             namespace, but it is not one of the ones we know about and
+             have already dealt with, above (inluding dump-script), then
+             report an error. Otherwise, targets might begin to believe
+             they are allowed to use options in the LTWRAPPER_OPTION_PREFIX
+             namespace. The first time any user complains about this, we'll
+             need to make LTWRAPPER_OPTION_PREFIX a configure-time option
+             or a configure.ac-settable value.
+           */
+          lt_fatal ("Unrecognized option in %s namespace: '%s'",
+                    ltwrapper_option_prefix, argv[i]);
+        }
+      /* otherwise ... */
+      newargz[++newargc] = xstrdup (argv[i]);
+    }
+  newargz[++newargc] = NULL;
+
+  LTWRAPPER_DEBUGPRINTF     (("(main) lt_argv_zero : %s\n", (lt_argv_zero ? lt_argv_zero : "<NULL>")));
+  for (i = 0; i < newargc; i++)
+    {
+      LTWRAPPER_DEBUGPRINTF (("(main) newargz[%d]   : %s\n", i, (newargz[i] ? newargz[i] : "<NULL>")));
+    }
+
+EOF
+
+	    case $host_os in
+	      mingw*)
+		cat <<"EOF"
+  /* execv doesn't actually work on mingw as expected on unix */
+  rval = _spawnv (_P_WAIT, lt_argv_zero, (const char * const *) newargz);
+  if (rval == -1)
+    {
+      /* failed to start process */
+      LTWRAPPER_DEBUGPRINTF (("(main) failed to launch target \"%s\": errno = %d\n", lt_argv_zero, errno));
+      return 127;
+    }
+  return rval;
+EOF
+		;;
+	      *)
+		cat <<"EOF"
+  execv (lt_argv_zero, newargz);
+  return rval; /* =127, but avoids unused variable warning */
+EOF
+		;;
+	    esac
+
+	    cat <<"EOF"
+}
+
+void *
+xmalloc (size_t num)
+{
+  void *p = (void *) malloc (num);
+  if (!p)
+    lt_fatal ("Memory exhausted");
+
+  return p;
+}
+
+char *
+xstrdup (const char *string)
+{
+  return string ? strcpy ((char *) xmalloc (strlen (string) + 1),
+			  string) : NULL;
+}
+
+const char *
+base_name (const char *name)
+{
+  const char *base;
+
+#if defined (HAVE_DOS_BASED_FILE_SYSTEM)
+  /* Skip over the disk name in MSDOS pathnames. */
+  if (isalpha ((unsigned char) name[0]) && name[1] == ':')
+    name += 2;
+#endif
+
+  for (base = name; *name; name++)
+    if (IS_DIR_SEPARATOR (*name))
+      base = name + 1;
+  return base;
+}
+
+int
+check_executable (const char *path)
+{
+  struct stat st;
+
+  LTWRAPPER_DEBUGPRINTF (("(check_executable)  : %s\n",
+			  path ? (*path ? path : "EMPTY!") : "NULL!"));
+  if ((!path) || (!*path))
+    return 0;
+
+  if ((stat (path, &st) >= 0)
+      && (st.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH)))
+    return 1;
+  else
+    return 0;
+}
+
+int
+make_executable (const char *path)
+{
+  int rval = 0;
+  struct stat st;
+
+  LTWRAPPER_DEBUGPRINTF (("(make_executable)   : %s\n",
+			  path ? (*path ? path : "EMPTY!") : "NULL!"));
+  if ((!path) || (!*path))
+    return 0;
+
+  if (stat (path, &st) >= 0)
+    {
+      rval = chmod (path, st.st_mode | S_IXOTH | S_IXGRP | S_IXUSR);
+    }
+  return rval;
+}
+
+/* Searches for the full path of the wrapper.  Returns
+   newly allocated full path name if found, NULL otherwise
+   Does not chase symlinks, even on platforms that support them.
+*/
+char *
+find_executable (const char *wrapper)
+{
+  int has_slash = 0;
+  const char *p;
+  const char *p_next;
+  /* static buffer for getcwd */
+  char tmp[LT_PATHMAX + 1];
+  int tmp_len;
+  char *concat_name;
+
+  LTWRAPPER_DEBUGPRINTF (("(find_executable)   : %s\n",
+			  wrapper ? (*wrapper ? wrapper : "EMPTY!") : "NULL!"));
+
+  if ((wrapper == NULL) || (*wrapper == '\0'))
+    return NULL;
+
+  /* Absolute path? */
+#if defined (HAVE_DOS_BASED_FILE_SYSTEM)
+  if (isalpha ((unsigned char) wrapper[0]) && wrapper[1] == ':')
+    {
+      concat_name = xstrdup (wrapper);
+      if (check_executable (concat_name))
+	return concat_name;
+      XFREE (concat_name);
+    }
+  else
+    {
+#endif
+      if (IS_DIR_SEPARATOR (wrapper[0]))
+	{
+	  concat_name = xstrdup (wrapper);
+	  if (check_executable (concat_name))
+	    return concat_name;
+	  XFREE (concat_name);
+	}
+#if defined (HAVE_DOS_BASED_FILE_SYSTEM)
+    }
+#endif
+
+  for (p = wrapper; *p; p++)
+    if (*p == '/')
+      {
+	has_slash = 1;
+	break;
+      }
+  if (!has_slash)
+    {
+      /* no slashes; search PATH */
+      const char *path = getenv ("PATH");
+      if (path != NULL)
+	{
+	  for (p = path; *p; p = p_next)
+	    {
+	      const char *q;
+	      size_t p_len;
+	      for (q = p; *q; q++)
+		if (IS_PATH_SEPARATOR (*q))
+		  break;
+	      p_len = q - p;
+	      p_next = (*q == '\0' ? q : q + 1);
+	      if (p_len == 0)
+		{
+		  /* empty path: current directory */
+		  if (getcwd (tmp, LT_PATHMAX) == NULL)
+		    lt_fatal ("getcwd failed");
+		  tmp_len = strlen (tmp);
+		  concat_name =
+		    XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);
+		  memcpy (concat_name, tmp, tmp_len);
+		  concat_name[tmp_len] = '/';
+		  strcpy (concat_name + tmp_len + 1, wrapper);
+		}
+	      else
+		{
+		  concat_name =
+		    XMALLOC (char, p_len + 1 + strlen (wrapper) + 1);
+		  memcpy (concat_name, p, p_len);
+		  concat_name[p_len] = '/';
+		  strcpy (concat_name + p_len + 1, wrapper);
+		}
+	      if (check_executable (concat_name))
+		return concat_name;
+	      XFREE (concat_name);
+	    }
+	}
+      /* not found in PATH; assume curdir */
+    }
+  /* Relative path | not found in path: prepend cwd */
+  if (getcwd (tmp, LT_PATHMAX) == NULL)
+    lt_fatal ("getcwd failed");
+  tmp_len = strlen (tmp);
+  concat_name = XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);
+  memcpy (concat_name, tmp, tmp_len);
+  concat_name[tmp_len] = '/';
+  strcpy (concat_name + tmp_len + 1, wrapper);
+
+  if (check_executable (concat_name))
+    return concat_name;
+  XFREE (concat_name);
+  return NULL;
+}
+
+char *
+chase_symlinks (const char *pathspec)
+{
+#ifndef S_ISLNK
+  return xstrdup (pathspec);
+#else
+  char buf[LT_PATHMAX];
+  struct stat s;
+  char *tmp_pathspec = xstrdup (pathspec);
+  char *p;
+  int has_symlinks = 0;
+  while (strlen (tmp_pathspec) && !has_symlinks)
+    {
+      LTWRAPPER_DEBUGPRINTF (("checking path component for symlinks: %s\n",
+			      tmp_pathspec));
+      if (lstat (tmp_pathspec, &s) == 0)
+	{
+	  if (S_ISLNK (s.st_mode) != 0)
+	    {
+	      has_symlinks = 1;
+	      break;
+	    }
+
+	  /* search backwards for last DIR_SEPARATOR */
+	  p = tmp_pathspec + strlen (tmp_pathspec) - 1;
+	  while ((p > tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))
+	    p--;
+	  if ((p == tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))
+	    {
+	      /* no more DIR_SEPARATORS left */
+	      break;
+	    }
+	  *p = '\0';
+	}
+      else
+	{
+	  char *errstr = strerror (errno);
+	  lt_fatal ("Error accessing file %s (%s)", tmp_pathspec, errstr);
+	}
+    }
+  XFREE (tmp_pathspec);
+
+  if (!has_symlinks)
+    {
+      return xstrdup (pathspec);
+    }
+
+  tmp_pathspec = realpath (pathspec, buf);
+  if (tmp_pathspec == 0)
+    {
+      lt_fatal ("Could not follow symlinks for %s", pathspec);
+    }
+  return xstrdup (tmp_pathspec);
+#endif
+}
+
+char *
+strendzap (char *str, const char *pat)
+{
+  size_t len, patlen;
+
+  assert (str != NULL);
+  assert (pat != NULL);
+
+  len = strlen (str);
+  patlen = strlen (pat);
+
+  if (patlen <= len)
+    {
+      str += len - patlen;
+      if (strcmp (str, pat) == 0)
+	*str = '\0';
+    }
+  return str;
+}
+
+static void
+lt_error_core (int exit_status, const char *mode,
+	       const char *message, va_list ap)
+{
+  fprintf (stderr, "%s: %s: ", program_name, mode);
+  vfprintf (stderr, message, ap);
+  fprintf (stderr, ".\n");
+
+  if (exit_status >= 0)
+    exit (exit_status);
+}
+
+void
+lt_fatal (const char *message, ...)
+{
+  va_list ap;
+  va_start (ap, message);
+  lt_error_core (EXIT_FAILURE, "FATAL", message, ap);
+  va_end (ap);
+}
+
+void
+lt_setenv (const char *name, const char *value)
+{
+  LTWRAPPER_DEBUGPRINTF (("(lt_setenv) setting '%s' to '%s'\n",
+                          (name ? name : "<NULL>"),
+                          (value ? value : "<NULL>")));
+  {
+#ifdef HAVE_SETENV
+    /* always make a copy, for consistency with !HAVE_SETENV */
+    char *str = xstrdup (value);
+    setenv (name, str, 1);
+#else
+    int len = strlen (name) + 1 + strlen (value) + 1;
+    char *str = XMALLOC (char, len);
+    sprintf (str, "%s=%s", name, value);
+    if (putenv (str) != EXIT_SUCCESS)
+      {
+        XFREE (str);
+      }
+#endif
+  }
+}
+
+char *
+lt_extend_str (const char *orig_value, const char *add, int to_end)
+{
+  char *new_value;
+  if (orig_value && *orig_value)
+    {
+      int orig_value_len = strlen (orig_value);
+      int add_len = strlen (add);
+      new_value = XMALLOC (char, add_len + orig_value_len + 1);
+      if (to_end)
+        {
+          strcpy (new_value, orig_value);
+          strcpy (new_value + orig_value_len, add);
+        }
+      else
+        {
+          strcpy (new_value, add);
+          strcpy (new_value + add_len, orig_value);
+        }
+    }
+  else
+    {
+      new_value = xstrdup (add);
+    }
+  return new_value;
+}
+
+int
+lt_split_name_value (const char *arg, char** name, char** value)
+{
+  const char *p;
+  int len;
+  if (!arg || !*arg)
+    return 1;
+
+  p = strchr (arg, (int)'=');
+
+  if (!p)
+    return 1;
+
+  *value = xstrdup (++p);
+
+  len = strlen (arg) - strlen (*value);
+  *name = XMALLOC (char, len);
+  strncpy (*name, arg, len-1);
+  (*name)[len - 1] = '\0';
+
+  return 0;
+}
+
+void
+lt_opt_process_env_set (const char *arg)
+{
+  char *name = NULL;
+  char *value = NULL;
+
+  if (lt_split_name_value (arg, &name, &value) != 0)
+    {
+      XFREE (name);
+      XFREE (value);
+      lt_fatal ("bad argument for %s: '%s'", env_set_opt, arg);
+    }
+
+  lt_setenv (name, value);
+  XFREE (name);
+  XFREE (value);
+}
+
+void
+lt_opt_process_env_prepend (const char *arg)
+{
+  char *name = NULL;
+  char *value = NULL;
+  char *new_value = NULL;
+
+  if (lt_split_name_value (arg, &name, &value) != 0)
+    {
+      XFREE (name);
+      XFREE (value);
+      lt_fatal ("bad argument for %s: '%s'", env_prepend_opt, arg);
+    }
+
+  new_value = lt_extend_str (getenv (name), value, 0);
+  lt_setenv (name, new_value);
+  XFREE (new_value);
+  XFREE (name);
+  XFREE (value);
+}
+
+void
+lt_opt_process_env_append (const char *arg)
+{
+  char *name = NULL;
+  char *value = NULL;
+  char *new_value = NULL;
+
+  if (lt_split_name_value (arg, &name, &value) != 0)
+    {
+      XFREE (name);
+      XFREE (value);
+      lt_fatal ("bad argument for %s: '%s'", env_append_opt, arg);
+    }
+
+  new_value = lt_extend_str (getenv (name), value, 1);
+  lt_setenv (name, new_value);
+  XFREE (new_value);
+  XFREE (name);
+  XFREE (value);
+}
+
+void
+lt_update_exe_path (const char *name, const char *value)
+{
+  LTWRAPPER_DEBUGPRINTF (("(lt_update_exe_path) modifying '%s' by prepending '%s'\n",
+                          (name ? name : "<NULL>"),
+                          (value ? value : "<NULL>")));
+
+  if (name && *name && value && *value)
+    {
+      char *new_value = lt_extend_str (getenv (name), value, 0);
+      /* some systems can't cope with a ':'-terminated path #' */
+      int len = strlen (new_value);
+      while (((len = strlen (new_value)) > 0) && IS_PATH_SEPARATOR (new_value[len-1]))
+        {
+          new_value[len-1] = '\0';
+        }
+      lt_setenv (name, new_value);
+      XFREE (new_value);
+    }
+}
+
+void
+lt_update_lib_path (const char *name, const char *value)
+{
+  LTWRAPPER_DEBUGPRINTF (("(lt_update_lib_path) modifying '%s' by prepending '%s'\n",
+                          (name ? name : "<NULL>"),
+                          (value ? value : "<NULL>")));
+
+  if (name && *name && value && *value)
+    {
+      char *new_value = lt_extend_str (getenv (name), value, 0);
+      lt_setenv (name, new_value);
+      XFREE (new_value);
+    }
+}
+
+
+EOF
+}
+# end: func_emit_cwrapperexe_src
+
+# func_mode_link arg...
+func_mode_link ()
+{
+    $opt_debug
+    case $host in
+    *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)
+      # It is impossible to link a dll without this setting, and
+      # we shouldn't force the makefile maintainer to figure out
+      # which system we are compiling for in order to pass an extra
+      # flag for every libtool invocation.
+      # allow_undefined=no
+
+      # FIXME: Unfortunately, there are problems with the above when trying
+      # to make a dll which has undefined symbols, in which case not
+      # even a static library is built.  For now, we need to specify
+      # -no-undefined on the libtool link line when we can be certain
+      # that all symbols are satisfied, otherwise we get a static library.
+      allow_undefined=yes
+      ;;
+    *)
+      allow_undefined=yes
+      ;;
+    esac
+    libtool_args=$nonopt
+    base_compile="$nonopt $@"
+    compile_command=$nonopt
+    finalize_command=$nonopt
+
+    compile_rpath=
+    finalize_rpath=
+    compile_shlibpath=
+    finalize_shlibpath=
+    convenience=
+    old_convenience=
+    deplibs=
+    old_deplibs=
+    compiler_flags=
+    linker_flags=
+    dllsearchpath=
+    lib_search_path=`pwd`
+    inst_prefix_dir=
+    new_inherited_linker_flags=
+
+    avoid_version=no
+    dlfiles=
+    dlprefiles=
+    dlself=no
+    export_dynamic=no
+    export_symbols=
+    export_symbols_regex=
+    generated=
+    libobjs=
+    ltlibs=
+    module=no
+    no_install=no
+    objs=
+    non_pic_objects=
+    precious_files_regex=
+    prefer_static_libs=no
+    preload=no
+    prev=
+    prevarg=
+    release=
+    rpath=
+    xrpath=
+    perm_rpath=
+    temp_rpath=
+    thread_safe=no
+    vinfo=
+    vinfo_number=no
+    weak_libs=
+    single_module="${wl}-single_module"
+    func_infer_tag $base_compile
+
+    # We need to know -static, to get the right output filenames.
+    for arg
+    do
+      case $arg in
+      -shared)
+	test "$build_libtool_libs" != yes && \
+	  func_fatal_configuration "can not build a shared library"
+	build_old_libs=no
+	break
+	;;
+      -all-static | -static | -static-libtool-libs)
+	case $arg in
+	-all-static)
+	  if test "$build_libtool_libs" = yes && test -z "$link_static_flag"; then
+	    func_warning "complete static linking is impossible in this configuration"
+	  fi
+	  if test -n "$link_static_flag"; then
+	    dlopen_self=$dlopen_self_static
+	  fi
+	  prefer_static_libs=yes
+	  ;;
+	-static)
+	  if test -z "$pic_flag" && test -n "$link_static_flag"; then
+	    dlopen_self=$dlopen_self_static
+	  fi
+	  prefer_static_libs=built
+	  ;;
+	-static-libtool-libs)
+	  if test -z "$pic_flag" && test -n "$link_static_flag"; then
+	    dlopen_self=$dlopen_self_static
+	  fi
+	  prefer_static_libs=yes
+	  ;;
+	esac
+	build_libtool_libs=no
+	build_old_libs=yes
+	break
+	;;
+      esac
+    done
+
+    # See if our shared archives depend on static archives.
+    test -n "$old_archive_from_new_cmds" && build_old_libs=yes
+
+    # Go through the arguments, transforming them on the way.
+    while test "$#" -gt 0; do
+      arg="$1"
+      shift
+      func_quote_for_eval "$arg"
+      qarg=$func_quote_for_eval_unquoted_result
+      func_append libtool_args " $func_quote_for_eval_result"
+
+      # If the previous option needs an argument, assign it.
+      if test -n "$prev"; then
+	case $prev in
+	output)
+	  func_append compile_command " @OUTPUT@"
+	  func_append finalize_command " @OUTPUT@"
+	  ;;
+	esac
+
+	case $prev in
+	dlfiles|dlprefiles)
+	  if test "$preload" = no; then
+	    # Add the symbol object into the linking commands.
+	    func_append compile_command " @SYMFILE@"
+	    func_append finalize_command " @SYMFILE@"
+	    preload=yes
+	  fi
+	  case $arg in
+	  *.la | *.lo) ;;  # We handle these cases below.
+	  force)
+	    if test "$dlself" = no; then
+	      dlself=needless
+	      export_dynamic=yes
+	    fi
+	    prev=
+	    continue
+	    ;;
+	  self)
+	    if test "$prev" = dlprefiles; then
+	      dlself=yes
+	    elif test "$prev" = dlfiles && test "$dlopen_self" != yes; then
+	      dlself=yes
+	    else
+	      dlself=needless
+	      export_dynamic=yes
+	    fi
+	    prev=
+	    continue
+	    ;;
+	  *)
+	    if test "$prev" = dlfiles; then
+	      dlfiles="$dlfiles $arg"
+	    else
+	      dlprefiles="$dlprefiles $arg"
+	    fi
+	    prev=
+	    continue
+	    ;;
+	  esac
+	  ;;
+	expsyms)
+	  export_symbols="$arg"
+	  test -f "$arg" \
+	    || func_fatal_error "symbol file \`$arg' does not exist"
+	  prev=
+	  continue
+	  ;;
+	expsyms_regex)
+	  export_symbols_regex="$arg"
+	  prev=
+	  continue
+	  ;;
+	framework)
+	  case $host in
+	    *-*-darwin*)
+	      case "$deplibs " in
+		*" $qarg.ltframework "*) ;;
+		*) deplibs="$deplibs $qarg.ltframework" # this is fixed later
+		   ;;
+	      esac
+	      ;;
+	  esac
+	  prev=
+	  continue
+	  ;;
+	inst_prefix)
+	  inst_prefix_dir="$arg"
+	  prev=
+	  continue
+	  ;;
+	objectlist)
+	  if test -f "$arg"; then
+	    save_arg=$arg
+	    moreargs=
+	    for fil in `cat "$save_arg"`
+	    do
+#	      moreargs="$moreargs $fil"
+	      arg=$fil
+	      # A libtool-controlled object.
+
+	      # Check to see that this really is a libtool object.
+	      if func_lalib_unsafe_p "$arg"; then
+		pic_object=
+		non_pic_object=
+
+		# Read the .lo file
+		func_source "$arg"
+
+		if test -z "$pic_object" ||
+		   test -z "$non_pic_object" ||
+		   test "$pic_object" = none &&
+		   test "$non_pic_object" = none; then
+		  func_fatal_error "cannot find name of object for \`$arg'"
+		fi
+
+		# Extract subdirectory from the argument.
+		func_dirname "$arg" "/" ""
+		xdir="$func_dirname_result"
+
+		if test "$pic_object" != none; then
+		  # Prepend the subdirectory the object is found in.
+		  pic_object="$xdir$pic_object"
+
+		  if test "$prev" = dlfiles; then
+		    if test "$build_libtool_libs" = yes && test "$dlopen_support" = yes; then
+		      dlfiles="$dlfiles $pic_object"
+		      prev=
+		      continue
+		    else
+		      # If libtool objects are unsupported, then we need to preload.
+		      prev=dlprefiles
+		    fi
+		  fi
+
+		  # CHECK ME:  I think I busted this.  -Ossama
+		  if test "$prev" = dlprefiles; then
+		    # Preload the old-style object.
+		    dlprefiles="$dlprefiles $pic_object"
+		    prev=
+		  fi
+
+		  # A PIC object.
+		  func_append libobjs " $pic_object"
+		  arg="$pic_object"
+		fi
+
+		# Non-PIC object.
+		if test "$non_pic_object" != none; then
+		  # Prepend the subdirectory the object is found in.
+		  non_pic_object="$xdir$non_pic_object"
+
+		  # A standard non-PIC object
+		  func_append non_pic_objects " $non_pic_object"
+		  if test -z "$pic_object" || test "$pic_object" = none ; then
+		    arg="$non_pic_object"
+		  fi
+		else
+		  # If the PIC object exists, use it instead.
+		  # $xdir was prepended to $pic_object above.
+		  non_pic_object="$pic_object"
+		  func_append non_pic_objects " $non_pic_object"
+		fi
+	      else
+		# Only an error if not doing a dry-run.
+		if $opt_dry_run; then
+		  # Extract subdirectory from the argument.
+		  func_dirname "$arg" "/" ""
+		  xdir="$func_dirname_result"
+
+		  func_lo2o "$arg"
+		  pic_object=$xdir$objdir/$func_lo2o_result
+		  non_pic_object=$xdir$func_lo2o_result
+		  func_append libobjs " $pic_object"
+		  func_append non_pic_objects " $non_pic_object"
+	        else
+		  func_fatal_error "\`$arg' is not a valid libtool object"
+		fi
+	      fi
+	    done
+	  else
+	    func_fatal_error "link input file \`$arg' does not exist"
+	  fi
+	  arg=$save_arg
+	  prev=
+	  continue
+	  ;;
+	precious_regex)
+	  precious_files_regex="$arg"
+	  prev=
+	  continue
+	  ;;
+	release)
+	  release="-$arg"
+	  prev=
+	  continue
+	  ;;
+	rpath | xrpath)
+	  # We need an absolute path.
+	  case $arg in
+	  [\\/]* | [A-Za-z]:[\\/]*) ;;
+	  *)
+	    func_fatal_error "only absolute run-paths are allowed"
+	    ;;
+	  esac
+	  if test "$prev" = rpath; then
+	    case "$rpath " in
+	    *" $arg "*) ;;
+	    *) rpath="$rpath $arg" ;;
+	    esac
+	  else
+	    case "$xrpath " in
+	    *" $arg "*) ;;
+	    *) xrpath="$xrpath $arg" ;;
+	    esac
+	  fi
+	  prev=
+	  continue
+	  ;;
+	shrext)
+	  shrext_cmds="$arg"
+	  prev=
+	  continue
+	  ;;
+	weak)
+	  weak_libs="$weak_libs $arg"
+	  prev=
+	  continue
+	  ;;
+	xcclinker)
+	  linker_flags="$linker_flags $qarg"
+	  compiler_flags="$compiler_flags $qarg"
+	  prev=
+	  func_append compile_command " $qarg"
+	  func_append finalize_command " $qarg"
+	  continue
+	  ;;
+	xcompiler)
+	  compiler_flags="$compiler_flags $qarg"
+	  prev=
+	  func_append compile_command " $qarg"
+	  func_append finalize_command " $qarg"
+	  continue
+	  ;;
+	xlinker)
+	  linker_flags="$linker_flags $qarg"
+	  compiler_flags="$compiler_flags $wl$qarg"
+	  prev=
+	  func_append compile_command " $wl$qarg"
+	  func_append finalize_command " $wl$qarg"
+	  continue
+	  ;;
+	*)
+	  eval "$prev=\"\$arg\""
+	  prev=
+	  continue
+	  ;;
+	esac
+      fi # test -n "$prev"
+
+      prevarg="$arg"
+
+      case $arg in
+      -all-static)
+	if test -n "$link_static_flag"; then
+	  # See comment for -static flag below, for more details.
+	  func_append compile_command " $link_static_flag"
+	  func_append finalize_command " $link_static_flag"
+	fi
+	continue
+	;;
+
+      -allow-undefined)
+	# FIXME: remove this flag sometime in the future.
+	func_fatal_error "\`-allow-undefined' must not be used because it is the default"
+	;;
+
+      -avoid-version)
+	avoid_version=yes
+	continue
+	;;
+
+      -dlopen)
+	prev=dlfiles
+	continue
+	;;
+
+      -dlpreopen)
+	prev=dlprefiles
+	continue
+	;;
+
+      -export-dynamic)
+	export_dynamic=yes
+	continue
+	;;
+
+      -export-symbols | -export-symbols-regex)
+	if test -n "$export_symbols" || test -n "$export_symbols_regex"; then
+	  func_fatal_error "more than one -exported-symbols argument is not allowed"
+	fi
+	if test "X$arg" = "X-export-symbols"; then
+	  prev=expsyms
+	else
+	  prev=expsyms_regex
+	fi
+	continue
+	;;
+
+      -framework)
+	prev=framework
+	continue
+	;;
+
+      -inst-prefix-dir)
+	prev=inst_prefix
+	continue
+	;;
+
+      # The native IRIX linker understands -LANG:*, -LIST:* and -LNO:*
+      # so, if we see these flags be careful not to treat them like -L
+      -L[A-Z][A-Z]*:*)
+	case $with_gcc/$host in
+	no/*-*-irix* | /*-*-irix*)
+	  func_append compile_command " $arg"
+	  func_append finalize_command " $arg"
+	  ;;
+	esac
+	continue
+	;;
+
+      -L*)
+	func_stripname '-L' '' "$arg"
+	dir=$func_stripname_result
+	if test -z "$dir"; then
+	  if test "$#" -gt 0; then
+	    func_fatal_error "require no space between \`-L' and \`$1'"
+	  else
+	    func_fatal_error "need path for \`-L' option"
+	  fi
+	fi
+	# We need an absolute path.
+	case $dir in
+	[\\/]* | [A-Za-z]:[\\/]*) ;;
+	*)
+	  absdir=`cd "$dir" && pwd`
+	  test -z "$absdir" && \
+	    func_fatal_error "cannot determine absolute directory name of \`$dir'"
+	  dir="$absdir"
+	  ;;
+	esac
+	case "$deplibs " in
+	*" -L$dir "*) ;;
+	*)
+	  deplibs="$deplibs -L$dir"
+	  lib_search_path="$lib_search_path $dir"
+	  ;;
+	esac
+	case $host in
+	*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)
+	  testbindir=`$ECHO "X$dir" | $Xsed -e 's*/lib$*/bin*'`
+	  case :$dllsearchpath: in
+	  *":$dir:"*) ;;
+	  ::) dllsearchpath=$dir;;
+	  *) dllsearchpath="$dllsearchpath:$dir";;
+	  esac
+	  case :$dllsearchpath: in
+	  *":$testbindir:"*) ;;
+	  ::) dllsearchpath=$testbindir;;
+	  *) dllsearchpath="$dllsearchpath:$testbindir";;
+	  esac
+	  ;;
+	esac
+	continue
+	;;
+
+      -l*)
+	if test "X$arg" = "X-lc" || test "X$arg" = "X-lm"; then
+	  case $host in
+	  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-beos* | *-cegcc*)
+	    # These systems don't actually have a C or math library (as such)
+	    continue
+	    ;;
+	  *-*-os2*)
+	    # These systems don't actually have a C library (as such)
+	    test "X$arg" = "X-lc" && continue
+	    ;;
+	  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)
+	    # Do not include libc due to us having libc/libc_r.
+	    test "X$arg" = "X-lc" && continue
+	    ;;
+	  *-*-rhapsody* | *-*-darwin1.[012])
+	    # Rhapsody C and math libraries are in the System framework
+	    deplibs="$deplibs System.ltframework"
+	    continue
+	    ;;
+	  *-*-sco3.2v5* | *-*-sco5v6*)
+	    # Causes problems with __ctype
+	    test "X$arg" = "X-lc" && continue
+	    ;;
+	  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)
+	    # Compiler inserts libc in the correct place for threads to work
+	    test "X$arg" = "X-lc" && continue
+	    ;;
+	  esac
+	elif test "X$arg" = "X-lc_r"; then
+	 case $host in
+	 *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)
+	   # Do not include libc_r directly, use -pthread flag.
+	   continue
+	   ;;
+	 esac
+	fi
+	deplibs="$deplibs $arg"
+	continue
+	;;
+
+      -module)
+	module=yes
+	continue
+	;;
+
+      # Tru64 UNIX uses -model [arg] to determine the layout of C++
+      # classes, name mangling, and exception handling.
+      # Darwin uses the -arch flag to determine output architecture.
+      -model|-arch|-isysroot)
+	compiler_flags="$compiler_flags $arg"
+	func_append compile_command " $arg"
+	func_append finalize_command " $arg"
+	prev=xcompiler
+	continue
+	;;
+
+      -mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe|-threads)
+	compiler_flags="$compiler_flags $arg"
+	func_append compile_command " $arg"
+	func_append finalize_command " $arg"
+	case "$new_inherited_linker_flags " in
+	    *" $arg "*) ;;
+	    * ) new_inherited_linker_flags="$new_inherited_linker_flags $arg" ;;
+	esac
+	continue
+	;;
+
+      -multi_module)
+	single_module="${wl}-multi_module"
+	continue
+	;;
+
+      -no-fast-install)
+	fast_install=no
+	continue
+	;;
+
+      -no-install)
+	case $host in
+	*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-darwin* | *-cegcc*)
+	  # The PATH hackery in wrapper scripts is required on Windows
+	  # and Darwin in order for the loader to find any dlls it needs.
+	  func_warning "\`-no-install' is ignored for $host"
+	  func_warning "assuming \`-no-fast-install' instead"
+	  fast_install=no
+	  ;;
+	*) no_install=yes ;;
+	esac
+	continue
+	;;
+
+      -no-undefined)
+	allow_undefined=no
+	continue
+	;;
+
+      -objectlist)
+	prev=objectlist
+	continue
+	;;
+
+      -o) prev=output ;;
+
+      -precious-files-regex)
+	prev=precious_regex
+	continue
+	;;
+
+      -release)
+	prev=release
+	continue
+	;;
+
+      -rpath)
+	prev=rpath
+	continue
+	;;
+
+      -R)
+	prev=xrpath
+	continue
+	;;
+
+      -R*)
+	func_stripname '-R' '' "$arg"
+	dir=$func_stripname_result
+	# We need an absolute path.
+	case $dir in
+	[\\/]* | [A-Za-z]:[\\/]*) ;;
+	*)
+	  func_fatal_error "only absolute run-paths are allowed"
+	  ;;
+	esac
+	case "$xrpath " in
+	*" $dir "*) ;;
+	*) xrpath="$xrpath $dir" ;;
+	esac
+	continue
+	;;
+
+      -shared)
+	# The effects of -shared are defined in a previous loop.
+	continue
+	;;
+
+      -shrext)
+	prev=shrext
+	continue
+	;;
+
+      -static | -static-libtool-libs)
+	# The effects of -static are defined in a previous loop.
+	# We used to do the same as -all-static on platforms that
+	# didn't have a PIC flag, but the assumption that the effects
+	# would be equivalent was wrong.  It would break on at least
+	# Digital Unix and AIX.
+	continue
+	;;
+
+      -thread-safe)
+	thread_safe=yes
+	continue
+	;;
+
+      -version-info)
+	prev=vinfo
+	continue
+	;;
+
+      -version-number)
+	prev=vinfo
+	vinfo_number=yes
+	continue
+	;;
+
+      -weak)
+        prev=weak
+	continue
+	;;
+
+      -Wc,*)
+	func_stripname '-Wc,' '' "$arg"
+	args=$func_stripname_result
+	arg=
+	save_ifs="$IFS"; IFS=','
+	for flag in $args; do
+	  IFS="$save_ifs"
+          func_quote_for_eval "$flag"
+	  arg="$arg $wl$func_quote_for_eval_result"
+	  compiler_flags="$compiler_flags $func_quote_for_eval_result"
+	done
+	IFS="$save_ifs"
+	func_stripname ' ' '' "$arg"
+	arg=$func_stripname_result
+	;;
+
+      -Wl,*)
+	func_stripname '-Wl,' '' "$arg"
+	args=$func_stripname_result
+	arg=
+	save_ifs="$IFS"; IFS=','
+	for flag in $args; do
+	  IFS="$save_ifs"
+          func_quote_for_eval "$flag"
+	  arg="$arg $wl$func_quote_for_eval_result"
+	  compiler_flags="$compiler_flags $wl$func_quote_for_eval_result"
+	  linker_flags="$linker_flags $func_quote_for_eval_result"
+	done
+	IFS="$save_ifs"
+	func_stripname ' ' '' "$arg"
+	arg=$func_stripname_result
+	;;
+
+      -Xcompiler)
+	prev=xcompiler
+	continue
+	;;
+
+      -Xlinker)
+	prev=xlinker
+	continue
+	;;
+
+      -XCClinker)
+	prev=xcclinker
+	continue
+	;;
+
+      # -msg_* for osf cc
+      -msg_*)
+	func_quote_for_eval "$arg"
+	arg="$func_quote_for_eval_result"
+	;;
+
+      # -64, -mips[0-9] enable 64-bit mode on the SGI compiler
+      # -r[0-9][0-9]* specifies the processor on the SGI compiler
+      # -xarch=*, -xtarget=* enable 64-bit mode on the Sun compiler
+      # +DA*, +DD* enable 64-bit mode on the HP compiler
+      # -q* pass through compiler args for the IBM compiler
+      # -m*, -t[45]*, -txscale* pass through architecture-specific
+      # compiler args for GCC
+      # -F/path gives path to uninstalled frameworks, gcc on darwin
+      # -p, -pg, --coverage, -fprofile-* pass through profiling flag for GCC
+      # @file GCC response files
+      -64|-mips[0-9]|-r[0-9][0-9]*|-xarch=*|-xtarget=*|+DA*|+DD*|-q*|-m*| \
+      -t[45]*|-txscale*|-p|-pg|--coverage|-fprofile-*|-F*|@*)
+        func_quote_for_eval "$arg"
+	arg="$func_quote_for_eval_result"
+        func_append compile_command " $arg"
+        func_append finalize_command " $arg"
+        compiler_flags="$compiler_flags $arg"
+        continue
+        ;;
+
+      # Some other compiler flag.
+      -* | +*)
+        func_quote_for_eval "$arg"
+	arg="$func_quote_for_eval_result"
+	;;
+
+      *.$objext)
+	# A standard object.
+	objs="$objs $arg"
+	;;
+
+      *.lo)
+	# A libtool-controlled object.
+
+	# Check to see that this really is a libtool object.
+	if func_lalib_unsafe_p "$arg"; then
+	  pic_object=
+	  non_pic_object=
+
+	  # Read the .lo file
+	  func_source "$arg"
+
+	  if test -z "$pic_object" ||
+	     test -z "$non_pic_object" ||
+	     test "$pic_object" = none &&
+	     test "$non_pic_object" = none; then
+	    func_fatal_error "cannot find name of object for \`$arg'"
+	  fi
+
+	  # Extract subdirectory from the argument.
+	  func_dirname "$arg" "/" ""
+	  xdir="$func_dirname_result"
+
+	  if test "$pic_object" != none; then
+	    # Prepend the subdirectory the object is found in.
+	    pic_object="$xdir$pic_object"
+
+	    if test "$prev" = dlfiles; then
+	      if test "$build_libtool_libs" = yes && test "$dlopen_support" = yes; then
+		dlfiles="$dlfiles $pic_object"
+		prev=
+		continue
+	      else
+		# If libtool objects are unsupported, then we need to preload.
+		prev=dlprefiles
+	      fi
+	    fi
+
+	    # CHECK ME:  I think I busted this.  -Ossama
+	    if test "$prev" = dlprefiles; then
+	      # Preload the old-style object.
+	      dlprefiles="$dlprefiles $pic_object"
+	      prev=
+	    fi
+
+	    # A PIC object.
+	    func_append libobjs " $pic_object"
+	    arg="$pic_object"
+	  fi
+
+	  # Non-PIC object.
+	  if test "$non_pic_object" != none; then
+	    # Prepend the subdirectory the object is found in.
+	    non_pic_object="$xdir$non_pic_object"
+
+	    # A standard non-PIC object
+	    func_append non_pic_objects " $non_pic_object"
+	    if test -z "$pic_object" || test "$pic_object" = none ; then
+	      arg="$non_pic_object"
+	    fi
+	  else
+	    # If the PIC object exists, use it instead.
+	    # $xdir was prepended to $pic_object above.
+	    non_pic_object="$pic_object"
+	    func_append non_pic_objects " $non_pic_object"
+	  fi
+	else
+	  # Only an error if not doing a dry-run.
+	  if $opt_dry_run; then
+	    # Extract subdirectory from the argument.
+	    func_dirname "$arg" "/" ""
+	    xdir="$func_dirname_result"
+
+	    func_lo2o "$arg"
+	    pic_object=$xdir$objdir/$func_lo2o_result
+	    non_pic_object=$xdir$func_lo2o_result
+	    func_append libobjs " $pic_object"
+	    func_append non_pic_objects " $non_pic_object"
+	  else
+	    func_fatal_error "\`$arg' is not a valid libtool object"
+	  fi
+	fi
+	;;
+
+      *.$libext)
+	# An archive.
+	deplibs="$deplibs $arg"
+	old_deplibs="$old_deplibs $arg"
+	continue
+	;;
+
+      *.la)
+	# A libtool-controlled library.
+
+	if test "$prev" = dlfiles; then
+	  # This library was specified with -dlopen.
+	  dlfiles="$dlfiles $arg"
+	  prev=
+	elif test "$prev" = dlprefiles; then
+	  # The library was specified with -dlpreopen.
+	  dlprefiles="$dlprefiles $arg"
+	  prev=
+	else
+	  deplibs="$deplibs $arg"
+	fi
+	continue
+	;;
+
+      # Some other compiler argument.
+      *)
+	# Unknown arguments in both finalize_command and compile_command need
+	# to be aesthetically quoted because they are evaled later.
+	func_quote_for_eval "$arg"
+	arg="$func_quote_for_eval_result"
+	;;
+      esac # arg
+
+      # Now actually substitute the argument into the commands.
+      if test -n "$arg"; then
+	func_append compile_command " $arg"
+	func_append finalize_command " $arg"
+      fi
+    done # argument parsing loop
+
+    test -n "$prev" && \
+      func_fatal_help "the \`$prevarg' option requires an argument"
+
+    if test "$export_dynamic" = yes && test -n "$export_dynamic_flag_spec"; then
+      eval arg=\"$export_dynamic_flag_spec\"
+      func_append compile_command " $arg"
+      func_append finalize_command " $arg"
+    fi
+
+    oldlibs=
+    # calculate the name of the file, without its directory
+    func_basename "$output"
+    outputname="$func_basename_result"
+    libobjs_save="$libobjs"
+
+    if test -n "$shlibpath_var"; then
+      # get the directories listed in $shlibpath_var
+      eval shlib_search_path=\`\$ECHO \"X\${$shlibpath_var}\" \| \$Xsed -e \'s/:/ /g\'\`
+    else
+      shlib_search_path=
+    fi
+    eval sys_lib_search_path=\"$sys_lib_search_path_spec\"
+    eval sys_lib_dlsearch_path=\"$sys_lib_dlsearch_path_spec\"
+
+    func_dirname "$output" "/" ""
+    output_objdir="$func_dirname_result$objdir"
+    # Create the object directory.
+    func_mkdir_p "$output_objdir"
+
+    # Determine the type of output
+    case $output in
+    "")
+      func_fatal_help "you must specify an output file"
+      ;;
+    *.$libext) linkmode=oldlib ;;
+    *.lo | *.$objext) linkmode=obj ;;
+    *.la) linkmode=lib ;;
+    *) linkmode=prog ;; # Anything else should be a program.
+    esac
+
+    specialdeplibs=
+
+    libs=
+    # Find all interdependent deplibs by searching for libraries
+    # that are linked more than once (e.g. -la -lb -la)
+    for deplib in $deplibs; do
+      if $opt_duplicate_deps ; then
+	case "$libs " in
+	*" $deplib "*) specialdeplibs="$specialdeplibs $deplib" ;;
+	esac
+      fi
+      libs="$libs $deplib"
+    done
+
+    if test "$linkmode" = lib; then
+      libs="$predeps $libs $compiler_lib_search_path $postdeps"
+
+      # Compute libraries that are listed more than once in $predeps
+      # $postdeps and mark them as special (i.e., whose duplicates are
+      # not to be eliminated).
+      pre_post_deps=
+      if $opt_duplicate_compiler_generated_deps; then
+	for pre_post_dep in $predeps $postdeps; do
+	  case "$pre_post_deps " in
+	  *" $pre_post_dep "*) specialdeplibs="$specialdeplibs $pre_post_deps" ;;
+	  esac
+	  pre_post_deps="$pre_post_deps $pre_post_dep"
+	done
+      fi
+      pre_post_deps=
+    fi
+
+    deplibs=
+    newdependency_libs=
+    newlib_search_path=
+    need_relink=no # whether we're linking any uninstalled libtool libraries
+    notinst_deplibs= # not-installed libtool libraries
+    notinst_path= # paths that contain not-installed libtool libraries
+
+    case $linkmode in
+    lib)
+	passes="conv dlpreopen link"
+	for file in $dlfiles $dlprefiles; do
+	  case $file in
+	  *.la) ;;
+	  *)
+	    func_fatal_help "libraries can \`-dlopen' only libtool libraries: $file"
+	    ;;
+	  esac
+	done
+	;;
+    prog)
+	compile_deplibs=
+	finalize_deplibs=
+	alldeplibs=no
+	newdlfiles=
+	newdlprefiles=
+	passes="conv scan dlopen dlpreopen link"
+	;;
+    *)  passes="conv"
+	;;
+    esac
+
+    for pass in $passes; do
+      # The preopen pass in lib mode reverses $deplibs; put it back here
+      # so that -L comes before libs that need it for instance...
+      if test "$linkmode,$pass" = "lib,link"; then
+	## FIXME: Find the place where the list is rebuilt in the wrong
+	##        order, and fix it there properly
+        tmp_deplibs=
+	for deplib in $deplibs; do
+	  tmp_deplibs="$deplib $tmp_deplibs"
+	done
+	deplibs="$tmp_deplibs"
+      fi
+
+      if test "$linkmode,$pass" = "lib,link" ||
+	 test "$linkmode,$pass" = "prog,scan"; then
+	libs="$deplibs"
+	deplibs=
+      fi
+      if test "$linkmode" = prog; then
+	case $pass in
+	dlopen) libs="$dlfiles" ;;
+	dlpreopen) libs="$dlprefiles" ;;
+	link)
+	  libs="$deplibs %DEPLIBS%"
+	  test "X$link_all_deplibs" != Xno && libs="$libs $dependency_libs"
+	  ;;
+	esac
+      fi
+      if test "$linkmode,$pass" = "lib,dlpreopen"; then
+	# Collect and forward deplibs of preopened libtool libs
+	for lib in $dlprefiles; do
+	  # Ignore non-libtool-libs
+	  dependency_libs=
+	  case $lib in
+	  *.la)	func_source "$lib" ;;
+	  esac
+
+	  # Collect preopened libtool deplibs, except any this library
+	  # has declared as weak libs
+	  for deplib in $dependency_libs; do
+            deplib_base=`$ECHO "X$deplib" | $Xsed -e "$basename"`
+	    case " $weak_libs " in
+	    *" $deplib_base "*) ;;
+	    *) deplibs="$deplibs $deplib" ;;
+	    esac
+	  done
+	done
+	libs="$dlprefiles"
+      fi
+      if test "$pass" = dlopen; then
+	# Collect dlpreopened libraries
+	save_deplibs="$deplibs"
+	deplibs=
+      fi
+
+      for deplib in $libs; do
+	lib=
+	found=no
+	case $deplib in
+	-mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe|-threads)
+	  if test "$linkmode,$pass" = "prog,link"; then
+	    compile_deplibs="$deplib $compile_deplibs"
+	    finalize_deplibs="$deplib $finalize_deplibs"
+	  else
+	    compiler_flags="$compiler_flags $deplib"
+	    if test "$linkmode" = lib ; then
+		case "$new_inherited_linker_flags " in
+		    *" $deplib "*) ;;
+		    * ) new_inherited_linker_flags="$new_inherited_linker_flags $deplib" ;;
+		esac
+	    fi
+	  fi
+	  continue
+	  ;;
+	-l*)
+	  if test "$linkmode" != lib && test "$linkmode" != prog; then
+	    func_warning "\`-l' is ignored for archives/objects"
+	    continue
+	  fi
+	  func_stripname '-l' '' "$deplib"
+	  name=$func_stripname_result
+	  if test "$linkmode" = lib; then
+	    searchdirs="$newlib_search_path $lib_search_path $compiler_lib_search_dirs $sys_lib_search_path $shlib_search_path"
+	  else
+	    searchdirs="$newlib_search_path $lib_search_path $sys_lib_search_path $shlib_search_path"
+	  fi
+	  for searchdir in $searchdirs; do
+	    for search_ext in .la $std_shrext .so .a; do
+	      # Search the libtool library
+	      lib="$searchdir/lib${name}${search_ext}"
+	      if test -f "$lib"; then
+		if test "$search_ext" = ".la"; then
+		  found=yes
+		else
+		  found=no
+		fi
+		break 2
+	      fi
+	    done
+	  done
+	  if test "$found" != yes; then
+	    # deplib doesn't seem to be a libtool library
+	    if test "$linkmode,$pass" = "prog,link"; then
+	      compile_deplibs="$deplib $compile_deplibs"
+	      finalize_deplibs="$deplib $finalize_deplibs"
+	    else
+	      deplibs="$deplib $deplibs"
+	      test "$linkmode" = lib && newdependency_libs="$deplib $newdependency_libs"
+	    fi
+	    continue
+	  else # deplib is a libtool library
+	    # If $allow_libtool_libs_with_static_runtimes && $deplib is a stdlib,
+	    # We need to do some special things here, and not later.
+	    if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+	      case " $predeps $postdeps " in
+	      *" $deplib "*)
+		if func_lalib_p "$lib"; then
+		  library_names=
+		  old_library=
+		  func_source "$lib"
+		  for l in $old_library $library_names; do
+		    ll="$l"
+		  done
+		  if test "X$ll" = "X$old_library" ; then # only static version available
+		    found=no
+		    func_dirname "$lib" "" "."
+		    ladir="$func_dirname_result"
+		    lib=$ladir/$old_library
+		    if test "$linkmode,$pass" = "prog,link"; then
+		      compile_deplibs="$deplib $compile_deplibs"
+		      finalize_deplibs="$deplib $finalize_deplibs"
+		    else
+		      deplibs="$deplib $deplibs"
+		      test "$linkmode" = lib && newdependency_libs="$deplib $newdependency_libs"
+		    fi
+		    continue
+		  fi
+		fi
+		;;
+	      *) ;;
+	      esac
+	    fi
+	  fi
+	  ;; # -l
+	*.ltframework)
+	  if test "$linkmode,$pass" = "prog,link"; then
+	    compile_deplibs="$deplib $compile_deplibs"
+	    finalize_deplibs="$deplib $finalize_deplibs"
+	  else
+	    deplibs="$deplib $deplibs"
+	    if test "$linkmode" = lib ; then
+		case "$new_inherited_linker_flags " in
+		    *" $deplib "*) ;;
+		    * ) new_inherited_linker_flags="$new_inherited_linker_flags $deplib" ;;
+		esac
+	    fi
+	  fi
+	  continue
+	  ;;
+	-L*)
+	  case $linkmode in
+	  lib)
+	    deplibs="$deplib $deplibs"
+	    test "$pass" = conv && continue
+	    newdependency_libs="$deplib $newdependency_libs"
+	    func_stripname '-L' '' "$deplib"
+	    newlib_search_path="$newlib_search_path $func_stripname_result"
+	    ;;
+	  prog)
+	    if test "$pass" = conv; then
+	      deplibs="$deplib $deplibs"
+	      continue
+	    fi
+	    if test "$pass" = scan; then
+	      deplibs="$deplib $deplibs"
+	    else
+	      compile_deplibs="$deplib $compile_deplibs"
+	      finalize_deplibs="$deplib $finalize_deplibs"
+	    fi
+	    func_stripname '-L' '' "$deplib"
+	    newlib_search_path="$newlib_search_path $func_stripname_result"
+	    ;;
+	  *)
+	    func_warning "\`-L' is ignored for archives/objects"
+	    ;;
+	  esac # linkmode
+	  continue
+	  ;; # -L
+	-R*)
+	  if test "$pass" = link; then
+	    func_stripname '-R' '' "$deplib"
+	    dir=$func_stripname_result
+	    # Make sure the xrpath contains only unique directories.
+	    case "$xrpath " in
+	    *" $dir "*) ;;
+	    *) xrpath="$xrpath $dir" ;;
+	    esac
+	  fi
+	  deplibs="$deplib $deplibs"
+	  continue
+	  ;;
+	*.la) lib="$deplib" ;;
+	*.$libext)
+	  if test "$pass" = conv; then
+	    deplibs="$deplib $deplibs"
+	    continue
+	  fi
+	  case $linkmode in
+	  lib)
+	    # Linking convenience modules into shared libraries is allowed,
+	    # but linking other static libraries is non-portable.
+	    case " $dlpreconveniencelibs " in
+	    *" $deplib "*) ;;
+	    *)
+	      valid_a_lib=no
+	      case $deplibs_check_method in
+		match_pattern*)
+		  set dummy $deplibs_check_method; shift
+		  match_pattern_regex=`expr "$deplibs_check_method" : "$1 \(.*\)"`
+		  if eval "\$ECHO \"X$deplib\"" 2>/dev/null | $Xsed -e 10q \
+		    | $EGREP "$match_pattern_regex" > /dev/null; then
+		    valid_a_lib=yes
+		  fi
+		;;
+		pass_all)
+		  valid_a_lib=yes
+		;;
+	      esac
+	      if test "$valid_a_lib" != yes; then
+		$ECHO
+		$ECHO "*** Warning: Trying to link with static lib archive $deplib."
+		$ECHO "*** I have the capability to make that library automatically link in when"
+		$ECHO "*** you link to this library.  But I can only do this if you have a"
+		$ECHO "*** shared version of the library, which you do not appear to have"
+		$ECHO "*** because the file extensions .$libext of this argument makes me believe"
+		$ECHO "*** that it is just a static archive that I should not use here."
+	      else
+		$ECHO
+		$ECHO "*** Warning: Linking the shared library $output against the"
+		$ECHO "*** static library $deplib is not portable!"
+		deplibs="$deplib $deplibs"
+	      fi
+	      ;;
+	    esac
+	    continue
+	    ;;
+	  prog)
+	    if test "$pass" != link; then
+	      deplibs="$deplib $deplibs"
+	    else
+	      compile_deplibs="$deplib $compile_deplibs"
+	      finalize_deplibs="$deplib $finalize_deplibs"
+	    fi
+	    continue
+	    ;;
+	  esac # linkmode
+	  ;; # *.$libext
+	*.lo | *.$objext)
+	  if test "$pass" = conv; then
+	    deplibs="$deplib $deplibs"
+	  elif test "$linkmode" = prog; then
+	    if test "$pass" = dlpreopen || test "$dlopen_support" != yes || test "$build_libtool_libs" = no; then
+	      # If there is no dlopen support or we're linking statically,
+	      # we need to preload.
+	      newdlprefiles="$newdlprefiles $deplib"
+	      compile_deplibs="$deplib $compile_deplibs"
+	      finalize_deplibs="$deplib $finalize_deplibs"
+	    else
+	      newdlfiles="$newdlfiles $deplib"
+	    fi
+	  fi
+	  continue
+	  ;;
+	%DEPLIBS%)
+	  alldeplibs=yes
+	  continue
+	  ;;
+	esac # case $deplib
+
+	if test "$found" = yes || test -f "$lib"; then :
+	else
+	  func_fatal_error "cannot find the library \`$lib' or unhandled argument \`$deplib'"
+	fi
+
+	# Check to see that this really is a libtool archive.
+	func_lalib_unsafe_p "$lib" \
+	  || func_fatal_error "\`$lib' is not a valid libtool archive"
+
+	func_dirname "$lib" "" "."
+	ladir="$func_dirname_result"
+
+	dlname=
+	dlopen=
+	dlpreopen=
+	libdir=
+	library_names=
+	old_library=
+	inherited_linker_flags=
+	# If the library was installed with an old release of libtool,
+	# it will not redefine variables installed, or shouldnotlink
+	installed=yes
+	shouldnotlink=no
+	avoidtemprpath=
+
+
+	# Read the .la file
+	func_source "$lib"
+
+	# Convert "-framework foo" to "foo.ltframework"
+	if test -n "$inherited_linker_flags"; then
+	  tmp_inherited_linker_flags=`$ECHO "X$inherited_linker_flags" | $Xsed -e 's/-framework \([^ $]*\)/\1.ltframework/g'`
+	  for tmp_inherited_linker_flag in $tmp_inherited_linker_flags; do
+	    case " $new_inherited_linker_flags " in
+	      *" $tmp_inherited_linker_flag "*) ;;
+	      *) new_inherited_linker_flags="$new_inherited_linker_flags $tmp_inherited_linker_flag";;
+	    esac
+	  done
+	fi
+	dependency_libs=`$ECHO "X $dependency_libs" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	if test "$linkmode,$pass" = "lib,link" ||
+	   test "$linkmode,$pass" = "prog,scan" ||
+	   { test "$linkmode" != prog && test "$linkmode" != lib; }; then
+	  test -n "$dlopen" && dlfiles="$dlfiles $dlopen"
+	  test -n "$dlpreopen" && dlprefiles="$dlprefiles $dlpreopen"
+	fi
+
+	if test "$pass" = conv; then
+	  # Only check for convenience libraries
+	  deplibs="$lib $deplibs"
+	  if test -z "$libdir"; then
+	    if test -z "$old_library"; then
+	      func_fatal_error "cannot find name of link library for \`$lib'"
+	    fi
+	    # It is a libtool convenience library, so add in its objects.
+	    convenience="$convenience $ladir/$objdir/$old_library"
+	    old_convenience="$old_convenience $ladir/$objdir/$old_library"
+	    tmp_libs=
+	    for deplib in $dependency_libs; do
+	      deplibs="$deplib $deplibs"
+	      if $opt_duplicate_deps ; then
+		case "$tmp_libs " in
+		*" $deplib "*) specialdeplibs="$specialdeplibs $deplib" ;;
+		esac
+	      fi
+	      tmp_libs="$tmp_libs $deplib"
+	    done
+	  elif test "$linkmode" != prog && test "$linkmode" != lib; then
+	    func_fatal_error "\`$lib' is not a convenience library"
+	  fi
+	  continue
+	fi # $pass = conv
+
+
+	# Get the name of the library we link against.
+	linklib=
+	for l in $old_library $library_names; do
+	  linklib="$l"
+	done
+	if test -z "$linklib"; then
+	  func_fatal_error "cannot find name of link library for \`$lib'"
+	fi
+
+	# This library was specified with -dlopen.
+	if test "$pass" = dlopen; then
+	  if test -z "$libdir"; then
+	    func_fatal_error "cannot -dlopen a convenience library: \`$lib'"
+	  fi
+	  if test -z "$dlname" ||
+	     test "$dlopen_support" != yes ||
+	     test "$build_libtool_libs" = no; then
+	    # If there is no dlname, no dlopen support or we're linking
+	    # statically, we need to preload.  We also need to preload any
+	    # dependent libraries so libltdl's deplib preloader doesn't
+	    # bomb out in the load deplibs phase.
+	    dlprefiles="$dlprefiles $lib $dependency_libs"
+	  else
+	    newdlfiles="$newdlfiles $lib"
+	  fi
+	  continue
+	fi # $pass = dlopen
+
+	# We need an absolute path.
+	case $ladir in
+	[\\/]* | [A-Za-z]:[\\/]*) abs_ladir="$ladir" ;;
+	*)
+	  abs_ladir=`cd "$ladir" && pwd`
+	  if test -z "$abs_ladir"; then
+	    func_warning "cannot determine absolute directory name of \`$ladir'"
+	    func_warning "passing it literally to the linker, although it might fail"
+	    abs_ladir="$ladir"
+	  fi
+	  ;;
+	esac
+	func_basename "$lib"
+	laname="$func_basename_result"
+
+	# Find the relevant object directory and library name.
+	if test "X$installed" = Xyes; then
+	  if test ! -f "$libdir/$linklib" && test -f "$abs_ladir/$linklib"; then
+	    func_warning "library \`$lib' was moved."
+	    dir="$ladir"
+	    absdir="$abs_ladir"
+	    libdir="$abs_ladir"
+	  else
+	    dir="$libdir"
+	    absdir="$libdir"
+	  fi
+	  test "X$hardcode_automatic" = Xyes && avoidtemprpath=yes
+	else
+	  if test ! -f "$ladir/$objdir/$linklib" && test -f "$abs_ladir/$linklib"; then
+	    dir="$ladir"
+	    absdir="$abs_ladir"
+	    # Remove this search path later
+	    notinst_path="$notinst_path $abs_ladir"
+	  else
+	    dir="$ladir/$objdir"
+	    absdir="$abs_ladir/$objdir"
+	    # Remove this search path later
+	    notinst_path="$notinst_path $abs_ladir"
+	  fi
+	fi # $installed = yes
+	func_stripname 'lib' '.la' "$laname"
+	name=$func_stripname_result
+
+	# This library was specified with -dlpreopen.
+	if test "$pass" = dlpreopen; then
+	  if test -z "$libdir" && test "$linkmode" = prog; then
+	    func_fatal_error "only libraries may -dlpreopen a convenience library: \`$lib'"
+	  fi
+	  # Prefer using a static library (so that no silly _DYNAMIC symbols
+	  # are required to link).
+	  if test -n "$old_library"; then
+	    newdlprefiles="$newdlprefiles $dir/$old_library"
+	    # Keep a list of preopened convenience libraries to check
+	    # that they are being used correctly in the link pass.
+	    test -z "$libdir" && \
+		dlpreconveniencelibs="$dlpreconveniencelibs $dir/$old_library"
+	  # Otherwise, use the dlname, so that lt_dlopen finds it.
+	  elif test -n "$dlname"; then
+	    newdlprefiles="$newdlprefiles $dir/$dlname"
+	  else
+	    newdlprefiles="$newdlprefiles $dir/$linklib"
+	  fi
+	fi # $pass = dlpreopen
+
+	if test -z "$libdir"; then
+	  # Link the convenience library
+	  if test "$linkmode" = lib; then
+	    deplibs="$dir/$old_library $deplibs"
+	  elif test "$linkmode,$pass" = "prog,link"; then
+	    compile_deplibs="$dir/$old_library $compile_deplibs"
+	    finalize_deplibs="$dir/$old_library $finalize_deplibs"
+	  else
+	    deplibs="$lib $deplibs" # used for prog,scan pass
+	  fi
+	  continue
+	fi
+
+
+	if test "$linkmode" = prog && test "$pass" != link; then
+	  newlib_search_path="$newlib_search_path $ladir"
+	  deplibs="$lib $deplibs"
+
+	  linkalldeplibs=no
+	  if test "$link_all_deplibs" != no || test -z "$library_names" ||
+	     test "$build_libtool_libs" = no; then
+	    linkalldeplibs=yes
+	  fi
+
+	  tmp_libs=
+	  for deplib in $dependency_libs; do
+	    case $deplib in
+	    -L*) func_stripname '-L' '' "$deplib"
+	         newlib_search_path="$newlib_search_path $func_stripname_result"
+		 ;;
+	    esac
+	    # Need to link against all dependency_libs?
+	    if test "$linkalldeplibs" = yes; then
+	      deplibs="$deplib $deplibs"
+	    else
+	      # Need to hardcode shared library paths
+	      # or/and link against static libraries
+	      newdependency_libs="$deplib $newdependency_libs"
+	    fi
+	    if $opt_duplicate_deps ; then
+	      case "$tmp_libs " in
+	      *" $deplib "*) specialdeplibs="$specialdeplibs $deplib" ;;
+	      esac
+	    fi
+	    tmp_libs="$tmp_libs $deplib"
+	  done # for deplib
+	  continue
+	fi # $linkmode = prog...
+
+	if test "$linkmode,$pass" = "prog,link"; then
+	  if test -n "$library_names" &&
+	     { { test "$prefer_static_libs" = no ||
+	         test "$prefer_static_libs,$installed" = "built,yes"; } ||
+	       test -z "$old_library"; }; then
+	    # We need to hardcode the library path
+	    if test -n "$shlibpath_var" && test -z "$avoidtemprpath" ; then
+	      # Make sure the rpath contains only unique directories.
+	      case "$temp_rpath:" in
+	      *"$absdir:"*) ;;
+	      *) temp_rpath="$temp_rpath$absdir:" ;;
+	      esac
+	    fi
+
+	    # Hardcode the library path.
+	    # Skip directories that are in the system default run-time
+	    # search path.
+	    case " $sys_lib_dlsearch_path " in
+	    *" $absdir "*) ;;
+	    *)
+	      case "$compile_rpath " in
+	      *" $absdir "*) ;;
+	      *) compile_rpath="$compile_rpath $absdir"
+	      esac
+	      ;;
+	    esac
+	    case " $sys_lib_dlsearch_path " in
+	    *" $libdir "*) ;;
+	    *)
+	      case "$finalize_rpath " in
+	      *" $libdir "*) ;;
+	      *) finalize_rpath="$finalize_rpath $libdir"
+	      esac
+	      ;;
+	    esac
+	  fi # $linkmode,$pass = prog,link...
+
+	  if test "$alldeplibs" = yes &&
+	     { test "$deplibs_check_method" = pass_all ||
+	       { test "$build_libtool_libs" = yes &&
+		 test -n "$library_names"; }; }; then
+	    # We only need to search for static libraries
+	    continue
+	  fi
+	fi
+
+	link_static=no # Whether the deplib will be linked statically
+	use_static_libs=$prefer_static_libs
+	if test "$use_static_libs" = built && test "$installed" = yes; then
+	  use_static_libs=no
+	fi
+	if test -n "$library_names" &&
+	   { test "$use_static_libs" = no || test -z "$old_library"; }; then
+	  case $host in
+	  *cygwin* | *mingw* | *cegcc*)
+	      # No point in relinking DLLs because paths are not encoded
+	      notinst_deplibs="$notinst_deplibs $lib"
+	      need_relink=no
+	    ;;
+	  *)
+	    if test "$installed" = no; then
+	      notinst_deplibs="$notinst_deplibs $lib"
+	      need_relink=yes
+	    fi
+	    ;;
+	  esac
+	  # This is a shared library
+
+	  # Warn about portability, can't link against -module's on some
+	  # systems (darwin).  Don't bleat about dlopened modules though!
+	  dlopenmodule=""
+	  for dlpremoduletest in $dlprefiles; do
+	    if test "X$dlpremoduletest" = "X$lib"; then
+	      dlopenmodule="$dlpremoduletest"
+	      break
+	    fi
+	  done
+	  if test -z "$dlopenmodule" && test "$shouldnotlink" = yes && test "$pass" = link; then
+	    $ECHO
+	    if test "$linkmode" = prog; then
+	      $ECHO "*** Warning: Linking the executable $output against the loadable module"
+	    else
+	      $ECHO "*** Warning: Linking the shared library $output against the loadable module"
+	    fi
+	    $ECHO "*** $linklib is not portable!"
+	  fi
+	  if test "$linkmode" = lib &&
+	     test "$hardcode_into_libs" = yes; then
+	    # Hardcode the library path.
+	    # Skip directories that are in the system default run-time
+	    # search path.
+	    case " $sys_lib_dlsearch_path " in
+	    *" $absdir "*) ;;
+	    *)
+	      case "$compile_rpath " in
+	      *" $absdir "*) ;;
+	      *) compile_rpath="$compile_rpath $absdir"
+	      esac
+	      ;;
+	    esac
+	    case " $sys_lib_dlsearch_path " in
+	    *" $libdir "*) ;;
+	    *)
+	      case "$finalize_rpath " in
+	      *" $libdir "*) ;;
+	      *) finalize_rpath="$finalize_rpath $libdir"
+	      esac
+	      ;;
+	    esac
+	  fi
+
+	  if test -n "$old_archive_from_expsyms_cmds"; then
+	    # figure out the soname
+	    set dummy $library_names
+	    shift
+	    realname="$1"
+	    shift
+	    libname=`eval "\\$ECHO \"$libname_spec\""`
+	    # use dlname if we got it. it's perfectly good, no?
+	    if test -n "$dlname"; then
+	      soname="$dlname"
+	    elif test -n "$soname_spec"; then
+	      # bleh windows
+	      case $host in
+	      *cygwin* | mingw* | *cegcc*)
+	        func_arith $current - $age
+		major=$func_arith_result
+		versuffix="-$major"
+		;;
+	      esac
+	      eval soname=\"$soname_spec\"
+	    else
+	      soname="$realname"
+	    fi
+
+	    # Make a new name for the extract_expsyms_cmds to use
+	    soroot="$soname"
+	    func_basename "$soroot"
+	    soname="$func_basename_result"
+	    func_stripname 'lib' '.dll' "$soname"
+	    newlib=libimp-$func_stripname_result.a
+
+	    # If the library has no export list, then create one now
+	    if test -f "$output_objdir/$soname-def"; then :
+	    else
+	      func_verbose "extracting exported symbol list from \`$soname'"
+	      func_execute_cmds "$extract_expsyms_cmds" 'exit $?'
+	    fi
+
+	    # Create $newlib
+	    if test -f "$output_objdir/$newlib"; then :; else
+	      func_verbose "generating import library for \`$soname'"
+	      func_execute_cmds "$old_archive_from_expsyms_cmds" 'exit $?'
+	    fi
+	    # make sure the library variables are pointing to the new library
+	    dir=$output_objdir
+	    linklib=$newlib
+	  fi # test -n "$old_archive_from_expsyms_cmds"
+
+	  if test "$linkmode" = prog || test "$mode" != relink; then
+	    add_shlibpath=
+	    add_dir=
+	    add=
+	    lib_linked=yes
+	    case $hardcode_action in
+	    immediate | unsupported)
+	      if test "$hardcode_direct" = no; then
+		add="$dir/$linklib"
+		case $host in
+		  *-*-sco3.2v5.0.[024]*) add_dir="-L$dir" ;;
+		  *-*-sysv4*uw2*) add_dir="-L$dir" ;;
+		  *-*-sysv5OpenUNIX* | *-*-sysv5UnixWare7.[01].[10]* | \
+		    *-*-unixware7*) add_dir="-L$dir" ;;
+		  *-*-darwin* )
+		    # if the lib is a (non-dlopened) module then we can not
+		    # link against it, someone is ignoring the earlier warnings
+		    if /usr/bin/file -L $add 2> /dev/null |
+			 $GREP ": [^:]* bundle" >/dev/null ; then
+		      if test "X$dlopenmodule" != "X$lib"; then
+			$ECHO "*** Warning: lib $linklib is a module, not a shared library"
+			if test -z "$old_library" ; then
+			  $ECHO
+			  $ECHO "*** And there doesn't seem to be a static archive available"
+			  $ECHO "*** The link will probably fail, sorry"
+			else
+			  add="$dir/$old_library"
+			fi
+		      elif test -n "$old_library"; then
+			add="$dir/$old_library"
+		      fi
+		    fi
+		esac
+	      elif test "$hardcode_minus_L" = no; then
+		case $host in
+		*-*-sunos*) add_shlibpath="$dir" ;;
+		esac
+		add_dir="-L$dir"
+		add="-l$name"
+	      elif test "$hardcode_shlibpath_var" = no; then
+		add_shlibpath="$dir"
+		add="-l$name"
+	      else
+		lib_linked=no
+	      fi
+	      ;;
+	    relink)
+	      if test "$hardcode_direct" = yes &&
+	         test "$hardcode_direct_absolute" = no; then
+		add="$dir/$linklib"
+	      elif test "$hardcode_minus_L" = yes; then
+		add_dir="-L$dir"
+		# Try looking first in the location we're being installed to.
+		if test -n "$inst_prefix_dir"; then
+		  case $libdir in
+		    [\\/]*)
+		      add_dir="$add_dir -L$inst_prefix_dir$libdir"
+		      ;;
+		  esac
+		fi
+		add="-l$name"
+	      elif test "$hardcode_shlibpath_var" = yes; then
+		add_shlibpath="$dir"
+		add="-l$name"
+	      else
+		lib_linked=no
+	      fi
+	      ;;
+	    *) lib_linked=no ;;
+	    esac
+
+	    if test "$lib_linked" != yes; then
+	      func_fatal_configuration "unsupported hardcode properties"
+	    fi
+
+	    if test -n "$add_shlibpath"; then
+	      case :$compile_shlibpath: in
+	      *":$add_shlibpath:"*) ;;
+	      *) compile_shlibpath="$compile_shlibpath$add_shlibpath:" ;;
+	      esac
+	    fi
+	    if test "$linkmode" = prog; then
+	      test -n "$add_dir" && compile_deplibs="$add_dir $compile_deplibs"
+	      test -n "$add" && compile_deplibs="$add $compile_deplibs"
+	    else
+	      test -n "$add_dir" && deplibs="$add_dir $deplibs"
+	      test -n "$add" && deplibs="$add $deplibs"
+	      if test "$hardcode_direct" != yes &&
+		 test "$hardcode_minus_L" != yes &&
+		 test "$hardcode_shlibpath_var" = yes; then
+		case :$finalize_shlibpath: in
+		*":$libdir:"*) ;;
+		*) finalize_shlibpath="$finalize_shlibpath$libdir:" ;;
+		esac
+	      fi
+	    fi
+	  fi
+
+	  if test "$linkmode" = prog || test "$mode" = relink; then
+	    add_shlibpath=
+	    add_dir=
+	    add=
+	    # Finalize command for both is simple: just hardcode it.
+	    if test "$hardcode_direct" = yes &&
+	       test "$hardcode_direct_absolute" = no; then
+	      add="$libdir/$linklib"
+	    elif test "$hardcode_minus_L" = yes; then
+	      add_dir="-L$libdir"
+	      add="-l$name"
+	    elif test "$hardcode_shlibpath_var" = yes; then
+	      case :$finalize_shlibpath: in
+	      *":$libdir:"*) ;;
+	      *) finalize_shlibpath="$finalize_shlibpath$libdir:" ;;
+	      esac
+	      add="-l$name"
+	    elif test "$hardcode_automatic" = yes; then
+	      if test -n "$inst_prefix_dir" &&
+		 test -f "$inst_prefix_dir$libdir/$linklib" ; then
+		add="$inst_prefix_dir$libdir/$linklib"
+	      else
+		add="$libdir/$linklib"
+	      fi
+	    else
+	      # We cannot seem to hardcode it, guess we'll fake it.
+	      add_dir="-L$libdir"
+	      # Try looking first in the location we're being installed to.
+	      if test -n "$inst_prefix_dir"; then
+		case $libdir in
+		  [\\/]*)
+		    add_dir="$add_dir -L$inst_prefix_dir$libdir"
+		    ;;
+		esac
+	      fi
+	      add="-l$name"
+	    fi
+
+	    if test "$linkmode" = prog; then
+	      test -n "$add_dir" && finalize_deplibs="$add_dir $finalize_deplibs"
+	      test -n "$add" && finalize_deplibs="$add $finalize_deplibs"
+	    else
+	      test -n "$add_dir" && deplibs="$add_dir $deplibs"
+	      test -n "$add" && deplibs="$add $deplibs"
+	    fi
+	  fi
+	elif test "$linkmode" = prog; then
+	  # Here we assume that one of hardcode_direct or hardcode_minus_L
+	  # is not unsupported.  This is valid on all known static and
+	  # shared platforms.
+	  if test "$hardcode_direct" != unsupported; then
+	    test -n "$old_library" && linklib="$old_library"
+	    compile_deplibs="$dir/$linklib $compile_deplibs"
+	    finalize_deplibs="$dir/$linklib $finalize_deplibs"
+	  else
+	    compile_deplibs="-l$name -L$dir $compile_deplibs"
+	    finalize_deplibs="-l$name -L$dir $finalize_deplibs"
+	  fi
+	elif test "$build_libtool_libs" = yes; then
+	  # Not a shared library
+	  if test "$deplibs_check_method" != pass_all; then
+	    # We're trying link a shared library against a static one
+	    # but the system doesn't support it.
+
+	    # Just print a warning and add the library to dependency_libs so
+	    # that the program can be linked against the static library.
+	    $ECHO
+	    $ECHO "*** Warning: This system can not link to static lib archive $lib."
+	    $ECHO "*** I have the capability to make that library automatically link in when"
+	    $ECHO "*** you link to this library.  But I can only do this if you have a"
+	    $ECHO "*** shared version of the library, which you do not appear to have."
+	    if test "$module" = yes; then
+	      $ECHO "*** But as you try to build a module library, libtool will still create "
+	      $ECHO "*** a static module, that should work as long as the dlopening application"
+	      $ECHO "*** is linked with the -dlopen flag to resolve symbols at runtime."
+	      if test -z "$global_symbol_pipe"; then
+		$ECHO
+		$ECHO "*** However, this would only work if libtool was able to extract symbol"
+		$ECHO "*** lists from a program, using \`nm' or equivalent, but libtool could"
+		$ECHO "*** not find such a program.  So, this module is probably useless."
+		$ECHO "*** \`nm' from GNU binutils and a full rebuild may help."
+	      fi
+	      if test "$build_old_libs" = no; then
+		build_libtool_libs=module
+		build_old_libs=yes
+	      else
+		build_libtool_libs=no
+	      fi
+	    fi
+	  else
+	    deplibs="$dir/$old_library $deplibs"
+	    link_static=yes
+	  fi
+	fi # link shared/static library?
+
+	if test "$linkmode" = lib; then
+	  if test -n "$dependency_libs" &&
+	     { test "$hardcode_into_libs" != yes ||
+	       test "$build_old_libs" = yes ||
+	       test "$link_static" = yes; }; then
+	    # Extract -R from dependency_libs
+	    temp_deplibs=
+	    for libdir in $dependency_libs; do
+	      case $libdir in
+	      -R*) func_stripname '-R' '' "$libdir"
+	           temp_xrpath=$func_stripname_result
+		   case " $xrpath " in
+		   *" $temp_xrpath "*) ;;
+		   *) xrpath="$xrpath $temp_xrpath";;
+		   esac;;
+	      *) temp_deplibs="$temp_deplibs $libdir";;
+	      esac
+	    done
+	    dependency_libs="$temp_deplibs"
+	  fi
+
+	  newlib_search_path="$newlib_search_path $absdir"
+	  # Link against this library
+	  test "$link_static" = no && newdependency_libs="$abs_ladir/$laname $newdependency_libs"
+	  # ... and its dependency_libs
+	  tmp_libs=
+	  for deplib in $dependency_libs; do
+	    newdependency_libs="$deplib $newdependency_libs"
+	    if $opt_duplicate_deps ; then
+	      case "$tmp_libs " in
+	      *" $deplib "*) specialdeplibs="$specialdeplibs $deplib" ;;
+	      esac
+	    fi
+	    tmp_libs="$tmp_libs $deplib"
+	  done
+
+	  if test "$link_all_deplibs" != no; then
+	    # Add the search paths of all dependency libraries
+	    for deplib in $dependency_libs; do
+	      path=
+	      case $deplib in
+	      -L*) path="$deplib" ;;
+	      *.la)
+	        func_dirname "$deplib" "" "."
+		dir="$func_dirname_result"
+		# We need an absolute path.
+		case $dir in
+		[\\/]* | [A-Za-z]:[\\/]*) absdir="$dir" ;;
+		*)
+		  absdir=`cd "$dir" && pwd`
+		  if test -z "$absdir"; then
+		    func_warning "cannot determine absolute directory name of \`$dir'"
+		    absdir="$dir"
+		  fi
+		  ;;
+		esac
+		if $GREP "^installed=no" $deplib > /dev/null; then
+		case $host in
+		*-*-darwin*)
+		  depdepl=
+		  eval deplibrary_names=`${SED} -n -e 's/^library_names=\(.*\)$/\1/p' $deplib`
+		  if test -n "$deplibrary_names" ; then
+		    for tmp in $deplibrary_names ; do
+		      depdepl=$tmp
+		    done
+		    if test -f "$absdir/$objdir/$depdepl" ; then
+		      depdepl="$absdir/$objdir/$depdepl"
+		      darwin_install_name=`${OTOOL} -L $depdepl | awk '{if (NR == 2) {print $1;exit}}'`
+                      if test -z "$darwin_install_name"; then
+                          darwin_install_name=`${OTOOL64} -L $depdepl  | awk '{if (NR == 2) {print $1;exit}}'`
+                      fi
+		      compiler_flags="$compiler_flags ${wl}-dylib_file ${wl}${darwin_install_name}:${depdepl}"
+		      linker_flags="$linker_flags -dylib_file ${darwin_install_name}:${depdepl}"
+		      path=
+		    fi
+		  fi
+		  ;;
+		*)
+		  path="-L$absdir/$objdir"
+		  ;;
+		esac
+		else
+		  eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $deplib`
+		  test -z "$libdir" && \
+		    func_fatal_error "\`$deplib' is not a valid libtool archive"
+		  test "$absdir" != "$libdir" && \
+		    func_warning "\`$deplib' seems to be moved"
+
+		  path="-L$absdir"
+		fi
+		;;
+	      esac
+	      case " $deplibs " in
+	      *" $path "*) ;;
+	      *) deplibs="$path $deplibs" ;;
+	      esac
+	    done
+	  fi # link_all_deplibs != no
+	fi # linkmode = lib
+      done # for deplib in $libs
+      if test "$pass" = link; then
+	if test "$linkmode" = "prog"; then
+	  compile_deplibs="$new_inherited_linker_flags $compile_deplibs"
+	  finalize_deplibs="$new_inherited_linker_flags $finalize_deplibs"
+	else
+	  compiler_flags="$compiler_flags "`$ECHO "X $new_inherited_linker_flags" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	fi
+      fi
+      dependency_libs="$newdependency_libs"
+      if test "$pass" = dlpreopen; then
+	# Link the dlpreopened libraries before other libraries
+	for deplib in $save_deplibs; do
+	  deplibs="$deplib $deplibs"
+	done
+      fi
+      if test "$pass" != dlopen; then
+	if test "$pass" != conv; then
+	  # Make sure lib_search_path contains only unique directories.
+	  lib_search_path=
+	  for dir in $newlib_search_path; do
+	    case "$lib_search_path " in
+	    *" $dir "*) ;;
+	    *) lib_search_path="$lib_search_path $dir" ;;
+	    esac
+	  done
+	  newlib_search_path=
+	fi
+
+	if test "$linkmode,$pass" != "prog,link"; then
+	  vars="deplibs"
+	else
+	  vars="compile_deplibs finalize_deplibs"
+	fi
+	for var in $vars dependency_libs; do
+	  # Add libraries to $var in reverse order
+	  eval tmp_libs=\"\$$var\"
+	  new_libs=
+	  for deplib in $tmp_libs; do
+	    # FIXME: Pedantically, this is the right thing to do, so
+	    #        that some nasty dependency loop isn't accidentally
+	    #        broken:
+	    #new_libs="$deplib $new_libs"
+	    # Pragmatically, this seems to cause very few problems in
+	    # practice:
+	    case $deplib in
+	    -L*) new_libs="$deplib $new_libs" ;;
+	    -R*) ;;
+	    *)
+	      # And here is the reason: when a library appears more
+	      # than once as an explicit dependence of a library, or
+	      # is implicitly linked in more than once by the
+	      # compiler, it is considered special, and multiple
+	      # occurrences thereof are not removed.  Compare this
+	      # with having the same library being listed as a
+	      # dependency of multiple other libraries: in this case,
+	      # we know (pedantically, we assume) the library does not
+	      # need to be listed more than once, so we keep only the
+	      # last copy.  This is not always right, but it is rare
+	      # enough that we require users that really mean to play
+	      # such unportable linking tricks to link the library
+	      # using -Wl,-lname, so that libtool does not consider it
+	      # for duplicate removal.
+	      case " $specialdeplibs " in
+	      *" $deplib "*) new_libs="$deplib $new_libs" ;;
+	      *)
+		case " $new_libs " in
+		*" $deplib "*) ;;
+		*) new_libs="$deplib $new_libs" ;;
+		esac
+		;;
+	      esac
+	      ;;
+	    esac
+	  done
+	  tmp_libs=
+	  for deplib in $new_libs; do
+	    case $deplib in
+	    -L*)
+	      case " $tmp_libs " in
+	      *" $deplib "*) ;;
+	      *) tmp_libs="$tmp_libs $deplib" ;;
+	      esac
+	      ;;
+	    *) tmp_libs="$tmp_libs $deplib" ;;
+	    esac
+	  done
+	  eval $var=\"$tmp_libs\"
+	done # for var
+      fi
+      # Last step: remove runtime libs from dependency_libs
+      # (they stay in deplibs)
+      tmp_libs=
+      for i in $dependency_libs ; do
+	case " $predeps $postdeps $compiler_lib_search_path " in
+	*" $i "*)
+	  i=""
+	  ;;
+	esac
+	if test -n "$i" ; then
+	  tmp_libs="$tmp_libs $i"
+	fi
+      done
+      dependency_libs=$tmp_libs
+    done # for pass
+    if test "$linkmode" = prog; then
+      dlfiles="$newdlfiles"
+    fi
+    if test "$linkmode" = prog || test "$linkmode" = lib; then
+      dlprefiles="$newdlprefiles"
+    fi
+
+    case $linkmode in
+    oldlib)
+      if test -n "$dlfiles$dlprefiles" || test "$dlself" != no; then
+	func_warning "\`-dlopen' is ignored for archives"
+      fi
+
+      case " $deplibs" in
+      *\ -l* | *\ -L*)
+	func_warning "\`-l' and \`-L' are ignored for archives" ;;
+      esac
+
+      test -n "$rpath" && \
+	func_warning "\`-rpath' is ignored for archives"
+
+      test -n "$xrpath" && \
+	func_warning "\`-R' is ignored for archives"
+
+      test -n "$vinfo" && \
+	func_warning "\`-version-info/-version-number' is ignored for archives"
+
+      test -n "$release" && \
+	func_warning "\`-release' is ignored for archives"
+
+      test -n "$export_symbols$export_symbols_regex" && \
+	func_warning "\`-export-symbols' is ignored for archives"
+
+      # Now set the variables for building old libraries.
+      build_libtool_libs=no
+      oldlibs="$output"
+      objs="$objs$old_deplibs"
+      ;;
+
+    lib)
+      # Make sure we only generate libraries of the form `libNAME.la'.
+      case $outputname in
+      lib*)
+	func_stripname 'lib' '.la' "$outputname"
+	name=$func_stripname_result
+	eval shared_ext=\"$shrext_cmds\"
+	eval libname=\"$libname_spec\"
+	;;
+      *)
+	test "$module" = no && \
+	  func_fatal_help "libtool library \`$output' must begin with \`lib'"
+
+	if test "$need_lib_prefix" != no; then
+	  # Add the "lib" prefix for modules if required
+	  func_stripname '' '.la' "$outputname"
+	  name=$func_stripname_result
+	  eval shared_ext=\"$shrext_cmds\"
+	  eval libname=\"$libname_spec\"
+	else
+	  func_stripname '' '.la' "$outputname"
+	  libname=$func_stripname_result
+	fi
+	;;
+      esac
+
+      if test -n "$objs"; then
+	if test "$deplibs_check_method" != pass_all; then
+	  func_fatal_error "cannot build libtool library \`$output' from non-libtool objects on this host:$objs"
+	else
+	  $ECHO
+	  $ECHO "*** Warning: Linking the shared library $output against the non-libtool"
+	  $ECHO "*** objects $objs is not portable!"
+	  libobjs="$libobjs $objs"
+	fi
+      fi
+
+      test "$dlself" != no && \
+	func_warning "\`-dlopen self' is ignored for libtool libraries"
+
+      set dummy $rpath
+      shift
+      test "$#" -gt 1 && \
+	func_warning "ignoring multiple \`-rpath's for a libtool library"
+
+      install_libdir="$1"
+
+      oldlibs=
+      if test -z "$rpath"; then
+	if test "$build_libtool_libs" = yes; then
+	  # Building a libtool convenience library.
+	  # Some compilers have problems with a `.al' extension so
+	  # convenience libraries should have the same extension an
+	  # archive normally would.
+	  oldlibs="$output_objdir/$libname.$libext $oldlibs"
+	  build_libtool_libs=convenience
+	  build_old_libs=yes
+	fi
+
+	test -n "$vinfo" && \
+	  func_warning "\`-version-info/-version-number' is ignored for convenience libraries"
+
+	test -n "$release" && \
+	  func_warning "\`-release' is ignored for convenience libraries"
+      else
+
+	# Parse the version information argument.
+	save_ifs="$IFS"; IFS=':'
+	set dummy $vinfo 0 0 0
+	shift
+	IFS="$save_ifs"
+
+	test -n "$7" && \
+	  func_fatal_help "too many parameters to \`-version-info'"
+
+	# convert absolute version numbers to libtool ages
+	# this retains compatibility with .la files and attempts
+	# to make the code below a bit more comprehensible
+
+	case $vinfo_number in
+	yes)
+	  number_major="$1"
+	  number_minor="$2"
+	  number_revision="$3"
+	  #
+	  # There are really only two kinds -- those that
+	  # use the current revision as the major version
+	  # and those that subtract age and use age as
+	  # a minor version.  But, then there is irix
+	  # which has an extra 1 added just for fun
+	  #
+	  case $version_type in
+	  darwin|linux|osf|windows|none)
+	    func_arith $number_major + $number_minor
+	    current=$func_arith_result
+	    age="$number_minor"
+	    revision="$number_revision"
+	    ;;
+	  freebsd-aout|freebsd-elf|sunos)
+	    current="$number_major"
+	    revision="$number_minor"
+	    age="0"
+	    ;;
+	  irix|nonstopux)
+	    func_arith $number_major + $number_minor
+	    current=$func_arith_result
+	    age="$number_minor"
+	    revision="$number_minor"
+	    lt_irix_increment=no
+	    ;;
+	  *)
+	    func_fatal_configuration "$modename: unknown library version type \`$version_type'"
+	    ;;
+	  esac
+	  ;;
+	no)
+	  current="$1"
+	  revision="$2"
+	  age="$3"
+	  ;;
+	esac
+
+	# Check that each of the things are valid numbers.
+	case $current in
+	0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;
+	*)
+	  func_error "CURRENT \`$current' must be a nonnegative integer"
+	  func_fatal_error "\`$vinfo' is not valid version information"
+	  ;;
+	esac
+
+	case $revision in
+	0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;
+	*)
+	  func_error "REVISION \`$revision' must be a nonnegative integer"
+	  func_fatal_error "\`$vinfo' is not valid version information"
+	  ;;
+	esac
+
+	case $age in
+	0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;
+	*)
+	  func_error "AGE \`$age' must be a nonnegative integer"
+	  func_fatal_error "\`$vinfo' is not valid version information"
+	  ;;
+	esac
+
+	if test "$age" -gt "$current"; then
+	  func_error "AGE \`$age' is greater than the current interface number \`$current'"
+	  func_fatal_error "\`$vinfo' is not valid version information"
+	fi
+
+	# Calculate the version variables.
+	major=
+	versuffix=
+	verstring=
+	case $version_type in
+	none) ;;
+
+	darwin)
+	  # Like Linux, but with the current version available in
+	  # verstring for coding it into the library header
+	  func_arith $current - $age
+	  major=.$func_arith_result
+	  versuffix="$major.$age.$revision"
+	  # Darwin ld doesn't like 0 for these options...
+	  func_arith $current + 1
+	  minor_current=$func_arith_result
+	  xlcverstring="${wl}-compatibility_version ${wl}$minor_current ${wl}-current_version ${wl}$minor_current.$revision"
+	  verstring="-compatibility_version $minor_current -current_version $minor_current.$revision"
+	  ;;
+
+	freebsd-aout)
+	  major=".$current"
+	  versuffix=".$current.$revision";
+	  ;;
+
+	freebsd-elf)
+	  major=".$current"
+	  versuffix=".$current"
+	  ;;
+
+	irix | nonstopux)
+	  if test "X$lt_irix_increment" = "Xno"; then
+	    func_arith $current - $age
+	  else
+	    func_arith $current - $age + 1
+	  fi
+	  major=$func_arith_result
+
+	  case $version_type in
+	    nonstopux) verstring_prefix=nonstopux ;;
+	    *)         verstring_prefix=sgi ;;
+	  esac
+	  verstring="$verstring_prefix$major.$revision"
+
+	  # Add in all the interfaces that we are compatible with.
+	  loop=$revision
+	  while test "$loop" -ne 0; do
+	    func_arith $revision - $loop
+	    iface=$func_arith_result
+	    func_arith $loop - 1
+	    loop=$func_arith_result
+	    verstring="$verstring_prefix$major.$iface:$verstring"
+	  done
+
+	  # Before this point, $major must not contain `.'.
+	  major=.$major
+	  versuffix="$major.$revision"
+	  ;;
+
+	linux)
+	  func_arith $current - $age
+	  major=.$func_arith_result
+	  versuffix="$major.$age.$revision"
+	  ;;
+
+	osf)
+	  func_arith $current - $age
+	  major=.$func_arith_result
+	  versuffix=".$current.$age.$revision"
+	  verstring="$current.$age.$revision"
+
+	  # Add in all the interfaces that we are compatible with.
+	  loop=$age
+	  while test "$loop" -ne 0; do
+	    func_arith $current - $loop
+	    iface=$func_arith_result
+	    func_arith $loop - 1
+	    loop=$func_arith_result
+	    verstring="$verstring:${iface}.0"
+	  done
+
+	  # Make executables depend on our current version.
+	  verstring="$verstring:${current}.0"
+	  ;;
+
+	qnx)
+	  major=".$current"
+	  versuffix=".$current"
+	  ;;
+
+	sunos)
+	  major=".$current"
+	  versuffix=".$current.$revision"
+	  ;;
+
+	windows)
+	  # Use '-' rather than '.', since we only want one
+	  # extension on DOS 8.3 filesystems.
+	  func_arith $current - $age
+	  major=$func_arith_result
+	  versuffix="-$major"
+	  ;;
+
+	*)
+	  func_fatal_configuration "unknown library version type \`$version_type'"
+	  ;;
+	esac
+
+	# Clear the version info if we defaulted, and they specified a release.
+	if test -z "$vinfo" && test -n "$release"; then
+	  major=
+	  case $version_type in
+	  darwin)
+	    # we can't check for "0.0" in archive_cmds due to quoting
+	    # problems, so we reset it completely
+	    verstring=
+	    ;;
+	  *)
+	    verstring="0.0"
+	    ;;
+	  esac
+	  if test "$need_version" = no; then
+	    versuffix=
+	  else
+	    versuffix=".0.0"
+	  fi
+	fi
+
+	# Remove version info from name if versioning should be avoided
+	if test "$avoid_version" = yes && test "$need_version" = no; then
+	  major=
+	  versuffix=
+	  verstring=""
+	fi
+
+	# Check to see if the archive will have undefined symbols.
+	if test "$allow_undefined" = yes; then
+	  if test "$allow_undefined_flag" = unsupported; then
+	    func_warning "undefined symbols not allowed in $host shared libraries"
+	    build_libtool_libs=no
+	    build_old_libs=yes
+	  fi
+	else
+	  # Don't allow undefined symbols.
+	  allow_undefined_flag="$no_undefined_flag"
+	fi
+
+      fi
+
+      func_generate_dlsyms "$libname" "$libname" "yes"
+      libobjs="$libobjs $symfileobj"
+      test "X$libobjs" = "X " && libobjs=
+
+      if test "$mode" != relink; then
+	# Remove our outputs, but don't remove object files since they
+	# may have been created when compiling PIC objects.
+	removelist=
+	tempremovelist=`$ECHO "$output_objdir/*"`
+	for p in $tempremovelist; do
+	  case $p in
+	    *.$objext | *.gcno)
+	       ;;
+	    $output_objdir/$outputname | $output_objdir/$libname.* | $output_objdir/${libname}${release}.*)
+	       if test "X$precious_files_regex" != "X"; then
+		 if $ECHO "$p" | $EGREP -e "$precious_files_regex" >/dev/null 2>&1
+		 then
+		   continue
+		 fi
+	       fi
+	       removelist="$removelist $p"
+	       ;;
+	    *) ;;
+	  esac
+	done
+	test -n "$removelist" && \
+	  func_show_eval "${RM}r \$removelist"
+      fi
+
+      # Now set the variables for building old libraries.
+      if test "$build_old_libs" = yes && test "$build_libtool_libs" != convenience ; then
+	oldlibs="$oldlibs $output_objdir/$libname.$libext"
+
+	# Transform .lo files to .o files.
+	oldobjs="$objs "`$ECHO "X$libobjs" | $SP2NL | $Xsed -e '/\.'${libext}'$/d' -e "$lo2o" | $NL2SP`
+      fi
+
+      # Eliminate all temporary directories.
+      #for path in $notinst_path; do
+      #	lib_search_path=`$ECHO "X$lib_search_path " | $Xsed -e "s% $path % %g"`
+      #	deplibs=`$ECHO "X$deplibs " | $Xsed -e "s% -L$path % %g"`
+      #	dependency_libs=`$ECHO "X$dependency_libs " | $Xsed -e "s% -L$path % %g"`
+      #done
+
+      if test -n "$xrpath"; then
+	# If the user specified any rpath flags, then add them.
+	temp_xrpath=
+	for libdir in $xrpath; do
+	  temp_xrpath="$temp_xrpath -R$libdir"
+	  case "$finalize_rpath " in
+	  *" $libdir "*) ;;
+	  *) finalize_rpath="$finalize_rpath $libdir" ;;
+	  esac
+	done
+	if test "$hardcode_into_libs" != yes || test "$build_old_libs" = yes; then
+	  dependency_libs="$temp_xrpath $dependency_libs"
+	fi
+      fi
+
+      # Make sure dlfiles contains only unique files that won't be dlpreopened
+      old_dlfiles="$dlfiles"
+      dlfiles=
+      for lib in $old_dlfiles; do
+	case " $dlprefiles $dlfiles " in
+	*" $lib "*) ;;
+	*) dlfiles="$dlfiles $lib" ;;
+	esac
+      done
+
+      # Make sure dlprefiles contains only unique files
+      old_dlprefiles="$dlprefiles"
+      dlprefiles=
+      for lib in $old_dlprefiles; do
+	case "$dlprefiles " in
+	*" $lib "*) ;;
+	*) dlprefiles="$dlprefiles $lib" ;;
+	esac
+      done
+
+      if test "$build_libtool_libs" = yes; then
+	if test -n "$rpath"; then
+	  case $host in
+	  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-beos* | *-cegcc*)
+	    # these systems don't actually have a c library (as such)!
+	    ;;
+	  *-*-rhapsody* | *-*-darwin1.[012])
+	    # Rhapsody C library is in the System framework
+	    deplibs="$deplibs System.ltframework"
+	    ;;
+	  *-*-netbsd*)
+	    # Don't link with libc until the a.out ld.so is fixed.
+	    ;;
+	  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)
+	    # Do not include libc due to us having libc/libc_r.
+	    ;;
+	  *-*-sco3.2v5* | *-*-sco5v6*)
+	    # Causes problems with __ctype
+	    ;;
+	  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)
+	    # Compiler inserts libc in the correct place for threads to work
+	    ;;
+	  *)
+	    # Add libc to deplibs on all other systems if necessary.
+	    if test "$build_libtool_need_lc" = "yes"; then
+	      deplibs="$deplibs -lc"
+	    fi
+	    ;;
+	  esac
+	fi
+
+	# Transform deplibs into only deplibs that can be linked in shared.
+	name_save=$name
+	libname_save=$libname
+	release_save=$release
+	versuffix_save=$versuffix
+	major_save=$major
+	# I'm not sure if I'm treating the release correctly.  I think
+	# release should show up in the -l (ie -lgmp5) so we don't want to
+	# add it in twice.  Is that correct?
+	release=""
+	versuffix=""
+	major=""
+	newdeplibs=
+	droppeddeps=no
+	case $deplibs_check_method in
+	pass_all)
+	  # Don't check for shared/static.  Everything works.
+	  # This might be a little naive.  We might want to check
+	  # whether the library exists or not.  But this is on
+	  # osf3 & osf4 and I'm not really sure... Just
+	  # implementing what was already the behavior.
+	  newdeplibs=$deplibs
+	  ;;
+	test_compile)
+	  # This code stresses the "libraries are programs" paradigm to its
+	  # limits. Maybe even breaks it.  We compile a program, linking it
+	  # against the deplibs as a proxy for the library.  Then we can check
+	  # whether they linked in statically or dynamically with ldd.
+	  $opt_dry_run || $RM conftest.c
+	  cat > conftest.c <<EOF
+	  int main() { return 0; }
+EOF
+	  $opt_dry_run || $RM conftest
+	  if $LTCC $LTCFLAGS -o conftest conftest.c $deplibs; then
+	    ldd_output=`ldd conftest`
+	    for i in $deplibs; do
+	      case $i in
+	      -l*)
+		func_stripname -l '' "$i"
+		name=$func_stripname_result
+		if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+		  case " $predeps $postdeps " in
+		  *" $i "*)
+		    newdeplibs="$newdeplibs $i"
+		    i=""
+		    ;;
+		  esac
+		fi
+		if test -n "$i" ; then
+		  libname=`eval "\\$ECHO \"$libname_spec\""`
+		  deplib_matches=`eval "\\$ECHO \"$library_names_spec\""`
+		  set dummy $deplib_matches; shift
+		  deplib_match=$1
+		  if test `expr "$ldd_output" : ".*$deplib_match"` -ne 0 ; then
+		    newdeplibs="$newdeplibs $i"
+		  else
+		    droppeddeps=yes
+		    $ECHO
+		    $ECHO "*** Warning: dynamic linker does not accept needed library $i."
+		    $ECHO "*** I have the capability to make that library automatically link in when"
+		    $ECHO "*** you link to this library.  But I can only do this if you have a"
+		    $ECHO "*** shared version of the library, which I believe you do not have"
+		    $ECHO "*** because a test_compile did reveal that the linker did not use it for"
+		    $ECHO "*** its dynamic dependency list that programs get resolved with at runtime."
+		  fi
+		fi
+		;;
+	      *)
+		newdeplibs="$newdeplibs $i"
+		;;
+	      esac
+	    done
+	  else
+	    # Error occurred in the first compile.  Let's try to salvage
+	    # the situation: Compile a separate program for each library.
+	    for i in $deplibs; do
+	      case $i in
+	      -l*)
+		func_stripname -l '' "$i"
+		name=$func_stripname_result
+		$opt_dry_run || $RM conftest
+		if $LTCC $LTCFLAGS -o conftest conftest.c $i; then
+		  ldd_output=`ldd conftest`
+		  if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+		    case " $predeps $postdeps " in
+		    *" $i "*)
+		      newdeplibs="$newdeplibs $i"
+		      i=""
+		      ;;
+		    esac
+		  fi
+		  if test -n "$i" ; then
+		    libname=`eval "\\$ECHO \"$libname_spec\""`
+		    deplib_matches=`eval "\\$ECHO \"$library_names_spec\""`
+		    set dummy $deplib_matches; shift
+		    deplib_match=$1
+		    if test `expr "$ldd_output" : ".*$deplib_match"` -ne 0 ; then
+		      newdeplibs="$newdeplibs $i"
+		    else
+		      droppeddeps=yes
+		      $ECHO
+		      $ECHO "*** Warning: dynamic linker does not accept needed library $i."
+		      $ECHO "*** I have the capability to make that library automatically link in when"
+		      $ECHO "*** you link to this library.  But I can only do this if you have a"
+		      $ECHO "*** shared version of the library, which you do not appear to have"
+		      $ECHO "*** because a test_compile did reveal that the linker did not use this one"
+		      $ECHO "*** as a dynamic dependency that programs can get resolved with at runtime."
+		    fi
+		  fi
+		else
+		  droppeddeps=yes
+		  $ECHO
+		  $ECHO "*** Warning!  Library $i is needed by this library but I was not able to"
+		  $ECHO "*** make it link in!  You will probably need to install it or some"
+		  $ECHO "*** library that it depends on before this library will be fully"
+		  $ECHO "*** functional.  Installing it before continuing would be even better."
+		fi
+		;;
+	      *)
+		newdeplibs="$newdeplibs $i"
+		;;
+	      esac
+	    done
+	  fi
+	  ;;
+	file_magic*)
+	  set dummy $deplibs_check_method; shift
+	  file_magic_regex=`expr "$deplibs_check_method" : "$1 \(.*\)"`
+	  for a_deplib in $deplibs; do
+	    case $a_deplib in
+	    -l*)
+	      func_stripname -l '' "$a_deplib"
+	      name=$func_stripname_result
+	      if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+		case " $predeps $postdeps " in
+		*" $a_deplib "*)
+		  newdeplibs="$newdeplibs $a_deplib"
+		  a_deplib=""
+		  ;;
+		esac
+	      fi
+	      if test -n "$a_deplib" ; then
+		libname=`eval "\\$ECHO \"$libname_spec\""`
+		for i in $lib_search_path $sys_lib_search_path $shlib_search_path; do
+		  potential_libs=`ls $i/$libname[.-]* 2>/dev/null`
+		  for potent_lib in $potential_libs; do
+		      # Follow soft links.
+		      if ls -lLd "$potent_lib" 2>/dev/null |
+			 $GREP " -> " >/dev/null; then
+			continue
+		      fi
+		      # The statement above tries to avoid entering an
+		      # endless loop below, in case of cyclic links.
+		      # We might still enter an endless loop, since a link
+		      # loop can be closed while we follow links,
+		      # but so what?
+		      potlib="$potent_lib"
+		      while test -h "$potlib" 2>/dev/null; do
+			potliblink=`ls -ld $potlib | ${SED} 's/.* -> //'`
+			case $potliblink in
+			[\\/]* | [A-Za-z]:[\\/]*) potlib="$potliblink";;
+			*) potlib=`$ECHO "X$potlib" | $Xsed -e 's,[^/]*$,,'`"$potliblink";;
+			esac
+		      done
+		      if eval $file_magic_cmd \"\$potlib\" 2>/dev/null |
+			 $SED -e 10q |
+			 $EGREP "$file_magic_regex" > /dev/null; then
+			newdeplibs="$newdeplibs $a_deplib"
+			a_deplib=""
+			break 2
+		      fi
+		  done
+		done
+	      fi
+	      if test -n "$a_deplib" ; then
+		droppeddeps=yes
+		$ECHO
+		$ECHO "*** Warning: linker path does not have real file for library $a_deplib."
+		$ECHO "*** I have the capability to make that library automatically link in when"
+		$ECHO "*** you link to this library.  But I can only do this if you have a"
+		$ECHO "*** shared version of the library, which you do not appear to have"
+		$ECHO "*** because I did check the linker path looking for a file starting"
+		if test -z "$potlib" ; then
+		  $ECHO "*** with $libname but no candidates were found. (...for file magic test)"
+		else
+		  $ECHO "*** with $libname and none of the candidates passed a file format test"
+		  $ECHO "*** using a file magic. Last file checked: $potlib"
+		fi
+	      fi
+	      ;;
+	    *)
+	      # Add a -L argument.
+	      newdeplibs="$newdeplibs $a_deplib"
+	      ;;
+	    esac
+	  done # Gone through all deplibs.
+	  ;;
+	match_pattern*)
+	  set dummy $deplibs_check_method; shift
+	  match_pattern_regex=`expr "$deplibs_check_method" : "$1 \(.*\)"`
+	  for a_deplib in $deplibs; do
+	    case $a_deplib in
+	    -l*)
+	      func_stripname -l '' "$a_deplib"
+	      name=$func_stripname_result
+	      if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+		case " $predeps $postdeps " in
+		*" $a_deplib "*)
+		  newdeplibs="$newdeplibs $a_deplib"
+		  a_deplib=""
+		  ;;
+		esac
+	      fi
+	      if test -n "$a_deplib" ; then
+		libname=`eval "\\$ECHO \"$libname_spec\""`
+		for i in $lib_search_path $sys_lib_search_path $shlib_search_path; do
+		  potential_libs=`ls $i/$libname[.-]* 2>/dev/null`
+		  for potent_lib in $potential_libs; do
+		    potlib="$potent_lib" # see symlink-check above in file_magic test
+		    if eval "\$ECHO \"X$potent_lib\"" 2>/dev/null | $Xsed -e 10q | \
+		       $EGREP "$match_pattern_regex" > /dev/null; then
+		      newdeplibs="$newdeplibs $a_deplib"
+		      a_deplib=""
+		      break 2
+		    fi
+		  done
+		done
+	      fi
+	      if test -n "$a_deplib" ; then
+		droppeddeps=yes
+		$ECHO
+		$ECHO "*** Warning: linker path does not have real file for library $a_deplib."
+		$ECHO "*** I have the capability to make that library automatically link in when"
+		$ECHO "*** you link to this library.  But I can only do this if you have a"
+		$ECHO "*** shared version of the library, which you do not appear to have"
+		$ECHO "*** because I did check the linker path looking for a file starting"
+		if test -z "$potlib" ; then
+		  $ECHO "*** with $libname but no candidates were found. (...for regex pattern test)"
+		else
+		  $ECHO "*** with $libname and none of the candidates passed a file format test"
+		  $ECHO "*** using a regex pattern. Last file checked: $potlib"
+		fi
+	      fi
+	      ;;
+	    *)
+	      # Add a -L argument.
+	      newdeplibs="$newdeplibs $a_deplib"
+	      ;;
+	    esac
+	  done # Gone through all deplibs.
+	  ;;
+	none | unknown | *)
+	  newdeplibs=""
+	  tmp_deplibs=`$ECHO "X $deplibs" | $Xsed \
+	      -e 's/ -lc$//' -e 's/ -[LR][^ ]*//g'`
+	  if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+	    for i in $predeps $postdeps ; do
+	      # can't use Xsed below, because $i might contain '/'
+	      tmp_deplibs=`$ECHO "X $tmp_deplibs" | $Xsed -e "s,$i,,"`
+	    done
+	  fi
+	  if $ECHO "X $tmp_deplibs" | $Xsed -e 's/[	 ]//g' |
+	     $GREP . >/dev/null; then
+	    $ECHO
+	    if test "X$deplibs_check_method" = "Xnone"; then
+	      $ECHO "*** Warning: inter-library dependencies are not supported in this platform."
+	    else
+	      $ECHO "*** Warning: inter-library dependencies are not known to be supported."
+	    fi
+	    $ECHO "*** All declared inter-library dependencies are being dropped."
+	    droppeddeps=yes
+	  fi
+	  ;;
+	esac
+	versuffix=$versuffix_save
+	major=$major_save
+	release=$release_save
+	libname=$libname_save
+	name=$name_save
+
+	case $host in
+	*-*-rhapsody* | *-*-darwin1.[012])
+	  # On Rhapsody replace the C library with the System framework
+	  newdeplibs=`$ECHO "X $newdeplibs" | $Xsed -e 's/ -lc / System.ltframework /'`
+	  ;;
+	esac
+
+	if test "$droppeddeps" = yes; then
+	  if test "$module" = yes; then
+	    $ECHO
+	    $ECHO "*** Warning: libtool could not satisfy all declared inter-library"
+	    $ECHO "*** dependencies of module $libname.  Therefore, libtool will create"
+	    $ECHO "*** a static module, that should work as long as the dlopening"
+	    $ECHO "*** application is linked with the -dlopen flag."
+	    if test -z "$global_symbol_pipe"; then
+	      $ECHO
+	      $ECHO "*** However, this would only work if libtool was able to extract symbol"
+	      $ECHO "*** lists from a program, using \`nm' or equivalent, but libtool could"
+	      $ECHO "*** not find such a program.  So, this module is probably useless."
+	      $ECHO "*** \`nm' from GNU binutils and a full rebuild may help."
+	    fi
+	    if test "$build_old_libs" = no; then
+	      oldlibs="$output_objdir/$libname.$libext"
+	      build_libtool_libs=module
+	      build_old_libs=yes
+	    else
+	      build_libtool_libs=no
+	    fi
+	  else
+	    $ECHO "*** The inter-library dependencies that have been dropped here will be"
+	    $ECHO "*** automatically added whenever a program is linked with this library"
+	    $ECHO "*** or is declared to -dlopen it."
+
+	    if test "$allow_undefined" = no; then
+	      $ECHO
+	      $ECHO "*** Since this library must not contain undefined symbols,"
+	      $ECHO "*** because either the platform does not support them or"
+	      $ECHO "*** it was explicitly requested with -no-undefined,"
+	      $ECHO "*** libtool will only create a static version of it."
+	      if test "$build_old_libs" = no; then
+		oldlibs="$output_objdir/$libname.$libext"
+		build_libtool_libs=module
+		build_old_libs=yes
+	      else
+		build_libtool_libs=no
+	      fi
+	    fi
+	  fi
+	fi
+	# Done checking deplibs!
+	deplibs=$newdeplibs
+      fi
+      # Time to change all our "foo.ltframework" stuff back to "-framework foo"
+      case $host in
+	*-*-darwin*)
+	  newdeplibs=`$ECHO "X $newdeplibs" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	  new_inherited_linker_flags=`$ECHO "X $new_inherited_linker_flags" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	  deplibs=`$ECHO "X $deplibs" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	  ;;
+      esac
+
+      # move library search paths that coincide with paths to not yet
+      # installed libraries to the beginning of the library search list
+      new_libs=
+      for path in $notinst_path; do
+	case " $new_libs " in
+	*" -L$path/$objdir "*) ;;
+	*)
+	  case " $deplibs " in
+	  *" -L$path/$objdir "*)
+	    new_libs="$new_libs -L$path/$objdir" ;;
+	  esac
+	  ;;
+	esac
+      done
+      for deplib in $deplibs; do
+	case $deplib in
+	-L*)
+	  case " $new_libs " in
+	  *" $deplib "*) ;;
+	  *) new_libs="$new_libs $deplib" ;;
+	  esac
+	  ;;
+	*) new_libs="$new_libs $deplib" ;;
+	esac
+      done
+      deplibs="$new_libs"
+
+      # All the library-specific variables (install_libdir is set above).
+      library_names=
+      old_library=
+      dlname=
+
+      # Test again, we may have decided not to build it any more
+      if test "$build_libtool_libs" = yes; then
+	if test "$hardcode_into_libs" = yes; then
+	  # Hardcode the library paths
+	  hardcode_libdirs=
+	  dep_rpath=
+	  rpath="$finalize_rpath"
+	  test "$mode" != relink && rpath="$compile_rpath$rpath"
+	  for libdir in $rpath; do
+	    if test -n "$hardcode_libdir_flag_spec"; then
+	      if test -n "$hardcode_libdir_separator"; then
+		if test -z "$hardcode_libdirs"; then
+		  hardcode_libdirs="$libdir"
+		else
+		  # Just accumulate the unique libdirs.
+		  case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in
+		  *"$hardcode_libdir_separator$libdir$hardcode_libdir_separator"*)
+		    ;;
+		  *)
+		    hardcode_libdirs="$hardcode_libdirs$hardcode_libdir_separator$libdir"
+		    ;;
+		  esac
+		fi
+	      else
+		eval flag=\"$hardcode_libdir_flag_spec\"
+		dep_rpath="$dep_rpath $flag"
+	      fi
+	    elif test -n "$runpath_var"; then
+	      case "$perm_rpath " in
+	      *" $libdir "*) ;;
+	      *) perm_rpath="$perm_rpath $libdir" ;;
+	      esac
+	    fi
+	  done
+	  # Substitute the hardcoded libdirs into the rpath.
+	  if test -n "$hardcode_libdir_separator" &&
+	     test -n "$hardcode_libdirs"; then
+	    libdir="$hardcode_libdirs"
+	    if test -n "$hardcode_libdir_flag_spec_ld"; then
+	      eval dep_rpath=\"$hardcode_libdir_flag_spec_ld\"
+	    else
+	      eval dep_rpath=\"$hardcode_libdir_flag_spec\"
+	    fi
+	  fi
+	  if test -n "$runpath_var" && test -n "$perm_rpath"; then
+	    # We should set the runpath_var.
+	    rpath=
+	    for dir in $perm_rpath; do
+	      rpath="$rpath$dir:"
+	    done
+	    eval "$runpath_var='$rpath\$$runpath_var'; export $runpath_var"
+	  fi
+	  test -n "$dep_rpath" && deplibs="$dep_rpath $deplibs"
+	fi
+
+	shlibpath="$finalize_shlibpath"
+	test "$mode" != relink && shlibpath="$compile_shlibpath$shlibpath"
+	if test -n "$shlibpath"; then
+	  eval "$shlibpath_var='$shlibpath\$$shlibpath_var'; export $shlibpath_var"
+	fi
+
+	# Get the real and link names of the library.
+	eval shared_ext=\"$shrext_cmds\"
+	eval library_names=\"$library_names_spec\"
+	set dummy $library_names
+	shift
+	realname="$1"
+	shift
+
+	if test -n "$soname_spec"; then
+	  eval soname=\"$soname_spec\"
+	else
+	  soname="$realname"
+	fi
+	if test -z "$dlname"; then
+	  dlname=$soname
+	fi
+
+	lib="$output_objdir/$realname"
+	linknames=
+	for link
+	do
+	  linknames="$linknames $link"
+	done
+
+	# Use standard objects if they are pic
+	test -z "$pic_flag" && libobjs=`$ECHO "X$libobjs" | $SP2NL | $Xsed -e "$lo2o" | $NL2SP`
+	test "X$libobjs" = "X " && libobjs=
+
+	delfiles=
+	if test -n "$export_symbols" && test -n "$include_expsyms"; then
+	  $opt_dry_run || cp "$export_symbols" "$output_objdir/$libname.uexp"
+	  export_symbols="$output_objdir/$libname.uexp"
+	  delfiles="$delfiles $export_symbols"
+	fi
+
+	orig_export_symbols=
+	case $host_os in
+	cygwin* | mingw* | cegcc*)
+	  if test -n "$export_symbols" && test -z "$export_symbols_regex"; then
+	    # exporting using user supplied symfile
+	    if test "x`$SED 1q $export_symbols`" != xEXPORTS; then
+	      # and it's NOT already a .def file. Must figure out
+	      # which of the given symbols are data symbols and tag
+	      # them as such. So, trigger use of export_symbols_cmds.
+	      # export_symbols gets reassigned inside the "prepare
+	      # the list of exported symbols" if statement, so the
+	      # include_expsyms logic still works.
+	      orig_export_symbols="$export_symbols"
+	      export_symbols=
+	      always_export_symbols=yes
+	    fi
+	  fi
+	  ;;
+	esac
+
+	# Prepare the list of exported symbols
+	if test -z "$export_symbols"; then
+	  if test "$always_export_symbols" = yes || test -n "$export_symbols_regex"; then
+	    func_verbose "generating symbol list for \`$libname.la'"
+	    export_symbols="$output_objdir/$libname.exp"
+	    $opt_dry_run || $RM $export_symbols
+	    cmds=$export_symbols_cmds
+	    save_ifs="$IFS"; IFS='~'
+	    for cmd in $cmds; do
+	      IFS="$save_ifs"
+	      eval cmd=\"$cmd\"
+	      func_len " $cmd"
+	      len=$func_len_result
+	      if test "$len" -lt "$max_cmd_len" || test "$max_cmd_len" -le -1; then
+		func_show_eval "$cmd" 'exit $?'
+		skipped_export=false
+	      else
+		# The command line is too long to execute in one step.
+		func_verbose "using reloadable object file for export list..."
+		skipped_export=:
+		# Break out early, otherwise skipped_export may be
+		# set to false by a later but shorter cmd.
+		break
+	      fi
+	    done
+	    IFS="$save_ifs"
+	    if test -n "$export_symbols_regex" && test "X$skipped_export" != "X:"; then
+	      func_show_eval '$EGREP -e "$export_symbols_regex" "$export_symbols" > "${export_symbols}T"'
+	      func_show_eval '$MV "${export_symbols}T" "$export_symbols"'
+	    fi
+	  fi
+	fi
+
+	if test -n "$export_symbols" && test -n "$include_expsyms"; then
+	  tmp_export_symbols="$export_symbols"
+	  test -n "$orig_export_symbols" && tmp_export_symbols="$orig_export_symbols"
+	  $opt_dry_run || eval '$ECHO "X$include_expsyms" | $Xsed | $SP2NL >> "$tmp_export_symbols"'
+	fi
+
+	if test "X$skipped_export" != "X:" && test -n "$orig_export_symbols"; then
+	  # The given exports_symbols file has to be filtered, so filter it.
+	  func_verbose "filter symbol list for \`$libname.la' to tag DATA exports"
+	  # FIXME: $output_objdir/$libname.filter potentially contains lots of
+	  # 's' commands which not all seds can handle. GNU sed should be fine
+	  # though. Also, the filter scales superlinearly with the number of
+	  # global variables. join(1) would be nice here, but unfortunately
+	  # isn't a blessed tool.
+	  $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\(.*\)\([ \,].*\),s|^\1$|\1\2|,' < $export_symbols > $output_objdir/$libname.filter
+	  delfiles="$delfiles $export_symbols $output_objdir/$libname.filter"
+	  export_symbols=$output_objdir/$libname.def
+	  $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols
+	fi
+
+	tmp_deplibs=
+	for test_deplib in $deplibs; do
+	  case " $convenience " in
+	  *" $test_deplib "*) ;;
+	  *)
+	    tmp_deplibs="$tmp_deplibs $test_deplib"
+	    ;;
+	  esac
+	done
+	deplibs="$tmp_deplibs"
+
+	if test -n "$convenience"; then
+	  if test -n "$whole_archive_flag_spec" &&
+	    test "$compiler_needs_object" = yes &&
+	    test -z "$libobjs"; then
+	    # extract the archives, so we have objects to list.
+	    # TODO: could optimize this to just extract one archive.
+	    whole_archive_flag_spec=
+	  fi
+	  if test -n "$whole_archive_flag_spec"; then
+	    save_libobjs=$libobjs
+	    eval libobjs=\"\$libobjs $whole_archive_flag_spec\"
+	    test "X$libobjs" = "X " && libobjs=
+	  else
+	    gentop="$output_objdir/${outputname}x"
+	    generated="$generated $gentop"
+
+	    func_extract_archives $gentop $convenience
+	    libobjs="$libobjs $func_extract_archives_result"
+	    test "X$libobjs" = "X " && libobjs=
+	  fi
+	fi
+
+	if test "$thread_safe" = yes && test -n "$thread_safe_flag_spec"; then
+	  eval flag=\"$thread_safe_flag_spec\"
+	  linker_flags="$linker_flags $flag"
+	fi
+
+	# Make a backup of the uninstalled library when relinking
+	if test "$mode" = relink; then
+	  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}U && $MV $realname ${realname}U)' || exit $?
+	fi
+
+	# Do each of the archive commands.
+	if test "$module" = yes && test -n "$module_cmds" ; then
+	  if test -n "$export_symbols" && test -n "$module_expsym_cmds"; then
+	    eval test_cmds=\"$module_expsym_cmds\"
+	    cmds=$module_expsym_cmds
+	  else
+	    eval test_cmds=\"$module_cmds\"
+	    cmds=$module_cmds
+	  fi
+	else
+	  if test -n "$export_symbols" && test -n "$archive_expsym_cmds"; then
+	    eval test_cmds=\"$archive_expsym_cmds\"
+	    cmds=$archive_expsym_cmds
+	  else
+	    eval test_cmds=\"$archive_cmds\"
+	    cmds=$archive_cmds
+	  fi
+	fi
+
+	if test "X$skipped_export" != "X:" &&
+	   func_len " $test_cmds" &&
+	   len=$func_len_result &&
+	   test "$len" -lt "$max_cmd_len" || test "$max_cmd_len" -le -1; then
+	  :
+	else
+	  # The command line is too long to link in one step, link piecewise
+	  # or, if using GNU ld and skipped_export is not :, use a linker
+	  # script.
+
+	  # Save the value of $output and $libobjs because we want to
+	  # use them later.  If we have whole_archive_flag_spec, we
+	  # want to use save_libobjs as it was before
+	  # whole_archive_flag_spec was expanded, because we can't
+	  # assume the linker understands whole_archive_flag_spec.
+	  # This may have to be revisited, in case too many
+	  # convenience libraries get linked in and end up exceeding
+	  # the spec.
+	  if test -z "$convenience" || test -z "$whole_archive_flag_spec"; then
+	    save_libobjs=$libobjs
+	  fi
+	  save_output=$output
+	  output_la=`$ECHO "X$output" | $Xsed -e "$basename"`
+
+	  # Clear the reloadable object creation command queue and
+	  # initialize k to one.
+	  test_cmds=
+	  concat_cmds=
+	  objlist=
+	  last_robj=
+	  k=1
+
+	  if test -n "$save_libobjs" && test "X$skipped_export" != "X:" && test "$with_gnu_ld" = yes; then
+	    output=${output_objdir}/${output_la}.lnkscript
+	    func_verbose "creating GNU ld script: $output"
+	    $ECHO 'INPUT (' > $output
+	    for obj in $save_libobjs
+	    do
+	      $ECHO "$obj" >> $output
+	    done
+	    $ECHO ')' >> $output
+	    delfiles="$delfiles $output"
+	  elif test -n "$save_libobjs" && test "X$skipped_export" != "X:" && test "X$file_list_spec" != X; then
+	    output=${output_objdir}/${output_la}.lnk
+	    func_verbose "creating linker input file list: $output"
+	    : > $output
+	    set x $save_libobjs
+	    shift
+	    firstobj=
+	    if test "$compiler_needs_object" = yes; then
+	      firstobj="$1 "
+	      shift
+	    fi
+	    for obj
+	    do
+	      $ECHO "$obj" >> $output
+	    done
+	    delfiles="$delfiles $output"
+	    output=$firstobj\"$file_list_spec$output\"
+	  else
+	    if test -n "$save_libobjs"; then
+	      func_verbose "creating reloadable object files..."
+	      output=$output_objdir/$output_la-${k}.$objext
+	      eval test_cmds=\"$reload_cmds\"
+	      func_len " $test_cmds"
+	      len0=$func_len_result
+	      len=$len0
+
+	      # Loop over the list of objects to be linked.
+	      for obj in $save_libobjs
+	      do
+		func_len " $obj"
+		func_arith $len + $func_len_result
+		len=$func_arith_result
+		if test "X$objlist" = X ||
+		   test "$len" -lt "$max_cmd_len"; then
+		  func_append objlist " $obj"
+		else
+		  # The command $test_cmds is almost too long, add a
+		  # command to the queue.
+		  if test "$k" -eq 1 ; then
+		    # The first file doesn't have a previous command to add.
+		    eval concat_cmds=\"$reload_cmds $objlist $last_robj\"
+		  else
+		    # All subsequent reloadable object files will link in
+		    # the last one created.
+		    eval concat_cmds=\"\$concat_cmds~$reload_cmds $objlist $last_robj~\$RM $last_robj\"
+		  fi
+		  last_robj=$output_objdir/$output_la-${k}.$objext
+		  func_arith $k + 1
+		  k=$func_arith_result
+		  output=$output_objdir/$output_la-${k}.$objext
+		  objlist=$obj
+		  func_len " $last_robj"
+		  func_arith $len0 + $func_len_result
+		  len=$func_arith_result
+		fi
+	      done
+	      # Handle the remaining objects by creating one last
+	      # reloadable object file.  All subsequent reloadable object
+	      # files will link in the last one created.
+	      test -z "$concat_cmds" || concat_cmds=$concat_cmds~
+	      eval concat_cmds=\"\${concat_cmds}$reload_cmds $objlist $last_robj\"
+	      if test -n "$last_robj"; then
+	        eval concat_cmds=\"\${concat_cmds}~\$RM $last_robj\"
+	      fi
+	      delfiles="$delfiles $output"
+
+	    else
+	      output=
+	    fi
+
+	    if ${skipped_export-false}; then
+	      func_verbose "generating symbol list for \`$libname.la'"
+	      export_symbols="$output_objdir/$libname.exp"
+	      $opt_dry_run || $RM $export_symbols
+	      libobjs=$output
+	      # Append the command to create the export file.
+	      test -z "$concat_cmds" || concat_cmds=$concat_cmds~
+	      eval concat_cmds=\"\$concat_cmds$export_symbols_cmds\"
+	      if test -n "$last_robj"; then
+		eval concat_cmds=\"\$concat_cmds~\$RM $last_robj\"
+	      fi
+	    fi
+
+	    test -n "$save_libobjs" &&
+	      func_verbose "creating a temporary reloadable object file: $output"
+
+	    # Loop through the commands generated above and execute them.
+	    save_ifs="$IFS"; IFS='~'
+	    for cmd in $concat_cmds; do
+	      IFS="$save_ifs"
+	      $opt_silent || {
+		  func_quote_for_expand "$cmd"
+		  eval "func_echo $func_quote_for_expand_result"
+	      }
+	      $opt_dry_run || eval "$cmd" || {
+		lt_exit=$?
+
+		# Restore the uninstalled library and exit
+		if test "$mode" = relink; then
+		  ( cd "$output_objdir" && \
+		    $RM "${realname}T" && \
+		    $MV "${realname}U" "$realname" )
+		fi
+
+		exit $lt_exit
+	      }
+	    done
+	    IFS="$save_ifs"
+
+	    if test -n "$export_symbols_regex" && ${skipped_export-false}; then
+	      func_show_eval '$EGREP -e "$export_symbols_regex" "$export_symbols" > "${export_symbols}T"'
+	      func_show_eval '$MV "${export_symbols}T" "$export_symbols"'
+	    fi
+	  fi
+
+          if ${skipped_export-false}; then
+	    if test -n "$export_symbols" && test -n "$include_expsyms"; then
+	      tmp_export_symbols="$export_symbols"
+	      test -n "$orig_export_symbols" && tmp_export_symbols="$orig_export_symbols"
+	      $opt_dry_run || eval '$ECHO "X$include_expsyms" | $Xsed | $SP2NL >> "$tmp_export_symbols"'
+	    fi
+
+	    if test -n "$orig_export_symbols"; then
+	      # The given exports_symbols file has to be filtered, so filter it.
+	      func_verbose "filter symbol list for \`$libname.la' to tag DATA exports"
+	      # FIXME: $output_objdir/$libname.filter potentially contains lots of
+	      # 's' commands which not all seds can handle. GNU sed should be fine
+	      # though. Also, the filter scales superlinearly with the number of
+	      # global variables. join(1) would be nice here, but unfortunately
+	      # isn't a blessed tool.
+	      $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\(.*\)\([ \,].*\),s|^\1$|\1\2|,' < $export_symbols > $output_objdir/$libname.filter
+	      delfiles="$delfiles $export_symbols $output_objdir/$libname.filter"
+	      export_symbols=$output_objdir/$libname.def
+	      $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols
+	    fi
+	  fi
+
+	  libobjs=$output
+	  # Restore the value of output.
+	  output=$save_output
+
+	  if test -n "$convenience" && test -n "$whole_archive_flag_spec"; then
+	    eval libobjs=\"\$libobjs $whole_archive_flag_spec\"
+	    test "X$libobjs" = "X " && libobjs=
+	  fi
+	  # Expand the library linking commands again to reset the
+	  # value of $libobjs for piecewise linking.
+
+	  # Do each of the archive commands.
+	  if test "$module" = yes && test -n "$module_cmds" ; then
+	    if test -n "$export_symbols" && test -n "$module_expsym_cmds"; then
+	      cmds=$module_expsym_cmds
+	    else
+	      cmds=$module_cmds
+	    fi
+	  else
+	    if test -n "$export_symbols" && test -n "$archive_expsym_cmds"; then
+	      cmds=$archive_expsym_cmds
+	    else
+	      cmds=$archive_cmds
+	    fi
+	  fi
+	fi
+
+	if test -n "$delfiles"; then
+	  # Append the command to remove temporary files to $cmds.
+	  eval cmds=\"\$cmds~\$RM $delfiles\"
+	fi
+
+	# Add any objects from preloaded convenience libraries
+	if test -n "$dlprefiles"; then
+	  gentop="$output_objdir/${outputname}x"
+	  generated="$generated $gentop"
+
+	  func_extract_archives $gentop $dlprefiles
+	  libobjs="$libobjs $func_extract_archives_result"
+	  test "X$libobjs" = "X " && libobjs=
+	fi
+
+	save_ifs="$IFS"; IFS='~'
+	for cmd in $cmds; do
+	  IFS="$save_ifs"
+	  eval cmd=\"$cmd\"
+	  $opt_silent || {
+	    func_quote_for_expand "$cmd"
+	    eval "func_echo $func_quote_for_expand_result"
+	  }
+	  $opt_dry_run || eval "$cmd" || {
+	    lt_exit=$?
+
+	    # Restore the uninstalled library and exit
+	    if test "$mode" = relink; then
+	      ( cd "$output_objdir" && \
+	        $RM "${realname}T" && \
+		$MV "${realname}U" "$realname" )
+	    fi
+
+	    exit $lt_exit
+	  }
+	done
+	IFS="$save_ifs"
+
+	# Restore the uninstalled library and exit
+	if test "$mode" = relink; then
+	  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}T && $MV $realname ${realname}T && $MV ${realname}U $realname)' || exit $?
+
+	  if test -n "$convenience"; then
+	    if test -z "$whole_archive_flag_spec"; then
+	      func_show_eval '${RM}r "$gentop"'
+	    fi
+	  fi
+
+	  exit $EXIT_SUCCESS
+	fi
+
+	# Create links to the real library.
+	for linkname in $linknames; do
+	  if test "$realname" != "$linkname"; then
+	    func_show_eval '(cd "$output_objdir" && $RM "$linkname" && $LN_S "$realname" "$linkname")' 'exit $?'
+	  fi
+	done
+
+	# If -module or -export-dynamic was specified, set the dlname.
+	if test "$module" = yes || test "$export_dynamic" = yes; then
+	  # On all known operating systems, these are identical.
+	  dlname="$soname"
+	fi
+      fi
+      ;;
+
+    obj)
+      if test -n "$dlfiles$dlprefiles" || test "$dlself" != no; then
+	func_warning "\`-dlopen' is ignored for objects"
+      fi
+
+      case " $deplibs" in
+      *\ -l* | *\ -L*)
+	func_warning "\`-l' and \`-L' are ignored for objects" ;;
+      esac
+
+      test -n "$rpath" && \
+	func_warning "\`-rpath' is ignored for objects"
+
+      test -n "$xrpath" && \
+	func_warning "\`-R' is ignored for objects"
+
+      test -n "$vinfo" && \
+	func_warning "\`-version-info' is ignored for objects"
+
+      test -n "$release" && \
+	func_warning "\`-release' is ignored for objects"
+
+      case $output in
+      *.lo)
+	test -n "$objs$old_deplibs" && \
+	  func_fatal_error "cannot build library object \`$output' from non-libtool objects"
+
+	libobj=$output
+	func_lo2o "$libobj"
+	obj=$func_lo2o_result
+	;;
+      *)
+	libobj=
+	obj="$output"
+	;;
+      esac
+
+      # Delete the old objects.
+      $opt_dry_run || $RM $obj $libobj
+
+      # Objects from convenience libraries.  This assumes
+      # single-version convenience libraries.  Whenever we create
+      # different ones for PIC/non-PIC, this we'll have to duplicate
+      # the extraction.
+      reload_conv_objs=
+      gentop=
+      # reload_cmds runs $LD directly, so let us get rid of
+      # -Wl from whole_archive_flag_spec and hope we can get by with
+      # turning comma into space..
+      wl=
+
+      if test -n "$convenience"; then
+	if test -n "$whole_archive_flag_spec"; then
+	  eval tmp_whole_archive_flags=\"$whole_archive_flag_spec\"
+	  reload_conv_objs=$reload_objs\ `$ECHO "X$tmp_whole_archive_flags" | $Xsed -e 's|,| |g'`
+	else
+	  gentop="$output_objdir/${obj}x"
+	  generated="$generated $gentop"
+
+	  func_extract_archives $gentop $convenience
+	  reload_conv_objs="$reload_objs $func_extract_archives_result"
+	fi
+      fi
+
+      # Create the old-style object.
+      reload_objs="$objs$old_deplibs "`$ECHO "X$libobjs" | $SP2NL | $Xsed -e '/\.'${libext}$'/d' -e '/\.lib$/d' -e "$lo2o" | $NL2SP`" $reload_conv_objs" ### testsuite: skip nested quoting test
+
+      output="$obj"
+      func_execute_cmds "$reload_cmds" 'exit $?'
+
+      # Exit if we aren't doing a library object file.
+      if test -z "$libobj"; then
+	if test -n "$gentop"; then
+	  func_show_eval '${RM}r "$gentop"'
+	fi
+
+	exit $EXIT_SUCCESS
+      fi
+
+      if test "$build_libtool_libs" != yes; then
+	if test -n "$gentop"; then
+	  func_show_eval '${RM}r "$gentop"'
+	fi
+
+	# Create an invalid libtool object if no PIC, so that we don't
+	# accidentally link it into a program.
+	# $show "echo timestamp > $libobj"
+	# $opt_dry_run || eval "echo timestamp > $libobj" || exit $?
+	exit $EXIT_SUCCESS
+      fi
+
+      if test -n "$pic_flag" || test "$pic_mode" != default; then
+	# Only do commands if we really have different PIC objects.
+	reload_objs="$libobjs $reload_conv_objs"
+	output="$libobj"
+	func_execute_cmds "$reload_cmds" 'exit $?'
+      fi
+
+      if test -n "$gentop"; then
+	func_show_eval '${RM}r "$gentop"'
+      fi
+
+      exit $EXIT_SUCCESS
+      ;;
+
+    prog)
+      case $host in
+	*cygwin*) func_stripname '' '.exe' "$output"
+	          output=$func_stripname_result.exe;;
+      esac
+      test -n "$vinfo" && \
+	func_warning "\`-version-info' is ignored for programs"
+
+      test -n "$release" && \
+	func_warning "\`-release' is ignored for programs"
+
+      test "$preload" = yes \
+        && test "$dlopen_support" = unknown \
+	&& test "$dlopen_self" = unknown \
+	&& test "$dlopen_self_static" = unknown && \
+	  func_warning "\`LT_INIT([dlopen])' not used. Assuming no dlopen support."
+
+      case $host in
+      *-*-rhapsody* | *-*-darwin1.[012])
+	# On Rhapsody replace the C library is the System framework
+	compile_deplibs=`$ECHO "X $compile_deplibs" | $Xsed -e 's/ -lc / System.ltframework /'`
+	finalize_deplibs=`$ECHO "X $finalize_deplibs" | $Xsed -e 's/ -lc / System.ltframework /'`
+	;;
+      esac
+
+      case $host in
+      *-*-darwin*)
+	# Don't allow lazy linking, it breaks C++ global constructors
+	# But is supposedly fixed on 10.4 or later (yay!).
+	if test "$tagname" = CXX ; then
+	  case ${MACOSX_DEPLOYMENT_TARGET-10.0} in
+	    10.[0123])
+	      compile_command="$compile_command ${wl}-bind_at_load"
+	      finalize_command="$finalize_command ${wl}-bind_at_load"
+	    ;;
+	  esac
+	fi
+	# Time to change all our "foo.ltframework" stuff back to "-framework foo"
+	compile_deplibs=`$ECHO "X $compile_deplibs" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	finalize_deplibs=`$ECHO "X $finalize_deplibs" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	;;
+      esac
+
+
+      # move library search paths that coincide with paths to not yet
+      # installed libraries to the beginning of the library search list
+      new_libs=
+      for path in $notinst_path; do
+	case " $new_libs " in
+	*" -L$path/$objdir "*) ;;
+	*)
+	  case " $compile_deplibs " in
+	  *" -L$path/$objdir "*)
+	    new_libs="$new_libs -L$path/$objdir" ;;
+	  esac
+	  ;;
+	esac
+      done
+      for deplib in $compile_deplibs; do
+	case $deplib in
+	-L*)
+	  case " $new_libs " in
+	  *" $deplib "*) ;;
+	  *) new_libs="$new_libs $deplib" ;;
+	  esac
+	  ;;
+	*) new_libs="$new_libs $deplib" ;;
+	esac
+      done
+      compile_deplibs="$new_libs"
+
+
+      compile_command="$compile_command $compile_deplibs"
+      finalize_command="$finalize_command $finalize_deplibs"
+
+      if test -n "$rpath$xrpath"; then
+	# If the user specified any rpath flags, then add them.
+	for libdir in $rpath $xrpath; do
+	  # This is the magic to use -rpath.
+	  case "$finalize_rpath " in
+	  *" $libdir "*) ;;
+	  *) finalize_rpath="$finalize_rpath $libdir" ;;
+	  esac
+	done
+      fi
+
+      # Now hardcode the library paths
+      rpath=
+      hardcode_libdirs=
+      for libdir in $compile_rpath $finalize_rpath; do
+	if test -n "$hardcode_libdir_flag_spec"; then
+	  if test -n "$hardcode_libdir_separator"; then
+	    if test -z "$hardcode_libdirs"; then
+	      hardcode_libdirs="$libdir"
+	    else
+	      # Just accumulate the unique libdirs.
+	      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in
+	      *"$hardcode_libdir_separator$libdir$hardcode_libdir_separator"*)
+		;;
+	      *)
+		hardcode_libdirs="$hardcode_libdirs$hardcode_libdir_separator$libdir"
+		;;
+	      esac
+	    fi
+	  else
+	    eval flag=\"$hardcode_libdir_flag_spec\"
+	    rpath="$rpath $flag"
+	  fi
+	elif test -n "$runpath_var"; then
+	  case "$perm_rpath " in
+	  *" $libdir "*) ;;
+	  *) perm_rpath="$perm_rpath $libdir" ;;
+	  esac
+	fi
+	case $host in
+	*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)
+	  testbindir=`${ECHO} "$libdir" | ${SED} -e 's*/lib$*/bin*'`
+	  case :$dllsearchpath: in
+	  *":$libdir:"*) ;;
+	  ::) dllsearchpath=$libdir;;
+	  *) dllsearchpath="$dllsearchpath:$libdir";;
+	  esac
+	  case :$dllsearchpath: in
+	  *":$testbindir:"*) ;;
+	  ::) dllsearchpath=$testbindir;;
+	  *) dllsearchpath="$dllsearchpath:$testbindir";;
+	  esac
+	  ;;
+	esac
+      done
+      # Substitute the hardcoded libdirs into the rpath.
+      if test -n "$hardcode_libdir_separator" &&
+	 test -n "$hardcode_libdirs"; then
+	libdir="$hardcode_libdirs"
+	eval rpath=\" $hardcode_libdir_flag_spec\"
+      fi
+      compile_rpath="$rpath"
+
+      rpath=
+      hardcode_libdirs=
+      for libdir in $finalize_rpath; do
+	if test -n "$hardcode_libdir_flag_spec"; then
+	  if test -n "$hardcode_libdir_separator"; then
+	    if test -z "$hardcode_libdirs"; then
+	      hardcode_libdirs="$libdir"
+	    else
+	      # Just accumulate the unique libdirs.
+	      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in
+	      *"$hardcode_libdir_separator$libdir$hardcode_libdir_separator"*)
+		;;
+	      *)
+		hardcode_libdirs="$hardcode_libdirs$hardcode_libdir_separator$libdir"
+		;;
+	      esac
+	    fi
+	  else
+	    eval flag=\"$hardcode_libdir_flag_spec\"
+	    rpath="$rpath $flag"
+	  fi
+	elif test -n "$runpath_var"; then
+	  case "$finalize_perm_rpath " in
+	  *" $libdir "*) ;;
+	  *) finalize_perm_rpath="$finalize_perm_rpath $libdir" ;;
+	  esac
+	fi
+      done
+      # Substitute the hardcoded libdirs into the rpath.
+      if test -n "$hardcode_libdir_separator" &&
+	 test -n "$hardcode_libdirs"; then
+	libdir="$hardcode_libdirs"
+	eval rpath=\" $hardcode_libdir_flag_spec\"
+      fi
+      finalize_rpath="$rpath"
+
+      if test -n "$libobjs" && test "$build_old_libs" = yes; then
+	# Transform all the library objects into standard objects.
+	compile_command=`$ECHO "X$compile_command" | $SP2NL | $Xsed -e "$lo2o" | $NL2SP`
+	finalize_command=`$ECHO "X$finalize_command" | $SP2NL | $Xsed -e "$lo2o" | $NL2SP`
+      fi
+
+      func_generate_dlsyms "$outputname" "@PROGRAM@" "no"
+
+      # template prelinking step
+      if test -n "$prelink_cmds"; then
+	func_execute_cmds "$prelink_cmds" 'exit $?'
+      fi
+
+      wrappers_required=yes
+      case $host in
+      *cygwin* | *mingw* )
+        if test "$build_libtool_libs" != yes; then
+          wrappers_required=no
+        fi
+        ;;
+      *cegcc)
+        # Disable wrappers for cegcc, we are cross compiling anyway.
+        wrappers_required=no
+        ;;
+      *)
+        if test "$need_relink" = no || test "$build_libtool_libs" != yes; then
+          wrappers_required=no
+        fi
+        ;;
+      esac
+      if test "$wrappers_required" = no; then
+	# Replace the output file specification.
+	compile_command=`$ECHO "X$compile_command" | $Xsed -e 's%@OUTPUT@%'"$output"'%g'`
+	link_command="$compile_command$compile_rpath"
+
+	# We have no uninstalled library dependencies, so finalize right now.
+	exit_status=0
+	func_show_eval "$link_command" 'exit_status=$?'
+
+	# Delete the generated files.
+	if test -f "$output_objdir/${outputname}S.${objext}"; then
+	  func_show_eval '$RM "$output_objdir/${outputname}S.${objext}"'
+	fi
+
+	exit $exit_status
+      fi
+
+      if test -n "$compile_shlibpath$finalize_shlibpath"; then
+	compile_command="$shlibpath_var=\"$compile_shlibpath$finalize_shlibpath\$$shlibpath_var\" $compile_command"
+      fi
+      if test -n "$finalize_shlibpath"; then
+	finalize_command="$shlibpath_var=\"$finalize_shlibpath\$$shlibpath_var\" $finalize_command"
+      fi
+
+      compile_var=
+      finalize_var=
+      if test -n "$runpath_var"; then
+	if test -n "$perm_rpath"; then
+	  # We should set the runpath_var.
+	  rpath=
+	  for dir in $perm_rpath; do
+	    rpath="$rpath$dir:"
+	  done
+	  compile_var="$runpath_var=\"$rpath\$$runpath_var\" "
+	fi
+	if test -n "$finalize_perm_rpath"; then
+	  # We should set the runpath_var.
+	  rpath=
+	  for dir in $finalize_perm_rpath; do
+	    rpath="$rpath$dir:"
+	  done
+	  finalize_var="$runpath_var=\"$rpath\$$runpath_var\" "
+	fi
+      fi
+
+      if test "$no_install" = yes; then
+	# We don't need to create a wrapper script.
+	link_command="$compile_var$compile_command$compile_rpath"
+	# Replace the output file specification.
+	link_command=`$ECHO "X$link_command" | $Xsed -e 's%@OUTPUT@%'"$output"'%g'`
+	# Delete the old output file.
+	$opt_dry_run || $RM $output
+	# Link the executable and exit
+	func_show_eval "$link_command" 'exit $?'
+	exit $EXIT_SUCCESS
+      fi
+
+      if test "$hardcode_action" = relink; then
+	# Fast installation is not supported
+	link_command="$compile_var$compile_command$compile_rpath"
+	relink_command="$finalize_var$finalize_command$finalize_rpath"
+
+	func_warning "this platform does not like uninstalled shared libraries"
+	func_warning "\`$output' will be relinked during installation"
+      else
+	if test "$fast_install" != no; then
+	  link_command="$finalize_var$compile_command$finalize_rpath"
+	  if test "$fast_install" = yes; then
+	    relink_command=`$ECHO "X$compile_var$compile_command$compile_rpath" | $Xsed -e 's%@OUTPUT@%\$progdir/\$file%g'`
+	  else
+	    # fast_install is set to needless
+	    relink_command=
+	  fi
+	else
+	  link_command="$compile_var$compile_command$compile_rpath"
+	  relink_command="$finalize_var$finalize_command$finalize_rpath"
+	fi
+      fi
+
+      # Replace the output file specification.
+      link_command=`$ECHO "X$link_command" | $Xsed -e 's%@OUTPUT@%'"$output_objdir/$outputname"'%g'`
+
+      # Delete the old output files.
+      $opt_dry_run || $RM $output $output_objdir/$outputname $output_objdir/lt-$outputname
+
+      func_show_eval "$link_command" 'exit $?'
+
+      # Now create the wrapper script.
+      func_verbose "creating $output"
+
+      # Quote the relink command for shipping.
+      if test -n "$relink_command"; then
+	# Preserve any variables that may affect compiler behavior
+	for var in $variables_saved_for_relink; do
+	  if eval test -z \"\${$var+set}\"; then
+	    relink_command="{ test -z \"\${$var+set}\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command"
+	  elif eval var_value=\$$var; test -z "$var_value"; then
+	    relink_command="$var=; export $var; $relink_command"
+	  else
+	    func_quote_for_eval "$var_value"
+	    relink_command="$var=$func_quote_for_eval_result; export $var; $relink_command"
+	  fi
+	done
+	relink_command="(cd `pwd`; $relink_command)"
+	relink_command=`$ECHO "X$relink_command" | $Xsed -e "$sed_quote_subst"`
+      fi
+
+      # Quote $ECHO for shipping.
+      if test "X$ECHO" = "X$SHELL $progpath --fallback-echo"; then
+	case $progpath in
+	[\\/]* | [A-Za-z]:[\\/]*) qecho="$SHELL $progpath --fallback-echo";;
+	*) qecho="$SHELL `pwd`/$progpath --fallback-echo";;
+	esac
+	qecho=`$ECHO "X$qecho" | $Xsed -e "$sed_quote_subst"`
+      else
+	qecho=`$ECHO "X$ECHO" | $Xsed -e "$sed_quote_subst"`
+      fi
+
+      # Only actually do things if not in dry run mode.
+      $opt_dry_run || {
+	# win32 will think the script is a binary if it has
+	# a .exe suffix, so we strip it off here.
+	case $output in
+	  *.exe) func_stripname '' '.exe' "$output"
+	         output=$func_stripname_result ;;
+	esac
+	# test for cygwin because mv fails w/o .exe extensions
+	case $host in
+	  *cygwin*)
+	    exeext=.exe
+	    func_stripname '' '.exe' "$outputname"
+	    outputname=$func_stripname_result ;;
+	  *) exeext= ;;
+	esac
+	case $host in
+	  *cygwin* | *mingw* )
+	    func_dirname_and_basename "$output" "" "."
+	    output_name=$func_basename_result
+	    output_path=$func_dirname_result
+	    cwrappersource="$output_path/$objdir/lt-$output_name.c"
+	    cwrapper="$output_path/$output_name.exe"
+	    $RM $cwrappersource $cwrapper
+	    trap "$RM $cwrappersource $cwrapper; exit $EXIT_FAILURE" 1 2 15
+
+	    func_emit_cwrapperexe_src > $cwrappersource
+
+	    # The wrapper executable is built using the $host compiler,
+	    # because it contains $host paths and files. If cross-
+	    # compiling, it, like the target executable, must be
+	    # executed on the $host or under an emulation environment.
+	    $opt_dry_run || {
+	      $LTCC $LTCFLAGS -o $cwrapper $cwrappersource
+	      $STRIP $cwrapper
+	    }
+
+	    # Now, create the wrapper script for func_source use:
+	    func_ltwrapper_scriptname $cwrapper
+	    $RM $func_ltwrapper_scriptname_result
+	    trap "$RM $func_ltwrapper_scriptname_result; exit $EXIT_FAILURE" 1 2 15
+	    $opt_dry_run || {
+	      # note: this script will not be executed, so do not chmod.
+	      if test "x$build" = "x$host" ; then
+		$cwrapper --lt-dump-script > $func_ltwrapper_scriptname_result
+	      else
+		func_emit_wrapper no > $func_ltwrapper_scriptname_result
+	      fi
+	    }
+	  ;;
+	  * )
+	    $RM $output
+	    trap "$RM $output; exit $EXIT_FAILURE" 1 2 15
+
+	    func_emit_wrapper no > $output
+	    chmod +x $output
+	  ;;
+	esac
+      }
+      exit $EXIT_SUCCESS
+      ;;
+    esac
+
+    # See if we need to build an old-fashioned archive.
+    for oldlib in $oldlibs; do
+
+      if test "$build_libtool_libs" = convenience; then
+	oldobjs="$libobjs_save $symfileobj"
+	addlibs="$convenience"
+	build_libtool_libs=no
+      else
+	if test "$build_libtool_libs" = module; then
+	  oldobjs="$libobjs_save"
+	  build_libtool_libs=no
+	else
+	  oldobjs="$old_deplibs $non_pic_objects"
+	  if test "$preload" = yes && test -f "$symfileobj"; then
+	    oldobjs="$oldobjs $symfileobj"
+	  fi
+	fi
+	addlibs="$old_convenience"
+      fi
+
+      if test -n "$addlibs"; then
+	gentop="$output_objdir/${outputname}x"
+	generated="$generated $gentop"
+
+	func_extract_archives $gentop $addlibs
+	oldobjs="$oldobjs $func_extract_archives_result"
+      fi
+
+      # Do each command in the archive commands.
+      if test -n "$old_archive_from_new_cmds" && test "$build_libtool_libs" = yes; then
+	cmds=$old_archive_from_new_cmds
+      else
+
+	# Add any objects from preloaded convenience libraries
+	if test -n "$dlprefiles"; then
+	  gentop="$output_objdir/${outputname}x"
+	  generated="$generated $gentop"
+
+	  func_extract_archives $gentop $dlprefiles
+	  oldobjs="$oldobjs $func_extract_archives_result"
+	fi
+
+	# POSIX demands no paths to be encoded in archives.  We have
+	# to avoid creating archives with duplicate basenames if we
+	# might have to extract them afterwards, e.g., when creating a
+	# static archive out of a convenience library, or when linking
+	# the entirety of a libtool archive into another (currently
+	# not supported by libtool).
+	if (for obj in $oldobjs
+	    do
+	      func_basename "$obj"
+	      $ECHO "$func_basename_result"
+	    done | sort | sort -uc >/dev/null 2>&1); then
+	  :
+	else
+	  $ECHO "copying selected object files to avoid basename conflicts..."
+	  gentop="$output_objdir/${outputname}x"
+	  generated="$generated $gentop"
+	  func_mkdir_p "$gentop"
+	  save_oldobjs=$oldobjs
+	  oldobjs=
+	  counter=1
+	  for obj in $save_oldobjs
+	  do
+	    func_basename "$obj"
+	    objbase="$func_basename_result"
+	    case " $oldobjs " in
+	    " ") oldobjs=$obj ;;
+	    *[\ /]"$objbase "*)
+	      while :; do
+		# Make sure we don't pick an alternate name that also
+		# overlaps.
+		newobj=lt$counter-$objbase
+		func_arith $counter + 1
+		counter=$func_arith_result
+		case " $oldobjs " in
+		*[\ /]"$newobj "*) ;;
+		*) if test ! -f "$gentop/$newobj"; then break; fi ;;
+		esac
+	      done
+	      func_show_eval "ln $obj $gentop/$newobj || cp $obj $gentop/$newobj"
+	      oldobjs="$oldobjs $gentop/$newobj"
+	      ;;
+	    *) oldobjs="$oldobjs $obj" ;;
+	    esac
+	  done
+	fi
+	eval cmds=\"$old_archive_cmds\"
+
+	func_len " $cmds"
+	len=$func_len_result
+	if test "$len" -lt "$max_cmd_len" || test "$max_cmd_len" -le -1; then
+	  cmds=$old_archive_cmds
+	else
+	  # the command line is too long to link in one step, link in parts
+	  func_verbose "using piecewise archive linking..."
+	  save_RANLIB=$RANLIB
+	  RANLIB=:
+	  objlist=
+	  concat_cmds=
+	  save_oldobjs=$oldobjs
+	  oldobjs=
+	  # Is there a better way of finding the last object in the list?
+	  for obj in $save_oldobjs
+	  do
+	    last_oldobj=$obj
+	  done
+	  eval test_cmds=\"$old_archive_cmds\"
+	  func_len " $test_cmds"
+	  len0=$func_len_result
+	  len=$len0
+	  for obj in $save_oldobjs
+	  do
+	    func_len " $obj"
+	    func_arith $len + $func_len_result
+	    len=$func_arith_result
+	    func_append objlist " $obj"
+	    if test "$len" -lt "$max_cmd_len"; then
+	      :
+	    else
+	      # the above command should be used before it gets too long
+	      oldobjs=$objlist
+	      if test "$obj" = "$last_oldobj" ; then
+		RANLIB=$save_RANLIB
+	      fi
+	      test -z "$concat_cmds" || concat_cmds=$concat_cmds~
+	      eval concat_cmds=\"\${concat_cmds}$old_archive_cmds\"
+	      objlist=
+	      len=$len0
+	    fi
+	  done
+	  RANLIB=$save_RANLIB
+	  oldobjs=$objlist
+	  if test "X$oldobjs" = "X" ; then
+	    eval cmds=\"\$concat_cmds\"
+	  else
+	    eval cmds=\"\$concat_cmds~\$old_archive_cmds\"
+	  fi
+	fi
+      fi
+      func_execute_cmds "$cmds" 'exit $?'
+    done
+
+    test -n "$generated" && \
+      func_show_eval "${RM}r$generated"
+
+    # Now create the libtool archive.
+    case $output in
+    *.la)
+      old_library=
+      test "$build_old_libs" = yes && old_library="$libname.$libext"
+      func_verbose "creating $output"
+
+      # Preserve any variables that may affect compiler behavior
+      for var in $variables_saved_for_relink; do
+	if eval test -z \"\${$var+set}\"; then
+	  relink_command="{ test -z \"\${$var+set}\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command"
+	elif eval var_value=\$$var; test -z "$var_value"; then
+	  relink_command="$var=; export $var; $relink_command"
+	else
+	  func_quote_for_eval "$var_value"
+	  relink_command="$var=$func_quote_for_eval_result; export $var; $relink_command"
+	fi
+      done
+      # Quote the link command for shipping.
+      relink_command="(cd `pwd`; $SHELL $progpath $preserve_args --mode=relink $libtool_args @inst_prefix_dir@)"
+      relink_command=`$ECHO "X$relink_command" | $Xsed -e "$sed_quote_subst"`
+      if test "$hardcode_automatic" = yes ; then
+	relink_command=
+      fi
+
+      # Only create the output if not a dry run.
+      $opt_dry_run || {
+	for installed in no yes; do
+	  if test "$installed" = yes; then
+	    if test -z "$install_libdir"; then
+	      break
+	    fi
+	    output="$output_objdir/$outputname"i
+	    # Replace all uninstalled libtool libraries with the installed ones
+	    newdependency_libs=
+	    for deplib in $dependency_libs; do
+	      case $deplib in
+	      *.la)
+		func_basename "$deplib"
+		name="$func_basename_result"
+		eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $deplib`
+		test -z "$libdir" && \
+		  func_fatal_error "\`$deplib' is not a valid libtool archive"
+		newdependency_libs="$newdependency_libs $libdir/$name"
+		;;
+	      *) newdependency_libs="$newdependency_libs $deplib" ;;
+	      esac
+	    done
+	    dependency_libs="$newdependency_libs"
+	    newdlfiles=
+
+	    for lib in $dlfiles; do
+	      case $lib in
+	      *.la)
+	        func_basename "$lib"
+		name="$func_basename_result"
+		eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $lib`
+		test -z "$libdir" && \
+		  func_fatal_error "\`$lib' is not a valid libtool archive"
+		newdlfiles="$newdlfiles $libdir/$name"
+		;;
+	      *) newdlfiles="$newdlfiles $lib" ;;
+	      esac
+	    done
+	    dlfiles="$newdlfiles"
+	    newdlprefiles=
+	    for lib in $dlprefiles; do
+	      case $lib in
+	      *.la)
+		# Only pass preopened files to the pseudo-archive (for
+		# eventual linking with the app. that links it) if we
+		# didn't already link the preopened objects directly into
+		# the library:
+		func_basename "$lib"
+		name="$func_basename_result"
+		eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $lib`
+		test -z "$libdir" && \
+		  func_fatal_error "\`$lib' is not a valid libtool archive"
+		newdlprefiles="$newdlprefiles $libdir/$name"
+		;;
+	      esac
+	    done
+	    dlprefiles="$newdlprefiles"
+	  else
+	    newdlfiles=
+	    for lib in $dlfiles; do
+	      case $lib in
+		[\\/]* | [A-Za-z]:[\\/]*) abs="$lib" ;;
+		*) abs=`pwd`"/$lib" ;;
+	      esac
+	      newdlfiles="$newdlfiles $abs"
+	    done
+	    dlfiles="$newdlfiles"
+	    newdlprefiles=
+	    for lib in $dlprefiles; do
+	      case $lib in
+		[\\/]* | [A-Za-z]:[\\/]*) abs="$lib" ;;
+		*) abs=`pwd`"/$lib" ;;
+	      esac
+	      newdlprefiles="$newdlprefiles $abs"
+	    done
+	    dlprefiles="$newdlprefiles"
+	  fi
+	  $RM $output
+	  # place dlname in correct position for cygwin
+	  tdlname=$dlname
+	  case $host,$output,$installed,$module,$dlname in
+	    *cygwin*,*lai,yes,no,*.dll | *mingw*,*lai,yes,no,*.dll | *cegcc*,*lai,yes,no,*.dll) tdlname=../bin/$dlname ;;
+	  esac
+	  $ECHO > $output "\
+# $outputname - a libtool library file
+# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION
+#
+# Please DO NOT delete this file!
+# It is necessary for linking the library.
+
+# The name that we can dlopen(3).
+dlname='$tdlname'
+
+# Names of this library.
+library_names='$library_names'
+
+# The name of the static archive.
+old_library='$old_library'
+
+# Linker flags that can not go in dependency_libs.
+inherited_linker_flags='$new_inherited_linker_flags'
+
+# Libraries that this one depends upon.
+dependency_libs='$dependency_libs'
+
+# Names of additional weak libraries provided by this library
+weak_library_names='$weak_libs'
+
+# Version information for $libname.
+current=$current
+age=$age
+revision=$revision
+
+# Is this an already installed library?
+installed=$installed
+
+# Should we warn about portability when linking against -modules?
+shouldnotlink=$module
+
+# Files to dlopen/dlpreopen
+dlopen='$dlfiles'
+dlpreopen='$dlprefiles'
+
+# Directory that this library needs to be installed in:
+libdir='$install_libdir'"
+	  if test "$installed" = no && test "$need_relink" = yes; then
+	    $ECHO >> $output "\
+relink_command=\"$relink_command\""
+	  fi
+	done
+      }
+
+      # Do a symbolic link so that the libtool archive can be found in
+      # LD_LIBRARY_PATH before the program is installed.
+      func_show_eval '( cd "$output_objdir" && $RM "$outputname" && $LN_S "../$outputname" "$outputname" )' 'exit $?'
+      ;;
+    esac
+    exit $EXIT_SUCCESS
+}
+
+{ test "$mode" = link || test "$mode" = relink; } &&
+    func_mode_link ${1+"$@"}
+
+
+# func_mode_uninstall arg...
+func_mode_uninstall ()
+{
+    $opt_debug
+    RM="$nonopt"
+    files=
+    rmforce=
+    exit_status=0
+
+    # This variable tells wrapper scripts just to set variables rather
+    # than running their programs.
+    libtool_install_magic="$magic"
+
+    for arg
+    do
+      case $arg in
+      -f) RM="$RM $arg"; rmforce=yes ;;
+      -*) RM="$RM $arg" ;;
+      *) files="$files $arg" ;;
+      esac
+    done
+
+    test -z "$RM" && \
+      func_fatal_help "you must specify an RM program"
+
+    rmdirs=
+
+    origobjdir="$objdir"
+    for file in $files; do
+      func_dirname "$file" "" "."
+      dir="$func_dirname_result"
+      if test "X$dir" = X.; then
+	objdir="$origobjdir"
+      else
+	objdir="$dir/$origobjdir"
+      fi
+      func_basename "$file"
+      name="$func_basename_result"
+      test "$mode" = uninstall && objdir="$dir"
+
+      # Remember objdir for removal later, being careful to avoid duplicates
+      if test "$mode" = clean; then
+	case " $rmdirs " in
+	  *" $objdir "*) ;;
+	  *) rmdirs="$rmdirs $objdir" ;;
+	esac
+      fi
+
+      # Don't error if the file doesn't exist and rm -f was used.
+      if { test -L "$file"; } >/dev/null 2>&1 ||
+	 { test -h "$file"; } >/dev/null 2>&1 ||
+	 test -f "$file"; then
+	:
+      elif test -d "$file"; then
+	exit_status=1
+	continue
+      elif test "$rmforce" = yes; then
+	continue
+      fi
+
+      rmfiles="$file"
+
+      case $name in
+      *.la)
+	# Possibly a libtool archive, so verify it.
+	if func_lalib_p "$file"; then
+	  func_source $dir/$name
+
+	  # Delete the libtool libraries and symlinks.
+	  for n in $library_names; do
+	    rmfiles="$rmfiles $objdir/$n"
+	  done
+	  test -n "$old_library" && rmfiles="$rmfiles $objdir/$old_library"
+
+	  case "$mode" in
+	  clean)
+	    case "  $library_names " in
+	    # "  " in the beginning catches empty $dlname
+	    *" $dlname "*) ;;
+	    *) rmfiles="$rmfiles $objdir/$dlname" ;;
+	    esac
+	    test -n "$libdir" && rmfiles="$rmfiles $objdir/$name $objdir/${name}i"
+	    ;;
+	  uninstall)
+	    if test -n "$library_names"; then
+	      # Do each command in the postuninstall commands.
+	      func_execute_cmds "$postuninstall_cmds" 'test "$rmforce" = yes || exit_status=1'
+	    fi
+
+	    if test -n "$old_library"; then
+	      # Do each command in the old_postuninstall commands.
+	      func_execute_cmds "$old_postuninstall_cmds" 'test "$rmforce" = yes || exit_status=1'
+	    fi
+	    # FIXME: should reinstall the best remaining shared library.
+	    ;;
+	  esac
+	fi
+	;;
+
+      *.lo)
+	# Possibly a libtool object, so verify it.
+	if func_lalib_p "$file"; then
+
+	  # Read the .lo file
+	  func_source $dir/$name
+
+	  # Add PIC object to the list of files to remove.
+	  if test -n "$pic_object" &&
+	     test "$pic_object" != none; then
+	    rmfiles="$rmfiles $dir/$pic_object"
+	  fi
+
+	  # Add non-PIC object to the list of files to remove.
+	  if test -n "$non_pic_object" &&
+	     test "$non_pic_object" != none; then
+	    rmfiles="$rmfiles $dir/$non_pic_object"
+	  fi
+	fi
+	;;
+
+      *)
+	if test "$mode" = clean ; then
+	  noexename=$name
+	  case $file in
+	  *.exe)
+	    func_stripname '' '.exe' "$file"
+	    file=$func_stripname_result
+	    func_stripname '' '.exe' "$name"
+	    noexename=$func_stripname_result
+	    # $file with .exe has already been added to rmfiles,
+	    # add $file without .exe
+	    rmfiles="$rmfiles $file"
+	    ;;
+	  esac
+	  # Do a test to see if this is a libtool program.
+	  if func_ltwrapper_p "$file"; then
+	    if func_ltwrapper_executable_p "$file"; then
+	      func_ltwrapper_scriptname "$file"
+	      relink_command=
+	      func_source $func_ltwrapper_scriptname_result
+	      rmfiles="$rmfiles $func_ltwrapper_scriptname_result"
+	    else
+	      relink_command=
+	      func_source $dir/$noexename
+	    fi
+
+	    # note $name still contains .exe if it was in $file originally
+	    # as does the version of $file that was added into $rmfiles
+	    rmfiles="$rmfiles $objdir/$name $objdir/${name}S.${objext}"
+	    if test "$fast_install" = yes && test -n "$relink_command"; then
+	      rmfiles="$rmfiles $objdir/lt-$name"
+	    fi
+	    if test "X$noexename" != "X$name" ; then
+	      rmfiles="$rmfiles $objdir/lt-${noexename}.c"
+	    fi
+	  fi
+	fi
+	;;
+      esac
+      func_show_eval "$RM $rmfiles" 'exit_status=1'
+    done
+    objdir="$origobjdir"
+
+    # Try to remove the ${objdir}s in the directories where we deleted files
+    for dir in $rmdirs; do
+      if test -d "$dir"; then
+	func_show_eval "rmdir $dir >/dev/null 2>&1"
+      fi
+    done
+
+    exit $exit_status
+}
+
+{ test "$mode" = uninstall || test "$mode" = clean; } &&
+    func_mode_uninstall ${1+"$@"}
+
+test -z "$mode" && {
+  help="$generic_help"
+  func_fatal_help "you must specify a MODE"
+}
+
+test -z "$exec_cmd" && \
+  func_fatal_help "invalid operation mode \`$mode'"
+
+if test -n "$exec_cmd"; then
+  eval exec "$exec_cmd"
+  exit $EXIT_FAILURE
+fi
+
+exit $exit_status
+
+
+# The TAGs below are defined such that we never get into a situation
+# in which we disable both kinds of libraries.  Given conflicting
+# choices, we go for a static library, that is the most portable,
+# since we can't tell whether shared libraries were disabled because
+# the user asked for that or because the platform doesn't support
+# them.  This is particularly important on AIX, because we don't
+# support having both static and shared libraries enabled at the same
+# time on that platform, so we default to a shared-only configuration.
+# If a disable-shared tag is given, we'll fallback to a static-only
+# configuration.  But we'll never go from static-only to shared-only.
+
+# ### BEGIN LIBTOOL TAG CONFIG: disable-shared
+build_libtool_libs=no
+build_old_libs=yes
+# ### END LIBTOOL TAG CONFIG: disable-shared
+
+# ### BEGIN LIBTOOL TAG CONFIG: disable-static
+build_old_libs=`case $build_libtool_libs in yes) echo no;; *) echo yes;; esac`
+# ### END LIBTOOL TAG CONFIG: disable-static
+
+# Local Variables:
+# mode:shell-script
+# sh-indentation:2
+# End:
+# vi:sw=2
+
diff -urN dovecot-1.2.4/dovecot-libsieve/Makefile.am dovecot-1.2.4.debian/dovecot-libsieve/Makefile.am
--- dovecot-1.2.4/dovecot-libsieve/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/Makefile.am	2009-08-21 00:52:15.000000000 +0200
@@ -0,0 +1,128 @@
+SUBDIRS = src
+
+unfinished = doc/man/sieve-filter.1
+
+if BUILD_UNFINISHED
+unfinished_mans = $(unfinished)
+else
+unfinished_dist = $(unfinished)
+endif
+
+EXTRA_DIST = \
+	tests \
+	examples/* \
+	doc/rfc \
+	doc/devel \
+	COPYING.LGPL \
+	ChangeLog \
+	$(unfinished_dist)
+
+dist_man_MANS = \
+	doc/man/sievec.1 \
+	doc/man/sieved.1 \
+	doc/man/sieve-test.1 \
+	$(unfinished_mans)
+
+if MAINTAINER_MODE
+ChangeLog: .hg/dirstate
+	hg log --style=changelog > ChangeLog
+endif
+
+# Testsuite tests
+
+TESTSUITE_BIN = $(top_srcdir)/src/testsuite/testsuite
+
+if TESTSUITE_VALGRIND
+TEST_BIN = valgrind -q --error-exitcode=1 --show-reachable=yes --leak-check=full $(TESTSUITE_BIN) 
+else
+TEST_BIN = $(TESTSUITE_BIN)
+endif
+
+test_cases = \
+	tests/testsuite.svtest\
+	tests/control-structures.svtest \
+	tests/compile/compile.svtest \
+	tests/compile/errors.svtest \
+	tests/execute/errors.svtest \
+	tests/execute/actions.svtest \
+	tests/execute/smtp.svtest \
+	tests/execute/mailstore.svtest \
+	tests/execute/examples.svtest \
+	tests/exists.svtest \
+	tests/header.svtest \
+	tests/address.svtest \
+	tests/lexer.svtest \
+	tests/comparators/core.svtest \
+	tests/match-types/is.svtest \
+	tests/match-types/contains.svtest \
+	tests/match-types/matches.svtest \
+	tests/extensions/encoded-character.svtest \
+	tests/extensions/envelope.svtest \
+	tests/extensions/variables/basic.svtest \
+	tests/extensions/variables/match.svtest \
+	tests/extensions/variables/modifiers.svtest \
+	tests/extensions/variables/quoting.svtest \
+	tests/extensions/variables/string.svtest \
+	tests/extensions/variables/errors.svtest \
+	tests/extensions/variables/regex.svtest \
+	tests/extensions/include/errors.svtest \
+	tests/extensions/include/variables.svtest \
+	tests/extensions/include/once.svtest \
+	tests/extensions/include/twice.svtest \
+	tests/extensions/include/rfc.svtest \
+	tests/extensions/include/execute.svtest \
+	tests/extensions/imap4flags/basic.svtest \
+	tests/extensions/imap4flags/hasflag.svtest \
+	tests/extensions/imap4flags/errors.svtest \
+	tests/extensions/imap4flags/execute.svtest \
+	tests/extensions/imap4flags/flagstore.svtest \
+	tests/extensions/body/basic.svtest \
+	tests/extensions/body/match-values.svtest \
+	tests/extensions/regex/basic.svtest \
+	tests/extensions/regex/match-values.svtest \
+	tests/extensions/regex/errors.svtest \
+	tests/extensions/reject/execute.svtest \
+	tests/extensions/reject/smtp.svtest \
+	tests/extensions/relational/basic.svtest \
+	tests/extensions/relational/rfc.svtest \
+	tests/extensions/relational/errors.svtest \
+	tests/extensions/subaddress/basic.svtest \
+	tests/extensions/subaddress/rfc.svtest \
+	tests/extensions/vacation/errors.svtest \
+	tests/extensions/vacation/execute.svtest \
+	tests/extensions/vacation/message.svtest \
+	tests/extensions/vacation/smtp.svtest \
+	tests/extensions/enotify/basic.svtest \
+	tests/extensions/enotify/encodeurl.svtest \
+	tests/extensions/enotify/valid_notify_method.svtest \
+	tests/extensions/enotify/notify_method_capability.svtest \
+	tests/extensions/enotify/errors.svtest \
+	tests/extensions/enotify/execute.svtest \
+	tests/extensions/enotify/mailto.svtest \
+	tests/extensions/environment/basic.svtest \
+	tests/extensions/environment/rfc.svtest \
+	tests/extensions/mailbox/execute.svtest \
+	tests/extensions/date/basic.svtest \
+	tests/extensions/date/date-parts.svtest \
+	tests/extensions/date/zones.svtest \
+	tests/multiscript/basic.svtest \
+	tests/deprecated/notify/basic.svtest \
+	tests/deprecated/notify/mailto.svtest \
+	tests/deprecated/notify/errors.svtest \
+	tests/deprecated/notify/execute.svtest
+
+if HAVE_DOVECOT_LIBS
+
+$(test_cases):
+	@$(TEST_BIN) $@
+
+.PHONY: $(test_cases)
+
+test: $(test_cases)
+
+else
+
+test:
+	@echo "Cannot compile or execute the testsuite without the Dovecot sources."
+
+endif	
diff -urN dovecot-1.2.4/dovecot-libsieve/missing dovecot-1.2.4.debian/dovecot-libsieve/missing
--- dovecot-1.2.4/dovecot-libsieve/missing	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/missing	2008-07-18 12:31:10.000000000 +0200
@@ -0,0 +1,367 @@
+#! /bin/sh
+# Common stub for a few missing GNU programs while installing.
+
+scriptversion=2006-05-10.23
+
+# Copyright (C) 1996, 1997, 1999, 2000, 2002, 2003, 2004, 2005, 2006
+#   Free Software Foundation, Inc.
+# Originally by Fran,cois Pinard <pinard@iro.umontreal.ca>, 1996.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+# 02110-1301, USA.
+
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+if test $# -eq 0; then
+  echo 1>&2 "Try \`$0 --help' for more information"
+  exit 1
+fi
+
+run=:
+sed_output='s/.* --output[ =]\([^ ]*\).*/\1/p'
+sed_minuso='s/.* -o \([^ ]*\).*/\1/p'
+
+# In the cases where this matters, `missing' is being run in the
+# srcdir already.
+if test -f configure.ac; then
+  configure_ac=configure.ac
+else
+  configure_ac=configure.in
+fi
+
+msg="missing on your system"
+
+case $1 in
+--run)
+  # Try to run requested program, and just exit if it succeeds.
+  run=
+  shift
+  "$@" && exit 0
+  # Exit code 63 means version mismatch.  This often happens
+  # when the user try to use an ancient version of a tool on
+  # a file that requires a minimum version.  In this case we
+  # we should proceed has if the program had been absent, or
+  # if --run hadn't been passed.
+  if test $? = 63; then
+    run=:
+    msg="probably too old"
+  fi
+  ;;
+
+  -h|--h|--he|--hel|--help)
+    echo "\
+$0 [OPTION]... PROGRAM [ARGUMENT]...
+
+Handle \`PROGRAM [ARGUMENT]...' for when PROGRAM is missing, or return an
+error status if there is no known handling for PROGRAM.
+
+Options:
+  -h, --help      display this help and exit
+  -v, --version   output version information and exit
+  --run           try to run the given command, and emulate it if it fails
+
+Supported PROGRAM values:
+  aclocal      touch file \`aclocal.m4'
+  autoconf     touch file \`configure'
+  autoheader   touch file \`config.h.in'
+  autom4te     touch the output file, or create a stub one
+  automake     touch all \`Makefile.in' files
+  bison        create \`y.tab.[ch]', if possible, from existing .[ch]
+  flex         create \`lex.yy.c', if possible, from existing .c
+  help2man     touch the output file
+  lex          create \`lex.yy.c', if possible, from existing .c
+  makeinfo     touch the output file
+  tar          try tar, gnutar, gtar, then tar without non-portable flags
+  yacc         create \`y.tab.[ch]', if possible, from existing .[ch]
+
+Send bug reports to <bug-automake@gnu.org>."
+    exit $?
+    ;;
+
+  -v|--v|--ve|--ver|--vers|--versi|--versio|--version)
+    echo "missing $scriptversion (GNU Automake)"
+    exit $?
+    ;;
+
+  -*)
+    echo 1>&2 "$0: Unknown \`$1' option"
+    echo 1>&2 "Try \`$0 --help' for more information"
+    exit 1
+    ;;
+
+esac
+
+# Now exit if we have it, but it failed.  Also exit now if we
+# don't have it and --version was passed (most likely to detect
+# the program).
+case $1 in
+  lex|yacc)
+    # Not GNU programs, they don't have --version.
+    ;;
+
+  tar)
+    if test -n "$run"; then
+       echo 1>&2 "ERROR: \`tar' requires --run"
+       exit 1
+    elif test "x$2" = "x--version" || test "x$2" = "x--help"; then
+       exit 1
+    fi
+    ;;
+
+  *)
+    if test -z "$run" && ($1 --version) > /dev/null 2>&1; then
+       # We have it, but it failed.
+       exit 1
+    elif test "x$2" = "x--version" || test "x$2" = "x--help"; then
+       # Could not run --version or --help.  This is probably someone
+       # running `$TOOL --version' or `$TOOL --help' to check whether
+       # $TOOL exists and not knowing $TOOL uses missing.
+       exit 1
+    fi
+    ;;
+esac
+
+# If it does not exist, or fails to run (possibly an outdated version),
+# try to emulate it.
+case $1 in
+  aclocal*)
+    echo 1>&2 "\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified \`acinclude.m4' or \`${configure_ac}'.  You might want
+         to install the \`Automake' and \`Perl' packages.  Grab them from
+         any GNU archive site."
+    touch aclocal.m4
+    ;;
+
+  autoconf)
+    echo 1>&2 "\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified \`${configure_ac}'.  You might want to install the
+         \`Autoconf' and \`GNU m4' packages.  Grab them from any GNU
+         archive site."
+    touch configure
+    ;;
+
+  autoheader)
+    echo 1>&2 "\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified \`acconfig.h' or \`${configure_ac}'.  You might want
+         to install the \`Autoconf' and \`GNU m4' packages.  Grab them
+         from any GNU archive site."
+    files=`sed -n 's/^[ ]*A[CM]_CONFIG_HEADER(\([^)]*\)).*/\1/p' ${configure_ac}`
+    test -z "$files" && files="config.h"
+    touch_files=
+    for f in $files; do
+      case $f in
+      *:*) touch_files="$touch_files "`echo "$f" |
+				       sed -e 's/^[^:]*://' -e 's/:.*//'`;;
+      *) touch_files="$touch_files $f.in";;
+      esac
+    done
+    touch $touch_files
+    ;;
+
+  automake*)
+    echo 1>&2 "\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified \`Makefile.am', \`acinclude.m4' or \`${configure_ac}'.
+         You might want to install the \`Automake' and \`Perl' packages.
+         Grab them from any GNU archive site."
+    find . -type f -name Makefile.am -print |
+	   sed 's/\.am$/.in/' |
+	   while read f; do touch "$f"; done
+    ;;
+
+  autom4te)
+    echo 1>&2 "\
+WARNING: \`$1' is needed, but is $msg.
+         You might have modified some files without having the
+         proper tools for further handling them.
+         You can get \`$1' as part of \`Autoconf' from any GNU
+         archive site."
+
+    file=`echo "$*" | sed -n "$sed_output"`
+    test -z "$file" && file=`echo "$*" | sed -n "$sed_minuso"`
+    if test -f "$file"; then
+	touch $file
+    else
+	test -z "$file" || exec >$file
+	echo "#! /bin/sh"
+	echo "# Created by GNU Automake missing as a replacement of"
+	echo "#  $ $@"
+	echo "exit 0"
+	chmod +x $file
+	exit 1
+    fi
+    ;;
+
+  bison|yacc)
+    echo 1>&2 "\
+WARNING: \`$1' $msg.  You should only need it if
+         you modified a \`.y' file.  You may need the \`Bison' package
+         in order for those modifications to take effect.  You can get
+         \`Bison' from any GNU archive site."
+    rm -f y.tab.c y.tab.h
+    if test $# -ne 1; then
+        eval LASTARG="\${$#}"
+	case $LASTARG in
+	*.y)
+	    SRCFILE=`echo "$LASTARG" | sed 's/y$/c/'`
+	    if test -f "$SRCFILE"; then
+	         cp "$SRCFILE" y.tab.c
+	    fi
+	    SRCFILE=`echo "$LASTARG" | sed 's/y$/h/'`
+	    if test -f "$SRCFILE"; then
+	         cp "$SRCFILE" y.tab.h
+	    fi
+	  ;;
+	esac
+    fi
+    if test ! -f y.tab.h; then
+	echo >y.tab.h
+    fi
+    if test ! -f y.tab.c; then
+	echo 'main() { return 0; }' >y.tab.c
+    fi
+    ;;
+
+  lex|flex)
+    echo 1>&2 "\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified a \`.l' file.  You may need the \`Flex' package
+         in order for those modifications to take effect.  You can get
+         \`Flex' from any GNU archive site."
+    rm -f lex.yy.c
+    if test $# -ne 1; then
+        eval LASTARG="\${$#}"
+	case $LASTARG in
+	*.l)
+	    SRCFILE=`echo "$LASTARG" | sed 's/l$/c/'`
+	    if test -f "$SRCFILE"; then
+	         cp "$SRCFILE" lex.yy.c
+	    fi
+	  ;;
+	esac
+    fi
+    if test ! -f lex.yy.c; then
+	echo 'main() { return 0; }' >lex.yy.c
+    fi
+    ;;
+
+  help2man)
+    echo 1>&2 "\
+WARNING: \`$1' is $msg.  You should only need it if
+	 you modified a dependency of a manual page.  You may need the
+	 \`Help2man' package in order for those modifications to take
+	 effect.  You can get \`Help2man' from any GNU archive site."
+
+    file=`echo "$*" | sed -n "$sed_output"`
+    test -z "$file" && file=`echo "$*" | sed -n "$sed_minuso"`
+    if test -f "$file"; then
+	touch $file
+    else
+	test -z "$file" || exec >$file
+	echo ".ab help2man is required to generate this page"
+	exit 1
+    fi
+    ;;
+
+  makeinfo)
+    echo 1>&2 "\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified a \`.texi' or \`.texinfo' file, or any other file
+         indirectly affecting the aspect of the manual.  The spurious
+         call might also be the consequence of using a buggy \`make' (AIX,
+         DU, IRIX).  You might want to install the \`Texinfo' package or
+         the \`GNU make' package.  Grab either from any GNU archive site."
+    # The file to touch is that specified with -o ...
+    file=`echo "$*" | sed -n "$sed_output"`
+    test -z "$file" && file=`echo "$*" | sed -n "$sed_minuso"`
+    if test -z "$file"; then
+      # ... or it is the one specified with @setfilename ...
+      infile=`echo "$*" | sed 's/.* \([^ ]*\) *$/\1/'`
+      file=`sed -n '
+	/^@setfilename/{
+	  s/.* \([^ ]*\) *$/\1/
+	  p
+	  q
+	}' $infile`
+      # ... or it is derived from the source name (dir/f.texi becomes f.info)
+      test -z "$file" && file=`echo "$infile" | sed 's,.*/,,;s,.[^.]*$,,'`.info
+    fi
+    # If the file does not exist, the user really needs makeinfo;
+    # let's fail without touching anything.
+    test -f $file || exit 1
+    touch $file
+    ;;
+
+  tar)
+    shift
+
+    # We have already tried tar in the generic part.
+    # Look for gnutar/gtar before invocation to avoid ugly error
+    # messages.
+    if (gnutar --version > /dev/null 2>&1); then
+       gnutar "$@" && exit 0
+    fi
+    if (gtar --version > /dev/null 2>&1); then
+       gtar "$@" && exit 0
+    fi
+    firstarg="$1"
+    if shift; then
+	case $firstarg in
+	*o*)
+	    firstarg=`echo "$firstarg" | sed s/o//`
+	    tar "$firstarg" "$@" && exit 0
+	    ;;
+	esac
+	case $firstarg in
+	*h*)
+	    firstarg=`echo "$firstarg" | sed s/h//`
+	    tar "$firstarg" "$@" && exit 0
+	    ;;
+	esac
+    fi
+
+    echo 1>&2 "\
+WARNING: I can't seem to be able to run \`tar' with the given arguments.
+         You may want to install GNU tar or Free paxutils, or check the
+         command line arguments."
+    exit 1
+    ;;
+
+  *)
+    echo 1>&2 "\
+WARNING: \`$1' is needed, and is $msg.
+         You might have modified some files without having the
+         proper tools for further handling them.  Check the \`README' file,
+         it often tells you about the needed prerequisites for installing
+         this package.  You may also peek at any GNU archive site, in case
+         some other package would contain this missing \`$1' program."
+    exit 1
+    ;;
+esac
+
+exit 0
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "scriptversion="
+# time-stamp-format: "%:y-%02m-%02d.%02H"
+# time-stamp-end: "$"
+# End:
diff -urN dovecot-1.2.4/dovecot-libsieve/NEWS dovecot-1.2.4.debian/dovecot-libsieve/NEWS
--- dovecot-1.2.4/dovecot-libsieve/NEWS	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/NEWS	2009-08-21 01:04:01.000000000 +0200
@@ -0,0 +1,253 @@
+v0.1.12 21-08-2009 Stephan Bosch <stephan@rename-it.nl>
+
+	+ Testsuite: added support for testing binaries stored on disk.
+	+ Implemented the new date extension. This allows matching against date
+	  values in header fields and the current date at the time of script
+	  evaluation.
+
+v0.1.11 08-08-2009 Stephan Bosch <stephan@rename-it.nl>
+
+	+ Built skeleton implementation for the date extension (RFC 5260). It
+	  compiles, but it does not do anything useful yet. Therefore, it is not
+	  part of the default compilation. 
+	- Fixed ARM portability issues caused by char type not being signed on that
+	  platform. Reading optional operands from a binary would fail for action
+	  side effects.	Also, an accidental mixup of an int return type with bool
+	  caused the interpreter to continue on ARM even though an error occured.  
+	- Removed direct stdint.h includes to prevent portability issues.
+	- Fixed segfault bug in the handling of script open failures.
+	- Include: improved user error messages and system log messages.
+	- Fixed copy-paste mixup between sieve_after and sieve_before settings in the
+	  LDA Sieve plugin. If only a sieve_after script was active, nothing would 
+	  have been executed. Patch by Mike Abbott.
+	- Include: fixed a bug in HOME substitution in the sieve_dir path. Surfaced
+	  in ManageSieve.
+
+v0.1.10 03-08-2009 Stephan Bosch <stephan@rename-it.nl>
+
+	* Changed action execution of fileinto and keep. These changes depend on
+	  API additions in Dovecot, making this release depend on Dovecot v1.2.2 
+	  or newer.
+	* Further developed the sieve-filter command line tool. This required a few
+	  changes to the action execution of the Sieve engine. The tool was 
+	  successfully tested on folders with a few 100k spam messages. However, 
+	  the commandline options are still incomplete, a man page is missing and it
+	  needs much more testing before I can recommend anyone to use this tool. 
+	+ Added support for the mailbox extension. This allows checking whether a 
+	  mailbox exists using the mailboxexists command and it adds the :create 
+	  argument to the fileinto command to create the mailbox when it is missing. 
+	  The :create feature is useless unless the Deliver LDA is run with the -n 
+	  option.
+	+ Improved the testsuite with tests for message delivery. Messages stored
+	  using keep and fileinto can be fed back into the Sieve engine for
+	  verification. This includes testing of applied IMAP flags.
+	+ Updated the man pages with the new method of specifying the supported 
+	  extensions using + and - (for the -x parameter of the sieve tools)
+	+ Further developed the deprecated notify extension. A dummy for the denotify
+	  command exists, meaning that its use does not cause an error anymore. 
+	- Fixed a bug in the derivation of the binary path from the script path. A 
+	  bare filename would yield a path relative to root.
+	- Fixed a bug in the value matching code. The context data now uses a proper
+	  pool in stead of the data stack. Bug reported by Jan Sechser.
+	- Fixed assertion fail in the include extension caused by missing 
+	  initialization upon binary load. This bug surfaces only for stored
+	  binaries. Bug reported by Tom Hendrikx.
+	- Fixed include error message for failed :global include. It mentioned the 
+	  wrong config parameter.
+	- Fixed broken wiki reference in an error message of the plugin about the
+	  'sieve' setting.
+	- Fixed behavior of fileinto when delivering into a namespace prefix.
+	  Previous fix used the wrong storage.
+
+v0.1.9 22-07-2009  Stephan Bosch <stephan@rename-it.nl>
+
+	* Removed the unfinished sieve-filter tool from the default build. It is now 
+	  only built when the --with-unfinished-features switch is supplied during 
+	  configure.
+	+ Started building support for the ereject version of the reject action, 
+	  which has a preference to use an SMTP/LMTP protocol error in stead of a 
+	  bounce message. This is to be used to make the Sieve plugin honour Deliver's
+	  -e parameter. This is not yet finished and not built by default. 
+	+ Improved 'Permission denied' error messages just like Dovecot does,
+	  precisely specifying what permission is missing to access or create a file.
+	+ Added additional headers to the list of allowed headers for the address 
+	  test. The restrictive nature of the address test is not always appropriate. 
+	  Still thinking of a better, less restrictive implementation.
+	+ Made the deprecated notify extension compatible with the old CMUSieve
+	  plugin. However, the denotify command and the $text$ substitution are not
+	  yet supported. 
+	+ Made the discard action log a message to avoid confusion about disappearing 
+	  messages.
+	- Fixed behavior of fileinto when delivering into a namespace prefix. It now
+	  uses silent delivery into INBOX as fallback.
+	- Fixed logging of folder namespace prefix upon delivery into a prefixed 
+	  namespace. Formerly it only logged the bare folder name.
+	- Fixed a potential segfault in the argument validation. It didn't surface
+	  because no command could have a :tag followed by an associated parameter as
+	  last argument.
+	- Fixed segfault bug occuring in envelope test when performed on null (<>) 
+	  envelope path. The fix involves a rather large restructuring of the code to 
+	  make sure envelope addresses are properly handled everywhere (bug reported
+	  by Nikita Koshikov)
+	- Envelope: fixed bug in application of address parts; failure to obtain 
+	  the part would cause inappropriate match success (bug reported by Ron Lee)
+	- Fixed extension conflict checks during validation. It could sometimes
+	  produce useless errormessages. This is currently only used by the 
+	  deprecated extensions.
+	- Forgot to remove old explicit storage library dependency (patch by 
+	  Arkadiusz Miskiewicz).
+	- Fixed compiler warnings on certain platforms regarding the use fwrite for 
+	  outgoing message construction
+
+v0.1.8 12-07-2009  Stephan Bosch <stephan@rename-it.nl>
+
+	- Fixed AIX compile problem. For portability, the typeof operator is
+	  not used anymore. 
+	+ Added partial support for the deprecated notify extension. However, it
+	  turns out that the implementation provided by cmusieve is even older (2001),
+	  meaning that this is currently not backwards compatible with cmusieve.
+
+v0.1.7 05-07-2009  Stephan Bosch <stephan@rename-it.nl>
+
+	+ Added support for CRLF line breaks in strbuf error handler to fix a
+	  ManageSieve problem.
+	+ Improved consistency of sieve tool documentation and fixed missing
+	  parameters in internal tool help output.
+	+ Enhanced extensions configuration, allowing to specify the enabled
+	  extensions relatively to the default (patch by Steffen Kaiser).
+	- Forgot to initialize script execution status in Sieve plugin, causing 
+	  segfaults on compile errors in specific conditions.
+	- Fixed logging in Sieve plugin for execution of default main script (went 
+	  to STDERR).
+                                                                               
+v0.1.6 18-06-2009  Stephan Bosch <stephan@rename-it.nl>
+
+	* Adjusted to changes in Dovecot to make it compile against v1.2.rc5
+	* Made default of sieve_dir setting match the ManageSieve implementation.
+	- Fixed a few problems in de body extension that caused assert failures in
+	  specific situations.	
+
+v0.1.5 18-04-2009  Stephan Bosch <stephan@rename-it.nl>
+
+	* Ported the implementation of the Sieve include extension to the latest 
+	  draft. This means that the import and export commands are replaced by a new 
+	  command called global. The import and export commands are now DEPRICATED and
+	  are mere aliases for the global command. The new specification also adds the
+	  :once modifier to the include command. The also newly specified global.* 
+	  variable namespace is not implemented yet as support for variable namespaces
+	  is currently missing.
+	* Did a major rework of the multiscript support for better error handling and
+	  made sure that persistent global scripts (sieve_before/sieve_after) are
+	  always executed, even when the user does not have a script of his own and 
+	  a global default is missing. 
+	+ Provided basic support for the environment extension. Currenly, the name,
+	  version and host items are useful. Others are pending.
+	+ Improved error message that is presented when an unknown Sieve extension is
+	  provided as argument to the require command. It now notifies the user that
+	  Sieve core commands do not need to be specified in require.
+	- Fixed bug in includes at levels deeper than one.
+	- Fixed bug in address matching that was caused by the failure to handle group 
+	  specifications. In dovecot, these are marked by address items with NULL 
+	  elements, which causes a segfault if not considered. The group 'undisclosed-
+	  recipients:;' in particular triggered this bug. Bug reported by Bernhard
+	  Schmidt. 	  
+
+v0.1.4 21-03-2009  Stephan Bosch <stephan@rename-it.nl>
+
+	* Started work on the sieve-filter tool. With this command line tool it will 
+	  be possible to (re-)apply Sieve filters on a mail folder. It is currently
+	  undocumented and far from functional.
+	+ Added a custom debug extension that provides the possibility to print debug 
+	  messages from scripts executed by the Sieve tools.
+	- Fixed issue with opening relative paths as a mail file. Bug reported by Ian
+	  P. Christian.
+	- Fixed MAC OSX compile problem. Turns out the extern modifier was missing at
+	  multiple places. Bug reported by Edgar Fuss.
+	- Fixed Solaris compile problem: removed unecessary and unportable linker
+	  flags that caused compile to fail. Bug reported by Andrs Yacopino.
+
+v0.1.3 12-02-2009  Stephan Bosch <stephan@rename-it.nl>
+
+	* Adapted to changes in Dovecot, making this release dependent on Dovecot
+	  >= 1.2.beta1
+	* Made mail address comparison fully case-insensitive. This is particularly
+	  noticeable for the :addresses argument of the vacation command. 
+	+ Finished enotify extension. Currently, only the mailto notification method
+	  is implemented. All still needs to be tested thoroughly.
+	+ Implemented multiscript support. It is now possible to execute multiple
+	  Sieve scripts sequentially. Administrator-controlled scripts can be
+	  executed before and after the user's script. Still needs to be tested
+	  thoroughly.
+	+ Implemented support for configuring the available Sieve extensions.
+	+ Made the subaddress extension (partially) configurable using the
+	  sieve_subaddress_sep setting, which allows specifying a (multi-charater)
+	  separator other than '+'.
+	+ Compiler now warns about invalid header field names used for the header and
+	  address tests.
+	+ Vacation extension now properly generates a References header for the 
+	  response message.
+	+ Added testing of basic result execution to the test suite. Also added 
+	  supportfor testing the outgoing messages produced by the Sieve interpreter. 
+	+ Included execution of the actual result in the sieve-test command line tool.
+	  The undocumented sieve-exec tool that existed for this is now removed as 
+	  planned.
+	+ Added support for the now obsolete 'imapflags' extension for backwards
+	  compatibility with CMUSieve. This also implements the mark/unmark commands.
+	- Fixed bugs in the regex extension: 1) if an optional match value did not in 
+	  fact match, subsequent match values would get unexpected indexes. 2) fixed
+	  segfault bug occuring when regex is freed.
+	- Fixed bug in the use of the :from agrument for the vacation command. If this
+	  address included a phrase part, the response would not be a valid RFC822
+	  message.
+	- Plugged a theoretical security hole occuring when a directory is opened as a 
+	  Sieve binary.
+	- Cleaned up and fixed various log messages.
+	- Fixed bug in the outgoing address verification. Addresses ending in ',' were 
+	  erroneously accepted.
+
+v0.1.2 26-11-2008  Stephan Bosch <stephan@rename-it.nl>
+
+	- Fixed important bug in the redirect action (and probably other actions like
+	  reject and vacation that only send messages). This was a bug in the handling
+	  of context information during the execution of actions. It caused the sieve 
+	  interpreter to crash with a segfault when redirect was executed. 
+
+v0.1.1 24-11-2008  Stephan Bosch <stephan@rename-it.nl>
+
+	* Re-enabled support for compiling against dovecot headers. Much like 
+	  cmusieve, command line tools like sievec and sieved are not compiled in this 
+	  case.
+	* Started implementation of enotify extension. Not anywhere near finished
+	  though. 
+	* Adapted to changes in Dovecot on various occasions, making this release
+	  dependent on Dovecot >= v1.2.alpa4.
+
+	+ Improved logging of errors at specific occasions and added debug messages to
+	  find script execution problems quicker. 
+	+ Removed code duplication between command line tools and the test suite. 
+	  Also restructured the sources of the tools.
+	+ Added UTF-8 to UTF-7 folder name conversion for compatibility with IMAP.
+	+ Created man pages for the command line tools. These are automatically 
+	  installed upon 'make install'
+	+ Incorporated Valgrind support into the testsuite and fixed a few memory
+	  leaks in the process.
+	- Fixed compile error surfacing for gcc3.4. Forgot mask argument for the 
+	  open() system call when the O_CREAT flag is specified. Bug found by 
+	  Sergey Ivanov.
+	- Fixed bug in the sievec tool. -d output was always written to stdout.
+	- Fixed important bug in the imap4flags extension. When no :flags argument is 
+	  specified, the previous version would always use the final value of the
+	  internal variable to set the flags. This means that modifications to the 
+	  internal variable also affected the bare fileinto/keep actions executed 
+	  earlier. This does not comply to the RFC. 
+	- Fixed bug in the include extension's import/export commands. Duplicate
+	  import/exports caused problems.
+	- Fixed bug in the handling of non-existent scripts. Errors were sometimes 
+	  ignored. 
+	- Dovecot omitted unfolding multi-line headers. This was added to the cmusieve
+	  plugin after the code was incorporated into the new implementation. This is
+	  now mplicitly fixed by concurrent change in Dovecot. 
+
+v0.1.0 23-10-2008  Stephan Bosch <stephan@rename-it.nl>
+
+	* Initial release
diff -urN dovecot-1.2.4/dovecot-libsieve/README dovecot-1.2.4.debian/dovecot-libsieve/README
--- dovecot-1.2.4/dovecot-libsieve/README	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/README	2009-08-21 00:52:15.000000000 +0200
@@ -0,0 +1,196 @@
+Sieve implementation for Dovecot v1.2
+
+Introduction
+------------
+
+Sieve is a machine language specifically tailored for internet message 
+filtering. This package compiles into a Sieve plugin for the Dovecot local 
+delivery agent called Deliver. The plugin adds Sieve filtering support to the 
+delivery process.  
+
+Previously, the same functionality was provided by the cmusieve plugin for 
+Dovecot. This old plugin is based on the CMU Sieve implementation included with
+the Cyrus project. This new package provides a complete rewrite of the Sieve 
+engine integrating it tightly with Dovecot. The actual execution of the Sieve 
+actions is based on the original cmusieve plugin, but only on the code added to 
+interface the CMU Sieve implementation with Dovocot. 
+
+The main reason for rewriting the Sieve engine is to provide more reliable 
+script execution and to provide better error messages to users and system 
+administrators. Also, since the Sieve language evolves quickly, with new 
+language extensions published every year, the aim is to provide support for 
+quickly extending the engine with new features. 
+
+Features
+--------
+
+* Well-structured 3-stage compiler:
+ 
+  Uses dovecot framework and avoids using lex/yacc. Compiler doesn't bail on 
+  first error, but tries to find more. Produced errors are aimed to be useful 
+  and generally user-comprehensible. Things like 'Generic error' are a nuisance 
+  of the past. 
+
+* Highly extendable with new Sieve capabilities: 
+
+  This keeps the possibility of plugins in mind. It should eventually provide 
+  the necessary infrastructure for at least all currently known (proposed) 
+  extensions. The goal is to keep the extension interface provided by sieve 
+  engine as generic as possible, i.e. without explicit support for specific 
+  extensions. New similar extensions can then use the same interface methods 
+  without changes to the sieve engine code. If an extension is not loaded using 
+  the require command, the compiler truly does not know of its existance. 
+
+* Supports all extensions provided by the original CMUSieve plugin:
+ 
+  In addition, it has support for the new and very useful variables extension
+  (see next section). 
+
+  NOTE: The original CMUSieve plugin is based on old specifications of the 
+  imap4flags and enotify extension. Among other subtle differences, these 
+  extensions were known as 'imapflags' and 'notify' for the CMU Sieve plugin.
+  Support for the old imapflags extension is provided for backwards compatibility.
+
+* Supports executing multiple scrips sequentially.
+  
+  Using this feature it is possible to execute administrator-controlled Sieve
+  scripts before and after the user's Sieve script is executed. As long as the
+  verdict is at least (implicit) keep, the execution will continue with the next
+  script. Multiple scripts can be executed before or after the user's script by 
+  specifying directories containing sieve files.
+
+* Supported by ManageSieve service:
+
+  This Sieve implementation is supported by the ManageSieve implementation for 
+  Dovecot v1.2. Therefore, ManageSieve support can be added to Dovecot for the
+  new Sieve plugin just as for the cmusieve plugin.
+
+* Test suite included:
+	
+  This package includes a test suite to automatically asses whether the compiled 
+  sieve engine works correctly. The test suite is an extension to the Sieve 
+  language and is therefore easily extended with new tests. Currently, the 
+  test suite is mostly limited to testing script processing. The performed actions 
+  are not tested fully yet. 
+
+Implementation Status
+---------------------
+
+The the core of the language (as specified in RFC 5228) is fully supported. In 
+addition to that, this Sieve implementation features various extensions. The 
+following list outlines the implementation status of each supported extension:
+	
+  Base specification (RFC5228):
+    fileinto: full
+    reject: full (without Dovecot LMTP currently no refuse support)
+    envelope: full
+    encoded-character: full
+
+  Other RFCs/drafts:
+    subaddress: full (limited configurability)
+    comparator-i;ascii-numeric: full
+    relational: full 
+    copy: full
+    regex: mostly full; but suboptimal and no UTF-8
+    body: mostly full, but text body-transform implementation is simple
+        and some issues make it still not completely RFC incompliant. 
+    include: almost full; global namespace missing 
+    vacation: mostly full; handling of utf-8 in headers is non-existant
+    imap4flags: full (old imapflags supported for backwards compatibility)
+    variables: mostly full; currently no support for future namespaces 
+    notify: full, mailto support only; needs to be tested more
+	environment: basic
+	mailbox: almost full, but mailboxexists command lacks ACL support
+	date: full
+
+All implemented extensions are like the engine itself currently experimental. 
+A status of 'full' does not necessarily mean that the extension is bug-free or 
+even fully RFC-compliant. Check the TODO file for open issues.
+ 
+Many more extensions to the language exist. Not all of these extensions are 
+useful for Dovecot in particular, but many of them are. Currently, the author 
+has taken notice of the following extensions:
+
+    date,index: planned
+    editheader: planned, needs additional support from Dovecot though.
+    mimeloop: planned
+
+These extensions will be added as soon as the necessary infrastructure is 
+available. 
+
+Compiling and Configuring
+-------------------------
+
+Refer to INSTALL file.
+
+Using
+-----
+
+The main purpose of this package is to replace the existing cmusieve plugin that 
+is currently available for Dovecot's deliver. With this respect it is currently 
+not very different from the cmusieve plugin implementation.
+
+Unlike cmusieve, this sieve module logs runtime errors to <scriptfile>.log if 
+it can and not <scriptfile>.err. It appends new timestamped log entries to the 
+end of the logfile. If the log grows too large (currently > 10kB), the logfile 
+is rotated to <scriptfile>.log.0 and <scriptfile>.log starts out empty again. 
+
+The cmusieve plugin compiled the script into a file with an appended 'c', e.g. 
+'test.sievec'. This new implementation recognizes scripts to have the .sieve 
+extension. The binary is (by default) written to a file with extension .svbin. 
+This means that the default .dovecot.sieve is compiled into .dovecot.svbin. 
+Included scripts are currently always compiled into the main binary, meaning 
+that no other files are written and no permission to do so is necessary for the 
+global script directories. 
+
+To test the sieve engine outside deliver, it is useful to try the commands that 
+exist in the src/sieve-tools/ directory of this package. After installation, 
+these are available at your $prefix/bin directory. The following commands are 
+installed:
+
+sievec     - Compiles sieve scripts into a binary representation for later 
+             execution.
+
+sieve-test - This is a universal Sieve test tool for testing the effect of a
+             Sieve script on a particular message. It allows compiling, running 
+             and testing Sieve scripts. It can either be used to display the
+             actions that would be performed on the provided test message or it
+             can be used to test the actual delivery of the message and show the
+             messages that would normally be sent through SMTP.
+
+sieved     - Dumps the content of a Sieve binary file for (development) 
+             debugging purposes.
+
+When installed, man pages are also available for these commands. In this package
+the man pages are present in doc/man and can be viewed before install using e.g.: 
+
+man -l doc/man/sieve-test.1
+
+Various example scripts are bundled in the directory 'examples'. These scripts
+were downloaded from various locations. View the top comment in the scripts for 
+url and author information.
+
+Known issues
+------------
+
+Most open issues are outlined in the TODO file. The more generic ones are (re-)
+listed here:
+
+- Compile errors are sometimes a bit obscure and long. This needs work. 
+  Suggestions for improvement are welcome. 
+- The documentation needs work.
+
+Authors
+-------
+
+Refer to AUTHORS file.
+
+Contact Info
+------------
+
+Stephan Bosch <stephan at rename-it dot nl>
+IRC: Freenode, #dovecot, S[r]us
+
+Please use the Dovecot mailing list <dovecot at dovecot.org> for questions about 
+this package. You can post to the list without subscribing, the mail then waits 
+in a moderator queue for a while. See http://dovecot.org/mailinglists.html
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/cmd-discard.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/cmd-discard.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/cmd-discard.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/cmd-discard.c	2009-07-17 01:03:08.000000000 +0200
@@ -0,0 +1,160 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str-sanitize.h"
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-dump.h"
+#include "sieve-actions.h"
+#include "sieve-validator.h" 
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-result.h"
+
+/* 
+ * Discard command 
+ * 
+ * Syntax
+ *   discard
+ */	
+
+static bool cmd_discard_generate
+	(const struct sieve_codegen_env *cgenv, 
+		struct sieve_command_context *ctx ATTR_UNUSED); 
+
+const struct sieve_command cmd_discard = { 
+	"discard", 
+	SCT_COMMAND, 
+	0, 0, FALSE, FALSE,
+	NULL, NULL, NULL, 
+	cmd_discard_generate, 
+	NULL 
+};
+
+/*
+ * Discard operation
+ */
+
+static bool cmd_discard_operation_dump
+	(const struct sieve_operation *op,
+    	const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_discard_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation cmd_discard_operation = { 
+	"DISCARD",
+	NULL,
+	SIEVE_OPERATION_DISCARD,
+	cmd_discard_operation_dump, 
+	cmd_discard_operation_execute 
+};
+
+/* 
+ * Discard actions
+ */
+
+static void act_discard_print
+	(const struct sieve_action *action, const struct sieve_result_print_env *rpenv,
+		void *context, bool *keep);	
+static bool act_discard_commit
+	(const struct sieve_action *action, 
+		const struct sieve_action_exec_env *aenv, void *tr_context, bool *keep);
+		
+const struct sieve_action act_discard = {
+	"discard",
+	0,
+	NULL, NULL, NULL,
+	act_discard_print,
+	NULL, NULL,
+	act_discard_commit,
+	NULL
+};
+
+/*
+ * Code generation
+ */
+ 
+static bool cmd_discard_generate
+(const struct sieve_codegen_env *cgenv, 
+	struct sieve_command_context *ctx ATTR_UNUSED) 
+{
+	sieve_operation_emit_code(cgenv->sbin, &cmd_discard_operation);
+
+	/* Emit line number */
+    sieve_code_source_line_emit(cgenv->sbin, sieve_command_source_line(ctx));
+
+	return TRUE;
+}
+
+/* 
+ * Code dump
+ */
+
+static bool cmd_discard_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+    const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+    sieve_code_dumpf(denv, "DISCARD");
+    sieve_code_descend(denv);
+
+    /* Source line */
+    if ( !sieve_code_source_line_dump(denv, address) )
+        return FALSE;
+
+    return sieve_code_dumper_print_optional_operands(denv, address);
+}
+
+/*
+ * Interpretation
+ */
+
+static int cmd_discard_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv ATTR_UNUSED, 
+	sieve_size_t *address ATTR_UNUSED)
+{	
+	unsigned int source_line;
+	
+	/* Source line */
+    if ( !sieve_code_source_line_read(renv, address, &source_line) ) {
+		sieve_runtime_trace_error(renv, "failed to read source line");
+        return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	sieve_runtime_trace(renv, "DISCARD action");
+
+	return ( sieve_result_add_action
+		(renv, &act_discard, NULL, source_line, NULL, 0) >= 0 );
+}
+
+/*
+ * Action implementation
+ */
+ 
+static void act_discard_print
+(const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_result_print_env *rpenv, void *context ATTR_UNUSED, 
+	bool *keep)	
+{
+	sieve_result_action_printf(rpenv, "discard");
+	
+	*keep = FALSE;
+}
+
+static bool act_discard_commit
+(const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_action_exec_env *aenv, 
+	void *tr_context ATTR_UNUSED, bool *keep)
+{
+	sieve_result_log(aenv, 
+		"marked message to be discarded if not explicitly delivered "
+		"(discard action)");
+	*keep = FALSE;
+
+	return TRUE;
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/cmd-if.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/cmd-if.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/cmd-if.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/cmd-if.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,225 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+
+/*
+ * Commands
+ */
+
+/* If command
+ *
+ * Syntax:   
+ *   if <test1: test> <block1: block>
+ */
+
+static bool cmd_if_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd);
+static bool cmd_if_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command cmd_if = { 
+	"if", 
+	SCT_COMMAND, 
+	0, 1, TRUE, TRUE,
+	NULL, NULL,
+	cmd_if_validate, 
+	cmd_if_generate, 
+	NULL 
+};
+
+/* ElsIf command
+ *
+ * Santax:
+ *   elsif <test2: test> <block2: block>
+ */
+
+static bool cmd_elsif_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd);
+
+const struct sieve_command cmd_elsif = {
+    "elsif", 
+	SCT_COMMAND,
+	0, 1, TRUE, TRUE, 
+	NULL, NULL, 
+	cmd_elsif_validate, 
+	cmd_if_generate, 
+	NULL 
+};
+
+/* Else command 
+ *
+ * Syntax:   
+ *   else <block>
+ */
+
+static bool cmd_else_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command cmd_else = {
+    "else", 
+	SCT_COMMAND, 
+	0, 0, TRUE, TRUE,
+	NULL, NULL,
+	cmd_elsif_validate, 
+	cmd_else_generate, 
+	NULL 
+};
+
+/* 
+ * Context management
+ */
+
+struct cmd_if_context_data {
+	struct cmd_if_context_data *previous;
+	struct cmd_if_context_data *next;
+	
+	bool jump_generated;
+	sieve_size_t exit_jump;
+};
+
+static void cmd_if_initialize_context_data
+(struct sieve_command_context *cmd, struct cmd_if_context_data *previous) 
+{ 	
+	struct cmd_if_context_data *ctx_data;
+
+	/* Assign context */
+	ctx_data = p_new(sieve_command_pool(cmd), struct cmd_if_context_data, 1);
+	ctx_data->exit_jump = 0;
+	ctx_data->jump_generated = FALSE;
+
+	/* Update linked list of contexts */
+	ctx_data->previous = previous;
+	ctx_data->next = NULL;	
+	if ( previous != NULL )
+		previous->next = ctx_data;
+	
+	/* Assign to command context */
+	cmd->data = ctx_data;
+}
+
+/* 
+ * Validation 
+ */
+
+static bool cmd_if_validate
+(struct sieve_validator *validator ATTR_UNUSED, struct sieve_command_context *cmd) 
+{ 
+	/* Start if-command structure */
+	cmd_if_initialize_context_data(cmd, NULL);
+	
+	return TRUE;
+}
+
+static bool cmd_elsif_validate
+(struct sieve_validator *validator, struct sieve_command_context *cmd)
+{
+	struct sieve_command_context *prev_context = 
+		sieve_command_prev_context(cmd);
+
+	/* Check valid command placement */
+	if ( prev_context == NULL ||
+		( prev_context->command != &cmd_if &&
+			prev_context->command != &cmd_elsif ) ) 
+	{		
+		sieve_command_validate_error(validator, cmd, 
+			"the %s command must follow an if or elseif command", 
+			cmd->command->identifier);
+		return FALSE;
+	}
+	
+	/* Previous command in this block is 'if' or 'elsif', so we can safely refer 
+	 * to its context data 
+	 */
+	cmd_if_initialize_context_data(cmd, prev_context->data);
+
+	return TRUE;
+}
+
+/* 
+ * Code generation 
+ */
+
+/* The if command does not generate specific IF-ELSIF-ELSE opcodes, but only uses
+ * JMP instructions. This is why the implementation of the if command does not 
+ * include an opcode implementation.
+ */
+
+static void cmd_if_resolve_exit_jumps
+(struct sieve_binary *sbin, struct cmd_if_context_data *ctx_data) 
+{
+	struct cmd_if_context_data *if_ctx = ctx_data->previous;
+	
+	/* Iterate backwards through all if-command contexts and resolve the 
+	 * exit jumps to the current code position.
+	 */
+	while ( if_ctx != NULL ) {
+		if ( if_ctx->jump_generated ) 
+			sieve_binary_resolve_offset(sbin, if_ctx->exit_jump);
+		if_ctx = if_ctx->previous;	
+	}
+}
+
+static bool cmd_if_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx)
+{
+	struct sieve_binary *sbin = cgenv->sbin;
+	struct cmd_if_context_data *ctx_data = (struct cmd_if_context_data *) ctx->data;
+	struct sieve_ast_node *test;
+	struct sieve_jumplist jmplist;
+	
+	/* Prepare jumplist */
+	sieve_jumplist_init_temp(&jmplist, sbin);
+	
+	/* Generate test condition */
+	test = sieve_ast_test_first(ctx->ast_node);
+	if ( !sieve_generate_test(cgenv, test, &jmplist, FALSE) )
+		return FALSE;
+		
+	/* Case true { */
+	if ( !sieve_generate_block(cgenv, ctx->ast_node) ) 
+		return FALSE;
+	
+	/* Are we the final command in this if-elsif-else structure? */
+	if ( ctx_data->next != NULL ) {
+		/* No, generate jump to end of if-elsif-else structure (resolved later) 
+		 * This of course is not necessary if the {} block contains a command 
+		 * like stop at top level that unconditionally exits the block already
+		 * anyway. 
+		 */
+		if ( !sieve_command_block_exits_unconditionally(ctx) ) {
+			sieve_operation_emit_code(sbin, &sieve_jmp_operation);
+			ctx_data->exit_jump = sieve_binary_emit_offset(sbin, 0);
+			ctx_data->jump_generated = TRUE;
+		}
+	} else {
+		/* Yes, Resolve previous exit jumps to this point */
+		cmd_if_resolve_exit_jumps(sbin, ctx_data);
+	}
+	
+	/* Case false ... (subsequent elsif/else commands might generate more) */
+	sieve_jumplist_resolve(&jmplist);	
+		
+	return TRUE;
+}
+
+static bool cmd_else_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx)
+{
+	struct cmd_if_context_data *ctx_data = (struct cmd_if_context_data *) ctx->data;
+	
+	/* Else { */
+	if ( !sieve_generate_block(cgenv, ctx->ast_node) ) 
+		return FALSE;
+		
+	/* } End: resolve all exit blocks */	
+	cmd_if_resolve_exit_jumps(cgenv->sbin, ctx_data);
+		
+	return TRUE;
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/cmd-keep.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/cmd-keep.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/cmd-keep.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/cmd-keep.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,124 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-dump.h"
+#include "sieve-actions.h"
+#include "sieve-validator.h" 
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-result.h"
+
+/* 
+ * Keep command 
+ *
+ * Syntax:
+ *   keep
+ */	
+
+static bool cmd_keep_generate
+	(const struct sieve_codegen_env *cgenv, 
+		struct sieve_command_context *ctx);
+
+const struct sieve_command cmd_keep = { 
+	"keep", 
+	SCT_COMMAND, 
+	0, 0, FALSE, FALSE,
+	NULL, NULL, NULL, 
+	cmd_keep_generate, 
+	NULL
+};
+
+/* 
+ * Keep operation 
+ */
+
+static bool cmd_keep_operation_dump
+	(const struct sieve_operation *op,
+    	const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_keep_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation cmd_keep_operation = { 
+	"KEEP",
+	NULL,
+	SIEVE_OPERATION_KEEP,
+	cmd_keep_operation_dump, 
+	cmd_keep_operation_execute 
+};
+
+/*
+ * Code generation
+ */
+
+static bool cmd_keep_generate
+(const struct sieve_codegen_env *cgenv, 
+	struct sieve_command_context *ctx ATTR_UNUSED) 
+{
+	/* Emit opcode */
+	sieve_operation_emit_code(cgenv->sbin, &cmd_keep_operation);
+
+	/* Emit line number */
+    sieve_code_source_line_emit(cgenv->sbin, sieve_command_source_line(ctx));
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, ctx, NULL);
+}
+
+/* 
+ * Code dump
+ */
+
+static bool cmd_keep_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+    const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+    sieve_code_dumpf(denv, "KEEP");
+    sieve_code_descend(denv);
+
+    /* Source line */
+    if ( !sieve_code_source_line_dump(denv, address) )
+        return FALSE;
+
+    return sieve_code_dumper_print_optional_operands(denv, address);
+}
+
+/*
+ * Interpretation
+ */
+
+static int cmd_keep_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv ATTR_UNUSED, 
+	sieve_size_t *address ATTR_UNUSED)
+{	
+	struct sieve_side_effects_list *slist = NULL;
+	unsigned int source_line;
+	int ret = 0;	
+
+	/* Source line */
+	if ( !sieve_code_source_line_read(renv, address, &source_line) ) {
+		sieve_runtime_trace_error(renv, "invalid source line");
+        return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/* Optional operands (side effects only) */
+	if ( (ret=sieve_interpreter_handle_optional_operands
+		(renv, address, &slist)) <= 0 ) 
+		return ret;
+
+	sieve_runtime_trace(renv, "KEEP action");
+	
+	/* Add keep action to result. 
+	 */
+	ret = sieve_result_add_keep(renv, slist, source_line);
+	
+	return ( ret >= 0 );
+}
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/cmd-redirect.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/cmd-redirect.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/cmd-redirect.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/cmd-redirect.c	2009-07-21 03:02:37.000000000 +0200
@@ -0,0 +1,386 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "ioloop.h"
+#include "str-sanitize.h"
+#include "istream.h"
+#include "istream-crlf.h"
+#include "istream-header-filter.h"
+
+#include "rfc2822.h"
+
+#include "sieve-common.h"
+#include "sieve-limits.h"
+#include "sieve-address.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-actions.h"
+#include "sieve-validator.h" 
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-code-dumper.h"
+#include "sieve-result.h"
+#include "sieve-message.h"
+
+#include <stdio.h>
+
+/* 
+ * Configuration 
+ */
+
+#define CMD_REDIRECT_DUPLICATE_KEEP (3600 * 24)
+
+/* 
+ * Redirect command 
+ * 
+ * Syntax
+ *   redirect <address: string>
+ */
+
+static bool cmd_redirect_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd);
+static bool cmd_redirect_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command cmd_redirect = { 
+	"redirect", 
+	SCT_COMMAND,
+	1, 0, FALSE, FALSE, 
+	NULL, NULL,
+	cmd_redirect_validate, 
+	cmd_redirect_generate, 
+	NULL 
+};
+
+/* 
+ * Redirect operation 
+ */
+
+static bool cmd_redirect_operation_dump
+	(const struct sieve_operation *op,
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_redirect_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation cmd_redirect_operation = { 
+	"REDIRECT",
+	NULL, 
+	SIEVE_OPERATION_REDIRECT,
+	cmd_redirect_operation_dump, 
+	cmd_redirect_operation_execute 
+};
+
+/* 
+ * Redirect action 
+ */
+
+static bool act_redirect_equals
+	(const struct sieve_script_env *senv, const void *ctx1, const void *ctx2);
+static int act_redirect_check_duplicate
+	(const struct sieve_runtime_env *renv,
+		const struct sieve_action_data *act, 
+		const struct sieve_action_data *act_other);
+static void act_redirect_print
+	(const struct sieve_action *action, const struct sieve_result_print_env *rpenv,
+		void *context, bool *keep);	
+static bool act_redirect_commit
+	(const struct sieve_action *action, const struct sieve_action_exec_env *aenv,
+		void *tr_context, bool *keep);
+		
+const struct sieve_action act_redirect = {
+	"redirect",
+	SIEVE_ACTFLAG_TRIES_DELIVER,
+	act_redirect_equals,
+	act_redirect_check_duplicate, 
+	NULL,
+	act_redirect_print,
+	NULL, NULL,
+	act_redirect_commit,
+	NULL
+};
+
+struct act_redirect_context {
+	const char *to_address;
+};
+
+/* 
+ * Validation 
+ */
+
+static bool cmd_redirect_validate
+(struct sieve_validator *validator, struct sieve_command_context *cmd) 
+{
+	struct sieve_ast_argument *arg = cmd->first_positional;
+
+	/* Check and activate address argument */
+
+	if ( !sieve_validate_positional_argument
+		(validator, cmd, arg, "address", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+	
+	if ( !sieve_validator_argument_activate(validator, cmd, arg, FALSE) )
+		return FALSE;
+
+	/* We can only assess the validity of the outgoing address when it is 
+	 * a string literal. For runtime-generated strings this needs to be 
+	 * done at runtime (FIXME!)
+     */
+	if ( sieve_argument_is_string_literal(arg) ) {
+		string_t *address = sieve_ast_argument_str(arg);
+		const char *error;
+		const char *norm_address;
+
+		T_BEGIN {
+			/* Verify and normalize the address to 'local_part@domain' */
+			norm_address = sieve_address_normalize(address, &error);
+		
+			if ( norm_address == NULL ) {
+				sieve_argument_validate_error(validator, arg, 
+					"specified redirect address '%s' is invalid: %s",
+					str_sanitize(str_c(address),128), error);
+			} else {
+				/* Replace string literal in AST */
+				sieve_ast_argument_string_setc(arg, norm_address);
+			}
+		} T_END;
+
+		return ( norm_address != NULL );
+	}		
+
+	return TRUE;
+}
+
+/*
+ * Code generation
+ */
+ 
+static bool cmd_redirect_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx) 
+{
+	sieve_operation_emit_code(cgenv->sbin, &cmd_redirect_operation);
+
+	/* Emit line number */
+	sieve_code_source_line_emit(cgenv->sbin, sieve_command_source_line(ctx));
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, ctx, NULL);
+}
+
+/* 
+ * Code dump
+ */
+ 
+static bool cmd_redirect_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	sieve_code_dumpf(denv, "REDIRECT");
+	sieve_code_descend(denv);
+
+	/* Source line */
+    if ( !sieve_code_source_line_dump(denv, address) )
+        return FALSE;
+
+	if ( !sieve_code_dumper_print_optional_operands(denv, address) )
+		return FALSE;
+
+	return sieve_opr_string_dump(denv, address, "reason");
+}
+
+/*
+ * Intepretation
+ */
+
+static int cmd_redirect_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	struct sieve_side_effects_list *slist = NULL;
+	struct act_redirect_context *act;
+	string_t *redirect;
+	unsigned int source_line;
+	pool_t pool;
+	int ret = 0;
+
+	/* Source line */
+    if ( !sieve_code_source_line_read(renv, address, &source_line) ) {
+		sieve_runtime_trace_error(renv, "invalid source line");
+        return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Optional operands (side effects) */
+	if ( (ret=sieve_interpreter_handle_optional_operands
+		(renv, address, &slist)) <= 0 )
+		return ret;
+
+	/* Read the address */
+	if ( !sieve_opr_string_read(renv, address, &redirect) ) {
+		sieve_runtime_trace_error(renv, "invalid address string");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* FIXME: perform address normalization if the string is not a string literal
+	 */
+
+	sieve_runtime_trace(renv, "REDIRECT action (\"%s\")", str_sanitize(str_c(redirect), 64));
+	
+	/* Add redirect action to the result */
+
+	pool = sieve_result_pool(renv->result);
+	act = p_new(pool, struct act_redirect_context, 1);
+	act->to_address = p_strdup(pool, str_c(redirect));
+	
+	ret = sieve_result_add_action
+		(renv, &act_redirect, slist, source_line, (void *) act, sieve_max_redirects);
+	
+	return ( ret >= 0 );
+}
+
+/*
+ * Action implementation
+ */
+
+static bool act_redirect_equals
+(const struct sieve_script_env *senv ATTR_UNUSED, 
+	const void *ctx1, const void *ctx2)
+{
+	struct act_redirect_context *rd_ctx1 = 
+		(struct act_redirect_context *) ctx1;
+	struct act_redirect_context *rd_ctx2 = 
+		(struct act_redirect_context *) ctx2;
+
+	/* Address is already normalized */
+	return ( sieve_address_compare
+		(rd_ctx1->to_address, rd_ctx2->to_address, TRUE) == 0 );
+}
+ 
+static int act_redirect_check_duplicate
+(const struct sieve_runtime_env *renv ATTR_UNUSED,
+	const struct sieve_action_data *act, 
+	const struct sieve_action_data *act_other)
+{
+	return ( act_redirect_equals
+		(renv->scriptenv, act->context, act_other->context) ? 1 : 0 );
+}
+
+static void act_redirect_print
+(const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_result_print_env *rpenv, void *context, bool *keep)	
+{
+	struct act_redirect_context *ctx = (struct act_redirect_context *) context;
+	
+	sieve_result_action_printf(rpenv, "redirect message to: %s", 
+		str_sanitize(ctx->to_address, 128));
+	
+	*keep = FALSE;
+}
+
+static bool act_redirect_send	
+(const struct sieve_action_exec_env *aenv, struct act_redirect_context *ctx)
+{
+	static const char *hide_headers[] = { "Return-Path", "X-Sieve" };
+
+	const struct sieve_message_data *msgdata = aenv->msgdata;
+	const struct sieve_script_env *senv = aenv->scriptenv;
+	const char *sender = sieve_message_get_sender(aenv->msgctx);
+	struct istream *input, *crlf_input;
+	void *smtp_handle;
+	FILE *f;
+	const unsigned char *data;
+	size_t size;
+	int ret;
+	
+	/* Just to be sure */
+	if ( senv->smtp_open == NULL || senv->smtp_close == NULL ) {
+		sieve_result_warning(aenv, "redirect action has no means to send mail.");
+		return TRUE;
+	}
+	
+	if (mail_get_stream(msgdata->mail, NULL, NULL, &input) < 0)
+		return FALSE;
+		
+	/* Open SMTP transport */
+	smtp_handle = senv->smtp_open(ctx->to_address, sender, &f);
+
+	/* Remove unwanted headers */
+	input = i_stream_create_header_filter
+		(input, HEADER_FILTER_EXCLUDE, hide_headers,
+			N_ELEMENTS(hide_headers), null_header_filter_callback, NULL);
+	
+	/* Make sure the message contains CRLF consistently */
+	crlf_input = i_stream_create_crlf(input);
+
+	/* Prepend sieve version header (should not affect signatures) */
+	rfc2822_header_field_write(f, "X-Sieve", SIEVE_IMPLEMENTATION);
+
+	/* Pipe the message to the outgoing SMTP transport */
+	while ((ret = i_stream_read_data(crlf_input, &data, &size, 0)) > 0) {	
+		if (fwrite(data, size, 1, f) == 0)
+			break;
+		i_stream_skip(crlf_input, size);
+	}
+
+	i_stream_unref(&crlf_input);
+	i_stream_unref(&input);
+
+	/* Close SMTP transport */
+	if ( !senv->smtp_close(smtp_handle) ) {
+		sieve_result_error(aenv, 
+			"failed to redirect message to <%s> "
+			"(refer to server log for more information)",
+			str_sanitize(ctx->to_address, 80));
+		return FALSE;
+	}
+	
+	return TRUE;
+}
+
+static bool act_redirect_commit
+(const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_action_exec_env *aenv, void *tr_context, bool *keep)
+{
+	struct act_redirect_context *ctx = (struct act_redirect_context *) tr_context;
+	const struct sieve_message_data *msgdata = aenv->msgdata;
+	const struct sieve_script_env *senv = aenv->scriptenv;
+	const char *dupeid;
+	
+	/* Prevent mail loops if possible */
+	dupeid = msgdata->id == NULL ? 
+		NULL : t_strdup_printf("%s-%s", msgdata->id, ctx->to_address);
+	if (dupeid != NULL) {
+		/* Check whether we've seen this message before */
+		if (senv->duplicate_check(dupeid, strlen(dupeid), senv->username)) {
+			sieve_result_log(aenv, "discarded duplicate forward to <%s>",
+				str_sanitize(ctx->to_address, 128));
+			return TRUE;
+		}
+	}
+	
+	/* Try to forward the message */
+	if ( act_redirect_send(aenv, ctx) ) {
+	
+		/* Mark this message id as forwarded to the specified destination */
+		if (dupeid != NULL) {
+			senv->duplicate_mark(dupeid, strlen(dupeid), senv->username,
+				ioloop_time + CMD_REDIRECT_DUPLICATE_KEEP);
+		}
+	
+		sieve_result_log(aenv, "forwarded to <%s>", 
+			str_sanitize(ctx->to_address, 128));	
+
+		/* Indicate that message was successfully forwarded */
+		aenv->exec_status->message_forwarded = TRUE;
+
+		/* Cancel implicit keep */
+		*keep = FALSE;
+
+		return TRUE;
+	}
+  
+	return FALSE;
+}
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/cmd-require.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/cmd-require.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/cmd-require.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/cmd-require.c	2009-04-18 09:54:24.000000000 +0200
@@ -0,0 +1,86 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-extensions.h"
+#include "sieve-validator.h" 
+#include "sieve-generator.h"
+
+/* 
+ * Require command
+ *
+ * Syntax 
+ *   Syntax: require <capabilities: string-list>
+ */
+
+static bool cmd_require_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd);
+
+const struct sieve_command cmd_require = { 
+	"require", 
+	SCT_COMMAND, 
+	1, 0, FALSE, FALSE,
+	NULL, NULL, 
+	cmd_require_validate, 
+	NULL, NULL
+};
+ 
+/* 
+ * Validation 
+ */
+
+static bool cmd_require_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd) 
+{
+	bool result = TRUE;
+	struct sieve_ast_argument *arg;
+	struct sieve_command_context *prev_context = 
+		sieve_command_prev_context(cmd);
+	
+	/* Check valid command placement */
+	if ( !sieve_command_is_toplevel(cmd) ||
+		( !sieve_command_is_first(cmd) && prev_context != NULL &&
+			prev_context->command != &cmd_require ) ) 
+	{	
+		sieve_command_validate_error(validator, cmd, 
+			"require commands can only be placed at top level "
+			"at the beginning of the file");
+		return FALSE;
+	}
+	
+	/* Check argument and load specified extension(s) */
+
+	arg = cmd->first_positional;
+	if ( sieve_ast_argument_type(arg) == SAAT_STRING ) {
+		/* Single string */
+		const struct sieve_extension *ext = sieve_validator_extension_load
+			(validator, cmd, arg, sieve_ast_argument_str(arg));	
+
+		if ( ext == NULL ) result = FALSE;
+		
+	} else if ( sieve_ast_argument_type(arg) == SAAT_STRING_LIST ) {
+		/* String list */
+		struct sieve_ast_argument *stritem = sieve_ast_strlist_first(arg);
+		
+		while ( stritem != NULL ) {
+			const struct sieve_extension *ext = sieve_validator_extension_load
+				(validator, cmd, stritem, sieve_ast_strlist_str(stritem));
+
+			if ( ext == NULL ) result = FALSE;
+	
+			stritem = sieve_ast_strlist_next(stritem);
+		}
+	} else {
+		/* Something else */
+		sieve_argument_validate_error(validator, arg, 
+			"the require command accepts a single string or string list argument, "
+			"but %s was found", 
+			sieve_ast_argument_name(arg));
+		return FALSE;
+	}
+	 
+	return result;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/cmd-stop.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/cmd-stop.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/cmd-stop.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/cmd-stop.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,90 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+
+/* 
+ * Stop command 
+ * 
+ * Syntax
+ *   stop
+ */	
+
+static bool cmd_stop_generate
+	(const struct sieve_codegen_env *cgenv, 
+		struct sieve_command_context *ctx ATTR_UNUSED);
+static bool cmd_stop_validate
+	(struct sieve_validator *validator, struct sieve_command_context *ctx);
+	
+const struct sieve_command cmd_stop = { 
+	"stop", 
+	SCT_COMMAND, 
+	0, 0, FALSE, FALSE,
+	NULL, NULL,  
+	cmd_stop_validate, 
+	cmd_stop_generate, 
+	NULL 
+};
+
+/* 
+ * Stop operation
+ */
+
+static int opc_stop_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation cmd_stop_operation = { 
+	"STOP",
+	NULL,
+	SIEVE_OPERATION_STOP,
+	NULL, 
+	opc_stop_execute 
+};
+
+/*
+ * Command validation
+ */
+ 
+static bool cmd_stop_validate
+(struct sieve_validator *validator ATTR_UNUSED, 
+	struct sieve_command_context *ctx)
+{
+	sieve_command_exit_block_unconditionally(ctx);
+	
+	return TRUE;
+}
+
+/*
+ * Code generation
+ */
+
+static bool cmd_stop_generate
+(const struct sieve_codegen_env *cgenv, 
+	struct sieve_command_context *ctx ATTR_UNUSED) 
+{
+	sieve_operation_emit_code(cgenv->sbin, &cmd_stop_operation);
+
+	return TRUE;
+}
+
+/*
+ * Code execution
+ */
+
+static int opc_stop_execute
+(const struct sieve_operation *op ATTR_UNUSED, 
+	const struct sieve_runtime_env *renv,  
+	sieve_size_t *address ATTR_UNUSED)
+{	
+	sieve_runtime_trace(renv, "STOP");
+	
+	sieve_interpreter_interrupt(renv->interp);
+
+	return SIEVE_EXEC_OK;
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/cmp-i-ascii-casemap.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/cmp-i-ascii-casemap.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/cmp-i-ascii-casemap.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/cmp-i-ascii-casemap.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,96 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+
+/* Comparator 'i;ascii-casemap': 
+ *
+ */
+
+#include "lib.h"
+
+#include "sieve-common.h"
+#include "sieve-comparators.h"
+
+#include <string.h>
+#include <stdio.h>
+#include <ctype.h>
+
+/*
+ * Forward declarations
+ */
+ 
+static int cmp_i_ascii_casemap_compare
+	(const struct sieve_comparator *cmp,
+		const char *val1, size_t val1_size, const char *val2, size_t val2_size);
+static bool cmp_i_ascii_casemap_char_match
+	(const struct sieve_comparator *cmp, const char **val1, const char *val1_end, 
+		const char **val2, const char *val2_end);
+
+/*
+ * Comparator object
+ */
+ 
+const struct sieve_comparator i_ascii_casemap_comparator = {
+	SIEVE_OBJECT
+		("i;ascii-casemap", &comparator_operand, SIEVE_COMPARATOR_I_ASCII_CASEMAP),
+	SIEVE_COMPARATOR_FLAG_ORDERING | SIEVE_COMPARATOR_FLAG_EQUALITY |
+		SIEVE_COMPARATOR_FLAG_SUBSTRING_MATCH | SIEVE_COMPARATOR_FLAG_PREFIX_MATCH,
+	cmp_i_ascii_casemap_compare,
+	cmp_i_ascii_casemap_char_match,
+	sieve_comparator_octet_skip
+};
+
+/*
+ * Comparator implementation
+ */
+
+static int cmp_i_ascii_casemap_compare(
+	const struct sieve_comparator *cmp ATTR_UNUSED,
+	const char *val1, size_t val1_size, const char *val2, size_t val2_size)
+{
+	int result;
+
+	if ( val1_size == val2_size ) {
+		return strncasecmp(val1, val2, val1_size);
+	} 
+	
+	if ( val1_size > val2_size ) {
+		result = strncasecmp(val1, val2, val2_size);
+		
+		if ( result == 0 ) return 1;
+		
+		return result;
+	} 
+
+	result = strncasecmp(val1, val2, val1_size);
+		
+	if ( result == 0 ) return -1;
+		
+	return result;
+}
+
+static bool cmp_i_ascii_casemap_char_match
+	(const struct sieve_comparator *cmp ATTR_UNUSED, 
+		const char **val, const char *val_end, 
+		const char **key, const char *key_end)
+{
+	const char *val_begin = *val;
+	const char *key_begin = *key;
+	
+	while ( i_tolower(**val) == i_tolower(**key) &&
+		*val < val_end && *key < key_end ) {
+		(*val)++;
+		(*key)++;
+	}
+	
+	if ( *key < key_end ) {
+		/* Reset */
+		*val = val_begin;
+		*key = key_begin;	
+		
+		return FALSE;
+	}
+	
+	return TRUE;
+}
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/cmp-i-octet.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/cmp-i-octet.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/cmp-i-octet.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/cmp-i-octet.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,93 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+
+/* Comparator 'i;octet': 
+ *
+ */
+
+#include "lib.h"
+
+#include "sieve-common.h"
+#include "sieve-comparators.h"
+
+#include <string.h>
+#include <stdio.h>
+
+/*
+ * Forward declarations
+ */
+
+static int cmp_i_octet_compare
+	(const struct sieve_comparator *cmp,
+		const char *val1, size_t val1_size, const char *val2, size_t val2_size);
+static bool cmp_i_octet_char_match
+	(const struct sieve_comparator *cmp, const char **val1, const char *val1_end, 
+		const char **val2, const char *val2_end);
+
+/*
+ * Comparator object
+ */
+
+const struct sieve_comparator i_octet_comparator = {
+	SIEVE_OBJECT("i;octet",	&comparator_operand, SIEVE_COMPARATOR_I_OCTET),
+	SIEVE_COMPARATOR_FLAG_ORDERING | SIEVE_COMPARATOR_FLAG_EQUALITY |
+		SIEVE_COMPARATOR_FLAG_SUBSTRING_MATCH | SIEVE_COMPARATOR_FLAG_PREFIX_MATCH,
+	cmp_i_octet_compare,
+	cmp_i_octet_char_match,
+	sieve_comparator_octet_skip	
+};
+
+/*
+ * Comparator implementation
+ */
+ 
+static int cmp_i_octet_compare(
+	const struct sieve_comparator *cmp ATTR_UNUSED,
+	const char *val1, size_t val1_size, const char *val2, size_t val2_size)
+{
+	int result;
+
+	if ( val1_size == val2_size ) {
+		return memcmp((void *) val1, (void *) val2, val1_size);
+	} 
+	
+	if ( val1_size > val2_size ) {
+		result = memcmp((void *) val1, (void *) val2, val2_size);
+		
+		if ( result == 0 ) return 1;
+		
+		return result;
+	} 
+
+	result = memcmp((void *) val1, (void *) val2, val1_size);
+		
+	if ( result == 0 ) return -1;
+		
+	return result;
+}
+
+static bool cmp_i_octet_char_match
+	(const struct sieve_comparator *cmp ATTR_UNUSED, 
+		const char **val, const char *val_end, 
+		const char **key, const char *key_end)
+{
+	const char *val_begin = *val;
+	const char *key_begin = *key;
+	
+	while ( **val == **key && *val < val_end && *key < key_end ) {
+		(*val)++;
+		(*key)++;
+	}
+	
+	if ( *key < key_end ) {
+		/* Reset */
+		*val = val_begin;
+		*key = key_begin;	
+	
+		return FALSE;
+	}
+	
+	return TRUE;
+}
+ 
+ 
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/ext-encoded-character.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/ext-encoded-character.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/ext-encoded-character.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/ext-encoded-character.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,280 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension encoded-character 
+ * ---------------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: RFC5228
+ * Implementation: full 
+ * Status: experimental, largely untested
+ *
+ */
+
+#include "lib.h"
+#include "unichar.h"
+
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+
+#include <ctype.h>
+
+/* 
+ * Extension
+ */
+
+static bool ext_encoded_character_validator_load
+	(struct sieve_validator *validator);
+
+static int ext_my_id = -1;
+	
+struct sieve_extension encoded_character_extension = { 
+	"encoded-character", 
+	&ext_my_id,
+	NULL, NULL,
+	ext_encoded_character_validator_load, 
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_NO_OPERATIONS, 
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+/*
+ * Encoded string argument
+ */
+
+bool arg_encoded_string_validate
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *context);
+
+const struct sieve_argument encoded_string_argument = { 
+	"@encoded-string", 
+	NULL, NULL,
+	arg_encoded_string_validate, 
+	NULL, NULL 
+};
+
+/* Parsing */
+
+static bool _skip_whitespace
+	(const char **in, const char *inend)
+{
+	while ( *in < inend ) {
+		if ( **in == '\r' ) {
+			(*in)++;
+			if ( **in != '\n' )
+				return FALSE;
+			continue;
+		}
+		
+		/* (Loose LF is non-standard) */
+		if ( **in != ' ' && **in != '\n' && **in != '\t' ) 
+			break;
+			
+		(*in)++;
+	}
+	
+	return TRUE;
+}
+
+static bool _parse_hexint
+(const char **in, const char *inend, int max_digits, unsigned int *result)
+{
+	int digit = 0;
+	*result = 0;
+		
+	while ( *in < inend && (max_digits == 0 || digit < max_digits) ) {
+	
+		if ( (**in) >= '0' && (**in) <= '9' ) 
+			*result = ((*result) << 4) + (**in) - ((unsigned int) '0');
+		else if ( (**in) >= 'a' && (**in) <= 'f' )
+			*result = ((*result) << 4) + (**in) - ((unsigned int) 'a') + 0x0a;
+		else if ( (**in) >= 'A' && (**in) <= 'F' )
+			*result = ((*result) << 4) + (**in) - ((unsigned int) 'A') + 0x0a;
+		else
+			return ( digit > 0 );
+	
+		(*in)++;
+		digit++;
+	}
+	
+	if ( digit == max_digits ) {
+		/* Hex digit _MUST_ end here */
+		if ( (**in >= '0' && **in <= '9')	|| (**in >= 'a' && **in <= 'f') ||
+			(**in >= 'A' && **in <= 'F') )
+			return FALSE;
+			
+		return TRUE;
+	}
+	
+	return ( digit > 0 );
+}
+
+static bool _decode_hex
+(const char **in, const char *inend, string_t *result) 
+{
+	int values = 0;
+	
+	while ( *in < inend ) {
+		unsigned int hexpair;
+		
+		if ( !_skip_whitespace(in, inend) ) return FALSE;
+		
+		if ( !_parse_hexint(in, inend, 2, &hexpair) ) break;
+		
+		str_append_c(result, (unsigned char) hexpair);
+		values++;
+	}
+	
+	return ( values > 0 );
+}
+
+static int _decode_unicode
+(const char **in, const char *inend, string_t *result, unsigned int *error_hex) 
+{
+	int values = 0;
+	bool valid = TRUE;
+	
+	while ( *in < inend ) {
+		unsigned int unicode_hex;
+		
+		if ( !_skip_whitespace(in, inend) ) return FALSE;
+		
+		if ( !_parse_hexint(in, inend, 0, &unicode_hex) ) break;
+
+		if ( (unicode_hex <= 0xD7FF) || 
+			(unicode_hex >= 0xE000 && unicode_hex <= 0x10FFFF)	) 
+			uni_ucs4_to_utf8_c((unichar_t) unicode_hex, result);
+		else {
+			if ( valid ) *error_hex = unicode_hex;
+			valid = FALSE;
+		}	
+		values++;
+	}
+	
+	return ( values > 0 );
+}
+
+bool arg_encoded_string_validate
+(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd)
+{
+	bool result = TRUE;
+	enum { ST_NONE, ST_OPEN, ST_TYPE, ST_CLOSE } 
+		state = ST_NONE;
+	string_t *str = sieve_ast_argument_str(*arg);
+	string_t *tmpstr, *newstr = NULL;
+	const char *p, *mark, *strstart, *substart = NULL;
+	const char *strval = (const char *) str_data(str);
+	const char *strend = strval + str_len(str);
+	unsigned int error_hex = 0;
+
+	T_BEGIN {		
+		tmpstr = t_str_new(32);	
+			
+		p = strval;
+		strstart = p;
+		while ( result && p < strend ) {
+			switch ( state ) {
+			/* Normal string */
+			case ST_NONE:
+				if ( *p == '$' ) {
+					substart = p;
+					state = ST_OPEN;
+				}
+				p++;
+				break;
+			/* Parsed '$' */
+			case ST_OPEN:
+				if ( *p == '{' ) {
+					state = ST_TYPE;
+					p++;
+				} else 
+					state = ST_NONE;
+				break;
+			/* Parsed '${' */
+			case ST_TYPE:
+				mark = p;
+				/* Scan for 'hex' or 'unicode' */
+				while ( p < strend && i_isalpha(*p) ) p++;
+					
+				if ( *p != ':' ) {
+					state = ST_NONE;
+					break;
+				}
+				
+				state = ST_CLOSE;
+				
+				str_truncate(tmpstr, 0);
+				if ( strncasecmp(mark, "hex", p - mark) == 0 ) {
+					/* Hexadecimal */
+					p++;
+					if ( !_decode_hex(&p, strend, tmpstr) )
+						state = ST_NONE;
+				} else if ( strncasecmp(mark, "unicode", p - mark) == 0 ) {
+					/* Unicode */
+					p++;
+					if ( !_decode_unicode(&p, strend, tmpstr, &error_hex) )
+						state = ST_NONE;
+				} else {	
+					/* Invalid encoding */
+					p++;
+					state = ST_NONE;
+				}
+				break;
+			case ST_CLOSE:
+				if ( *p == '}' ) {				
+					/* We now know that the substitution is valid */	
+
+					if ( error_hex != 0 ) {
+						sieve_argument_validate_error(validator, *arg, 
+							"invalid unicode character 0x%08x in encoded character substitution",
+							error_hex);
+						result = FALSE;
+						break;
+					}
+					
+					if ( newstr == NULL ) {
+						newstr = str_new(sieve_ast_pool((*arg)->ast), str_len(str)*2);
+					}
+					
+					str_append_n(newstr, strstart, substart-strstart);
+					str_append_str(newstr, tmpstr);
+					
+					strstart = p + 1;
+					substart = strstart;
+					
+					p++;	
+				} 
+				state = ST_NONE;
+			}
+		}
+	} T_END;
+
+	if ( !result ) return FALSE;
+	
+	if ( newstr != NULL ) {
+		if ( strstart != strend )
+			str_append_n(newstr, strstart, strend-strstart);	
+	
+		sieve_ast_argument_string_set(*arg, newstr);
+	}
+	
+	/* Pass the processed string to a (possible) next layer of processing */
+	return sieve_validator_argument_activate_super
+		(validator, cmd, *arg, TRUE);
+}
+
+/* 
+ * Extension implementation
+ */
+
+static bool ext_encoded_character_validator_load
+(struct sieve_validator *validator ATTR_UNUSED)
+{
+	/* Override the constant string argument with our own */
+	sieve_validator_argument_override(validator, SAT_CONST_STRING, 
+		&encoded_string_argument); 
+	
+	return TRUE;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/ext-envelope.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/ext-envelope.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/ext-envelope.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/ext-envelope.c	2009-07-30 00:45:42.000000000 +0200
@@ -0,0 +1,523 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension envelope 
+ * ------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: RFC5228
+ * Implementation: full
+ * Status: experimental, largely untested
+ *
+ */
+
+#include "lib.h"
+#include "str-sanitize.h"
+#include "array.h"
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-address.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-address-parts.h"
+#include "sieve-message.h"
+
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+/*
+ * Forward declarations
+ */
+
+static const struct sieve_command envelope_test;
+const struct sieve_operation envelope_operation;
+const struct sieve_extension envelope_extension;
+
+/* 
+ * Extension 
+ */
+
+static bool ext_envelope_validator_load(struct sieve_validator *validator);
+
+static int ext_my_id = -1;
+
+const struct sieve_extension envelope_extension = { 
+	"envelope", 
+	&ext_my_id,
+	NULL, NULL,
+	ext_envelope_validator_load, 
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATION(envelope_operation), 
+	SIEVE_EXT_DEFINE_NO_OPERANDS 
+};
+
+static bool ext_envelope_validator_load(struct sieve_validator *validator)
+{
+	/* Register new test */
+	sieve_validator_register_command(validator, &envelope_test);
+
+	return TRUE;
+}
+
+/* 
+ * Envelope test 
+ *
+ * Syntax
+ *   envelope [COMPARATOR] [ADDRESS-PART] [MATCH-TYPE]
+ *     <envelope-part: string-list> <key-list: string-list>   
+ */
+
+static bool tst_envelope_registered
+	(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg);
+static bool tst_envelope_validate
+	(struct sieve_validator *validator, struct sieve_command_context *tst);
+static bool tst_envelope_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+static const struct sieve_command envelope_test = { 
+	"envelope", 
+	SCT_TEST, 
+	2, 0, FALSE, FALSE,
+	tst_envelope_registered, 
+	NULL,
+	tst_envelope_validate, 
+	tst_envelope_generate, 
+	NULL 
+};
+
+/* 
+ * Envelope operation 
+ */
+
+static bool ext_envelope_operation_dump
+	(const struct sieve_operation *op, 
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int ext_envelope_operation_execute
+	(const struct sieve_operation *op,
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation envelope_operation = { 
+	"ENVELOPE",
+	&envelope_extension,
+	0,
+	ext_envelope_operation_dump, 
+	ext_envelope_operation_execute 
+};
+
+/*
+ * Envelope parts
+ *
+ * FIXME: not available to extensions
+ */
+
+struct sieve_envelope_part {
+	const char *identifier;
+
+	const struct sieve_address *const *(*get_addresses)
+		(const struct sieve_runtime_env *renv);
+	const char * const *(*get_values)
+		(const struct sieve_runtime_env *renv);
+};
+
+static const struct sieve_address *const *_from_part_get_addresses
+	(const struct sieve_runtime_env *renv);
+static const char *const *_from_part_get_values
+	(const struct sieve_runtime_env *renv);
+static const struct sieve_address *const *_to_part_get_addresses
+	(const struct sieve_runtime_env *renv);
+static const char *const *_to_part_get_values
+	(const struct sieve_runtime_env *renv);
+static const char *const *_auth_part_get_values
+	(const struct sieve_runtime_env *renv);
+
+static const struct sieve_envelope_part _from_part = {
+	"from",
+	_from_part_get_addresses,
+	_from_part_get_values,
+};
+
+static const struct sieve_envelope_part _to_part = {
+	"to",
+	_to_part_get_addresses,
+	_to_part_get_values,
+};	
+
+static const struct sieve_envelope_part _auth_part = {
+	"auth",
+	NULL,
+	_auth_part_get_values,
+};	
+
+static const struct sieve_envelope_part *_envelope_parts[] = {
+	/* Required */
+	&_from_part, &_to_part, 
+
+	/* Non-standard */
+	&_auth_part
+};
+
+static unsigned int _envelope_part_count = N_ELEMENTS(_envelope_parts);
+
+static const struct sieve_envelope_part *_envelope_part_find
+(const char *identifier)
+{
+	unsigned int i;
+
+	for ( i = 0; i < _envelope_part_count; i++ ) {
+		if ( strcasecmp( _envelope_parts[i]->identifier, identifier ) == 0 ) {
+			return _envelope_parts[i];
+        }
+	}
+	
+	return NULL;
+}
+
+
+/* 
+ * Command Registration 
+ */
+
+static bool tst_envelope_registered
+(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg) 
+{
+	/* The order of these is not significant */
+	sieve_comparators_link_tag(validator, cmd_reg, SIEVE_AM_OPT_COMPARATOR);
+	sieve_address_parts_link_tags(validator, cmd_reg, SIEVE_AM_OPT_ADDRESS_PART);
+	sieve_match_types_link_tags(validator, cmd_reg, SIEVE_AM_OPT_MATCH_TYPE);
+	
+	return TRUE;
+}
+
+/* 
+ * Validation 
+ */
+ 
+static int _envelope_part_is_supported
+(void *context, struct sieve_ast_argument *arg)
+{
+	const struct sieve_envelope_part **not_address =
+		(const struct sieve_envelope_part **) context;
+
+	if ( sieve_argument_is_string_literal(arg) ) {
+		const struct sieve_envelope_part *epart;
+
+		if ( (epart=_envelope_part_find(sieve_ast_strlist_strc(arg))) != NULL ) {
+			if ( epart->get_addresses == NULL ) {
+				if ( *not_address == NULL )
+					*not_address = epart;
+			}
+					
+			return TRUE;
+		}
+		
+		return FALSE;
+	} 
+	
+	return TRUE; /* Can't check at compile time */
+}
+
+static bool tst_envelope_validate
+(struct sieve_validator *validator, struct sieve_command_context *tst) 
+{ 		
+	struct sieve_ast_argument *arg = tst->first_positional;
+	struct sieve_ast_argument *epart;
+	const struct sieve_envelope_part *not_address = NULL;
+				
+	if ( !sieve_validate_positional_argument
+		(validator, tst, arg, "envelope part", 1, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+	
+	if ( !sieve_validator_argument_activate(validator, tst, arg, FALSE) )
+		return FALSE;
+		
+	/* Check whether supplied envelope parts are supported
+	 *   FIXME: verify dynamic envelope parts at runtime 
+	 */
+	epart = arg;
+	if ( !sieve_ast_stringlist_map(&epart, (void *) &not_address, 
+		_envelope_part_is_supported) ) {		
+		
+		sieve_argument_validate_error(validator, epart, 
+			"specified envelope part '%s' is not supported by the envelope test", 
+				str_sanitize(sieve_ast_strlist_strc(epart), 64));
+		return FALSE;
+	}
+
+	if ( not_address != NULL ) {
+		struct sieve_ast_argument *addrp_arg = 
+			sieve_command_find_argument(tst, &address_part_tag);
+
+		if ( addrp_arg != NULL ) {
+			sieve_argument_validate_error(validator, addrp_arg,
+				"address part ':%s' specified while non-address envelope part '%s' "
+				"is tested with the envelope test",
+                sieve_ast_argument_tag(addrp_arg), not_address->identifier);
+	        return FALSE;
+		}
+	}
+	
+	arg = sieve_ast_argument_next(arg);
+	
+	if ( !sieve_validate_positional_argument
+		(validator, tst, arg, "key list", 2, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+	
+	if ( !sieve_validator_argument_activate(validator, tst, arg, FALSE) )
+		return FALSE;
+
+	/* Validate the key argument to a specified match type */
+	return sieve_match_type_validate
+		(validator, tst, arg, &is_match_type, &i_ascii_casemap_comparator);
+}
+
+/*
+ * Code generation
+ */
+ 
+static bool tst_envelope_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx) 
+{
+	(void)sieve_operation_emit_code(cgenv->sbin, &envelope_operation);
+
+	/* Generate arguments */
+	if ( !sieve_generate_arguments(cgenv, ctx, NULL) )
+		return FALSE;
+
+	return TRUE;
+}
+
+/* 
+ * Code dump 
+ */
+ 
+static bool ext_envelope_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED, 
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	sieve_code_dumpf(denv, "ENVELOPE");
+	sieve_code_descend(denv);
+
+	/* Handle any optional arguments */
+	if ( !sieve_addrmatch_default_dump_optionals(denv, address) )
+		return FALSE;
+
+	return
+		sieve_opr_stringlist_dump(denv, address, "envelope part") &&
+		sieve_opr_stringlist_dump(denv, address, "key list");
+}
+
+/*
+ * Interpretation
+ */
+
+static const struct sieve_address *const *_from_part_get_addresses
+(const struct sieve_runtime_env *renv)
+{
+	ARRAY_DEFINE(envelope_values, const struct sieve_address *);
+	const struct sieve_address *address =
+		sieve_message_get_sender_address(renv->msgctx);
+	
+	if ( address != NULL ) {
+		t_array_init(&envelope_values, 2);
+
+        array_append(&envelope_values, &address, 1);
+
+	    (void)array_append_space(&envelope_values);
+    	return array_idx(&envelope_values, 0);
+	} 
+
+	return NULL;
+}
+
+static const char *const *_from_part_get_values
+(const struct sieve_runtime_env *renv)
+{
+	ARRAY_DEFINE(envelope_values, const char *);
+
+	t_array_init(&envelope_values, 2);
+
+	if ( renv->msgdata->return_path != NULL ) {
+        array_append(&envelope_values, &renv->msgdata->return_path, 1);
+	}
+
+	(void)array_append_space(&envelope_values);
+
+	return array_idx(&envelope_values, 0);
+}
+
+static const struct sieve_address *const *_to_part_get_addresses
+(const struct sieve_runtime_env *renv)
+{
+	ARRAY_DEFINE(envelope_values, const struct sieve_address *);
+	const struct sieve_address *address = 
+		sieve_message_get_recipient_address(renv->msgctx);	
+
+	if ( address != NULL && address->local_part != NULL ) {
+		t_array_init(&envelope_values, 2);
+
+        array_append(&envelope_values, &address, 1);
+
+	    (void)array_append_space(&envelope_values);
+    	return array_idx(&envelope_values, 0);
+	}
+
+	return NULL;
+}
+
+static const char *const *_to_part_get_values
+(const struct sieve_runtime_env *renv)
+{
+	ARRAY_DEFINE(envelope_values, const char *);
+
+	t_array_init(&envelope_values, 2);
+
+	if ( renv->msgdata->to_address != NULL ) {
+        array_append(&envelope_values, &renv->msgdata->to_address, 1);
+	}
+
+	(void)array_append_space(&envelope_values);
+
+	return array_idx(&envelope_values, 0);
+}
+
+
+static const char *const *_auth_part_get_values
+(const struct sieve_runtime_env *renv)
+{
+	ARRAY_DEFINE(envelope_values, const char *);
+
+	t_array_init(&envelope_values, 2);
+
+	if ( renv->msgdata->auth_user != NULL )
+        array_append(&envelope_values, &renv->msgdata->auth_user, 1);
+
+	(void)array_append_space(&envelope_values);
+
+	return array_idx(&envelope_values, 0);
+}
+
+static int ext_envelope_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	bool result = TRUE;
+	const struct sieve_comparator *cmp = &i_ascii_casemap_comparator;
+	const struct sieve_match_type *mtch = &is_match_type;
+	const struct sieve_address_part *addrp = &all_address_part;
+	struct sieve_match_context *mctx;
+	struct sieve_coded_stringlist *envp_list;
+	struct sieve_coded_stringlist *key_list;
+	string_t *envp_item;
+	bool matched;
+	int ret;
+
+	/*
+	 * Read operands
+	 */
+	
+	sieve_runtime_trace(renv, "ENVELOPE test");
+
+	if ( (ret=sieve_addrmatch_default_get_optionals
+		(renv, address, &addrp, &mtch, &cmp)) <= 0 )
+		return ret; 
+
+	/* Read envelope-part */
+	if ( (envp_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid envelope-part operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Read key-list */
+	if ( (key_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid key-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/* Initialize match */
+	mctx = sieve_match_begin(renv->interp, mtch, cmp, NULL, key_list);
+	
+	/* Iterate through all requested headers to match */
+	envp_item = NULL;
+	matched = FALSE;
+	while ( result && !matched && 
+		(result=sieve_coded_stringlist_next_item(envp_list, &envp_item)) 
+		&& envp_item != NULL ) {
+		const struct sieve_envelope_part *epart;
+			
+		if ( (epart=_envelope_part_find(str_c(envp_item))) != NULL ) {
+			const struct sieve_address * const *addresses = NULL;
+			int i;
+
+			if ( epart->get_addresses != NULL ) {
+				/* Field contains addresses */
+				addresses = epart->get_addresses(renv);
+
+				if ( addresses != NULL ) {
+					for ( i = 0; !matched && addresses[i] != NULL; i++ ) {
+						if ( addresses[i]->local_part == NULL ) {
+							/* Null path <> */
+							ret = sieve_match_value(mctx, "", 0);
+						} else {
+							const char *part = addrp->extract_from(addresses[i]);
+
+							if ( part != NULL ) 
+								ret = sieve_match_value(mctx, part, strlen(part));
+							else
+								ret = 0;
+						}
+
+						if ( ret < 0 ) {
+							result = FALSE;
+							break;
+						}
+
+       	        		matched = ret > 0;
+					}
+				}
+			} 
+
+			if ( epart->get_values != NULL && addresses == NULL && 
+				addrp == &all_address_part ) {
+				/* Field contains something else */
+				const char *const *values = epart->get_values(renv);
+
+				if ( values == NULL ) continue;
+	
+				for ( i = 0; !matched && values[i] != NULL; i++ ) {				
+
+					if ( (ret=sieve_match_value
+						(mctx, values[i], strlen(values[i]))) < 0 ) {
+	                    result = FALSE;
+    	                break;
+        	        }
+			
+					matched = ret > 0;				
+				}
+			}
+		}
+	}
+	
+	/* Finish match */
+	if ( (ret=sieve_match_end(&mctx)) < 0 ) 
+		result = FALSE;
+	else
+		matched = ( ret > 0 || matched );
+
+	if ( result ) {
+		/* Set test result for subsequent conditional jump */
+		sieve_interpreter_set_test_result(renv->interp, matched);
+		return SIEVE_EXEC_OK;
+	}
+	
+	sieve_runtime_trace_error(renv, "invalid string-list item");	
+	return SIEVE_EXEC_BIN_CORRUPT;
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/ext-fileinto.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/ext-fileinto.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/ext-fileinto.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/ext-fileinto.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,223 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension fileinto 
+ * ------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: RFC5228
+ * Implementation: full
+ * Status: experimental, largely untested
+ *
+ */
+
+#include "lib.h"
+#include "str-sanitize.h"
+#include "imap-utf7.h"
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-binary.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-actions.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-result.h"
+
+/* 
+ * Forward declarations 
+ */
+
+static const struct sieve_command fileinto_command;
+const struct sieve_operation fileinto_operation;
+const struct sieve_extension fileinto_extension; 
+
+/* 
+ * Extension
+ */
+
+static bool ext_fileinto_validator_load(struct sieve_validator *validator);
+
+static int ext_my_id = -1;
+
+const struct sieve_extension fileinto_extension = { 
+	"fileinto", 
+	&ext_my_id,
+	NULL, NULL,
+	ext_fileinto_validator_load, 
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATION(fileinto_operation), 
+	SIEVE_EXT_DEFINE_NO_OPERANDS	
+};
+
+static bool ext_fileinto_validator_load(struct sieve_validator *validator)
+{
+	/* Register new command */
+	sieve_validator_register_command(validator, &fileinto_command);
+
+	return TRUE;
+}
+
+/* 
+ * Fileinto command
+ *
+ * Syntax: 
+ *   fileinto <folder: string>
+ */
+
+static bool cmd_fileinto_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd);
+static bool cmd_fileinto_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+static const struct sieve_command fileinto_command = { 
+	"fileinto", 
+	SCT_COMMAND,
+	1, 0, FALSE, FALSE, 
+	NULL, NULL,
+	cmd_fileinto_validate, 
+	cmd_fileinto_generate, 
+	NULL 
+};
+
+/* 
+ * Fileinto operation 
+ */
+
+static bool ext_fileinto_operation_dump
+	(const struct sieve_operation *op, 
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int ext_fileinto_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address); 
+
+const struct sieve_operation fileinto_operation = { 
+	"FILEINTO",
+	&fileinto_extension,
+	0,
+	ext_fileinto_operation_dump, 
+	ext_fileinto_operation_execute 
+};
+
+/* 
+ * Validation 
+ */
+
+static bool cmd_fileinto_validate
+(struct sieve_validator *validator, struct sieve_command_context *cmd) 
+{ 	
+	struct sieve_ast_argument *arg = cmd->first_positional;
+	
+	if ( !sieve_validate_positional_argument
+		(validator, cmd, arg, "folder", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+	
+	return sieve_validator_argument_activate(validator, cmd, arg, FALSE);
+}
+
+/*
+ * Code generation
+ */
+ 
+static bool cmd_fileinto_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx) 
+{
+	sieve_operation_emit_code(cgenv->sbin, &fileinto_operation);
+
+	/* Emit line number */
+    sieve_code_source_line_emit(cgenv->sbin, sieve_command_source_line(ctx));
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, ctx, NULL);
+}
+
+/* 
+ * Code dump
+ */
+ 
+static bool ext_fileinto_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	sieve_code_dumpf(denv, "FILEINTO");
+	sieve_code_descend(denv);
+
+	/* Source line */
+    if ( !sieve_code_source_line_dump(denv, address) )
+        return FALSE;
+
+	if ( !sieve_code_dumper_print_optional_operands(denv, address) ) {
+		return FALSE;
+	}
+
+	return sieve_opr_string_dump(denv, address, "folder");
+}
+
+/*
+ * Execution
+ */
+
+static int ext_fileinto_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	struct sieve_side_effects_list *slist = NULL; 
+	string_t *folder, *folder_utf7;
+	const char *mailbox;
+	unsigned int source_line;
+	int ret = 0;
+	
+	/*
+	 * Read operands
+	 */
+
+	/* Source line */
+	if ( !sieve_code_source_line_read(renv, address, &source_line) ) {
+		sieve_runtime_trace_error(renv, "invalid source line");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/* Optional operands */
+	if ( (ret=sieve_interpreter_handle_optional_operands(renv, address, &slist)) 
+		<= 0 )
+		return ret;
+
+	/* Folder operand */
+	if ( !sieve_opr_string_read(renv, address, &folder) ) {
+		sieve_runtime_trace_error(renv, "invalid folder operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/*
+	 * Perform operation
+	 */
+
+	mailbox = str_sanitize(str_c(folder), 64);
+	sieve_runtime_trace(renv, "FILEINTO action (\"%s\")", mailbox);
+		
+	/* Convert utf-8 folder name to utf-7
+	 *   FIXME: perform this at compile time when possible.
+	 */
+	folder_utf7 = t_str_new(256);
+	if ( imap_utf8_to_utf7(str_c(folder), folder_utf7) < 0 ) {
+		sieve_runtime_error
+			(renv, sieve_error_script_location(renv->script, source_line),
+				"mailbox name not utf-8: %s", mailbox);
+	}	
+		
+	/* Add action to result */	
+	ret = sieve_act_store_add_to_result
+		(renv, slist, str_c(folder_utf7), source_line);
+
+	return ( ret >= 0 );
+}
+
+
+
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/ext-reject.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/ext-reject.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/ext-reject.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/ext-reject.c	2009-07-21 03:07:54.000000000 +0200
@@ -0,0 +1,534 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension reject 
+ * ----------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: RFC5429
+ * Implementation: full  
+ * Status: experimental
+ *
+ */
+
+#include "lib.h"
+#include "ioloop.h"
+#include "hostpid.h"
+#include "str-sanitize.h"
+#include "message-date.h"
+#include "message-size.h"
+#include "istream.h"
+#include "istream-header-filter.h"
+
+#include "rfc2822.h"
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-actions.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-result.h"
+#include "sieve-message.h"
+
+/* 
+ * Forward declarations 
+ */
+
+static const struct sieve_command reject_command;
+static const struct sieve_operation reject_operation;
+
+static const struct sieve_command ereject_command;
+static const struct sieve_operation ereject_operation;
+
+/* 
+ * Extensions
+ */
+
+/* Reject */
+
+static bool ext_reject_validator_load(struct sieve_validator *validator);
+
+static int ext_reject_my_id = -1;
+	
+const struct sieve_extension reject_extension = { 
+	"reject", 
+	&ext_reject_my_id,
+	NULL, NULL,
+	ext_reject_validator_load, 
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATION(reject_operation), 
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+static bool ext_reject_validator_load(struct sieve_validator *validator)
+{
+	/* Register new command */
+	sieve_validator_register_command(validator, &reject_command);
+
+	return TRUE;
+}
+
+/* EReject */
+
+static bool ext_ereject_validator_load(struct sieve_validator *validator);
+
+static int ext_ereject_my_id = -1;
+	
+const struct sieve_extension ereject_extension = { 
+	"ereject", 
+	&ext_ereject_my_id,
+	NULL, NULL,
+	ext_ereject_validator_load, 
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATION(ereject_operation), 
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+static bool ext_ereject_validator_load(struct sieve_validator *validator)
+{
+	/* Register new command */
+	sieve_validator_register_command(validator, &ereject_command);
+
+	return TRUE;
+}
+
+/* 
+ * Commands
+ */
+
+/* Forward declarations */
+
+static bool cmd_reject_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd);
+static bool cmd_reject_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx); 
+
+/* Reject command
+ * 
+ * Syntax: 
+ *   reject <reason: string>
+ */
+
+static const struct sieve_command reject_command = { 
+	"reject", 
+	SCT_COMMAND, 
+	1, 0, FALSE, FALSE,
+	NULL, NULL,
+	cmd_reject_validate, 
+	cmd_reject_generate, 
+	NULL 
+};
+
+/* EReject command
+ * 
+ * Syntax: 
+ *   ereject <reason: string>
+ */
+
+static const struct sieve_command ereject_command = { 
+	"ereject", 
+	SCT_COMMAND, 
+	1, 0, FALSE, FALSE,
+	NULL, NULL,
+	cmd_reject_validate, 
+	cmd_reject_generate, 
+	NULL 
+};
+
+/*
+ * Operations
+ */
+
+/* Forward declarations */
+
+static bool ext_reject_operation_dump
+	(const struct sieve_operation *op, 
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int ext_reject_operation_execute
+	(const struct sieve_operation *op,
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+/* Reject operation */
+
+static const struct sieve_operation reject_operation = { 
+	"REJECT",
+	&reject_extension, 
+	0,
+	ext_reject_operation_dump, 
+	ext_reject_operation_execute 
+};
+
+/* EReject operation */
+
+static const struct sieve_operation ereject_operation = { 
+	"EREJECT",
+	&ereject_extension, 
+	0,
+	ext_reject_operation_dump, 
+	ext_reject_operation_execute 
+};
+
+/* 
+ * Reject action 
+ */
+
+static int act_reject_check_duplicate
+	(const struct sieve_runtime_env *renv, 
+		const struct sieve_action_data *act, 
+		const struct sieve_action_data *act_other);
+int act_reject_check_conflict
+	(const struct sieve_runtime_env *renv, 
+		const struct sieve_action_data *act, 
+		const struct sieve_action_data *act_other);
+static void act_reject_print
+	(const struct sieve_action *action, const struct sieve_result_print_env *rpenv,
+		void *context, bool *keep);	
+static bool act_reject_commit
+	(const struct sieve_action *action ATTR_UNUSED, 
+		const struct sieve_action_exec_env *aenv, void *tr_context, bool *keep);
+		
+const struct sieve_action act_reject = {
+	"reject",
+	SIEVE_ACTFLAG_SENDS_RESPONSE,
+	NULL,
+	act_reject_check_duplicate, 
+	act_reject_check_conflict,
+	act_reject_print,
+	NULL, NULL,
+	act_reject_commit,
+	NULL
+};
+
+struct act_reject_context {
+	const char *reason;
+	bool ereject;
+};
+
+/* 
+ * Validation 
+ */
+
+static bool cmd_reject_validate
+(struct sieve_validator *validator, struct sieve_command_context *cmd) 
+{ 	
+	struct sieve_ast_argument *arg = cmd->first_positional;
+		
+	if ( !sieve_validate_positional_argument
+		(validator, cmd, arg, "reason", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+	
+	return sieve_validator_argument_activate(validator, cmd, arg, FALSE);
+}
+
+/*
+ * Code generation
+ */
+ 
+static bool cmd_reject_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx) 
+{
+	if ( ctx->command == &reject_command )
+		sieve_operation_emit_code(cgenv->sbin, &reject_operation);
+	else
+		sieve_operation_emit_code(cgenv->sbin, &ereject_operation);
+
+	/* Emit line number */
+	sieve_code_source_line_emit(cgenv->sbin, sieve_command_source_line(ctx));
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, ctx, NULL);
+}
+
+/* 
+ * Code dump
+ */
+ 
+static bool ext_reject_operation_dump
+(const struct sieve_operation *op,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	sieve_code_dumpf(denv, "%s", op->mnemonic);
+	sieve_code_descend(denv);
+	
+	/* Source line */
+	if ( !sieve_code_source_line_dump(denv, address) )
+		return FALSE;
+
+	if ( !sieve_code_dumper_print_optional_operands(denv, address) )
+		return FALSE;
+	
+	return sieve_opr_string_dump(denv, address, "reason");
+}
+
+/*
+ * Interpretation
+ */
+
+static int ext_reject_operation_execute
+(const struct sieve_operation *op,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	struct sieve_side_effects_list *slist = NULL;
+	struct act_reject_context *act;
+	string_t *reason;
+	unsigned int source_line;
+	pool_t pool;
+	int ret;
+
+	/* Source line */
+	if ( !sieve_code_source_line_read(renv, address, &source_line) ) {
+		sieve_runtime_trace_error(renv, "invalid source line");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/* Optional operands (side effects) */
+	if ( (ret=sieve_interpreter_handle_optional_operands
+		(renv, address, &slist)) <= 0 )
+		return ret;
+
+	/* Read rejection reason */
+	if ( !sieve_opr_string_read(renv, address, &reason) ) {
+		sieve_runtime_trace_error(renv, "invalid reason operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	sieve_runtime_trace(renv, "%s action (\"%s\")", op->mnemonic, str_sanitize(str_c(reason), 64));
+
+	/* Add reject action to the result */
+	pool = sieve_result_pool(renv->result);
+	act = p_new(pool, struct act_reject_context, 1);
+	act->reason = p_strdup(pool, str_c(reason));
+	act->ereject = ( op == &ereject_operation );
+	
+	ret = sieve_result_add_action
+		(renv, &act_reject, slist, source_line, (void *) act, 0);
+	
+	return ( ret >= 0 );
+}
+
+/*
+ * Action implementation
+ */
+
+static int act_reject_check_duplicate
+(const struct sieve_runtime_env *renv ATTR_UNUSED,
+	const struct sieve_action_data *act, 
+	const struct sieve_action_data *act_other)
+{
+	if ( !act_other->executed ) {
+		sieve_runtime_error(renv, act->location, 
+			"duplicate reject/ereject action not allowed "
+			"(previously triggered one was here: %s)", act_other->location);	
+		return -1;
+	}
+	
+	return 1;
+}
+ 
+int act_reject_check_conflict
+(const struct sieve_runtime_env *renv,
+	const struct sieve_action_data *act, 
+	const struct sieve_action_data *act_other)
+{
+	if ( (act_other->action->flags & SIEVE_ACTFLAG_TRIES_DELIVER) > 0 ) {
+		if ( !act_other->executed ) {
+			sieve_runtime_error(renv, act->location, 
+				"reject/ereject action conflicts with other action: "
+				"the %s action (%s) tries to deliver the message",
+				act_other->action->name, act_other->location);	
+			return -1;
+		}
+	}
+
+	if ( (act_other->action->flags & SIEVE_ACTFLAG_SENDS_RESPONSE) > 0 ) {
+		struct act_reject_context *rj_ctx;
+
+		if ( !act_other->executed ) {
+			sieve_runtime_error(renv, act->location, 
+				"reject/ereject action conflicts with other action: "
+				"the %s action (%s) also sends a response to the sender",
+				act_other->action->name, act_other->location);	
+			return -1;
+		}
+
+		/* Conflicting action was already executed, transform reject into discard
+		 * equivalent.
+		 */
+		rj_ctx = (struct act_reject_context *) act->context;
+		rj_ctx->reason = NULL;
+	}
+
+	return 0;
+}
+ 
+static void act_reject_print
+(const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_result_print_env *rpenv, void *context, bool *keep)	
+{
+	struct act_reject_context *rj_ctx = (struct act_reject_context *) context;
+	
+	if ( rj_ctx->reason != NULL ) {
+		sieve_result_action_printf(rpenv, "reject message with reason: %s", 
+			str_sanitize(rj_ctx->reason, 128));
+	} else {
+		sieve_result_action_printf(rpenv, "reject message without sending a response (discard)"); 		
+	}
+	
+	*keep = FALSE;
+}
+
+static bool act_reject_send	
+(const struct sieve_action_exec_env *aenv, struct act_reject_context *ctx,
+	const char *sender, const char *recipient)
+{
+	const struct sieve_script_env *senv = aenv->scriptenv;
+	const struct sieve_message_data *msgdata = aenv->msgdata;
+	struct istream *input;
+	void *smtp_handle;
+	struct message_size hdr_size;
+	FILE *f;
+	const char *new_msgid, *boundary;
+	const unsigned char *data;
+	const char *header;
+	size_t size;
+	int ret;
+
+	/* Just to be sure */
+	if ( senv->smtp_open == NULL || senv->smtp_close == NULL ) {
+		sieve_result_warning(aenv, "reject action has no means to send mail");
+		return TRUE;
+	}
+
+	smtp_handle = senv->smtp_open(sender, NULL, &f);
+
+	new_msgid = sieve_message_get_new_id(senv);
+	boundary = t_strdup_printf("%s/%s", my_pid, senv->hostname);
+
+	rfc2822_header_field_write(f, "X-Sieve", SIEVE_IMPLEMENTATION);
+	rfc2822_header_field_write(f, "Message-ID", new_msgid);
+	rfc2822_header_field_write(f, "Date", message_date_create(ioloop_time));
+	rfc2822_header_field_printf(f, "From", "Mail Delivery Subsystem <%s>",
+		senv->postmaster_address);
+	rfc2822_header_field_printf(f, "To", "<%s>", sender);
+	rfc2822_header_field_write(f, "Subject", "Automatically rejected mail");
+	rfc2822_header_field_write(f, "Auto-Submitted", "auto-replied (rejected)");
+	rfc2822_header_field_write(f, "Precedence", "bulk");
+	
+	rfc2822_header_field_write(f, "MIME-Version", "1.0");
+	rfc2822_header_field_printf(f, "Content-Type", 
+		"multipart/report; report-type=disposition-notification;\n"
+		"boundary=\"%s\"", boundary);
+	
+	fprintf(f, "\r\nThis is a MIME-encapsulated message\r\n\r\n");
+
+	/* Human readable status report */
+	fprintf(f, "--%s\r\n", boundary);
+	fprintf(f, "Content-Type: text/plain; charset=utf-8\r\n");
+	fprintf(f, "Content-Disposition: inline\r\n");
+	fprintf(f, "Content-Transfer-Encoding: 8bit\r\n\r\n");
+
+	/* FIXME: var_expand_table expansion not possible */
+	fprintf(f, "Your message to <%s> was automatically rejected:\r\n"	
+		"%s\r\n", recipient, ctx->reason);
+
+	/* MDN status report */
+	fprintf(f, "--%s\r\n"
+		"Content-Type: message/disposition-notification\r\n\r\n", boundary);
+	fprintf(f, "Reporting-UA: %s; Dovecot Mail Delivery Agent\r\n",
+		senv->hostname);
+	if (mail_get_first_header(msgdata->mail, "Original-Recipient", &header) > 0)
+		fprintf(f, "Original-Recipient: rfc822; %s\r\n", header);
+	fprintf(f, "Final-Recipient: rfc822; %s\r\n", recipient);
+
+	if ( msgdata->id != NULL )
+		fprintf(f, "Original-Message-ID: %s\r\n", msgdata->id);
+	fprintf(f, "Disposition: "
+		"automatic-action/MDN-sent-automatically; deleted\r\n");
+	fprintf(f, "\r\n");
+
+	/* original message's headers */
+	fprintf(f, "--%s\r\nContent-Type: message/rfc822\r\n\r\n", boundary);
+
+	if (mail_get_stream(msgdata->mail, &hdr_size, NULL, &input) == 0) {
+		/* Note: If you add more headers, they need to be sorted.
+		 * We'll drop Content-Type because we're not including the message
+		 * body, and having a multipart Content-Type may confuse some
+		 * MIME parsers when they don't see the message boundaries. 
+		 */
+		static const char *const exclude_headers[] = {
+			"Content-Type"
+		};
+
+		input = i_stream_create_header_filter(input,
+			HEADER_FILTER_EXCLUDE | HEADER_FILTER_NO_CR | HEADER_FILTER_HIDE_BODY, 
+			exclude_headers, N_ELEMENTS(exclude_headers), 
+			null_header_filter_callback, NULL);
+
+		while ((ret = i_stream_read_data(input, &data, &size, 0)) > 0) {
+			if (fwrite(data, size, 1, f) == 0)
+				break;
+			i_stream_skip(input, size);
+		}
+		i_stream_unref(&input);
+			
+		i_assert(ret != 0);
+	}
+
+	fprintf(f, "\r\n\r\n--%s--\r\n", boundary);
+
+	if ( !senv->smtp_close(smtp_handle) ) {
+		sieve_result_error(aenv, 
+			"failed to send rejection message to <%s> "
+			"(refer to server log for more information)",
+			str_sanitize(sender, 80));
+		return FALSE;
+	}
+	
+	return TRUE;
+}
+
+static bool act_reject_commit
+(const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_action_exec_env *aenv, void *tr_context, bool *keep)
+{
+	struct act_reject_context *rj_ctx = (struct act_reject_context *) tr_context;
+	const char *sender = sieve_message_get_sender(aenv->msgctx);
+	const char *recipient = sieve_message_get_recipient(aenv->msgctx);
+
+	if ( recipient == NULL ) {
+		sieve_result_warning(aenv, "reject action aborted: envelope recipient is <>");
+		return TRUE;
+	}
+	
+	if ( rj_ctx->reason == NULL ) {
+		sieve_result_log(aenv, "not sending reject message (would cause second response to sender)");
+    
+		*keep = FALSE;
+		return TRUE;
+	}
+
+	if ( sender == NULL ) {
+		sieve_result_log(aenv, "not sending reject message to <>");
+    
+		*keep = FALSE;
+		return TRUE;
+	}
+		
+	if ( act_reject_send(aenv, rj_ctx, sender, recipient) ) {
+		sieve_result_log(aenv, "rejected message from <%s> (%s)", str_sanitize(sender, 80),
+			( rj_ctx->ereject ? "ereject" : "reject" ));
+
+		*keep = FALSE;
+		return TRUE;
+	}
+	  
+	return FALSE;
+}
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/Makefile.am dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/Makefile.am
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/Makefile.am	2009-08-21 00:52:15.000000000 +0200
@@ -0,0 +1,136 @@
+SUBDIRS = plugins
+
+noinst_LTLIBRARIES = libsieve.la
+
+AM_CPPFLAGS = \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage \
+	-I$(dovecot_incdir)/src/lib-imap
+
+tests = \
+	tst-truefalse.c \
+	tst-not.c \
+	tst-anyof.c \
+	tst-allof.c \
+	tst-address.c \
+	tst-header.c \
+	tst-exists.c \
+	tst-size.c
+
+commands = \
+	cmd-require.c \
+	cmd-stop.c \
+	cmd-if.c \
+	cmd-keep.c \
+	cmd-redirect.c \
+	cmd-discard.c
+
+extensions = \
+	ext-fileinto.c \
+	ext-reject.c \
+	ext-envelope.c \
+	ext-encoded-character.c
+
+match_types = \
+	mcht-is.c \
+	mcht-contains.c \
+	mcht-matches.c
+
+comparators = \
+	cmp-i-octet.c \
+	cmp-i-ascii-casemap.c
+
+if BUILD_UNFINISHED
+unfinished_plugins =
+endif
+
+# These are not actual plugins just yet...
+plugins = \
+	./plugins/vacation/libsieve_ext_vacation.la \
+	./plugins/subaddress/libsieve_ext_subaddress.la \
+ 	./plugins/comparator-i-ascii-numeric/libsieve_ext_comparator-i-ascii-numeric.la \
+	./plugins/relational/libsieve_ext_relational.la \
+	./plugins/regex/libsieve_ext_regex.la \
+	./plugins/copy/libsieve_ext_copy.la \
+	./plugins/imap4flags/libsieve_ext_imap4flags.la \
+	./plugins/include/libsieve_ext_include.la \
+	./plugins/body/libsieve_ext_body.la \
+	./plugins/variables/libsieve_ext_variables.la \
+	./plugins/enotify/libsieve_ext_enotify.la \
+	./plugins/notify/libsieve_ext_notify.la \
+	./plugins/environment/libsieve_ext_environment.la \
+	./plugins/mailbox/libsieve_ext_mailbox.la \
+	./plugins/date/libsieve_ext_date.la \
+	$(unfinished_plugins)
+
+libsieve_la_DEPENDENCIES = $(plugins)
+libsieve_la_LIBADD = $(plugins)
+
+libsieve_la_SOURCES = \
+	rfc2822.c \
+	sieve-limits.c \
+	sieve-message.c \
+	sieve-lexer.c \
+	sieve-script.c \
+	sieve-ast.c \
+	sieve-binary.c \
+	sieve-parser.c \
+	sieve-address.c \
+	sieve-validator.c \
+	sieve-generator.c \
+	sieve-interpreter.c \
+	sieve-code-dumper.c \
+	sieve-binary-dumper.c \
+	sieve-result.c \
+	sieve-error.c \
+	sieve-objects.c \
+	sieve-comparators.c \
+	sieve-match-types.c \
+	sieve-address-parts.c \
+	sieve-match.c \
+	sieve-commands.c \
+	sieve-code.c \
+	sieve-actions.c \
+	sieve-extensions.c \
+	$(comparators) \
+	$(match_types) \
+	$(tests) \
+	$(commands) \
+	$(extensions) \
+	sieve.c 
+
+noinst_HEADERS = \
+	rfc2822.h \
+	sieve-config.h \
+	sieve-types.h \
+	sieve-common.h \
+	sieve-limits.h \
+	sieve-message.h \
+	sieve-lexer.h \
+	sieve-script.h \
+	sieve-script-private.h \
+	sieve-ast.h \
+	sieve-binary.h \
+	sieve-parser.h \
+	sieve-address.h \
+	sieve-validator.h \
+	sieve-generator.h \
+	sieve-interpreter.h \
+	sieve-code-dumper.h \
+	sieve-binary-dumper.h \
+	sieve-dump.h \
+	sieve-result.h \
+	sieve-error.h \
+	sieve-error-private.h \
+	sieve-objects.h \
+	sieve-match.h \
+	sieve-comparators.h \
+	sieve-match-types.h \
+	sieve-address-parts.h \
+	sieve-commands.h \
+	sieve-code.h \
+	sieve-actions.h \
+	sieve-extensions.h \
+	sieve.h
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/Makefile.in dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/Makefile.in
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/Makefile.in	2009-08-21 00:55:42.000000000 +0200
@@ -0,0 +1,771 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+am__DEPENDENCIES_1 =
+am__DEPENDENCIES_2 = ./plugins/vacation/libsieve_ext_vacation.la \
+	./plugins/subaddress/libsieve_ext_subaddress.la \
+	./plugins/comparator-i-ascii-numeric/libsieve_ext_comparator-i-ascii-numeric.la \
+	./plugins/relational/libsieve_ext_relational.la \
+	./plugins/regex/libsieve_ext_regex.la \
+	./plugins/copy/libsieve_ext_copy.la \
+	./plugins/imap4flags/libsieve_ext_imap4flags.la \
+	./plugins/include/libsieve_ext_include.la \
+	./plugins/body/libsieve_ext_body.la \
+	./plugins/variables/libsieve_ext_variables.la \
+	./plugins/enotify/libsieve_ext_enotify.la \
+	./plugins/notify/libsieve_ext_notify.la \
+	./plugins/environment/libsieve_ext_environment.la \
+	./plugins/mailbox/libsieve_ext_mailbox.la \
+	./plugins/date/libsieve_ext_date.la $(am__DEPENDENCIES_1)
+am__objects_1 = cmp-i-octet.lo cmp-i-ascii-casemap.lo
+am__objects_2 = mcht-is.lo mcht-contains.lo mcht-matches.lo
+am__objects_3 = tst-truefalse.lo tst-not.lo tst-anyof.lo tst-allof.lo \
+	tst-address.lo tst-header.lo tst-exists.lo tst-size.lo
+am__objects_4 = cmd-require.lo cmd-stop.lo cmd-if.lo cmd-keep.lo \
+	cmd-redirect.lo cmd-discard.lo
+am__objects_5 = ext-fileinto.lo ext-reject.lo ext-envelope.lo \
+	ext-encoded-character.lo
+am_libsieve_la_OBJECTS = rfc2822.lo sieve-limits.lo sieve-message.lo \
+	sieve-lexer.lo sieve-script.lo sieve-ast.lo sieve-binary.lo \
+	sieve-parser.lo sieve-address.lo sieve-validator.lo \
+	sieve-generator.lo sieve-interpreter.lo sieve-code-dumper.lo \
+	sieve-binary-dumper.lo sieve-result.lo sieve-error.lo \
+	sieve-objects.lo sieve-comparators.lo sieve-match-types.lo \
+	sieve-address-parts.lo sieve-match.lo sieve-commands.lo \
+	sieve-code.lo sieve-actions.lo sieve-extensions.lo \
+	$(am__objects_1) $(am__objects_2) $(am__objects_3) \
+	$(am__objects_4) $(am__objects_5) sieve.lo
+libsieve_la_OBJECTS = $(am_libsieve_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_la_SOURCES)
+DIST_SOURCES = $(libsieve_la_SOURCES)
+RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
+	html-recursive info-recursive install-data-recursive \
+	install-dvi-recursive install-exec-recursive \
+	install-html-recursive install-info-recursive \
+	install-pdf-recursive install-ps-recursive install-recursive \
+	installcheck-recursive installdirs-recursive pdf-recursive \
+	ps-recursive uninstall-recursive
+HEADERS = $(noinst_HEADERS)
+RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
+  distclean-recursive maintainer-clean-recursive
+ETAGS = etags
+CTAGS = ctags
+DIST_SUBDIRS = $(SUBDIRS)
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+SUBDIRS = plugins
+noinst_LTLIBRARIES = libsieve.la
+AM_CPPFLAGS = \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage \
+	-I$(dovecot_incdir)/src/lib-imap
+
+tests = \
+	tst-truefalse.c \
+	tst-not.c \
+	tst-anyof.c \
+	tst-allof.c \
+	tst-address.c \
+	tst-header.c \
+	tst-exists.c \
+	tst-size.c
+
+commands = \
+	cmd-require.c \
+	cmd-stop.c \
+	cmd-if.c \
+	cmd-keep.c \
+	cmd-redirect.c \
+	cmd-discard.c
+
+extensions = \
+	ext-fileinto.c \
+	ext-reject.c \
+	ext-envelope.c \
+	ext-encoded-character.c
+
+match_types = \
+	mcht-is.c \
+	mcht-contains.c \
+	mcht-matches.c
+
+comparators = \
+	cmp-i-octet.c \
+	cmp-i-ascii-casemap.c
+
+@BUILD_UNFINISHED_TRUE@unfinished_plugins = 
+
+# These are not actual plugins just yet...
+plugins = \
+	./plugins/vacation/libsieve_ext_vacation.la \
+	./plugins/subaddress/libsieve_ext_subaddress.la \
+ 	./plugins/comparator-i-ascii-numeric/libsieve_ext_comparator-i-ascii-numeric.la \
+	./plugins/relational/libsieve_ext_relational.la \
+	./plugins/regex/libsieve_ext_regex.la \
+	./plugins/copy/libsieve_ext_copy.la \
+	./plugins/imap4flags/libsieve_ext_imap4flags.la \
+	./plugins/include/libsieve_ext_include.la \
+	./plugins/body/libsieve_ext_body.la \
+	./plugins/variables/libsieve_ext_variables.la \
+	./plugins/enotify/libsieve_ext_enotify.la \
+	./plugins/notify/libsieve_ext_notify.la \
+	./plugins/environment/libsieve_ext_environment.la \
+	./plugins/mailbox/libsieve_ext_mailbox.la \
+	./plugins/date/libsieve_ext_date.la \
+	$(unfinished_plugins)
+
+libsieve_la_DEPENDENCIES = $(plugins)
+libsieve_la_LIBADD = $(plugins)
+libsieve_la_SOURCES = \
+	rfc2822.c \
+	sieve-limits.c \
+	sieve-message.c \
+	sieve-lexer.c \
+	sieve-script.c \
+	sieve-ast.c \
+	sieve-binary.c \
+	sieve-parser.c \
+	sieve-address.c \
+	sieve-validator.c \
+	sieve-generator.c \
+	sieve-interpreter.c \
+	sieve-code-dumper.c \
+	sieve-binary-dumper.c \
+	sieve-result.c \
+	sieve-error.c \
+	sieve-objects.c \
+	sieve-comparators.c \
+	sieve-match-types.c \
+	sieve-address-parts.c \
+	sieve-match.c \
+	sieve-commands.c \
+	sieve-code.c \
+	sieve-actions.c \
+	sieve-extensions.c \
+	$(comparators) \
+	$(match_types) \
+	$(tests) \
+	$(commands) \
+	$(extensions) \
+	sieve.c 
+
+noinst_HEADERS = \
+	rfc2822.h \
+	sieve-config.h \
+	sieve-types.h \
+	sieve-common.h \
+	sieve-limits.h \
+	sieve-message.h \
+	sieve-lexer.h \
+	sieve-script.h \
+	sieve-script-private.h \
+	sieve-ast.h \
+	sieve-binary.h \
+	sieve-parser.h \
+	sieve-address.h \
+	sieve-validator.h \
+	sieve-generator.h \
+	sieve-interpreter.h \
+	sieve-code-dumper.h \
+	sieve-binary-dumper.h \
+	sieve-dump.h \
+	sieve-result.h \
+	sieve-error.h \
+	sieve-error-private.h \
+	sieve-objects.h \
+	sieve-match.h \
+	sieve-comparators.h \
+	sieve-match-types.h \
+	sieve-address-parts.h \
+	sieve-commands.h \
+	sieve-code.h \
+	sieve-actions.h \
+	sieve-extensions.h \
+	sieve.h
+
+all: all-recursive
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/lib-sieve/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  src/lib-sieve/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve.la: $(libsieve_la_OBJECTS) $(libsieve_la_DEPENDENCIES) 
+	$(LINK)  $(libsieve_la_OBJECTS) $(libsieve_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-discard.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-if.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-keep.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-redirect.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-require.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-stop.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmp-i-ascii-casemap.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmp-i-octet.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-encoded-character.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-envelope.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-fileinto.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-reject.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mcht-contains.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mcht-is.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mcht-matches.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rfc2822.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-actions.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-address-parts.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-address.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-ast.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-binary-dumper.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-binary.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-code-dumper.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-code.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-commands.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-comparators.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-error.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-extensions.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-generator.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-interpreter.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-lexer.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-limits.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-match-types.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-match.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-message.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-objects.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-parser.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-result.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-script.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-validator.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-address.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-allof.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-anyof.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-exists.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-header.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-not.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-size.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-truefalse.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run `make' without going through this Makefile.
+# To change the values of `make' variables: instead of editing Makefiles,
+# (1) if the variable is set in `config.status', edit `config.status'
+#     (which will cause the Makefiles to be regenerated when you run `make');
+# (2) otherwise, pass the desired values on the `make' command line.
+$(RECURSIVE_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+$(RECURSIVE_CLEAN_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	rev=''; for subdir in $$list; do \
+	  if test "$$subdir" = "."; then :; else \
+	    rev="$$subdir $$rev"; \
+	  fi; \
+	done; \
+	rev="$$rev ."; \
+	target=`echo $@ | sed s/-recursive//`; \
+	for subdir in $$rev; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done && test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
+	done
+ctags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	  empty_fix=.; \
+	else \
+	  include_option=--include; \
+	  empty_fix=; \
+	fi; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test ! -f $$subdir/TAGS || \
+	      tags="$$tags $$include_option=$$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+	list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test -d "$(distdir)/$$subdir" \
+	    || $(MKDIR_P) "$(distdir)/$$subdir" \
+	    || exit 1; \
+	    distdir=`$(am__cd) $(distdir) && pwd`; \
+	    top_distdir=`$(am__cd) $(top_distdir) && pwd`; \
+	    (cd $$subdir && \
+	      $(MAKE) $(AM_MAKEFLAGS) \
+	        top_distdir="$$top_distdir" \
+	        distdir="$$distdir/$$subdir" \
+		am__remove_distdir=: \
+		am__skip_length_check=: \
+	        distdir) \
+	      || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-recursive
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs: installdirs-recursive
+installdirs-am:
+install: install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-recursive
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-recursive
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-recursive
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-recursive
+
+dvi-am:
+
+html: html-recursive
+
+info: info-recursive
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-recursive
+
+install-exec-am:
+
+install-html: install-html-recursive
+
+install-info: install-info-recursive
+
+install-man:
+
+install-pdf: install-pdf-recursive
+
+install-ps: install-ps-recursive
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-recursive
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-recursive
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-recursive
+
+pdf-am:
+
+ps: ps-recursive
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) install-am \
+	install-strip
+
+.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
+	all all-am check check-am clean clean-generic clean-libtool \
+	clean-noinstLTLIBRARIES ctags ctags-recursive distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	installdirs-am maintainer-clean maintainer-clean-generic \
+	mostlyclean mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-recursive \
+	uninstall uninstall-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/mcht-contains.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/mcht-contains.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/mcht-contains.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/mcht-contains.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,69 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+
+/* Match-type ':contains' 
+ */
+
+#include "lib.h"
+
+#include "sieve-match-types.h"
+#include "sieve-comparators.h"
+#include "sieve-match.h"
+
+#include <string.h>
+#include <stdio.h>
+
+/*
+ * Forward declarations
+ */ 
+
+static int mcht_contains_match
+	(struct sieve_match_context *mctx, const char *val, size_t val_size, 
+		const char *key, size_t key_size, int key_index);
+
+/*
+ * Match-type object
+ */
+
+const struct sieve_match_type contains_match_type = {
+	SIEVE_OBJECT("contains", &match_type_operand,	SIEVE_MATCH_TYPE_CONTAINS),
+	TRUE, TRUE,
+	NULL,
+	sieve_match_substring_validate_context,
+	NULL,
+	mcht_contains_match,
+	NULL
+};
+
+/*
+ * Match-type implementation
+ */
+
+/* FIXME: Naive substring match implementation. Should switch to more 
+ * efficient algorithm if large values need to be searched (e.g. message body).
+ */
+static int mcht_contains_match
+(struct sieve_match_context *mctx, const char *val, size_t val_size, 
+	const char *key, size_t key_size, int key_index ATTR_UNUSED)
+{
+	const struct sieve_comparator *cmp = mctx->comparator;
+	const char *vend = (const char *) val + val_size;
+	const char *kend = (const char *) key + key_size;
+	const char *vp = val;
+	const char *kp = key;
+
+	if ( val == NULL || val_size == 0 ) 
+		return ( key_size == 0 );
+
+	if ( mctx->comparator->char_match == NULL ) 
+		return FALSE;
+
+	while ( (vp < vend) && (kp < kend) ) {
+		if ( !cmp->char_match(cmp, &vp, vend, &kp, kend) )
+			vp++;
+	}
+    
+	return (kp == kend);
+}
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/mcht-is.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/mcht-is.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/mcht-is.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/mcht-is.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,54 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+ 
+/* Match-type ':is': 
+ */
+
+#include "lib.h"
+
+#include "sieve-match-types.h"
+#include "sieve-comparators.h"
+#include "sieve-match.h"
+
+#include <string.h>
+#include <stdio.h>
+
+/* 
+ * Forward declarations 
+ */
+
+static int mcht_is_match
+	(struct sieve_match_context *mctx, const char *val, size_t val_size, 
+		const char *key, size_t key_size, int key_index);
+
+/* 
+ * Match-type object 
+ */
+
+const struct sieve_match_type is_match_type = {
+	SIEVE_OBJECT("is", &match_type_operand, SIEVE_MATCH_TYPE_IS),
+	TRUE, TRUE,
+	NULL, NULL, NULL,
+	mcht_is_match,
+	NULL
+};
+
+/*
+ * Match-type implementation
+ */
+
+static int mcht_is_match
+(struct sieve_match_context *mctx ATTR_UNUSED, 
+	const char *val, size_t val_size, 
+	const char *key, size_t key_size, int key_index ATTR_UNUSED)
+{
+	if ( (val == NULL || val_size == 0) ) 
+		return ( key_size == 0 );
+
+	if ( mctx->comparator->compare != NULL )
+		return (mctx->comparator->compare(mctx->comparator, 
+			val, val_size, key, key_size) == 0);
+
+	return FALSE;
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/mcht-matches.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/mcht-matches.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/mcht-matches.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/mcht-matches.c	2009-02-02 10:17:30.000000000 +0100
@@ -0,0 +1,434 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+ 
+/* Match-type ':matches' 
+ */
+
+#include "lib.h"
+#include "str.h"
+
+#include "sieve-match-types.h"
+#include "sieve-comparators.h"
+#include "sieve-match.h"
+
+#include <string.h>
+#include <stdio.h>
+
+/*
+ * Forward declarations
+ */
+
+static int mcht_matches_match
+	(struct sieve_match_context *mctx, const char *val, size_t val_size, 
+		const char *key, size_t key_size, int key_index);
+
+/*
+ * Match-type object
+ */
+
+const struct sieve_match_type matches_match_type = {
+	SIEVE_OBJECT("matches", &match_type_operand, SIEVE_MATCH_TYPE_MATCHES),
+	TRUE, FALSE,
+	NULL,
+	sieve_match_substring_validate_context, 
+	NULL,
+	mcht_matches_match,
+	NULL
+};
+
+/*
+ * Match-type implementation
+ */
+
+/* Quick 'n dirty debug */
+//#define MATCH_DEBUG
+#ifdef MATCH_DEBUG
+#define debug_printf(...) printf ("match debug: " __VA_ARGS__)
+#else
+#define debug_printf(...) 
+#endif
+
+/* FIXME: Naive implementation, substitute this with dovecot src/lib/str-find.c
+ */
+static inline bool _string_find(const struct sieve_comparator *cmp, 
+	const char **valp, const char *vend, const char **keyp, const char *kend)
+{
+	while ( (*valp < vend) && (*keyp < kend) ) {
+		if ( !cmp->char_match(cmp, valp, vend, keyp, kend) )
+			(*valp)++;
+	}
+	
+	return (*keyp == kend);
+}
+
+static char _scan_key_section
+	(string_t *section, const char **wcardp, const char *key_end)
+{
+	/* Find next wildcard and resolve escape sequences */	
+	str_truncate(section, 0);
+	while ( *wcardp < key_end && **wcardp != '*' && **wcardp != '?') {
+		if ( **wcardp == '\\' ) {
+			(*wcardp)++;
+		}
+		str_append_c(section, **wcardp);
+		(*wcardp)++;
+	}
+	
+	/* Record wildcard character or \0 */
+	if ( *wcardp < key_end ) {			
+		return **wcardp;
+	} 
+	
+	i_assert( *wcardp == key_end );
+	return '\0';
+}
+
+static int mcht_matches_match
+(struct sieve_match_context *mctx, const char *val, size_t val_size, 
+	const char *key, size_t key_size, int key_index ATTR_UNUSED)
+{
+	const struct sieve_comparator *cmp = mctx->comparator;
+	struct sieve_match_values *mvalues;
+	string_t *mvalue = NULL, *mchars = NULL;
+	string_t *section, *subsection;
+	const char *vend, *kend, *vp, *kp, *wp, *pvp;
+	bool backtrack = FALSE; /* TRUE: match of '?'-connected sections failed */
+	char wcard = '\0';      /* Current wildcard */
+	char next_wcard = '\0'; /* Next  widlcard */
+	unsigned int key_offset = 0;
+
+	/* Value may be NULL, parse empty string in stead */
+	if ( val == NULL ) {
+		val = "";
+		val_size = 0;
+	}
+	
+	/* Key sections */
+	section = t_str_new(32);    /* Section (after beginning or *) */
+	subsection = t_str_new(32); /* Sub-section (after ?) */
+	
+	/* Mark end of value and key */
+	vend = (const char *) val + val_size;
+	kend = (const char *) key + key_size;
+
+	/* Initialize pointers */
+	vp = val;                   /* Value pointer */
+	kp = key;                   /* Key pointer */
+	wp = key;                   /* Wildcard (key) pointer */
+	pvp = val;                  /* Previous value Pointer */
+
+	/* Start match values list if requested */
+	if ( (mvalues = sieve_match_values_start(mctx->interp)) != NULL ) {
+		/* Skip ${0} for now; added when match succeeds */
+		sieve_match_values_add(mvalues, NULL);
+
+		mvalue = t_str_new(32);     /* Match value (*) */
+		mchars = t_str_new(32);     /* Match characters (.?..?.??) */
+	}
+	
+	/* Match the pattern: 
+	 *   <pattern> = <section>*<section>*<section>...
+	 *   <section> = <sub-section>?<sub-section>?<sub-section>...
+	 *
+	 * Escape sequences \? and \* need special attention. 
+	 */
+	 
+	debug_printf("=== Start ===\n");
+	debug_printf("  key:   %s\n", t_strdup_until(key, kend));
+	debug_printf("  value: %s\n", t_strdup_until(val, vend));
+
+	/* Loop until either key or value ends */
+	while (kp < kend && vp < vend ) {
+		const char *needle, *nend;
+		
+		if ( !backtrack ) {
+			/* Search the next '*' wildcard in the key string */
+
+			wcard = next_wcard;
+			
+			/* Find the needle to look for in the string */	
+			key_offset = 0;	
+			for (;;) {
+				next_wcard = _scan_key_section(section, &wp, kend);
+				
+				if ( wcard == '\0' || str_len(section) > 0 ) 
+					break;
+					
+				if ( next_wcard == '*' ) {	
+					break;
+				}
+					
+				if ( wp < kend ) 
+					wp++;
+				else 
+					break;
+				key_offset++;
+			}
+			
+			debug_printf("found wildcard '%c' at pos [%d]\n", 
+				next_wcard, (int) (wp-key));
+	
+			if ( mvalues != NULL )			
+				str_truncate(mvalue, 0);
+		} else {
+			/* Backtracked; '*' wildcard is retained */
+			debug_printf("backtracked");
+			backtrack = FALSE;
+		}
+		
+		/* Determine what we are looking for */
+		needle = str_c(section);
+		nend = PTR_OFFSET(needle, str_len(section));		
+		 
+		debug_printf("  section needle:  '%s'\n", t_strdup_until(needle, nend));
+		debug_printf("  section key:     '%s'\n", t_strdup_until(kp, kend));
+		debug_printf("  section remnant: '%s'\n", t_strdup_until(wp, kend));
+		debug_printf("  value remnant:   '%s'\n", t_strdup_until(vp, vend));
+		debug_printf("  key offset:      %d\n", key_offset);
+		
+		pvp = vp;
+		if ( next_wcard == '\0' ) {
+			/* No more wildcards; find the needle substring at the end of string */
+	
+			const char *qp, *qend;
+			
+			debug_printf("next_wcard = NUL; must find needle at end\n");				 
+
+			/* Check if the value is still large enough */			
+			if ( vend - str_len(section) < vp ) {
+				debug_printf("  wont match: value is too short\n");
+				break;
+			}
+
+			/* Move value pointer to where the needle should be */
+			vp = PTR_OFFSET(vend, -str_len(section));
+
+			/* Record match values */
+			qend = vp;
+			qp = vp - key_offset;
+		
+			if ( mvalues != NULL )
+				str_append_n(mvalue, pvp, qp-pvp);
+					
+			/* Compare needle to end of value string */
+			if ( !cmp->char_match(cmp, &vp, vend, &needle, nend) ) {	
+				debug_printf("  match at end failed\n");				 
+				break;
+			}
+			
+			/* Add match values */
+			if ( mvalues != NULL ) {
+				/* Append '*' match value */
+				sieve_match_values_add(mvalues, mvalue);
+
+				/* Append any initial '?' match values */
+				for ( ; qp < qend; qp++ )
+					sieve_match_values_add_char(mvalues, *qp); 
+			}
+
+			/* Finish match */
+			kp = kend;
+			vp = vend;
+
+			debug_printf("  matched end of value\n");
+			break;
+		} else {
+			/* Next wildcard found; match needle before next wildcard */
+
+			const char *prv = NULL; /* Stored value pointer for backtrack */
+			const char *prk = NULL; /* Stored key pointer for backtrack */
+			const char *prw = NULL; /* Stored wildcard pointer for backtrack */
+			const char *chars;
+
+			/* Reset '?' match values */
+			if ( mvalues != NULL )		
+				str_truncate(mchars, 0);
+							
+			if ( wcard == '\0' ) {
+				/* No current wildcard; match needs to happen right at the beginning */
+				debug_printf("wcard = NUL; needle should be found at the beginning.\n");
+				debug_printf("  begin needle: '%s'\n", t_strdup_until(needle, nend));
+				debug_printf("  begin value:  '%s'\n", t_strdup_until(vp, vend));
+
+				if ( !cmp->char_match(cmp, &vp, vend, &needle, nend) ) {	
+					debug_printf("  failed to find needle at beginning\n");				 
+					break;
+				}
+
+			} else {
+				/* Current wildcard present; match needle between current and next wildcard */
+				debug_printf("wcard != NUL; must find needle at an offset (>= %d).\n",
+					key_offset);
+
+				/* Match may happen at any offset (>= key offset): find substring */				
+				vp += key_offset;
+				if ( (vp >= vend) || !_string_find(cmp, &vp, vend, &needle, nend) ) {
+					debug_printf("  failed to find needle at an offset\n"); 
+					break;
+				}
+
+				prv = vp - str_len(section);
+				prk = kp;
+				prw = wp;		
+	
+				/* Append match values */
+				if ( mvalues != NULL ) {
+					const char *qend = vp - str_len(section);
+					const char *qp = qend - key_offset;
+
+					/* Append '*' match value */
+					str_append_n(mvalue, pvp, qp-pvp);
+
+					/* Append any initial '?' match values (those that caused the key
+					 * offset.
+					 */
+					for ( ; qp < qend; qp++ )
+						str_append_c(mchars, *qp);
+				}
+			}
+			
+			/* Update wildcard and key pointers for next wildcard scan */
+			if ( wp < kend ) wp++;
+			kp = wp;
+		
+			/* Scan successive '?' wildcards */
+			while ( next_wcard == '?' ) {
+				debug_printf("next_wcard = '?'; need to match arbitrary character\n");
+				
+				/* Add match value */ 
+				if ( mvalues != NULL )
+					str_append_c(mchars, *vp);
+
+				vp++;
+
+				/* Scan for next '?' wildcard */				
+				next_wcard = _scan_key_section(subsection, &wp, kend);
+				debug_printf("found next wildcard '%c' at pos [%d] (fixed match)\n", 
+					next_wcard, (int) (wp-key));
+					
+				/* Determine what we are looking for */
+				needle = str_c(subsection);
+				nend = PTR_OFFSET(needle, str_len(subsection));
+
+				debug_printf("  sub key:       '%s'\n", t_strdup_until(needle, nend));
+				debug_printf("  value remnant: '%s'\n", vp <= vend ? t_strdup_until(vp, vend) : "");
+
+				/* Try matching the needle at fixed position */
+				if ( (needle == nend && next_wcard == '\0' && vp < vend ) || 
+					!cmp->char_match(cmp, &vp, vend, &needle, nend) ) {	
+					
+					/* Match failed: now we have a problem. We need to backtrack to the previous
+					 * '*' wildcard occurence and start scanning for the next possible match.
+					 */
+
+					debug_printf("  failed fixed match\n");
+					
+					/* Start backtrack */
+					if ( prv != NULL && prv + 1 < vend ) {
+						/* Restore pointers */
+						vp = prv;
+						kp = prk;
+						wp = prw;
+				
+						/* Skip forward one value character to scan the next possible match */
+						if ( mvalues != NULL )
+							str_append_c(mvalue, *vp);
+						vp++;
+				
+						/* Set wildcard state appropriately */
+						wcard = '*';
+						next_wcard = '?';
+				
+						/* Backtrack */
+						backtrack = TRUE;				 
+
+						debug_printf("  BACKTRACK\n");
+					}
+
+					/* Break '?' wildcard scanning loop */
+					break;
+				}
+				
+				/* Update wildcard and key pointers for next wildcard scan */
+				if ( wp < kend ) wp++;
+				kp = wp;
+			}
+			
+			if ( !backtrack ) {
+				unsigned int i;
+				
+				if ( next_wcard == '?' ) {
+					debug_printf("failed to match '?'\n");	
+					break;
+				}
+				
+				if ( mvalues != NULL ) {
+					if ( prv != NULL )
+						sieve_match_values_add(mvalues, mvalue);
+
+					chars = (const char *) str_data(mchars);
+
+					for ( i = 0; i < str_len(mchars); i++ ) {
+						sieve_match_values_add_char(mvalues, chars[i]);
+					}
+				}
+
+				if ( next_wcard != '*' ) {
+					debug_printf("failed to match at end of string\n");
+					break;
+				}
+			}
+		}
+					
+		/* Check whether string ends in a wildcard 
+		 * (avoid scanning the rest of the string)
+		 */
+		if ( kp == kend && next_wcard == '*' ) {
+			/* Add the rest of the string as match value */
+			if ( mvalues != NULL ) {
+				str_truncate(mvalue, 0);
+				str_append_n(mvalue, vp, vend-vp);
+				sieve_match_values_add(mvalues, mvalue);
+			}
+		
+			/* Finish match */
+			kp = kend;
+			vp = vend;
+		
+			debug_printf("key ends with '*'\n");
+			break;
+		}			
+					
+		debug_printf("== Loop ==\n");
+	}
+
+	/* Eat away a trailing series of *s */
+	if ( vp == vend ) {
+		while ( kp < kend && *kp == '*' ) kp++;
+	}
+
+	/* By definition, the match is only successful if both value and key pattern
+	 * are exhausted.
+	 */
+	
+	debug_printf("=== Finish ===\n");
+	debug_printf("  result: %s\n", (kp == kend && vp == vend) ? "true" : "false");
+	
+	if (kp == kend && vp == vend) {
+		/* Activate new match values after successful match */
+		if ( mvalues != NULL ) {
+			/* Set ${0} */
+			string_t *matched = str_new_const(pool_datastack_create(), val, val_size);
+			sieve_match_values_set(mvalues, 0, matched);
+
+			/* Commit new match values */
+			sieve_match_values_commit(mctx->interp, &mvalues);
+		}
+		return TRUE;
+	}
+
+	/* No match; drop collected match values */
+	sieve_match_values_abort(&mvalues);
+	return FALSE;
+}
+			 
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/body/ext-body.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/body/ext-body.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/body/ext-body.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/body/ext-body.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,73 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension body 
+ * ------------------
+ *
+ * Authors: Stephan Bosch, original CMUSieve implementation by Timo Sirainen
+ * Specification: RFC 5173
+ * Implementation: full, but text body-transform implementation is simple
+ * Status: experimental, largely untested
+ *
+ */
+ 
+/* FIXME: 
+ *
+ * From RFC with respect to :text body transform:
+ *
+ * "Sophisticated implementations MAY strip mark-up from the text prior
+ *  to matching, and MAY convert media types other than text to text
+ *  prior to matching.
+ *
+ *  (For example, they may be able to convert proprietary text editor
+ *  formats to text or apply optical character recognition algorithms to
+ *  image data.)"
+ *
+ * We might want to do this in the future, i.e. we must evaluate whether this is 
+ * feasible.
+ */
+ 
+#include "lib.h"
+#include "array.h"
+
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-address-parts.h"
+
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "ext-body-common.h"
+
+/* 
+ * Extension 
+ */
+
+static bool ext_body_validator_load(struct sieve_validator *validator);
+
+int ext_body_my_id = -1;
+
+const struct sieve_extension body_extension = { 
+	"body", 
+	&ext_body_my_id,
+	NULL, NULL,
+	ext_body_validator_load, 
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATION(body_operation), 
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+static bool ext_body_validator_load(struct sieve_validator *validator)
+{
+	/* Register new test */
+	sieve_validator_register_command(validator, &body_test);
+
+	return TRUE;
+}
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/body/ext-body-common.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/body/ext-body-common.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/body/ext-body-common.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/body/ext-body-common.c	2009-06-01 10:18:44.000000000 +0200
@@ -0,0 +1,343 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "mempool.h"
+#include "buffer.h"
+#include "array.h"
+#include "str.h"
+#include "istream.h"
+#include "rfc822-parser.h"
+#include "message-date.h"
+#include "message-parser.h"
+#include "message-decoder.h"
+
+#include "sieve-common.h"
+#include "sieve-message.h"
+#include "sieve-interpreter.h"
+
+#include "ext-body-common.h"
+
+/* This implementation is largely borrowed from the original sieve-cmu.c of the 
+ * cmusieve plugin.
+ */
+ 
+struct ext_body_part_cached {
+	const char *content_type;
+
+	const char *raw_body;
+	const char *decoded_body;
+	size_t raw_body_size;
+	size_t decoded_body_size;
+	
+	bool have_body; /* there's the empty end-of-headers line */
+};
+
+struct ext_body_message_context {
+	pool_t pool;
+	ARRAY_DEFINE(cached_body_parts, struct ext_body_part_cached);
+	ARRAY_DEFINE(return_body_parts, struct ext_body_part);
+	buffer_t *tmp_buffer;
+};
+
+static bool _is_wanted_content_type
+(const char * const *wanted_types, const char *content_type)
+{
+	const char *subtype = strchr(content_type, '/');
+	size_t type_len;
+
+	type_len = ( subtype == NULL ? strlen(content_type) :
+		(size_t)(subtype - content_type) );
+
+	i_assert( wanted_types != NULL );
+
+	for (; *wanted_types != NULL; wanted_types++) {
+		const char *wanted_subtype = strchr(*wanted_types, '/');
+
+		if (**wanted_types == '\0') {
+			/* empty string matches everything */
+			return TRUE;
+		}
+		if (wanted_subtype == NULL) {
+			/* match only main type */
+			if (strlen(*wanted_types) == type_len &&
+			    strncasecmp(*wanted_types, content_type,
+					type_len) == 0)
+				return TRUE;
+		} else {
+			/* match whole type/subtype */
+			if (strcasecmp(*wanted_types, content_type) == 0)
+				return TRUE;
+		}
+	}
+	return FALSE;
+}
+
+static bool ext_body_get_return_parts
+(struct ext_body_message_context *ctx, const char * const *wanted_types,
+	bool decode_to_plain)
+{
+	const struct ext_body_part_cached *body_parts;
+	unsigned int i, count;
+	struct ext_body_part *return_part;
+
+	/* Check whether any body parts are cached already */
+	body_parts = array_get(&ctx->cached_body_parts, &count);
+	if ( count == 0 )
+		return FALSE;
+
+	/* Clear result array */
+	array_clear(&ctx->return_body_parts);
+	
+	/* Fill result array with requested content_types */
+	for (i = 0; i < count; i++) {
+		if (!body_parts[i].have_body) {
+			/* Part has no body; according to RFC this MUST not match to anything and 
+			 * therefore it is not included in the result.
+			 */
+			continue;
+		}
+
+		/* Skip content types that are not requested */
+		if (!_is_wanted_content_type(wanted_types, body_parts[i].content_type))
+			continue;
+
+		/* Add new item to the result */
+		return_part = array_append_space(&ctx->return_body_parts);
+		
+		/* Depending on whether a decoded body part is requested, the appropriate
+		 * cache item is read. If it is missing, this function fails and the cache 
+		 * needs to be completed by ext_body_parts_add_missing().
+		 */
+		if (decode_to_plain) {
+			if (body_parts[i].decoded_body == NULL)
+				return FALSE;
+			return_part->content = body_parts[i].decoded_body;
+			return_part->size = body_parts[i].decoded_body_size;
+		} else {
+			if (body_parts[i].raw_body == NULL)
+				return FALSE;
+			return_part->content = body_parts[i].raw_body;
+			return_part->size = body_parts[i].raw_body_size;
+		}
+	}
+
+	return TRUE;
+}
+
+static void ext_body_part_save
+(struct ext_body_message_context *ctx, struct message_part *part,
+	struct ext_body_part_cached *body_part, bool decoded)
+{
+	buffer_t *buf = ctx->tmp_buffer;
+	char *part_data;
+	size_t part_size;
+
+	/* Add terminating NUL to the body part buffer */
+	buffer_append_c(buf, '\0');
+
+	part_data = p_malloc(ctx->pool, buf->used);
+	memcpy(part_data, buf->data, buf->used);
+	part_size = buf->used - 1;
+	
+	/* Depending on whether the part is decoded or not store message body in the
+	 * appropriate cache location.
+	 */
+	if ( !decoded ) {
+		body_part->raw_body = part_data;
+		body_part->raw_body_size = part_size;
+		i_assert(buf->used - 1 == part->body_size.physical_size);
+	} else {
+		body_part->decoded_body = part_data;
+		body_part->decoded_body_size = part_size;
+	}
+	
+	/* Clear buffer */
+	buffer_set_used_size(buf, 0);
+}
+
+static const char *_parse_content_type(const struct message_header_line *hdr)
+{
+	struct rfc822_parser_context parser;
+	string_t *content_type;
+
+	rfc822_parser_init(&parser, hdr->full_value, hdr->full_value_len, NULL);
+	(void)rfc822_skip_lwsp(&parser);
+
+	content_type = t_str_new(64);
+	if (rfc822_parse_content_type(&parser, content_type) < 0)
+		return "";
+	return str_c(content_type);
+}
+
+/* ext_body_parts_add_missing():
+ *   Add requested message body parts to the cache that are missing. 
+ */
+static bool ext_body_parts_add_missing
+(const struct sieve_message_data *msgdata, struct ext_body_message_context *ctx, 
+	const char * const *content_types, bool decode_to_plain)
+{
+	struct ext_body_part_cached *body_part = NULL;
+	struct message_parser_ctx *parser;
+	struct message_decoder_context *decoder;
+	struct message_block block, decoded;
+	struct message_part *parts, *prev_part = NULL;
+	struct istream *input;
+	unsigned int idx = 0;
+	bool save_body = FALSE, have_all;
+	int ret;
+
+	/* First check whether any are missing */
+	if (ext_body_get_return_parts(ctx, content_types, decode_to_plain)) {
+		/* Cache hit; all are present */
+		return TRUE;
+	}
+
+	/* Get the message stream */
+	if ( mail_get_stream(msgdata->mail, NULL, NULL, &input) < 0 )
+		return FALSE;
+		
+	buffer_set_used_size(ctx->tmp_buffer, 0);
+	
+	/* Initialize body decoder */
+	decoder = decode_to_plain ? message_decoder_init(FALSE) : NULL;
+	
+	parser = message_parser_init
+		(ctx->pool, input, 0, MESSAGE_PARSER_FLAG_SKIP_BODY_BLOCK);
+	while ( (ret = message_parser_parse_next_block(parser, &block)) > 0 ) {
+		if ( block.part != prev_part ) {
+			/* Save previous body part */
+			if ( body_part != NULL && save_body ) {
+				ext_body_part_save(ctx, prev_part, body_part, decoder != NULL);
+			}
+			
+			/* Start processing next */
+			prev_part = block.part;
+			body_part = array_idx_modifiable(&ctx->cached_body_parts, idx);
+			idx++;
+			body_part->content_type = "text/plain";
+		}
+		
+		if ( block.hdr != NULL || block.size == 0 ) {
+			/* reading headers */
+			if ( decoder != NULL ) {
+				(void)message_decoder_decode_next_block(decoder,
+					&block, &decoded);
+			}
+
+			if ( block.hdr == NULL ) {
+				/* save bodies only if we have a wanted
+				   content-type */
+				save_body = _is_wanted_content_type
+					(content_types, body_part->content_type);
+				continue;
+			}
+			
+			/* Encountered the empty line that indicates the end of the headers and 
+			 * the start of the body
+			 */
+			if ( block.hdr->eoh )
+				body_part->have_body = TRUE;
+				
+			/* We're interested of only Content-Type: header */
+			if ( strcasecmp(block.hdr->name, "Content-Type" ) != 0)
+				continue;
+
+			/* Header can have folding whitespace. Acquire the full value before 
+			 * continuing
+			 */
+			if ( block.hdr->continues ) {
+				block.hdr->use_full_value = TRUE;
+				continue;
+			}
+		
+			/* Parse the content type from the Content-type header */
+			T_BEGIN {
+				body_part->content_type =
+					p_strdup(ctx->pool, _parse_content_type(block.hdr));
+			} T_END;
+			
+			continue;
+		}
+
+		/* reading body */
+		if (save_body) {
+			if (decoder != NULL) {
+				(void)message_decoder_decode_next_block(decoder,
+							&block, &decoded);
+				buffer_append(ctx->tmp_buffer,
+					      decoded.data, decoded.size);
+			} else {
+				buffer_append(ctx->tmp_buffer,
+					      block.data, block.size);
+			}
+		}
+	}
+
+	/* Save last body part if necessary */
+	if (body_part != NULL && save_body)
+		ext_body_part_save(ctx, prev_part, body_part, decoder != NULL);
+
+	/* Try to fill the return_body_parts array once more */
+	have_all = ext_body_get_return_parts(ctx, content_types, decode_to_plain);
+	
+	/* This time, failure is a bug */
+	i_assert(have_all);
+
+	/* Cleanup */
+	(void)message_parser_deinit(&parser, &parts);
+	if (decoder != NULL)
+		message_decoder_deinit(&decoder);
+	
+	/* Return status */
+	return ( input->stream_errno == 0 );
+}
+
+static struct ext_body_message_context *ext_body_get_context
+(struct sieve_message_context *msgctx)
+{
+	pool_t pool = sieve_message_context_pool(msgctx);
+	struct ext_body_message_context *ctx;
+	
+	/* Get message context (contains cached message body information) */
+	ctx = (struct ext_body_message_context *)
+		sieve_message_context_extension_get(msgctx, &body_extension);
+	
+	/* Create it if it does not exist already */
+	if ( ctx == NULL ) {
+		ctx = p_new(pool, struct ext_body_message_context, 1);	
+		ctx->pool = pool;
+		p_array_init(&ctx->cached_body_parts, pool, 8);
+		p_array_init(&ctx->return_body_parts, pool, 8);
+		ctx->tmp_buffer = buffer_create_dynamic(pool, 1024*64);
+		
+		/* Register context */
+		sieve_message_context_extension_set(msgctx, &body_extension, (void *) ctx);
+	}
+	
+	return ctx;
+}
+
+bool ext_body_get_content
+(const struct sieve_runtime_env *renv, const char * const *content_types,
+	int decode_to_plain, struct ext_body_part **parts_r)
+{
+	bool result = TRUE;
+	struct ext_body_message_context *ctx = ext_body_get_context(renv->msgctx);
+
+	T_BEGIN {
+		/* Fill the return_body_parts array */
+		if ( !ext_body_parts_add_missing
+			(renv->msgdata, ctx, content_types, decode_to_plain != 0) )
+			result = FALSE;
+	} T_END;
+	
+	/* Check status */
+	if ( !result ) return FALSE;
+
+	/* Return the array of body items */
+	(void) array_append_space(&ctx->return_body_parts); /* NULL-terminate */
+	*parts_r = array_idx_modifiable(&ctx->return_body_parts, 0);
+
+	return result;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/body/ext-body-common.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/body/ext-body-common.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/body/ext-body-common.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/body/ext-body-common.h	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,38 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#ifndef __EXT_BODY_COMMON_H
+#define __EXT_BODY_COMMON_H
+
+/*
+ * Extension
+ */
+ 
+extern const struct sieve_extension body_extension;
+
+/* 
+ * Commands
+ */
+
+extern const struct sieve_command body_test;
+ 
+/*
+ * Operations
+ */
+
+extern const struct sieve_operation body_operation;
+
+/*
+ * Message body part extraction
+ */
+
+struct ext_body_part {
+	const char *content;
+	unsigned long size;
+};
+
+bool ext_body_get_content
+(const struct sieve_runtime_env *renv, const char * const *content_types,
+	int decode_to_plain, struct ext_body_part **parts_r);
+
+#endif /* __EXT_BODY_COMMON_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/body/Makefile.am dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/body/Makefile.am
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/body/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/body/Makefile.am	2008-10-20 01:35:49.000000000 +0200
@@ -0,0 +1,19 @@
+noinst_LTLIBRARIES = libsieve_ext_body.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+tsts = \
+	tst-body.c
+
+libsieve_ext_body_la_SOURCES = \
+	ext-body-common.c \
+	$(tsts) \
+	ext-body.c
+
+noinst_HEADERS = \
+	ext-body-common.h
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/body/Makefile.in dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/body/Makefile.in
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/body/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/body/Makefile.in	2009-08-21 00:55:43.000000000 +0200
@@ -0,0 +1,468 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve/plugins/body
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libsieve_ext_body_la_LIBADD =
+am__objects_1 = tst-body.lo
+am_libsieve_ext_body_la_OBJECTS = ext-body-common.lo $(am__objects_1) \
+	ext-body.lo
+libsieve_ext_body_la_OBJECTS = $(am_libsieve_ext_body_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_ext_body_la_SOURCES)
+DIST_SOURCES = $(libsieve_ext_body_la_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LTLIBRARIES = libsieve_ext_body.la
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+tsts = \
+	tst-body.c
+
+libsieve_ext_body_la_SOURCES = \
+	ext-body-common.c \
+	$(tsts) \
+	ext-body.c
+
+noinst_HEADERS = \
+	ext-body-common.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/lib-sieve/plugins/body/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  src/lib-sieve/plugins/body/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve_ext_body.la: $(libsieve_ext_body_la_OBJECTS) $(libsieve_ext_body_la_DEPENDENCIES) 
+	$(LINK)  $(libsieve_ext_body_la_OBJECTS) $(libsieve_ext_body_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-body-common.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-body.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-body.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/body/tst-body.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/body/tst-body.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/body/tst-body.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/body/tst-body.c	2009-08-08 14:57:37.000000000 +0200
@@ -0,0 +1,425 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-address-parts.h"
+
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+#include "ext-body-common.h"
+
+/*
+ * Types
+ */
+
+enum tst_body_transform {
+	TST_BODY_TRANSFORM_RAW,
+	TST_BODY_TRANSFORM_CONTENT,
+	TST_BODY_TRANSFORM_TEXT
+};
+
+/* 
+ * Body test 
+ *
+ * Syntax
+ *   body [COMPARATOR] [MATCH-TYPE] [BODY-TRANSFORM]
+ *     <key-list: string-list>
+ */
+
+static bool tst_body_registered
+	(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg);
+static bool tst_body_validate
+	(struct sieve_validator *validator, struct sieve_command_context *tst);
+static bool tst_body_generate
+	(const struct sieve_codegen_env *cgenv,	struct sieve_command_context *ctx);
+
+const struct sieve_command body_test = { 
+	"body", 
+	SCT_TEST, 
+	1, 0, FALSE, FALSE,
+	tst_body_registered, 
+	NULL,
+	tst_body_validate, 
+	tst_body_generate, 
+	NULL 
+};
+
+/* 
+ * Body operation 
+ */
+
+static bool ext_body_operation_dump
+	(const struct sieve_operation *op, 
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int ext_body_operation_execute
+	(const struct sieve_operation *op,
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation body_operation = { 
+	"body",
+	&body_extension,
+	0,
+	ext_body_operation_dump, 
+	ext_body_operation_execute 
+};
+
+/*
+ * Optional operands
+ */
+
+enum tst_body_optional {	
+	OPT_BODY_TRANSFORM = SIEVE_MATCH_OPT_LAST
+};
+
+/* 
+ * Tagged arguments 
+ */
+
+/* Forward declarations */
+
+static bool tag_body_transform_validate
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+static bool tag_body_transform_generate	
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+		struct sieve_command_context *cmd);
+
+/* Argument objects */
+ 
+static const struct sieve_argument body_raw_tag = { 
+	"raw", 
+	NULL, NULL,
+	tag_body_transform_validate, 
+	NULL, 
+	tag_body_transform_generate 
+};
+
+static const struct sieve_argument body_content_tag = { 
+	"content", 
+	NULL, NULL,
+	tag_body_transform_validate, 
+	NULL, 
+	tag_body_transform_generate 
+};
+
+static const struct sieve_argument body_text_tag = { 
+	"text", 
+	NULL, NULL,
+	tag_body_transform_validate, 
+	NULL, 
+	tag_body_transform_generate
+};
+
+/* Argument implementation */
+ 
+static bool tag_body_transform_validate
+(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd)
+{
+	enum tst_body_transform transform;
+	struct sieve_ast_argument *tag = *arg;
+
+	/* BODY-TRANSFORM:
+	 *   :raw
+	 *     / :content <content-types: string-list>
+	 *     / :text
+	 */
+	if ( (bool) cmd->data ) {
+		sieve_argument_validate_error(validator, *arg, 
+			"the :raw, :content and :text arguments for the body test are mutually "
+			"exclusive, but more than one was specified");
+		return FALSE;
+	}
+
+	/* Skip tag */
+	*arg = sieve_ast_argument_next(*arg);
+
+	/* :content tag has a string-list argument */
+	if ( tag->argument == &body_raw_tag ) 
+		transform = TST_BODY_TRANSFORM_RAW;
+		
+	else if ( tag->argument == &body_text_tag )
+		transform = TST_BODY_TRANSFORM_TEXT;
+		
+	else if ( tag->argument == &body_content_tag ) {
+		/* Check syntax:
+		 *   :content <content-types: string-list>
+		 */
+		if ( !sieve_validate_tag_parameter
+			(validator, cmd, tag, *arg, SAAT_STRING_LIST) ) {
+			return FALSE;
+		}
+		
+		if ( !sieve_validator_argument_activate(validator, cmd, *arg, FALSE) )
+			return FALSE;
+		
+		/* Assign tag parameters */
+		tag->parameters = *arg;
+		*arg = sieve_ast_arguments_detach(*arg,1);
+		
+		transform = TST_BODY_TRANSFORM_CONTENT;
+	} else 
+		return FALSE;
+	
+	/* Signal the presence of this tag */
+	cmd->data = (void *) TRUE;
+		
+	/* Assign context data */
+	tag->context = (void *) transform;	
+		
+	return TRUE;
+}
+
+/* 
+ * Command Registration 
+ */
+
+static bool tst_body_registered
+(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg) 
+{
+	/* The order of these is not significant */
+	sieve_comparators_link_tag(validator, cmd_reg, SIEVE_MATCH_OPT_COMPARATOR);
+	sieve_match_types_link_tags(validator, cmd_reg, SIEVE_MATCH_OPT_MATCH_TYPE);
+	
+	sieve_validator_register_tag
+		(validator, cmd_reg, &body_raw_tag, OPT_BODY_TRANSFORM); 	
+	sieve_validator_register_tag
+		(validator, cmd_reg, &body_content_tag, OPT_BODY_TRANSFORM); 	
+	sieve_validator_register_tag
+		(validator, cmd_reg, &body_text_tag, OPT_BODY_TRANSFORM); 	
+	
+	return TRUE;
+}
+
+/* 
+ * Validation 
+ */
+ 
+static bool tst_body_validate
+(struct sieve_validator *validator, struct sieve_command_context *tst) 
+{ 		
+	struct sieve_ast_argument *arg = tst->first_positional;
+					
+	if ( !sieve_validate_positional_argument
+		(validator, tst, arg, "key list", 1, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(validator, tst, arg, FALSE) )
+		return FALSE;
+
+	/* Validate the key argument to a specified match type */
+	return sieve_match_type_validate
+		(validator, tst, arg, &is_match_type, &i_ascii_casemap_comparator);
+}
+
+/*
+ * Code generation
+ */
+ 
+static bool tst_body_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx) 
+{
+	(void)sieve_operation_emit_code(cgenv->sbin, &body_operation);
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, ctx, NULL);
+}
+
+static bool tag_body_transform_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+	struct sieve_command_context *cmd ATTR_UNUSED)
+{
+	enum tst_body_transform transform =	(enum tst_body_transform) arg->context;
+	
+	sieve_binary_emit_byte(cgenv->sbin, transform);
+	sieve_generate_argument_parameters(cgenv, cmd, arg); 
+			
+	return TRUE;
+}
+
+/* 
+ * Code dump 
+ */
+ 
+static bool ext_body_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED, 
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	enum tst_body_transform transform;
+	int opt_code = 0;
+
+	sieve_code_dumpf(denv, "BODY");
+	sieve_code_descend(denv);
+
+	/* Handle any optional arguments */
+	do {
+		
+		if ( !sieve_match_dump_optional_operands(denv, address, &opt_code) )
+			return FALSE;
+
+		switch ( opt_code ) {
+		case SIEVE_MATCH_OPT_END:
+			break;
+		case OPT_BODY_TRANSFORM:
+			if ( !sieve_binary_read_byte(denv->sbin, address, &transform) )
+				return FALSE;
+			
+			switch ( transform ) {
+			case TST_BODY_TRANSFORM_RAW:
+				sieve_code_dumpf(denv, "BODY-TRANSFORM: RAW");
+				break;
+			case TST_BODY_TRANSFORM_TEXT:
+				sieve_code_dumpf(denv, "BODY-TRANSFORM: TEXT");
+				break;
+			case TST_BODY_TRANSFORM_CONTENT:
+				sieve_code_dumpf(denv, "BODY-TRANSFORM: CONTENT");
+				
+				sieve_code_descend(denv);
+				if ( !sieve_opr_stringlist_dump(denv, address, "content types") )
+					return FALSE;
+				sieve_code_ascend(denv);
+				break;
+			default:
+				return FALSE;
+			}
+			break;
+		default: 
+			return FALSE;
+		}
+	} while ( opt_code != SIEVE_MATCH_OPT_END );
+
+	return sieve_opr_stringlist_dump(denv, address, "key list");
+}
+
+/*
+ * Interpretation
+ */
+
+static int ext_body_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	static const char * const _no_content_types[] = { "", NULL };
+	
+	int ret = SIEVE_EXEC_OK;
+	int opt_code = 0;
+	int mret;
+	const struct sieve_comparator *cmp = &i_ascii_casemap_comparator;
+	const struct sieve_match_type *mtch = &is_match_type;
+	enum tst_body_transform transform;
+	struct sieve_coded_stringlist *key_list, *ctype_list = NULL;
+	struct sieve_match_context *mctx;
+	const char * const *content_types = _no_content_types;
+	struct ext_body_part *body_parts;
+	bool mvalues_active;
+	bool matched;
+
+	/*
+	 * Read operands
+	 */
+	
+	/* Handle any optional operands */
+	do {
+		if ( (ret=sieve_match_read_optional_operands
+			(renv, address, &opt_code, &cmp, &mtch)) <= 0 )
+			return ret;
+			
+		switch ( opt_code ) {
+		case SIEVE_MATCH_OPT_END: 
+			break;
+		case OPT_BODY_TRANSFORM:
+			if ( !sieve_binary_read_byte(renv->sbin, address, &transform) ||
+				transform > TST_BODY_TRANSFORM_TEXT ) {
+				sieve_runtime_trace_error(renv, "invalid body transform type");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+			
+			if ( transform == TST_BODY_TRANSFORM_CONTENT ) {				
+				if ( (ctype_list=sieve_opr_stringlist_read(renv, address)) 
+					== NULL ) {
+					sieve_runtime_trace_error(renv, 
+						"invalid :content body transform operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+			}
+			break;
+
+		default:
+			sieve_runtime_trace_error(renv, "unknown optional operand");
+			return SIEVE_EXEC_BIN_CORRUPT;
+		}
+	} while ( opt_code != SIEVE_MATCH_OPT_END );
+		
+	/* Read key-list */
+	if ( (key_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid key-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	if ( ctype_list != NULL && !sieve_coded_stringlist_read_all
+		(ctype_list, pool_datastack_create(), &content_types) ) {
+		sieve_runtime_trace_error(renv, "invalid content-type-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "BODY action");
+	
+	/* Extract requested parts */
+	
+	if ( !ext_body_get_content
+		(renv, content_types, transform != TST_BODY_TRANSFORM_RAW, &body_parts) ) {
+		return SIEVE_EXEC_FAILURE;
+	}
+
+	/* Disable match values processing as required by RFC */
+		
+	mvalues_active = sieve_match_values_set_enabled(renv->interp, FALSE);
+
+	/* Iterate through all requested body parts to match */
+
+	matched = FALSE;	
+	mctx = sieve_match_begin(renv->interp, mtch, cmp, NULL, key_list); 	
+	while ( !matched && body_parts->content != NULL ) {
+		if ( (mret=sieve_match_value(mctx, body_parts->content, body_parts->size)) 	
+			< 0) 
+		{
+			sieve_runtime_trace_error(renv, "invalid string list item");
+			ret = SIEVE_EXEC_BIN_CORRUPT;
+			break;
+		}
+		
+		matched = ( mret > 0 );			
+		body_parts++;	
+	}
+
+	if ( (mret=sieve_match_end(&mctx)) < 0 ) {
+		sieve_runtime_trace_error(renv, "invalid string list item");
+		ret = SIEVE_EXEC_BIN_CORRUPT;
+	} else	
+		matched = ( mret > 0 || matched ); 	
+	
+	/* Restore match values processing */ 
+	
+	(void)sieve_match_values_set_enabled(renv->interp, mvalues_active);
+	
+	/* Set test result */	
+	
+	if ( ret == SIEVE_EXEC_OK )
+		sieve_interpreter_set_test_result(renv->interp, matched);
+
+	return ret;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-numeric.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-numeric.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-numeric.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-numeric.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,166 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */ 
+
+/* Extension comparator-i;ascii-numeric
+ * ------------------------------------
+ *
+ * Author: Stephan Bosch
+ * Specification: RFC 2244
+ * Implementation: full
+ * Status: experimental, largely untested
+ * 
+ */
+ 
+#include "sieve-common.h"
+
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-comparators.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+
+#include <ctype.h>
+
+/* 
+ * Forward declarations 
+ */
+
+static const struct sieve_operand my_comparator_operand;
+
+const struct sieve_comparator i_ascii_numeric_comparator;
+
+static bool ext_cmp_i_ascii_numeric_validator_load
+	(struct sieve_validator *validator);
+
+/* 
+ * Extension
+ */
+
+static int ext_my_id = -1;
+
+const struct sieve_extension comparator_i_ascii_numeric_extension = { 
+	"comparator-i;ascii-numeric", 
+	&ext_my_id,
+	NULL, NULL,
+	ext_cmp_i_ascii_numeric_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_NO_OPERATIONS, 
+	SIEVE_EXT_DEFINE_OPERAND(my_comparator_operand)
+};
+
+static bool ext_cmp_i_ascii_numeric_validator_load
+	(struct sieve_validator *validator)
+{
+	sieve_comparator_register(validator, &i_ascii_numeric_comparator);
+	return TRUE;
+}
+
+/*
+ * Operand
+ */
+
+static const struct sieve_extension_objects ext_comparators =
+	SIEVE_EXT_DEFINE_COMPARATOR(i_ascii_numeric_comparator);
+	
+static const struct sieve_operand my_comparator_operand = { 
+	"comparator-i;ascii-numeric", 
+	&comparator_i_ascii_numeric_extension,
+	0, 
+	&sieve_comparator_operand_class,
+	&ext_comparators
+};
+
+/*
+ * Comparator
+ */
+
+/* Forward declarations */
+ 
+static int cmp_i_ascii_numeric_compare
+	(const struct sieve_comparator *cmp, 
+		const char *val1, size_t val1_size, const char *val2, size_t val2_size);
+
+/* Comparator object */
+
+const struct sieve_comparator i_ascii_numeric_comparator = { 
+	SIEVE_OBJECT("i;ascii-numeric", &my_comparator_operand, 0),
+	SIEVE_COMPARATOR_FLAG_ORDERING | SIEVE_COMPARATOR_FLAG_EQUALITY,
+	cmp_i_ascii_numeric_compare,
+	NULL,
+	NULL
+};
+
+/* Comparator implementation */
+
+static int cmp_i_ascii_numeric_compare
+	(const struct sieve_comparator *cmp ATTR_UNUSED, 
+		const char *val, size_t val_size, const char *key, size_t key_size)
+{	
+	const char *vend = val + val_size;
+	const char *kend = key + key_size;
+	const char *vp = val;
+	const char *kp = key;
+	int digits, i;
+
+	/* RFC 4790: All input is valid; strings that do not start with a digit 
+	 * represent positive infinity.
+	 */
+	if ( !i_isdigit(*vp) ) {
+		if ( i_isdigit(*kp) ) {
+			/* Value is greater */
+			return -1;
+		}
+	} else {
+		if ( !i_isdigit(*kp) ) {
+            /* Value is less */
+            return -1;
+        }
+	}
+	
+	/* Ignore leading zeros */
+
+	while ( *vp == '0' && vp < vend )  
+		vp++;
+
+	while ( *kp == '0' && kp < kend )  
+		kp++;
+
+	/* Check whether both numbers are equally long in terms of digits */
+
+	digits = 0;
+	while ( vp < vend && kp < kend && i_isdigit(*vp) && i_isdigit(*kp) ) {
+		vp++;
+		kp++;
+		digits++;	
+	}
+
+	if ( vp == vend || !i_isdigit(*vp) ) {
+		if ( kp != kend && i_isdigit(*kp) ) {
+			/* Value is less */
+			return -1;
+		}
+	} else {
+		/* Value is greater */	
+		return 1;
+	}
+
+	/* Equally long: compare digits */
+
+	vp -= digits;
+	kp -= digits;
+	i = 0;
+	while ( i < digits ) {
+		if ( *vp > *kp )
+			return 1;
+		else if ( *vp < *kp )
+			return -1;
+
+		kp++;
+		vp++;
+		i++;
+	}
+		
+	return 0;
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/comparator-i-ascii-numeric/Makefile.am dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/comparator-i-ascii-numeric/Makefile.am
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/comparator-i-ascii-numeric/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/comparator-i-ascii-numeric/Makefile.am	2008-10-20 01:35:49.000000000 +0200
@@ -0,0 +1,11 @@
+noinst_LTLIBRARIES = libsieve_ext_comparator-i-ascii-numeric.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+libsieve_ext_comparator_i_ascii_numeric_la_SOURCES = \
+	ext-cmp-i-ascii-numeric.c
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/comparator-i-ascii-numeric/Makefile.in dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/comparator-i-ascii-numeric/Makefile.in
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/comparator-i-ascii-numeric/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/comparator-i-ascii-numeric/Makefile.in	2009-08-21 00:55:43.000000000 +0200
@@ -0,0 +1,455 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve/plugins/comparator-i-ascii-numeric
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libsieve_ext_comparator_i_ascii_numeric_la_LIBADD =
+am_libsieve_ext_comparator_i_ascii_numeric_la_OBJECTS =  \
+	ext-cmp-i-ascii-numeric.lo
+libsieve_ext_comparator_i_ascii_numeric_la_OBJECTS =  \
+	$(am_libsieve_ext_comparator_i_ascii_numeric_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_ext_comparator_i_ascii_numeric_la_SOURCES)
+DIST_SOURCES = $(libsieve_ext_comparator_i_ascii_numeric_la_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LTLIBRARIES = libsieve_ext_comparator-i-ascii-numeric.la
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+libsieve_ext_comparator_i_ascii_numeric_la_SOURCES = \
+	ext-cmp-i-ascii-numeric.c
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/lib-sieve/plugins/comparator-i-ascii-numeric/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  src/lib-sieve/plugins/comparator-i-ascii-numeric/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve_ext_comparator-i-ascii-numeric.la: $(libsieve_ext_comparator_i_ascii_numeric_la_OBJECTS) $(libsieve_ext_comparator_i_ascii_numeric_la_DEPENDENCIES) 
+	$(LINK)  $(libsieve_ext_comparator_i_ascii_numeric_la_OBJECTS) $(libsieve_ext_comparator_i_ascii_numeric_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-cmp-i-ascii-numeric.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/copy/ext-copy.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/copy/ext-copy.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/copy/ext-copy.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/copy/ext-copy.c	2009-08-05 12:42:30.000000000 +0200
@@ -0,0 +1,177 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension copy
+ * ------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: RFC 3894
+ * Implementation: full
+ * Status: experimental, largely untested
+ * 
+ */
+
+#include <stdio.h>
+
+#include "sieve-common.h"
+
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-actions.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-result.h"
+
+/* 
+ * Forward declarations 
+ */
+
+static const struct sieve_argument copy_tag;
+static const struct sieve_operand copy_side_effect_operand;
+
+/* 
+ * Extension
+ */
+
+static bool ext_copy_validator_load(struct sieve_validator *validator);
+
+static int ext_my_id = -1;
+
+const struct sieve_extension copy_extension = { 
+	"copy", 
+	&ext_my_id,
+	NULL, NULL,
+	ext_copy_validator_load, 
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_NO_OPERATIONS,
+	SIEVE_EXT_DEFINE_OPERAND(copy_side_effect_operand)
+};
+
+static bool ext_copy_validator_load(struct sieve_validator *validator)
+{
+	/* Register copy tag with redirect and fileinto commands and we don't care
+	 * whether these commands are registered or even whether they will be
+	 * registered at all. The validator handles either situation gracefully 
+	 */
+	sieve_validator_register_external_tag
+		(validator, &copy_tag, "redirect", SIEVE_OPT_SIDE_EFFECT);
+	sieve_validator_register_external_tag
+		(validator, &copy_tag, "fileinto", SIEVE_OPT_SIDE_EFFECT);
+
+	return TRUE;
+}
+
+/*
+ * Side effect 
+ */
+
+static void seff_copy_print
+	(const struct sieve_side_effect *seffect, const struct sieve_action *action, 
+		const struct sieve_result_print_env *rpenv, void *se_context, bool *keep);
+static void seff_copy_post_commit
+	(const struct sieve_side_effect *seffect, const struct sieve_action *action, 
+		const struct sieve_action_exec_env *aenv, void *se_context,
+		void *tr_context, bool *keep);
+
+const struct sieve_side_effect copy_side_effect = {
+	SIEVE_OBJECT("copy", &copy_side_effect_operand, 0),
+	&act_store,
+	NULL, NULL, NULL,
+	seff_copy_print,
+	NULL, NULL,
+	seff_copy_post_commit, 
+	NULL
+};
+
+/* 
+ * Tagged argument 
+ */
+
+static bool tag_copy_validate
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+static bool tag_copy_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+    struct sieve_command_context *context);
+
+static const struct sieve_argument copy_tag = { 
+	"copy", 
+	NULL, NULL,
+	tag_copy_validate, 
+	NULL,
+	tag_copy_generate
+};
+
+/*
+ * Operand
+ */
+
+static const struct sieve_extension_objects ext_side_effects =
+	SIEVE_EXT_DEFINE_SIDE_EFFECT(copy_side_effect);
+
+static const struct sieve_operand copy_side_effect_operand = {
+	"copy operand",
+	&copy_extension,
+	0,
+	&sieve_side_effect_operand_class,
+	&ext_side_effects
+};
+
+/* 
+ * Tag validation 
+ */
+
+static bool tag_copy_validate
+	(struct sieve_validator *validator ATTR_UNUSED, 
+	struct sieve_ast_argument **arg ATTR_UNUSED, 
+	struct sieve_command_context *cmd ATTR_UNUSED)
+{
+	*arg = sieve_ast_argument_next(*arg);
+
+	return TRUE;
+}
+
+/*
+ * Code generation 
+ */
+
+static bool tag_copy_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+    struct sieve_command_context *context ATTR_UNUSED)
+{
+	if ( sieve_ast_argument_type(arg) != SAAT_TAG ) {
+		return FALSE;
+	}
+
+	sieve_opr_side_effect_emit(cgenv->sbin, &copy_side_effect);
+
+	return TRUE;
+}
+
+/* 
+ * Side effect implementation
+ */
+
+static void seff_copy_print
+(const struct sieve_side_effect *seffect ATTR_UNUSED, 
+	const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_result_print_env *rpenv,
+	void *se_context ATTR_UNUSED, bool *keep)
+{
+	sieve_result_seffect_printf(rpenv, "preserve implicit keep");
+
+	*keep = TRUE;
+}
+
+static void seff_copy_post_commit
+(const struct sieve_side_effect *seffect ATTR_UNUSED, 
+	const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_action_exec_env *aenv ATTR_UNUSED, 
+		void *se_context ATTR_UNUSED,	void *tr_context ATTR_UNUSED, bool *keep)
+{	
+	*keep = TRUE;
+}
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/copy/Makefile.am dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/copy/Makefile.am
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/copy/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/copy/Makefile.am	2008-10-20 01:35:49.000000000 +0200
@@ -0,0 +1,11 @@
+noinst_LTLIBRARIES = libsieve_ext_copy.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+libsieve_ext_copy_la_SOURCES = \
+	ext-copy.c
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/copy/Makefile.in dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/copy/Makefile.in
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/copy/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/copy/Makefile.in	2009-08-21 00:55:43.000000000 +0200
@@ -0,0 +1,453 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve/plugins/copy
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libsieve_ext_copy_la_LIBADD =
+am_libsieve_ext_copy_la_OBJECTS = ext-copy.lo
+libsieve_ext_copy_la_OBJECTS = $(am_libsieve_ext_copy_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_ext_copy_la_SOURCES)
+DIST_SOURCES = $(libsieve_ext_copy_la_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LTLIBRARIES = libsieve_ext_copy.la
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+libsieve_ext_copy_la_SOURCES = \
+	ext-copy.c
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/lib-sieve/plugins/copy/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  src/lib-sieve/plugins/copy/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve_ext_copy.la: $(libsieve_ext_copy_la_OBJECTS) $(libsieve_ext_copy_la_DEPENDENCIES) 
+	$(LINK)  $(libsieve_ext_copy_la_OBJECTS) $(libsieve_ext_copy_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-copy.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/date/ext-date.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/date/ext-date.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/date/ext-date.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/date/ext-date.c	2009-08-21 00:52:15.000000000 +0200
@@ -0,0 +1,67 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension date
+ * ------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: RFC 5260
+ * Implementation: full
+ * Status: experimental
+ *
+ */
+ 
+#include "lib.h"
+#include "array.h"
+
+#include "sieve-common.h"
+
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-address-parts.h"
+
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "ext-date-common.h"
+
+/* 
+ * Extension 
+ */
+
+static bool ext_date_validator_load(struct sieve_validator *validator);
+
+int ext_date_my_id = -1;
+
+const struct sieve_operation *ext_date_operations[] = {
+	&date_operation,
+	&currentdate_operation
+};
+
+const struct sieve_extension date_extension = { 
+	"date", 
+	&ext_date_my_id,
+	NULL, NULL,
+	ext_date_validator_load, 
+	NULL, 
+	ext_date_interpreter_load, 
+	NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATIONS(ext_date_operations), 
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+static bool ext_date_validator_load(struct sieve_validator *valdtr)
+{
+	/* Register new test */
+	sieve_validator_register_command(valdtr, &date_test);
+	sieve_validator_register_command(valdtr, &currentdate_test);
+
+	return TRUE;
+}
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/date/ext-date-common.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/date/ext-date-common.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/date/ext-date-common.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/date/ext-date-common.c	2009-08-21 00:52:15.000000000 +0200
@@ -0,0 +1,464 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "utc-offset.h"
+
+#include "sieve-common.h"
+#include "sieve-interpreter.h"
+#include "sieve-message.h"
+
+#include "ext-date-common.h"
+
+#include <time.h>
+#include <ctype.h>
+
+struct ext_date_context {
+	time_t current_date;
+	int zone_offset;
+};
+
+/*
+ * Runtime initialization
+ */
+
+static void ext_date_runtime_init
+(const struct sieve_runtime_env *renv, void *context ATTR_UNUSED)
+{
+	struct ext_date_context *dctx;
+	pool_t pool;
+	struct tm *tm;
+	time_t current_date;
+	int zone_offset;
+
+	/* Get current time at instance main script is started */
+	time(&current_date);	
+
+	tm = localtime(&current_date);
+	zone_offset = utc_offset(tm, current_date);
+
+	/* Create context */
+	pool = sieve_message_context_pool(renv->msgctx);
+	dctx = p_new(pool, struct ext_date_context, 1);
+	dctx->current_date = current_date;
+	dctx->zone_offset = zone_offset;
+
+	sieve_message_context_extension_set
+		(renv->msgctx, &date_extension, (void *) dctx);
+}
+
+static struct sieve_interpreter_extension date_interpreter_extension = {
+	&date_extension,
+	ext_date_runtime_init,
+	NULL,
+};
+
+bool ext_date_interpreter_load
+(const struct sieve_runtime_env *renv, sieve_size_t *address ATTR_UNUSED)
+{	
+	/* Register runtime hook to obtain stript start timestamp */
+	if ( renv->msgctx == NULL ||
+		sieve_message_context_extension_get(renv->msgctx, &date_extension)
+		== NULL ) {
+		sieve_interpreter_extension_register
+			(renv->interp, &date_interpreter_extension, NULL);
+	}
+
+	return TRUE;
+}
+
+/*
+ * Zone string
+ */
+
+bool ext_date_parse_timezone
+(const char *zone, int *zone_offset_r)
+{
+	const unsigned char *str = (const unsigned char *) zone;
+	size_t len = strlen(zone);
+
+	if (len == 5 && (*str == '+' || *str == '-')) {
+		int offset;
+
+		if (!i_isdigit(str[1]) || !i_isdigit(str[2]) ||
+		    !i_isdigit(str[3]) || !i_isdigit(str[4]))
+			return FALSE;
+
+		offset = ((str[1]-'0') * 10 + (str[2]-'0')) * 60  +
+			(str[3]-'0') * 10 + (str[4]-'0');
+
+		if ( zone_offset_r != NULL )		
+			*zone_offset_r = *str == '+' ? offset : -offset;
+
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+/*
+ * Current date
+ */
+
+time_t ext_date_get_current_date
+(const struct sieve_runtime_env *renv, int *zone_offset_r)
+{	
+	struct ext_date_context *dctx = (struct ext_date_context *) 
+		sieve_message_context_extension_get(renv->msgctx, &date_extension);
+
+	if ( dctx == NULL ) {
+		ext_date_runtime_init(renv, NULL);
+		dctx = (struct ext_date_context *) 
+			sieve_message_context_extension_get(renv->msgctx, &date_extension);
+
+		i_assert(dctx != NULL);
+	}
+
+	/* Read script start timestamp from message context */
+
+	if ( zone_offset_r != NULL )
+		*zone_offset_r = dctx->zone_offset;
+
+	return dctx->current_date;
+}
+
+/* 
+ * Date parts 
+ */
+
+/* "year"      => the year, "0000" .. "9999". 
+ */
+
+static const char *ext_date_year_part_get(struct tm *tm, int zone_offset);
+
+static const struct ext_date_part year_date_part = {
+	"year",
+	ext_date_year_part_get
+};
+
+/* "month"     => the month, "01" .. "12".
+ */
+
+static const char *ext_date_month_part_get(struct tm *tm, int zone_offset);
+
+static const struct ext_date_part month_date_part = {
+	"month",
+	ext_date_month_part_get
+};
+
+/* "day"       => the day, "01" .. "31".
+ */
+
+static const char *ext_date_day_part_get(struct tm *tm, int zone_offset);
+
+static const struct ext_date_part day_date_part = {
+	"day",
+	ext_date_day_part_get
+};
+
+/* "date"      => the date in "yyyy-mm-dd" format.
+ */
+
+static const char *ext_date_date_part_get(struct tm *tm, int zone_offset);
+
+static const struct ext_date_part date_date_part = {
+	"date",
+	ext_date_date_part_get
+};
+
+/* "julian"    => the Modified Julian Day, that is, the date
+ *              expressed as an integer number of days since
+ *              00:00 UTC on November 17, 1858 (using the Gregorian
+ *              calendar).  This corresponds to the regular
+ *              Julian Day minus 2400000.5.  Sample routines to
+ *              convert to and from modified Julian dates are
+ *              given in Appendix A.
+ */ 
+
+static const char *ext_date_julian_part_get(struct tm *tm, int zone_offset);
+
+static const struct ext_date_part julian_date_part = {
+	"julian",
+	ext_date_julian_part_get
+};
+
+/* "hour"      => the hour, "00" .. "23". 
+ */
+static const char *ext_date_hour_part_get(struct tm *tm, int zone_offset);
+
+static const struct ext_date_part hour_date_part = {
+	"hour",
+	ext_date_hour_part_get
+};
+
+/* "minute"    => the minute, "00" .. "59".
+ */
+static const char *ext_date_minute_part_get(struct tm *tm, int zone_offset);
+
+static const struct ext_date_part minute_date_part = {
+	"minute",
+	ext_date_minute_part_get
+};
+
+/* "second"    => the second, "00" .. "60".
+ */
+static const char *ext_date_second_part_get(struct tm *tm, int zone_offset);
+
+static const struct ext_date_part second_date_part = {
+	"second",
+	ext_date_second_part_get
+};
+
+/* "time"      => the time in "hh:mm:ss" format.
+ */
+static const char *ext_date_time_part_get(struct tm *tm, int zone_offset);
+
+static const struct ext_date_part time_date_part = {
+	"time",
+	ext_date_time_part_get
+};
+
+/* "iso8601"   => the date and time in restricted ISO 8601 format.
+ */
+static const char *ext_date_iso8601_part_get(struct tm *tm, int zone_offset);
+
+static const struct ext_date_part iso8601_date_part = {
+	"iso8601",
+	ext_date_iso8601_part_get
+};
+
+/* "std11"     => the date and time in a format appropriate
+ *                for use in a Date: header field [RFC2822].
+ */
+static const char *ext_date_std11_part_get(struct tm *tm, int zone_offset);
+
+static const struct ext_date_part std11_date_part = {
+	"std11",
+	ext_date_std11_part_get
+};
+
+/* "zone"      => the time zone in use.  If the user specified a
+ *                time zone with ":zone", "zone" will
+ *                contain that value.  If :originalzone is specified
+ *                this value will be the original zone specified
+ *                in the date-time value.  If neither argument is
+ *                specified the value will be the server's default
+ *                time zone in offset format "+hhmm" or "-hhmm".  An
+ *                 offset of 0 (Zulu) always has a positive sign.
+ */
+static const char *ext_date_zone_part_get(struct tm *tm, int zone_offset);
+
+static const struct ext_date_part zone_date_part = {
+	"zone",
+	ext_date_zone_part_get
+};
+ 
+/* "weekday"   => the day of the week expressed as an integer between
+ *                "0" and "6". "0" is Sunday, "1" is Monday, etc.
+ */
+static const char *ext_date_weekday_part_get(struct tm *tm, int zone_offset);
+
+static const struct ext_date_part weekday_date_part = {
+	"weekday",
+	ext_date_weekday_part_get
+};
+
+/*
+ * Date part extraction
+ */
+
+static const struct ext_date_part *date_parts[] = {
+	&year_date_part, &month_date_part, &day_date_part, &date_date_part,
+	&julian_date_part, &hour_date_part, &minute_date_part, &second_date_part,
+	&time_date_part, &iso8601_date_part, &std11_date_part, &zone_date_part, 
+	&weekday_date_part 
+};
+
+unsigned int date_parts_count = N_ELEMENTS(date_parts);
+
+const char *ext_date_part_extract
+(const char *part, struct tm *tm, int zone_offset)
+{
+	unsigned int i;
+
+	for ( i = 0; i < date_parts_count; i++ ) {
+		if ( strcasecmp(date_parts[i]->identifier, part) == 0 ) {
+			if ( date_parts[i]->get_string != NULL )
+				return date_parts[i]->get_string(tm, zone_offset);
+
+			return NULL;
+		}
+	}
+	
+	return NULL;
+}
+
+/*
+ * Date part implementations
+ */
+
+static const char *month_names[] = {
+	"Jan", "Feb", "Mar", "Apr", "May", "Jun",
+	"Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
+};
+
+static const char *weekday_names[] = {
+	"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
+};
+
+static const char *ext_date_year_part_get
+(struct tm *tm, int zone_offset ATTR_UNUSED)
+{
+	return t_strdup_printf("%04d", tm->tm_year + 1900);
+}
+
+static const char *ext_date_month_part_get
+(struct tm *tm, int zone_offset ATTR_UNUSED)
+{
+	return t_strdup_printf("%02d", tm->tm_mon + 1);
+}
+
+static const char *ext_date_day_part_get
+(struct tm *tm, int zone_offset ATTR_UNUSED)
+{
+	return t_strdup_printf("%02d", tm->tm_mday);
+}
+
+static const char *ext_date_date_part_get
+(struct tm *tm, int zone_offset ATTR_UNUSED)
+{
+	return t_strdup_printf("%04d-%02d-%02d", 
+		tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday);
+}
+
+static const char *ext_date_julian_part_get
+(struct tm *tm, int zone_offset ATTR_UNUSED)
+{
+	int year = tm->tm_year+1900;
+	int month = tm->tm_mon+1;
+	int day = tm->tm_mday;
+	int c, ya, jd;
+	
+	/* Modified from RFC 5260 Appendix A */	
+
+	if ( month > 2 )
+		month -= 3;
+	else {
+		month += 9;
+		year--;
+	}
+
+	c = year / 100;
+	ya = year - c * 100;
+
+	jd = c * 146097 / 4 + ya * 1461 / 4 + (month * 153 + 2) / 5 + day + 1721119;
+	
+	return t_strdup_printf("%d", jd - 2400001);
+}
+
+static const char *ext_date_hour_part_get
+(struct tm *tm, int zone_offset ATTR_UNUSED)
+{
+	return t_strdup_printf("%02d", tm->tm_hour);
+}
+
+static const char *ext_date_minute_part_get
+(struct tm *tm, int zone_offset ATTR_UNUSED)
+{
+	return t_strdup_printf("%02d", tm->tm_min);
+}
+
+static const char *ext_date_second_part_get
+(struct tm *tm, int zone_offset ATTR_UNUSED)
+{
+	return t_strdup_printf("%02d", tm->tm_sec);
+}
+
+static const char *ext_date_time_part_get
+(struct tm *tm, int zone_offset ATTR_UNUSED)
+{
+	return t_strdup_printf("%02d:%02d:%02d", tm->tm_hour, tm->tm_min, tm->tm_sec);
+}
+
+static const char *ext_date_iso8601_part_get
+(struct tm *tm, int zone_offset)
+{
+	const char *time_offset;
+
+	/* 
+	 * RFC 3339: 5.6. Internet Date/Time Format
+	 * 
+	 * The following profile of ISO 8601 [ISO8601] dates SHOULD be used in
+	 * new protocols on the Internet.  This is specified using the syntax
+	 * description notation defined in [ABNF].
+	 * 
+	 * date-fullyear   = 4DIGIT
+	 * date-month      = 2DIGIT  ; 01-12
+	 * date-mday       = 2DIGIT  ; 01-28, 01-29, 01-30, 01-31 based on
+	 * 		                     ; month/year
+	 * time-hour       = 2DIGIT  ; 00-23
+	 * time-minute     = 2DIGIT  ; 00-59
+	 * time-second     = 2DIGIT  ; 00-58, 00-59, 00-60 based on leap second
+	 * 		                     ; rules
+	 * time-secfrac    = "." 1*DIGIT
+	 * time-numoffset  = ("+" / "-") time-hour ":" time-minute
+	 * time-offset     = "Z" / time-numoffset
+	 * 
+	 * partial-time    = time-hour ":" time-minute ":" time-second
+	 * 		             [time-secfrac]
+	 * full-date       = date-fullyear "-" date-month "-" date-mday
+	 * full-time       = partial-time time-offset
+	 * 
+	 * date-time       = full-date "T" full-time
+	 * 
+	 */
+
+	if ( zone_offset == 0 )
+		time_offset = "Z";
+	else {
+		int offset = zone_offset > 0 ? zone_offset : -zone_offset;
+
+		time_offset = t_strdup_printf
+			("%c%02d:%02d", (zone_offset > 0 ? '+' : '-'), offset / 60, offset % 60);
+	}
+
+	return t_strdup_printf("%04d-%02d-%02dT%02d:%02d:%02d%s",
+		tm->tm_year + 1900, tm->tm_mon+1, tm->tm_mday, tm->tm_hour, tm->tm_min, 
+		tm->tm_sec, time_offset); 
+}
+
+static const char *ext_date_std11_part_get
+(struct tm *tm, int zone_offset)
+{
+	return t_strdup_printf("%s, %02d %s %04d %02d:%02d:%02d %s",
+		weekday_names[tm->tm_wday],
+		tm->tm_mday,
+		month_names[tm->tm_mon],
+		tm->tm_year+1900,
+		tm->tm_hour, tm->tm_min, tm->tm_sec, 
+		ext_date_zone_part_get(tm, zone_offset));
+}
+
+static const char *ext_date_zone_part_get
+(struct tm *tm ATTR_UNUSED, int zone_offset)
+{
+	bool negative;
+	int offset = zone_offset;
+
+	if (zone_offset >= 0)
+		negative = FALSE;
+	else {
+		negative = TRUE;
+		offset = -offset;
+	}
+
+	return t_strdup_printf
+		("%c%02d%02d", negative ? '-' : '+', offset / 60, offset % 60);
+}
+
+static const char *ext_date_weekday_part_get
+(struct tm *tm, int zone_offset ATTR_UNUSED)
+{
+	return t_strdup_printf("%d", tm->tm_wday);
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/date/ext-date-common.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/date/ext-date-common.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/date/ext-date-common.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/date/ext-date-common.h	2009-08-21 00:52:15.000000000 +0200
@@ -0,0 +1,65 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#ifndef __EXT_DATE_COMMON_H
+#define __EXT_DATE_COMMON_H
+
+#include "sieve-common.h"
+
+#include <time.h>
+
+/*
+ * Extension
+ */
+ 
+extern const struct sieve_extension date_extension;
+
+bool ext_date_interpreter_load
+	(const struct sieve_runtime_env *renv, sieve_size_t *address ATTR_UNUSED);
+
+/* 
+ * Tests
+ */
+
+extern const struct sieve_command date_test;
+extern const struct sieve_command currentdate_test;
+ 
+/*
+ * Operations
+ */
+
+enum ext_date_opcode {
+	EXT_DATE_OPERATION_DATE,
+	EXT_DATE_OPERATION_CURRENTDATE
+};
+
+extern const struct sieve_operation date_operation;
+extern const struct sieve_operation currentdate_operation;
+
+/*
+ * Zone string
+ */
+
+bool ext_date_parse_timezone(const char *zone, int *zone_offset_r);
+
+/*
+ * Current date
+ */
+
+time_t ext_date_get_current_date
+	(const struct sieve_runtime_env *renv, int *zone_offset_r);
+
+/*
+ * Date part
+ */
+
+struct ext_date_part {
+	const char *identifier;
+
+	const char *(*get_string)(struct tm *tm, int zone_offset);
+};
+
+const char *ext_date_part_extract
+	(const char *part, struct tm *tm, int zone_offset);
+
+#endif /* __EXT_DATE_COMMON_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/date/Makefile.am dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/date/Makefile.am
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/date/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/date/Makefile.am	2009-08-10 09:55:31.000000000 +0200
@@ -0,0 +1,19 @@
+noinst_LTLIBRARIES = libsieve_ext_date.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+tests = \
+	tst-date.c
+
+libsieve_ext_date_la_SOURCES = \
+	$(tests) \
+	ext-date-common.c \
+	ext-date.c
+
+noinst_HEADERS = \
+	ext-date-common.h
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/date/Makefile.in dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/date/Makefile.in
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/date/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/date/Makefile.in	2009-08-21 00:55:43.000000000 +0200
@@ -0,0 +1,468 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve/plugins/date
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libsieve_ext_date_la_LIBADD =
+am__objects_1 = tst-date.lo
+am_libsieve_ext_date_la_OBJECTS = $(am__objects_1) ext-date-common.lo \
+	ext-date.lo
+libsieve_ext_date_la_OBJECTS = $(am_libsieve_ext_date_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_ext_date_la_SOURCES)
+DIST_SOURCES = $(libsieve_ext_date_la_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LTLIBRARIES = libsieve_ext_date.la
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+tests = \
+	tst-date.c
+
+libsieve_ext_date_la_SOURCES = \
+	$(tests) \
+	ext-date-common.c \
+	ext-date.c
+
+noinst_HEADERS = \
+	ext-date-common.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/lib-sieve/plugins/date/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  src/lib-sieve/plugins/date/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve_ext_date.la: $(libsieve_ext_date_la_OBJECTS) $(libsieve_ext_date_la_DEPENDENCIES) 
+	$(LINK)  $(libsieve_ext_date_la_OBJECTS) $(libsieve_ext_date_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-date-common.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-date.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-date.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/date/tst-date.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/date/tst-date.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/date/tst-date.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/date/tst-date.c	2009-08-21 00:52:15.000000000 +0200
@@ -0,0 +1,546 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str-sanitize.h"
+#include "message-date.h"
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-address-parts.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+#include "ext-date-common.h"
+
+#include <time.h>
+
+/*
+ * Tests
+ */
+
+static bool tst_date_validate
+	(struct sieve_validator *valdtr, struct sieve_command_context *tst);
+static bool tst_date_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+ 
+/* Address test
+ *
+ * Syntax:
+ *    date [<":zone" <time-zone: string>> / ":originalzone"]
+ *         [COMPARATOR] [MATCH-TYPE] <header-name: string>
+ *         <date-part: string> <key-list: string-list>
+ */
+
+static bool tst_date_registered
+	(struct sieve_validator *valdtr, struct sieve_command_registration *cmd_reg);
+
+const struct sieve_command date_test = { 
+	"date", 
+	SCT_TEST, 
+	3, 0, FALSE, FALSE,
+	tst_date_registered,
+	NULL, 
+	tst_date_validate, 
+	tst_date_generate, 
+	NULL 
+};
+
+/* Currentdate test
+ * 
+ * Syntax:
+ *    currentdate [":zone" <time-zone: string>]
+ *                [COMPARATOR] [MATCH-TYPE]
+ *                <date-part: string> <key-list: string-list>
+ */
+
+static bool tst_currentdate_registered
+	(struct sieve_validator *valdtr, struct sieve_command_registration *cmd_reg);
+
+const struct sieve_command currentdate_test = { 
+	"currentdate", 
+	SCT_TEST, 
+	2, 0, FALSE, FALSE,
+	tst_currentdate_registered,
+	NULL, 
+	tst_date_validate, 
+	tst_date_generate, 
+	NULL 
+};
+
+/* 
+ * Tagged arguments 
+ */
+
+/* Forward declarations */
+
+static bool tag_zone_validate
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg,
+		struct sieve_command_context *cmd);
+static bool tag_zone_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+		struct sieve_command_context *cmd);
+
+/* Argument objects */
+
+static const struct sieve_argument date_zone_tag = {
+ 	"zone",
+	NULL, NULL,
+	tag_zone_validate,
+	NULL,
+	tag_zone_generate
+};
+
+static const struct sieve_argument date_originalzone_tag = {
+	"originalzone",
+	NULL, NULL,
+	tag_zone_validate,
+	NULL,
+	tag_zone_generate
+};
+
+/* 
+ * Address operation 
+ */
+
+static bool tst_date_operation_dump
+	(const struct sieve_operation *op, 
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_date_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation date_operation = { 
+	"DATE",
+	&date_extension,
+	EXT_DATE_OPERATION_DATE,
+	tst_date_operation_dump, 
+	tst_date_operation_execute 
+};
+
+const struct sieve_operation currentdate_operation = { 
+	"CURRENTDATE",
+	&date_extension,
+	EXT_DATE_OPERATION_CURRENTDATE,
+	tst_date_operation_dump, 
+	tst_date_operation_execute 
+};
+
+/*
+ * Optional operands
+ */
+
+enum tst_date_optional {
+	OPT_DATE_ZONE = SIEVE_MATCH_OPT_LAST,
+	OPT_DATE_LAST
+};
+
+/*
+ * Tag implementation
+ */
+
+static bool tag_zone_validate
+(struct sieve_validator *validator, struct sieve_ast_argument **arg,
+    struct sieve_command_context *cmd)
+{
+	struct sieve_ast_argument *tag = *arg;
+
+	if ( (bool) cmd->data ) {
+		if ( cmd->command == &date_test ) {
+			sieve_argument_validate_error(validator, *arg,
+				"multiple :zone or :originalzone arguments specified for "
+				"the currentdate test");
+		} else {
+			sieve_argument_validate_error(validator, *arg,
+				"multiple :zone arguments specified for the currentdate test");
+		}
+		return FALSE;
+	}
+
+	/* Skip tag */
+ 	*arg = sieve_ast_argument_next(*arg);
+
+	/* :content tag has a string-list argument */
+	if ( tag->argument == &date_zone_tag ) {
+
+		/* Check syntax:
+		 *   :zone <time-zone: string>
+		 */
+		if ( !sieve_validate_tag_parameter
+			(validator, cmd, tag, *arg, SAAT_STRING) ) {
+			return FALSE;
+		}
+
+		/* Check it */
+		if ( sieve_argument_is_string_literal(*arg) ) {
+			const char *zone = sieve_ast_argument_strc(*arg);
+	
+			if ( !ext_date_parse_timezone(zone, NULL) ) {
+				sieve_argument_validate_warning(validator, *arg,
+					"specified :zone argument '%s' is not a valid timezone",
+					str_sanitize(zone, 40));
+			}		
+		}
+	
+		/* Assign tag parameters */
+		tag->parameters = *arg;
+		*arg = sieve_ast_arguments_detach(*arg,1);
+	} 
+
+	cmd->data = (void *) TRUE;
+
+	return TRUE;
+}
+
+/* 
+ * Test registration 
+ */
+
+static bool tst_date_registered
+(struct sieve_validator *valdtr, struct sieve_command_registration *cmd_reg) 
+{
+	sieve_comparators_link_tag(valdtr, cmd_reg, SIEVE_MATCH_OPT_COMPARATOR);
+	sieve_match_types_link_tags(valdtr, cmd_reg, SIEVE_MATCH_OPT_MATCH_TYPE);
+
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, &date_zone_tag, OPT_DATE_ZONE);
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, &date_originalzone_tag, OPT_DATE_ZONE);
+
+	return TRUE;
+}
+
+static bool tst_currentdate_registered
+(struct sieve_validator *valdtr, struct sieve_command_registration *cmd_reg) 
+{
+	sieve_comparators_link_tag(valdtr, cmd_reg, SIEVE_MATCH_OPT_COMPARATOR);
+	sieve_match_types_link_tags(valdtr, cmd_reg, SIEVE_MATCH_OPT_MATCH_TYPE);
+
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, &date_zone_tag, OPT_DATE_ZONE);
+
+	return TRUE;
+}
+
+/* 
+ * Validation 
+ */
+ 
+static bool tst_date_validate
+	(struct sieve_validator *valdtr, struct sieve_command_context *tst) 
+{
+	struct sieve_ast_argument *arg = tst->first_positional;
+	unsigned int arg_offset = 0 ;
+		
+	/* Check header name */
+
+	if ( tst->command == &date_test ) {
+		arg_offset = 1;
+
+		if ( !sieve_validate_positional_argument
+			(valdtr, tst, arg, "header name", 1, SAAT_STRING) ) {
+			return FALSE;
+		}
+	
+		if ( !sieve_validator_argument_activate(valdtr, tst, arg, FALSE) )
+			return FALSE;
+
+		if ( !sieve_command_verify_headers_argument(valdtr, arg) )
+    	    return FALSE;
+
+		arg = sieve_ast_argument_next(arg);
+	}
+
+	/* Check date part */
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "date part", arg_offset + 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+	
+	if ( !sieve_validator_argument_activate(valdtr, tst, arg, FALSE) )
+		return FALSE;
+
+	arg = sieve_ast_argument_next(arg);
+
+	/* Check key list */
+		
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "key list", arg_offset + 2, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(valdtr, tst, arg, FALSE) )
+		return FALSE;
+	
+	/* Validate the key argument to a specified match type */
+	return sieve_match_type_validate
+		(valdtr, tst, arg, &is_match_type, &i_ascii_casemap_comparator); 
+}
+
+/* 
+ * Code generation 
+ */
+
+static bool tst_date_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *tst) 
+{
+	if ( tst->command == &date_test )
+		sieve_operation_emit_code(cgenv->sbin, &date_operation);
+	else if ( tst->command == &currentdate_test )
+		sieve_operation_emit_code(cgenv->sbin, &currentdate_operation);
+	else
+		i_unreached();
+
+	/* Generate arguments */  	
+	return sieve_generate_arguments(cgenv, tst, NULL);
+}
+
+static bool tag_zone_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+    struct sieve_command_context *cmd)
+{
+	struct sieve_ast_argument *param = arg->parameters;
+
+	if ( param == NULL ) {
+		sieve_opr_omitted_emit(cgenv->sbin);
+		return TRUE;
+	}
+
+	if ( param->argument != NULL && param->argument->generate != NULL )
+		return param->argument->generate(cgenv, param, cmd);
+
+	return FALSE;	
+}
+
+/* 
+ * Code dump 
+ */
+
+static bool tst_date_operation_dump
+(const struct sieve_operation *op,	
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	int opt_code = 0;
+	const struct sieve_operand *operand;
+
+	sieve_code_dumpf(denv, "%s", op->mnemonic);
+	sieve_code_descend(denv);
+	
+	/* Handle any optional arguments */
+  do {
+		if ( !sieve_match_dump_optional_operands(denv, address, &opt_code) )
+			return FALSE;
+
+		switch ( opt_code ) {
+		case SIEVE_MATCH_OPT_END:
+			break;
+		case OPT_DATE_ZONE:
+			operand = sieve_operand_read(denv->sbin, address);
+			if ( operand == NULL ) {
+				sieve_code_dumpf(denv, "ERROR: INVALID OPERAND");
+				return FALSE;
+			}				
+
+			if ( sieve_operand_is_omitted(operand) ) {
+				sieve_code_dumpf(denv, "zone: ORIGINAL");
+			} else {
+				if ( !sieve_opr_string_dump_data
+					(denv, operand, address, "zone") )
+					return FALSE;
+			}
+			break;
+    default:
+			return FALSE;
+		}
+	} while ( opt_code != SIEVE_MATCH_OPT_END );
+
+	if ( op == &date_operation &&
+		!sieve_opr_string_dump(denv, address, "header name") )
+		return FALSE;
+
+	return
+		sieve_opr_string_dump(denv, address, "date part") && 
+		sieve_opr_stringlist_dump(denv, address, "key list");
+}
+
+/* 
+ * Code execution 
+ */
+
+static int tst_date_operation_execute
+(const struct sieve_operation *op, 
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{	
+	bool result = TRUE, zone_specified = FALSE, got_date = FALSE, matched = FALSE;
+	int opt_code = 0;
+	const struct sieve_message_data *msgdata = renv->msgdata;
+	const struct sieve_comparator *cmp = &i_ascii_casemap_comparator;
+	const struct sieve_match_type *mtch = &is_match_type;
+	const struct sieve_operand *operand;
+	struct sieve_match_context *mctx;
+	string_t *header_name = NULL, *date_part = NULL, *zone = NULL;
+	struct sieve_coded_stringlist *key_list;
+	time_t date_value, local_time;
+	struct tm *date_tm;
+	const char *part_value;
+	int local_zone = 0, original_zone = 0, wanted_zone = 0;
+	int ret;
+	
+	/* Read optional operands */
+	do {
+		if ( (ret=sieve_match_read_optional_operands
+			(renv, address, &opt_code, &cmp, &mtch)) <= 0 )
+			return ret;
+
+		switch ( opt_code ) {
+		case SIEVE_MATCH_OPT_END:
+			break;
+		case OPT_DATE_ZONE:
+			operand = sieve_operand_read(renv->sbin, address);
+			if ( operand == NULL ) {
+				sieve_runtime_trace_error(renv, "invalid operand");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+
+			if ( !sieve_operand_is_omitted(operand) ) {
+				if ( !sieve_opr_string_read_data
+					(renv, operand, address, &zone) ) {
+					sieve_runtime_trace_error(renv, "invalid zone operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+			}
+
+			zone_specified = TRUE;
+			break;
+		default:
+			sieve_runtime_trace_error(renv, "unknown optional operand");
+			return SIEVE_EXEC_BIN_CORRUPT;
+		}
+	} while ( opt_code != SIEVE_MATCH_OPT_END );
+
+
+	if ( op == &date_operation ) {
+		/* Read header name */
+		if ( !sieve_opr_string_read(renv, address, &header_name) ) {
+			sieve_runtime_trace_error(renv, "invalid header-name operand");
+			return SIEVE_EXEC_BIN_CORRUPT;
+		}
+	}
+
+	/* Read date part */
+	if ( !sieve_opr_string_read(renv, address, &date_part) ) {
+		sieve_runtime_trace_error(renv, "invalid date-part operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+		
+	/* Read key-list */
+	if ( (key_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid key-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Perform test */
+
+	sieve_runtime_trace(renv, "%s test", op->mnemonic);
+
+	/* Get the date value */
+
+	local_time = ext_date_get_current_date(renv, &local_zone);
+
+	if ( op == 	&date_operation ) {
+		const char *header_value;
+		const char *date_string;
+
+		/* Get date from the message */
+
+		/* Read first header
+		 *   NOTE: need something for index extension to hook into some time. 
+		 */
+		if ( (ret=mail_get_first_header
+			(msgdata->mail, str_c(header_name), &header_value)) > 0 ) {
+
+			/* Extract the date string value */
+			date_string = strrchr(header_value, ';');
+			if ( date_string == NULL )
+				/* Direct header value */
+				date_string = header_value;
+			else {
+				/* Delimited by ';', e.g. a Received: header */
+				date_string++; 
+			}
+
+			/* Parse the date value */
+			if ( message_date_parse((const unsigned char *) date_string,
+				strlen(date_string), &date_value, &original_zone) ) {
+				got_date = TRUE;
+			}
+		}
+	} else if ( op == &currentdate_operation ) {
+		/* Use time stamp recorded at the time the script first started */
+
+		date_value = local_time;
+		original_zone = local_zone;
+		got_date = TRUE;
+
+	} else {
+		i_unreached();
+	}
+
+	if ( got_date ) {
+		/* Apply wanted timezone */
+
+		if ( !zone_specified )
+			wanted_zone = local_zone;
+		else if ( zone == NULL 
+			|| !ext_date_parse_timezone(str_c(zone), &wanted_zone) ) {
+
+			/* FIXME: warn about parse failures */
+			wanted_zone = original_zone;
+		}
+
+		date_value += wanted_zone * 60;
+
+		/* Convert timestamp to struct tm */
+
+		if ( (date_tm=gmtime(&date_value)) == NULL ) {
+			got_date = FALSE;
+		} else {
+			/* Extract the date part */
+			part_value = ext_date_part_extract
+				(str_c(date_part), date_tm, wanted_zone);
+		}
+	}
+
+	/* Initialize match */
+	mctx = sieve_match_begin(renv->interp, mtch, cmp, NULL, key_list); 	
+	
+	if ( got_date && part_value != NULL ) {		
+		/* Match value */
+		if ( (ret=sieve_match_value(mctx, part_value, strlen(part_value))) < 0 )
+			result = FALSE;
+		else
+			matched = ret > 0;
+	}
+
+	/* Finish match */
+	if ( (ret=sieve_match_end(&mctx)) < 0 ) 
+		result = FALSE;
+	else
+		matched = ( ret > 0 || matched );
+	
+	/* Set test result for subsequent conditional jump */
+	if ( result ) {
+		sieve_interpreter_set_test_result(renv->interp, matched);
+		return SIEVE_EXEC_OK;
+	}	
+
+	sieve_runtime_trace_error(renv, "invalid string-list item");
+	return SIEVE_EXEC_BIN_CORRUPT;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/enotify/cmd-notify.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/enotify/cmd-notify.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/enotify/cmd-notify.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/enotify/cmd-notify.c	2009-07-21 02:40:42.000000000 +0200
@@ -0,0 +1,597 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+
+#include "sieve-common.h"
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-actions.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-result.h"
+
+#include "ext-enotify-common.h"
+
+/* 
+ * Forward declarations 
+ */
+ 
+static const struct sieve_argument notify_importance_tag;
+static const struct sieve_argument notify_from_tag;
+static const struct sieve_argument notify_options_tag;
+static const struct sieve_argument notify_message_tag;
+
+/* 
+ * Notify command 
+ *	
+ * Syntax: 
+ *    notify [":from" string]
+ *           [":importance" <"1" / "2" / "3">]
+ *           [":options" string-list]
+ *           [":message" string]
+ *           <method: string>
+ */
+
+static bool cmd_notify_registered
+	(struct sieve_validator *valdtr, 
+		struct sieve_command_registration *cmd_reg);
+static bool cmd_notify_pre_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd);
+static bool cmd_notify_validate
+	(struct sieve_validator *valdtr, struct sieve_command_context *cmd);
+static bool cmd_notify_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command notify_command = { 
+	"notify",
+	SCT_COMMAND, 
+	1, 0, FALSE, FALSE, 
+	cmd_notify_registered,
+	cmd_notify_pre_validate,
+	cmd_notify_validate, 
+	cmd_notify_generate, 
+	NULL 
+};
+
+/*
+ * Notify command tags
+ */
+
+/* Forward declarations */
+
+static bool cmd_notify_validate_string_tag
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+static bool cmd_notify_validate_stringlist_tag
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+static bool cmd_notify_validate_importance_tag
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+
+/* Argument objects */
+
+static const struct sieve_argument notify_from_tag = { 
+	"from", 
+	NULL, NULL,
+	cmd_notify_validate_string_tag, 
+	NULL, NULL 
+};
+
+static const struct sieve_argument notify_options_tag = { 
+	"options", 
+	NULL, NULL,
+	cmd_notify_validate_stringlist_tag, 
+	NULL, NULL 
+};
+
+static const struct sieve_argument notify_message_tag = { 
+	"message", 
+	NULL, NULL, 
+	cmd_notify_validate_string_tag, 
+	NULL, NULL 
+};
+
+static const struct sieve_argument notify_importance_tag = { 
+	"importance", 
+	NULL, NULL,
+	cmd_notify_validate_importance_tag, 
+	NULL, NULL 
+};
+
+/* 
+ * Notify operation 
+ */
+
+static bool cmd_notify_operation_dump
+	(const struct sieve_operation *op,	
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_notify_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation notify_operation = { 
+	"NOTIFY",
+	&enotify_extension,
+	EXT_ENOTIFY_OPERATION_NOTIFY,
+	cmd_notify_operation_dump, 
+	cmd_notify_operation_execute
+};
+
+/* 
+ * Notify action 
+ */
+
+/* Forward declarations */
+
+static int act_notify_check_duplicate
+	(const struct sieve_runtime_env *renv, 
+		const struct sieve_action_data *act,
+		const struct sieve_action_data *act_other);
+static void act_notify_print
+	(const struct sieve_action *action, const struct sieve_result_print_env *rpenv,
+		void *context, bool *keep);	
+static bool act_notify_commit
+	(const struct sieve_action *action,	const struct sieve_action_exec_env *aenv, 
+		void *tr_context, bool *keep);
+
+/* Action object */
+
+const struct sieve_action act_notify = {
+	"notify",
+	0,
+	NULL,
+	act_notify_check_duplicate, 
+	NULL,
+	act_notify_print,
+	NULL, NULL,
+	act_notify_commit,
+	NULL
+};
+
+/*
+ * Command validation context
+ */
+ 
+struct cmd_notify_context_data {
+	struct sieve_ast_argument *from;
+	struct sieve_ast_argument *message;
+	struct sieve_ast_argument *options;
+};
+
+/* 
+ * Tag validation 
+ */
+
+static bool cmd_notify_validate_string_tag
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd)
+{
+	struct sieve_ast_argument *tag = *arg;
+	struct cmd_notify_context_data *ctx_data = 
+		(struct cmd_notify_context_data *) cmd->data; 
+
+	/* Detach the tag itself */
+	*arg = sieve_ast_arguments_detach(*arg,1);
+	
+	/* Check syntax:
+	 *   :from <string>
+	 *   :message <string>
+	 */
+	if ( !sieve_validate_tag_parameter(valdtr, cmd, tag, *arg, SAAT_STRING) )
+		return FALSE;
+
+	if ( tag->argument == &notify_from_tag ) {
+		ctx_data->from = *arg;
+		
+		/* Skip parameter */
+		*arg = sieve_ast_argument_next(*arg);
+		
+	} else if ( tag->argument == &notify_message_tag ) {
+		ctx_data->message = *arg;
+
+		/* Skip parameter */
+		*arg = sieve_ast_argument_next(*arg);	
+	}
+			
+	return TRUE;
+}
+
+static bool cmd_notify_validate_stringlist_tag
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd)
+{
+	struct sieve_ast_argument *tag = *arg;
+	struct cmd_notify_context_data *ctx_data = 
+		(struct cmd_notify_context_data *) cmd->data; 
+
+	/* Detach the tag itself */
+	*arg = sieve_ast_arguments_detach(*arg,1);
+	
+	/* Check syntax:
+	 *   :options string-list
+	 */
+	if ( !sieve_validate_tag_parameter(valdtr, cmd, tag, *arg, SAAT_STRING_LIST) ) 
+		return FALSE;
+		
+	/* Assign context */
+	ctx_data->options = *arg;	
+	
+	/* Skip parameter */
+	*arg = sieve_ast_argument_next(*arg);
+
+	return TRUE;
+}
+
+static bool cmd_notify_validate_importance_tag
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd ATTR_UNUSED)
+{
+	const struct sieve_ast_argument *tag = *arg;
+	const char *impstr;
+
+	/* Detach the tag itself */
+	*arg = sieve_ast_arguments_detach(*arg,1);
+
+	/* Check syntax: 
+	 *   :importance <"1" / "2" / "3">
+	 */
+
+	if ( sieve_ast_argument_type(*arg) != SAAT_STRING ) {
+		/* Not a string */
+		sieve_argument_validate_error(valdtr, *arg, 
+			"the :importance tag for the notify command requires a string parameter, "
+			"but %s was found", sieve_ast_argument_name(*arg));
+		return FALSE;
+	}
+
+	impstr = sieve_ast_argument_strc(*arg);
+
+	if ( impstr[0] < '1' || impstr[0]  > '3' || impstr[1] != '\0' ) {
+		/* Invalid importance */
+		sieve_argument_validate_error(valdtr, *arg, 
+			"invalid :importance value for notify command: %s", impstr);
+		return FALSE;
+	} 
+
+	sieve_ast_argument_number_substitute(*arg, impstr[0] - '0');
+	(*arg)->arg_id_code = tag->arg_id_code;
+	(*arg)->argument = &number_argument;
+
+	/* Skip parameter */
+	*arg = sieve_ast_argument_next(*arg);
+			
+	return TRUE;
+}
+
+
+/* 
+ * Command registration 
+ */
+
+static bool cmd_notify_registered
+(struct sieve_validator *valdtr, struct sieve_command_registration *cmd_reg) 
+{
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, &notify_importance_tag, CMD_NOTIFY_OPT_IMPORTANCE); 	
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, &notify_from_tag, CMD_NOTIFY_OPT_FROM); 	
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, &notify_options_tag, CMD_NOTIFY_OPT_OPTIONS); 	
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, &notify_message_tag, CMD_NOTIFY_OPT_MESSAGE); 	
+
+	return TRUE;
+}
+
+/* 
+ * Command validation 
+ */
+
+static bool cmd_notify_pre_validate
+(struct sieve_validator *validator ATTR_UNUSED, 
+	struct sieve_command_context *cmd) 
+{
+	struct cmd_notify_context_data *ctx_data;
+	
+	/* Assign context */
+	ctx_data = p_new(sieve_command_pool(cmd), 
+		struct cmd_notify_context_data, 1);
+	cmd->data = ctx_data;
+
+	return TRUE;
+}
+ 
+static bool cmd_notify_validate
+(struct sieve_validator *valdtr, struct sieve_command_context *cmd) 
+{ 	
+	struct sieve_ast_argument *arg = cmd->first_positional;
+	struct cmd_notify_context_data *ctx_data = 
+		(struct cmd_notify_context_data *) cmd->data; 
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, cmd, arg, "method", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+	
+	if ( !sieve_validator_argument_activate(valdtr, cmd, arg, FALSE) )
+		return FALSE;
+		
+	return ext_enotify_compile_check_arguments
+		(valdtr, arg, ctx_data->message, ctx_data->from, ctx_data->options);
+}
+
+/*
+ * Code generation
+ */
+ 
+static bool cmd_notify_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx) 
+{		 
+	sieve_operation_emit_code(cgenv->sbin, &notify_operation);
+
+	/* Emit source line */
+	sieve_code_source_line_emit(cgenv->sbin, sieve_command_source_line(ctx));
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, ctx, NULL);
+}
+
+/* 
+ * Code dump
+ */
+ 
+static bool cmd_notify_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{	
+	int opt_code = 1;
+	
+	sieve_code_dumpf(denv, "NOTIFY");
+	sieve_code_descend(denv);	
+
+	/* Source line */
+	if ( !sieve_code_source_line_dump(denv, address) )
+		return FALSE;
+
+	/* Dump optional operands */
+	if ( sieve_operand_optional_present(denv->sbin, address) ) {
+		while ( opt_code != 0 ) {
+			sieve_code_mark(denv);
+			
+			if ( !sieve_operand_optional_read(denv->sbin, address, &opt_code) ) 
+				return FALSE;
+
+			switch ( opt_code ) {
+			case 0:
+				break;
+			case CMD_NOTIFY_OPT_IMPORTANCE:
+				if ( !sieve_opr_number_dump(denv, address, "importance") )
+					return FALSE;
+				break;
+			case CMD_NOTIFY_OPT_FROM:
+				if ( !sieve_opr_string_dump(denv, address, "from") )
+					return FALSE;
+				break;
+			case CMD_NOTIFY_OPT_OPTIONS:
+				if ( !sieve_opr_stringlist_dump(denv, address, "options") )
+					return FALSE;
+				break;
+			case CMD_NOTIFY_OPT_MESSAGE:
+				if ( !sieve_opr_string_dump(denv, address, "message") )
+					return FALSE;
+				break;
+			default:
+				return FALSE;
+			}
+		}
+	}
+	
+	/* Dump reason and handle operands */
+	return 
+		sieve_opr_string_dump(denv, address, "method");
+}
+
+/* 
+ * Code execution
+ */
+ 
+static int cmd_notify_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{	
+	struct sieve_side_effects_list *slist = NULL;
+	struct sieve_enotify_action *act;
+	void *method_context;
+	pool_t pool;
+	int opt_code = 1, result = SIEVE_EXEC_OK;
+	sieve_number_t importance = 1;
+	struct sieve_coded_stringlist *options = NULL;
+	const struct sieve_enotify_method *method;
+	string_t *method_uri, *message = NULL, *from = NULL; 
+	unsigned int source_line;
+
+	/*
+	 * Read operands
+	 */
+		
+	/* Source line */
+	if ( !sieve_code_source_line_read(renv, address, &source_line) ) {
+		sieve_runtime_trace_error(renv, "invalid source line");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/* Optional operands */	
+	if ( sieve_operand_optional_present(renv->sbin, address) ) {
+		while ( opt_code != 0 ) {
+			if ( !sieve_operand_optional_read(renv->sbin, address, &opt_code) ) {
+				sieve_runtime_trace_error(renv, "invalid optional operand");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+
+			switch ( opt_code ) {
+			case 0:
+				break;
+			case CMD_NOTIFY_OPT_IMPORTANCE:
+				if ( !sieve_opr_number_read(renv, address, &importance) ) {
+					sieve_runtime_trace_error(renv, "invalid importance operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+	
+				/* Enforce 0 < importance < 4 (just to be sure) */
+				if ( importance < 1 ) 
+					importance = 1;
+				else if ( importance > 3 )
+					importance = 3;
+				break;
+			case CMD_NOTIFY_OPT_FROM:
+				if ( !sieve_opr_string_read(renv, address, &from) ) {
+					sieve_runtime_trace_error(renv, "invalid from operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+				break;
+			case CMD_NOTIFY_OPT_MESSAGE:
+				if ( !sieve_opr_string_read(renv, address, &message) ) {
+					sieve_runtime_trace_error(renv, "invalid from operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+				break;
+			case CMD_NOTIFY_OPT_OPTIONS:
+				if ( (options=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+					sieve_runtime_trace_error(renv, "invalid options operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+				break;
+			default:
+				sieve_runtime_trace_error(renv, "unknown optional operand: %d", 
+					opt_code);
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+		}
+	}
+	
+	/* Reason operand */
+	if ( !sieve_opr_string_read(renv, address, &method_uri) ) {
+		sieve_runtime_trace_error(renv, "invalid method operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+		
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "NOTIFY action");	
+
+	/* Check operands */
+
+	if ( (result=ext_enotify_runtime_check_operands
+		(renv, source_line, method_uri, message, from, options, &method, 
+			&method_context)) ) 
+	{
+		/* Add notify action to the result */
+
+		pool = sieve_result_pool(renv->result);
+		act = p_new(pool, struct sieve_enotify_action, 1);
+		act->method = method;
+		act->method_context = method_context;
+		act->importance = importance;
+		if ( message != NULL )
+			act->message = p_strdup(pool, str_c(message));
+		if ( from != NULL )
+			act->from = p_strdup(pool, str_c(from));
+		
+		return ( sieve_result_add_action
+			(renv, &act_notify, slist, source_line, (void *) act, 0) >= 0 );
+	}
+	
+	return result;
+}
+
+/*
+ * Action
+ */
+
+/* Runtime verification */
+
+static int act_notify_check_duplicate
+(const struct sieve_runtime_env *renv ATTR_UNUSED, 
+	const struct sieve_action_data *act ATTR_UNUSED,
+	const struct sieve_action_data *act_other ATTR_UNUSED)
+{
+	const struct sieve_enotify_action *nact1, *nact2;
+	struct sieve_enotify_log nlog;
+		
+	if ( act->context == NULL || act_other->context == NULL )
+		return 0;
+
+	nact1 = (const struct sieve_enotify_action *) act->context;
+	nact2 = (const struct sieve_enotify_action *) act_other->context;
+
+	if ( nact1->method == NULL || nact1->method->action_check_duplicates == NULL )
+		return 0;
+
+	memset(&nlog, 0, sizeof(nlog));
+	nlog.location = act->location;
+	nlog.ehandler = sieve_result_get_error_handler(renv->result);
+
+	return nact1->method->action_check_duplicates
+		(&nlog, nact1->method_context, nact2->method_context, act_other->location);
+}
+
+/* Result printing */
+ 
+static void act_notify_print
+(const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_result_print_env *rpenv, void *context, 
+	bool *keep ATTR_UNUSED)	
+{
+	const struct sieve_enotify_action *act = 
+		(const struct sieve_enotify_action *) context;
+
+	sieve_result_action_printf
+		( rpenv, "send notification with method '%s:':", act->method->identifier);
+		
+	if ( act->method->action_print != NULL ) {
+		struct sieve_enotify_print_env penv;
+
+		memset(&penv, 0, sizeof(penv));
+		penv.result_penv = rpenv;
+
+		act->method->action_print(&penv, act);
+	}
+}
+
+/* Result execution */
+
+static bool act_notify_commit
+(const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_action_exec_env *aenv, void *tr_context, 
+	bool *keep ATTR_UNUSED)
+{
+	const struct sieve_enotify_action *act = 
+		(const struct sieve_enotify_action *) tr_context;
+	struct sieve_enotify_exec_env nenv;
+	struct sieve_enotify_log nlog;
+		
+	memset(&nlog, 0, sizeof(nlog));
+	nlog.location = sieve_action_get_location(aenv);
+	nlog.ehandler = sieve_result_get_error_handler(aenv->result);
+
+	nenv.scriptenv = aenv->scriptenv;
+	nenv.msgdata = aenv->msgdata;
+	nenv.msgctx = aenv->msgctx;
+	nenv.notify_log = &nlog;
+
+	if ( act->method->action_execute != NULL )
+		return act->method->action_execute(&nenv, act);
+			
+	return TRUE;
+}
+
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/enotify/ext-enotify.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/enotify/ext-enotify.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/enotify/ext-enotify.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/enotify/ext-enotify.c	2009-02-02 10:17:30.000000000 +0100
@@ -0,0 +1,88 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension enotify
+ * ------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: RFC 5435
+ * Implementation: full
+ * Status: testing
+ * 
+ */
+	
+#include <stdio.h>
+
+#include "sieve-common.h"
+
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-actions.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-result.h"
+
+#include "sieve-ext-variables.h"
+
+#include "ext-enotify-common.h"
+
+/*
+ * Operations
+ */
+
+const struct sieve_operation *ext_enotify_operations[] = {
+	&notify_operation,
+	&valid_notify_method_operation,
+	&notify_method_capability_operation
+};
+
+/* 
+ * Extension
+ */
+
+static bool ext_enotify_load(void);
+static void ext_enotify_unload(void);
+static bool ext_enotify_validator_load(struct sieve_validator *valdtr);
+
+static int ext_my_id = -1;
+
+const struct sieve_extension enotify_extension = { 
+	"enotify", 
+	&ext_my_id,
+	ext_enotify_load,
+	ext_enotify_unload,
+	ext_enotify_validator_load, 
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATIONS(ext_enotify_operations),
+	SIEVE_EXT_DEFINE_OPERAND(encodeurl_operand)
+};
+
+static bool ext_enotify_load(void)
+{
+	ext_enotify_methods_init();
+
+	sieve_extension_capabilities_register(&notify_capabilities);
+
+	return TRUE;
+}
+
+static void ext_enotify_unload(void)
+{
+	ext_enotify_methods_deinit();
+}
+
+static bool ext_enotify_validator_load(struct sieve_validator *valdtr)
+{
+	/* Register new commands */
+	sieve_validator_register_command(valdtr, &notify_command);
+	sieve_validator_register_command(valdtr, &valid_notify_method_test);
+	sieve_validator_register_command(valdtr, &notify_method_capability_test);
+	
+	/* Register new set modifier for variables extension */
+	sieve_variables_modifier_register(valdtr, &encodeurl_modifier);
+	
+	return TRUE;
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/enotify/ext-enotify-common.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/enotify/ext-enotify-common.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/enotify/ext-enotify-common.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/enotify/ext-enotify-common.c	2009-01-21 23:50:10.000000000 +0100
@@ -0,0 +1,629 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+ 
+#include "lib.h"
+#include "str.h"
+#include "str-sanitize.h"
+#include "array.h"
+
+#include "sieve-common.h"
+#include "sieve-ast.h"
+#include "sieve-code.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-interpreter.h"
+#include "sieve-result.h"
+
+#include "ext-enotify-limits.h"
+#include "ext-enotify-common.h"
+
+#include <ctype.h>
+
+/* FIXME: (from draft RFC)
+ *
+ * Header/envelope tests [Sieve] together with Sieve variables can be
+ * used to extract the list of users to receive notifications from the
+ * incoming email message or its envelope.  This is potentially quite
+ * dangerous, as this can be used for Deny Of Service attacks on
+ * recipients controlled by the message sender.  For this reason
+ * implementations SHOULD NOT allow use of variables containing values
+ * extracted from the email message in the method parameter to the
+ * notify action.  Note that violation of this SHOULD NOT may result in
+ * the creation of an open relay, i.e. any sender would be able to
+ * create specially crafted email messages that would result in
+ * notifications delivered to recipients under the control of the
+ * sender.  In worst case this might result in financial loss by user
+ * controlling the Sieve script and/or by recipients of notifications
+ * (e.g. if a notification is an SMS message).
+ *
+ * --> This is currently not possible to check.
+ */
+
+/*
+ * Notify capability
+ */
+
+static const char *ext_notify_get_methods_string(void);
+
+const struct sieve_extension_capabilities notify_capabilities = {
+	"notify",
+	&enotify_extension,
+	ext_notify_get_methods_string
+};
+
+/*
+ * Notify method registry
+ */
+ 
+static ARRAY_DEFINE(ext_enotify_methods, const struct sieve_enotify_method *); 
+
+void ext_enotify_methods_init(void)
+{
+	p_array_init(&ext_enotify_methods, default_pool, 4);
+
+	sieve_enotify_method_register(&mailto_notify);
+}
+
+void ext_enotify_methods_deinit(void)
+{
+	array_free(&ext_enotify_methods);
+}
+
+void sieve_enotify_method_register(const struct sieve_enotify_method *method) 
+{
+	array_append(&ext_enotify_methods, &method, 1);
+}
+
+const struct sieve_enotify_method *ext_enotify_method_find
+(const char *identifier) 
+{
+	unsigned int meth_count, i;
+	const struct sieve_enotify_method *const *methods;
+	 
+	methods = array_get(&ext_enotify_methods, &meth_count);
+		
+	for ( i = 0; i < meth_count; i++ ) {
+		if ( strcasecmp(methods[i]->identifier, identifier) == 0 ) {
+			return methods[i];
+		}
+	}
+	
+	return NULL;
+}
+
+static const char *ext_notify_get_methods_string(void)
+{
+	unsigned int meth_count, i;
+	const struct sieve_enotify_method *const *methods;
+	string_t *result = t_str_new(128);
+	 
+	methods = array_get(&ext_enotify_methods, &meth_count);
+		
+	if ( meth_count > 0 ) {
+		str_append(result, methods[0]->identifier);
+		
+		for ( i = 1; i < meth_count; i++ ) {
+			str_append_c(result, ' ');
+			str_append(result, methods[i]->identifier);
+		}
+		
+		return str_c(result);
+	}
+	
+	return NULL;
+}
+
+/*
+ * Compile-time argument validation
+ */
+ 
+static const char *ext_enotify_uri_scheme_parse(const char **uri_p)
+{
+	string_t *scheme = t_str_new(EXT_ENOTIFY_MAX_SCHEME_LEN);
+	const char *p = *uri_p;
+	unsigned int len = 0;
+	
+	/* RFC 3968:
+	 *
+	 *   scheme  = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
+	 *
+	 * FIXME: we do not allow '%' in schemes. Is this correct?
+	 */
+	 
+	if ( !i_isalpha(*p) )
+		return NULL;
+		
+	str_append_c(scheme, *p);
+	p++;
+		
+	while ( *p != '\0' && len < EXT_ENOTIFY_MAX_SCHEME_LEN ) {
+			
+		if ( !i_isalnum(*p) && *p != '+' && *p != '-' && *p != '.' )
+			break;
+	
+		str_append_c(scheme, *p);
+		p++;
+		len++;
+	}
+	
+	if ( *p != ':' )
+		return NULL;
+	p++;
+	
+	*uri_p = p;
+	return str_c(scheme);
+}
+
+static bool ext_enotify_option_parse
+(struct sieve_enotify_log *nlog, const char *option, bool name_only,
+	const char **opt_name_r, const char **opt_value_r)
+{
+	const char *p = option;
+	
+	/* "<optionname>=<value>".
+	 * 
+	 * l-d = ALPHA / DIGIT
+	 * l-d-p = l-d / "." / "-" / "_"
+	 * optionname = l-d *l-d-p
+	 * value = *(%x01-09 / %x0B-0C / %x0E-FF)
+	 */
+				
+	/* 
+	 * Parse option name 
+	 *
+	 * optionname = l-d *l-d-p
+	 */
+	
+	/* Explicitly report empty option as such */
+	if ( *p == '\0' ) {
+		sieve_enotify_error(nlog, "empty option specified");
+		return FALSE;
+	}
+
+	/* l-d = ALPHA / DIGIT */
+	if ( i_isalnum(*p) ) {
+		p++;
+	
+		/* l-d-p = l-d / "." / "-" / "_" */
+		while ( i_isalnum(*p) || *p == '.' || *p == '-' || *p == '_' )
+			p++;
+	}
+	
+	/* Parsing must end at '=' and we must parse at least one character */
+	if ( *p != '=' || p == option ) {
+		sieve_enotify_error(nlog, "invalid option name specified in option '%s'",
+				str_sanitize(option, 80));
+		return FALSE;
+	}
+	
+	/* Assign option name */
+	if ( opt_name_r != NULL ) 
+		*opt_name_r = t_strdup_until(option, p);
+	
+	/* Skip '=' */
+	p++;
+	
+	/* Exit now if only the option name is of interest */
+	if ( name_only )
+		return TRUE;
+			
+	/* 
+	 * Parse option value
+	 */
+	 
+	/* value = *(%x01-09 / %x0B-0C / %x0E-FF) */
+	while ( *p != '\0' && *p != 0x0A && *p != 0x0D )
+		p++;
+		
+	/* Parse must end at end of string */
+	if ( *p != '\0' ) {
+		sieve_enotify_error(nlog, 
+			"notify command: invalid option value specified in option '%s'",
+				str_sanitize(option, 80));
+		return FALSE;
+	}
+	
+	/* Assign option value */
+	if ( opt_value_r != NULL )
+		*opt_value_r = p;
+		
+	return TRUE;
+} 
+
+struct _ext_enotify_option_check_context {
+	struct sieve_validator *valdtr;
+	const struct sieve_enotify_method *method;
+};
+
+static int _ext_enotify_option_check
+(void *context, struct sieve_ast_argument *arg)
+{
+	struct _ext_enotify_option_check_context *optn_context = 
+		(struct _ext_enotify_option_check_context *) context;
+	struct sieve_validator *valdtr = optn_context->valdtr;
+	const struct sieve_enotify_method *method = optn_context->method;
+	struct sieve_enotify_log nlog;
+	const char *option = sieve_ast_argument_strc(arg);
+	const char *opt_name = NULL, *opt_value = NULL;
+	bool literal = sieve_argument_is_string_literal(arg);
+	
+	/* Compose log structure */
+	memset(&nlog, 0, sizeof(nlog));
+	nlog.ehandler = sieve_validator_error_handler(valdtr);
+	nlog.prefix = "notify command";
+	nlog.location = sieve_error_script_location
+		(sieve_validator_script(valdtr), arg->source_line);
+		
+	/* Parse option */
+	if ( !literal ) {
+		/* Variable string: partial option parse
+		 * 
+		 * If the string item is not a string literal, it cannot be validated fully
+		 * at compile time. We can however check whether the '=' is in the string
+		 * specification and whether the part before the '=' is a valid option name.
+		 * In that case, the method option check function is called with the value
+		 * parameter equal to NULL, meaning that it should only check the validity
+		 * of the option itself and not the assigned value.
+		 */ 
+		if ( !ext_enotify_option_parse(NULL, option, TRUE, &opt_name, &opt_value) )
+			return TRUE;
+	} else {
+		/* Literal string: full option parse */
+		if ( !ext_enotify_option_parse
+			(&nlog, option, FALSE, &opt_name, &opt_value) )
+			return FALSE;
+	}
+	
+	/* Call method's option check function */
+	if ( method->compile_check_option != NULL ) 
+		return method->compile_check_option(&nlog, opt_name, opt_value); 
+	
+	return TRUE;
+}
+
+bool ext_enotify_compile_check_arguments
+(struct sieve_validator *valdtr, struct sieve_ast_argument *uri_arg,
+	struct sieve_ast_argument *msg_arg, struct sieve_ast_argument *from_arg,
+	struct sieve_ast_argument *options_arg)
+{
+	const char *uri = sieve_ast_argument_strc(uri_arg);
+	const char *scheme;
+	const struct sieve_enotify_method *method;
+	struct sieve_enotify_log nlog;
+
+	/* If the uri string is not a constant literal, we cannot determine which
+	 * method is used, so we bail out successfully and defer checking to runtime.
+	 */
+	if ( !sieve_argument_is_string_literal(uri_arg) )
+		return TRUE;
+	
+	/* Parse scheme part of URI */
+	if ( (scheme=ext_enotify_uri_scheme_parse(&uri)) == NULL ) {
+		sieve_argument_validate_error(valdtr, uri_arg, 
+			"notify command: invalid scheme part for method URI '%s'", 
+			str_sanitize(sieve_ast_argument_strc(uri_arg), 80));
+		return FALSE;
+	}
+	
+	/* Find used method with the parsed scheme identifier */
+	if ( (method=ext_enotify_method_find(scheme)) == NULL ) {
+		sieve_argument_validate_error(valdtr, uri_arg, 
+			"notify command: invalid method '%s'", scheme);
+		return FALSE;
+	}
+
+	/* Compose log structure */
+	memset(&nlog, 0, sizeof(nlog));
+	nlog.ehandler = sieve_validator_error_handler(valdtr);
+	nlog.prefix = "notify command";
+	
+	/* Check URI itself */
+	if ( method->compile_check_uri != NULL ) {
+		/* Set log location to location of URI argument */
+		nlog.location = sieve_error_script_location
+			(sieve_validator_script(valdtr), uri_arg->source_line);
+
+		/* Execute method check function */
+		if ( !method->compile_check_uri
+			(&nlog, sieve_ast_argument_strc(uri_arg), uri) )
+			return FALSE;
+	}
+
+	/* Check :message argument */
+	if ( msg_arg != NULL && sieve_argument_is_string_literal(msg_arg) && 
+		method->compile_check_message != NULL ) {
+		/* Set log location to location of :message argument */
+		nlog.location = sieve_error_script_location
+			(sieve_validator_script(valdtr), msg_arg->source_line);
+
+		/* Execute method check function */
+		if ( !method->compile_check_message
+			(&nlog, sieve_ast_argument_str(msg_arg)) )
+			return FALSE;
+	}
+
+	/* Check :from argument */
+	if ( from_arg != NULL && sieve_argument_is_string_literal(from_arg) &&
+		method->compile_check_from != NULL ) {
+		/* Set log location to location of :from argument */
+		nlog.location = sieve_error_script_location
+			(sieve_validator_script(valdtr), from_arg->source_line);
+
+		/* Execute method check function */
+		if ( !method->compile_check_from(&nlog, sieve_ast_argument_str(from_arg)) )
+			return FALSE;
+	}
+	
+	/* Check :options argument */
+	if ( options_arg != NULL ) {
+		struct sieve_ast_argument *option = options_arg;
+		struct _ext_enotify_option_check_context optn_context = { valdtr, method };
+		
+		/* Parse and check options */
+		if ( sieve_ast_stringlist_map
+			(&option, (void *) &optn_context, _ext_enotify_option_check) <= 0 )
+			return FALSE;
+			
+		/* Discard argument if options are not accepted by method */
+		if ( method->compile_check_option == NULL ) {
+			sieve_argument_validate_warning(valdtr, options_arg, 
+				"notify command: method '%s' accepts no options", scheme);
+			(void)sieve_ast_arguments_detach(options_arg,1);
+		}
+	}
+	
+	return TRUE;
+}
+
+/*
+ * Runtime operand checking
+ */
+ 
+bool ext_enotify_runtime_method_validate
+(const struct sieve_runtime_env *renv, unsigned int source_line,
+	string_t *method_uri)
+{
+	const struct sieve_enotify_method *method;
+	const char *uri = str_c(method_uri);
+	const char *scheme;
+	
+	/* Get the method */
+	
+	if ( (scheme=ext_enotify_uri_scheme_parse(&uri)) == NULL )
+		return FALSE;
+	
+	if ( (method=ext_enotify_method_find(scheme)) == NULL )
+		return FALSE;
+		
+	/* Validate the provided URI */
+	
+	if ( method->runtime_check_uri != NULL ) {
+		struct sieve_enotify_log nlog;
+		
+		memset(&nlog, 0, sizeof(nlog));
+		nlog.location = sieve_error_script_location(renv->script, source_line);
+		nlog.ehandler = sieve_interpreter_get_error_handler(renv->interp);
+		nlog.prefix = "valid_notify_method test";
+
+		/* Use the method check function to validate the URI */
+		return method->runtime_check_uri(&nlog, str_c(method_uri), uri);
+	}
+
+	/* Method has no check function */
+	return TRUE;
+}
+ 
+static const struct sieve_enotify_method *ext_enotify_get_method
+(const struct sieve_runtime_env *renv, unsigned int source_line,
+	string_t *method_uri, const char **uri_body_r)
+{
+	const struct sieve_enotify_method *method;
+	const char *uri = str_c(method_uri);
+	const char *scheme;
+	
+	/* Parse part before ':' of the uri (the scheme) and use it to identify
+	 * notify method.
+	 */
+	if ( (scheme=ext_enotify_uri_scheme_parse(&uri)) == NULL ) {
+		sieve_runtime_error
+			(renv, sieve_error_script_location(renv->script, source_line),
+				"invalid scheme part for method URI '%s'", 
+				str_sanitize(str_c(method_uri), 80));
+		return NULL;
+	}
+	
+	/* Find the notify method */
+	if ( (method=ext_enotify_method_find(scheme)) == NULL ) {
+		sieve_runtime_error
+			(renv, sieve_error_script_location(renv->script, source_line),
+				"invalid notify method '%s'", scheme);
+		return NULL;
+	}
+
+	/* Return the parse pointer and the found method */
+	*uri_body_r = uri;
+	return method;
+}
+
+const char *ext_enotify_runtime_get_method_capability
+(const struct sieve_runtime_env *renv, unsigned int source_line,
+	string_t *method_uri, const char *capability)
+{
+	const struct sieve_enotify_method *method;
+	const char *uri;
+	
+	/* Get method */
+	method = ext_enotify_get_method(renv, source_line, method_uri, &uri);
+	if ( method == NULL ) return NULL;
+	
+	/* Get requested capability */
+	if ( method->runtime_get_method_capability != NULL ) {
+		struct sieve_enotify_log nlog;
+		
+		/* Compose log structure */
+		memset(&nlog, 0, sizeof(nlog));
+		nlog.location = sieve_error_script_location(renv->script, source_line);
+		nlog.ehandler = sieve_interpreter_get_error_handler(renv->interp);
+		nlog.prefix = "notify_method_capability test";
+
+		/* Execute method function to acquire capability value */
+		return method->runtime_get_method_capability
+			(&nlog, str_c(method_uri), uri, capability);
+	}
+
+	return NULL;
+}
+
+int ext_enotify_runtime_check_operands
+(const struct sieve_runtime_env *renv, unsigned int source_line,
+	string_t *method_uri, string_t *message, string_t *from, 
+	struct sieve_coded_stringlist *options, 
+	const struct sieve_enotify_method **method_r, void **method_context)
+{
+	const struct sieve_enotify_method *method;
+	const char *uri;
+	
+	/* Get method */
+	method = ext_enotify_get_method(renv, source_line, method_uri, &uri);
+	if ( method == NULL ) return SIEVE_EXEC_FAILURE;
+	
+	/* Check provided operands */
+	if ( method->runtime_check_operands != NULL ) {
+		struct sieve_enotify_log nlog;
+		
+		/* Compose log structure */
+		memset(&nlog, 0, sizeof(nlog));
+		nlog.location = sieve_error_script_location(renv->script, source_line);
+		nlog.ehandler = sieve_interpreter_get_error_handler(renv->interp);
+		nlog.prefix = "notify action";
+
+		/* Execute check function */
+		if ( method->runtime_check_operands(&nlog, str_c(method_uri), uri, message, 
+			from, sieve_result_pool(renv->result), method_context) ) {
+			
+			/* Check any provided options */
+			if ( options != NULL ) {			
+				int result = TRUE;
+				string_t *option = NULL;
+			
+				/* Iterate through all provided options */
+				while ( result && 
+					(result=sieve_coded_stringlist_next_item(options, &option)) && 
+					option != NULL ) {
+					const char *opt_name = NULL, *opt_value = NULL;
+				
+					/* Parse option into <optionname> and <value> */
+					if ( ext_enotify_option_parse
+						(&nlog, str_c(option), FALSE, &opt_name, &opt_value) ) {
+					
+						/* Set option */
+						if ( method->runtime_set_option != NULL ) {
+							(void) method->runtime_set_option
+								(&nlog, *method_context, opt_name, opt_value);
+						}
+					}
+				}
+			
+				/* Check for binary corruptions encountered during string list iteration
+				 */
+				if ( result ) {
+					*method_r = method;
+					return SIEVE_EXEC_OK;
+				}
+	
+				/* Binary corrupt */
+				sieve_runtime_trace_error(renv, "invalid item in options string list");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+
+			/* No options */			
+			*method_r = method;
+			return SIEVE_EXEC_OK;
+		}
+		
+		/* Check failed */
+		return SIEVE_EXEC_FAILURE;
+	}
+
+	/* No check function defined: a most unlikely situation */
+	*method_context = NULL;	
+	*method_r = method;
+	return SIEVE_EXEC_OK;
+}
+
+/*
+ * Notify method printing
+ */
+
+void sieve_enotify_method_printf
+(const struct sieve_enotify_print_env *penv, const char *fmt, ...)
+{
+	va_list args;
+	
+	va_start(args, fmt);	
+	sieve_result_vprintf(penv->result_penv, fmt, args);
+	va_end(args);	 
+}
+
+/*
+ * Method logging
+ */
+
+void sieve_enotify_error
+(const struct sieve_enotify_log *nlog, const char *fmt, ...) 
+{
+	va_list args;
+	va_start(args, fmt);
+	
+	if ( nlog == NULL ) return;
+	
+	T_BEGIN {
+		if ( nlog->prefix == NULL )
+			sieve_verror(nlog->ehandler, nlog->location, fmt, args);
+		else
+			sieve_error(nlog->ehandler, nlog->location, "%s: %s", nlog->prefix, 
+				t_strdup_vprintf(fmt, args));
+	} T_END;
+	
+	va_end(args);
+}
+
+void sieve_enotify_warning
+(const struct sieve_enotify_log *nlog, const char *fmt, ...) 
+{
+	va_list args;
+	va_start(args, fmt);
+	
+	if ( nlog == NULL ) return;
+	
+	T_BEGIN { 
+		if ( nlog->prefix == NULL )
+			sieve_vwarning(nlog->ehandler, nlog->location, fmt, args);
+		else			
+			sieve_warning(nlog->ehandler, nlog->location, "%s: %s", nlog->prefix, 
+				t_strdup_vprintf(fmt, args));
+	} T_END;
+	
+	va_end(args);
+}
+
+void sieve_enotify_log
+(const struct sieve_enotify_log *nlog, const char *fmt, ...) 
+{
+	va_list args;
+	va_start(args, fmt);
+
+	if ( nlog == NULL ) return;
+	
+	T_BEGIN { 
+		if ( nlog->prefix == NULL )
+			sieve_vinfo(nlog->ehandler, nlog->location, fmt, args);
+		else
+			sieve_info(nlog->ehandler, nlog->location, "%s: %s", nlog->prefix, 
+				t_strdup_vprintf(fmt, args));	
+	} T_END;
+	
+	va_end(args);
+}
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/enotify/ext-enotify-common.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/enotify/ext-enotify-common.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/enotify/ext-enotify-common.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/enotify/ext-enotify-common.h	2009-07-08 18:55:52.000000000 +0200
@@ -0,0 +1,126 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_ENOTIFY_COMMON_H
+#define __EXT_ENOTIFY_COMMON_H
+
+#include "sieve-ext-variables.h"
+
+#include "sieve-ext-enotify.h"
+
+/*
+ * Extension
+ */
+
+extern const struct sieve_extension enotify_extension;
+extern const struct sieve_extension notify_extension;
+extern const struct sieve_extension_capabilities notify_capabilities;
+
+/*
+ * Commands
+ */
+
+extern const struct sieve_command notify_command;
+
+/* Codes for optional arguments */
+
+enum cmd_notify_optional {
+    CMD_NOTIFY_OPT_END,
+    CMD_NOTIFY_OPT_FROM,
+    CMD_NOTIFY_OPT_OPTIONS,
+    CMD_NOTIFY_OPT_MESSAGE,
+    CMD_NOTIFY_OPT_IMPORTANCE
+};
+
+/*
+ * Tests
+ */
+
+extern const struct sieve_command valid_notify_method_test;
+extern const struct sieve_command notify_method_capability_test;
+
+/*
+ * Operations
+ */
+
+extern const struct sieve_operation notify_operation;
+extern const struct sieve_operation valid_notify_method_operation;
+extern const struct sieve_operation notify_method_capability_operation;
+
+enum ext_variables_opcode {
+	EXT_ENOTIFY_OPERATION_NOTIFY,
+	EXT_ENOTIFY_OPERATION_VALID_NOTIFY_METHOD,
+	EXT_ENOTIFY_OPERATION_NOTIFY_METHOD_CAPABILITY
+};
+
+/*
+ * Operands
+ */
+ 
+extern const struct sieve_operand encodeurl_operand;
+
+/*
+ * Modifiers
+ */
+
+extern const struct sieve_variables_modifier encodeurl_modifier;
+
+/*
+ * Notify methods
+ */
+ 
+extern const struct sieve_enotify_method mailto_notify;
+ 
+void ext_enotify_methods_init(void);
+void ext_enotify_methods_deinit(void);
+
+const struct sieve_enotify_method *ext_enotify_method_find
+	(const char *identifier);
+	
+/*
+ * Validation
+ */
+ 
+bool ext_enotify_compile_check_arguments
+(struct sieve_validator *valdtr, struct sieve_ast_argument *uri_arg,
+	struct sieve_ast_argument *msg_arg, struct sieve_ast_argument *from_arg,
+	struct sieve_ast_argument *options_arg);
+
+/*
+ * Runtime
+ */
+ 
+bool ext_enotify_runtime_method_validate
+	(const struct sieve_runtime_env *renv, unsigned int source_line,
+		string_t *method_uri);
+ 
+const char *ext_enotify_runtime_get_method_capability
+	(const struct sieve_runtime_env *renv, unsigned int source_line,
+		string_t *method_uri, const char *capability);
+
+int ext_enotify_runtime_check_operands
+	(const struct sieve_runtime_env *renv, unsigned int source_line,
+		string_t *method_uri, string_t *message, string_t *from, 
+		struct sieve_coded_stringlist *options, 
+		const struct sieve_enotify_method **method_r, void **method_context);
+		
+/*
+ * Method printing
+ */
+
+struct sieve_enotify_print_env {
+	const struct sieve_result_print_env *result_penv;
+};
+
+/*
+ * Method logging
+ */ 
+
+struct sieve_enotify_log {
+	struct sieve_error_handler *ehandler;
+	
+	const char *location;
+	const char *prefix;
+};
+
+#endif /* __EXT_ENOTIFY_COMMON_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/enotify/ext-enotify-limits.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/enotify/ext-enotify-limits.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/enotify/ext-enotify-limits.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/enotify/ext-enotify-limits.h	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,9 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#ifndef __EXT_ENOTIFY_LIMITS_H
+#define __EXT_ENOTIFY_LIMITS_H
+
+#define EXT_ENOTIFY_MAX_SCHEME_LEN  32
+
+#endif /* __EXT_ENOTIFY_LIMITS_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/enotify/Makefile.am dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/enotify/Makefile.am
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/enotify/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/enotify/Makefile.am	2009-07-19 15:54:39.000000000 +0200
@@ -0,0 +1,36 @@
+noinst_LTLIBRARIES = libsieve_ext_enotify.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I../variables \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+commands = \
+	cmd-notify.c
+
+tests = \
+	tst-valid-notify-method.c \
+	tst-notify-method-capability.c
+
+var_modifiers = \
+	vmodf-encodeurl.c
+
+notify_methods = \
+	ntfy-mailto.c
+
+libsieve_ext_enotify_la_SOURCES = \
+	ext-enotify.c \
+	ext-enotify-common.c \
+	$(commands) \
+	$(tests) \
+	$(var_modifiers) \
+	$(notify_methods)
+
+noinst_HEADERS = \
+	sieve-ext-enotify.h \
+	ext-enotify-limits.h \
+	ext-enotify-common.h
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/enotify/Makefile.in dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/enotify/Makefile.in
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/enotify/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/enotify/Makefile.in	2009-08-21 00:55:43.000000000 +0200
@@ -0,0 +1,494 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve/plugins/enotify
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libsieve_ext_enotify_la_LIBADD =
+am__objects_1 = cmd-notify.lo
+am__objects_2 = tst-valid-notify-method.lo \
+	tst-notify-method-capability.lo
+am__objects_3 = vmodf-encodeurl.lo
+am__objects_4 = ntfy-mailto.lo
+am_libsieve_ext_enotify_la_OBJECTS = ext-enotify.lo \
+	ext-enotify-common.lo $(am__objects_1) $(am__objects_2) \
+	$(am__objects_3) $(am__objects_4)
+libsieve_ext_enotify_la_OBJECTS =  \
+	$(am_libsieve_ext_enotify_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_ext_enotify_la_SOURCES)
+DIST_SOURCES = $(libsieve_ext_enotify_la_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LTLIBRARIES = libsieve_ext_enotify.la
+AM_CPPFLAGS = \
+	-I../../ \
+	-I../variables \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+commands = \
+	cmd-notify.c
+
+tests = \
+	tst-valid-notify-method.c \
+	tst-notify-method-capability.c
+
+var_modifiers = \
+	vmodf-encodeurl.c
+
+notify_methods = \
+	ntfy-mailto.c
+
+libsieve_ext_enotify_la_SOURCES = \
+	ext-enotify.c \
+	ext-enotify-common.c \
+	$(commands) \
+	$(tests) \
+	$(var_modifiers) \
+	$(notify_methods)
+
+noinst_HEADERS = \
+	sieve-ext-enotify.h \
+	ext-enotify-limits.h \
+	ext-enotify-common.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/lib-sieve/plugins/enotify/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  src/lib-sieve/plugins/enotify/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve_ext_enotify.la: $(libsieve_ext_enotify_la_OBJECTS) $(libsieve_ext_enotify_la_DEPENDENCIES) 
+	$(LINK)  $(libsieve_ext_enotify_la_OBJECTS) $(libsieve_ext_enotify_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-notify.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-enotify-common.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-enotify.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ntfy-mailto.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-notify-method-capability.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-valid-notify-method.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/vmodf-encodeurl.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/enotify/ntfy-mailto.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/enotify/ntfy-mailto.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/enotify/ntfy-mailto.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/enotify/ntfy-mailto.c	2009-07-21 03:15:57.000000000 +0200
@@ -0,0 +1,1104 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+ 
+/* Notify method mailto
+ * --------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: RFC 5436
+ * Implementation: full
+ * Status: testing
+ * 
+ */
+ 
+/* FIXME: URI syntax conforms to something somewhere in between RFC 2368 and
+ *   draft-duerst-mailto-bis-05.txt. Should fully migrate to new specification
+ *   when it matures. This requires modifications to the address parser (no
+ *   whitespace allowed within the address itself) and UTF-8 support will be
+ *   required in the URL.
+ */
+ 
+#include "lib.h"
+#include "array.h"
+#include "str.h"
+#include "ioloop.h"
+#include "str-sanitize.h"
+#include "message-date.h"
+#include "mail-storage.h"
+
+#include "rfc2822.h"
+
+#include "sieve-ext-enotify.h"
+#include "sieve-address.h"
+#include "sieve-message.h"
+
+/*
+ * Configuration
+ */
+ 
+#define NTFY_MAILTO_MAX_RECIPIENTS  8
+#define NTFY_MAILTO_MAX_HEADERS     16
+#define NTFY_MAILTO_MAX_SUBJECT     256
+
+/* 
+ * Types 
+ */
+
+struct ntfy_mailto_header_field {
+	const char *name;
+	const char *body;
+};
+
+struct ntfy_mailto_recipient {
+	const char *full;
+	const char *normalized;
+	bool carbon_copy;
+};
+
+ARRAY_DEFINE_TYPE(recipients, struct ntfy_mailto_recipient);
+ARRAY_DEFINE_TYPE(headers, struct ntfy_mailto_header_field);
+
+/* 
+ * Mailto notification method
+ */
+ 
+static bool ntfy_mailto_compile_check_uri
+	(const struct sieve_enotify_log *nlog, const char *uri, const char *uri_body);
+static bool ntfy_mailto_compile_check_from
+	(const struct sieve_enotify_log *nlog, string_t *from);
+
+static const char *ntfy_mailto_runtime_get_notify_capability
+	(const struct sieve_enotify_log *nlog, const char *uri, const char *uri_body, 
+		const char *capability);
+static bool ntfy_mailto_runtime_check_uri
+	(const struct sieve_enotify_log *nlog, const char *uri, const char *uri_body);
+static bool ntfy_mailto_runtime_check_operands
+	(const struct sieve_enotify_log *nlog, const char *uri,const char *uri_body, 
+		string_t *message, string_t *from, pool_t context_pool, 
+		void **method_context);
+
+static int ntfy_mailto_action_check_duplicates
+	(const struct sieve_enotify_log *nlog, void *method_ctx1, void *method_ctx2,
+		const char *dupl_location);
+
+static void ntfy_mailto_action_print
+	(const struct sieve_enotify_print_env *penv, 
+		const struct sieve_enotify_action *act);	
+
+static bool ntfy_mailto_action_execute
+	(const struct sieve_enotify_exec_env *nenv, 
+		const struct sieve_enotify_action *act);
+
+const struct sieve_enotify_method mailto_notify = {
+	"mailto",
+	ntfy_mailto_compile_check_uri,
+	NULL,
+	ntfy_mailto_compile_check_from,
+	NULL,
+	ntfy_mailto_runtime_check_uri,
+	ntfy_mailto_runtime_get_notify_capability,
+	ntfy_mailto_runtime_check_operands,
+	NULL,
+	ntfy_mailto_action_check_duplicates,
+	ntfy_mailto_action_print,
+	ntfy_mailto_action_execute
+};
+
+/*
+ * Method context data
+ */
+ 
+struct ntfy_mailto_context {
+	ARRAY_TYPE(recipients) recipients;
+	ARRAY_TYPE(headers) headers;
+	const char *subject;
+	const char *body;
+	const char *from_normalized;
+};
+
+/*
+ * Reserved headers
+ */
+ 
+static const char *_reserved_headers[] = {
+	"auto-submitted",
+	"received",
+	"message-id",
+	"data",
+	"bcc",
+	"in-reply-to",
+	"references",
+	"resent-date",
+	"resent-from",
+	"resent-sender",
+	"resent-to",
+	"resent-cc",
+ 	"resent-bcc",
+	"resent-msg-id",
+	"from",
+	"sender",
+	NULL
+};
+
+static const char *_unique_headers[] = {
+	"reply-to",
+	NULL
+};
+
+static inline bool _ntfy_mailto_header_allowed(const char *field_name)
+{
+	const char **rhdr = _reserved_headers;
+
+	/* Check whether it is reserved */
+	while ( *rhdr != NULL ) {
+		if ( strcasecmp(field_name, *rhdr) == 0 )
+			return FALSE;
+		rhdr++;
+	}
+
+	return TRUE;
+}
+
+static inline bool _ntfy_mailto_header_unique(const char *field_name)
+{
+	const char **rhdr = _unique_headers;
+
+	/* Check whether it is supposed to be unique */
+	while ( *rhdr != NULL ) {
+		if ( strcasecmp(field_name, *rhdr) == 0 )
+			return TRUE;
+		rhdr++;
+	}
+
+	return FALSE;
+}
+
+/*
+ * Mailto URI parsing
+ */
+ 
+/* Util functions */
+
+#define _uri_parse_error(LOG, ...) \
+	sieve_enotify_error(LOG, "invalid mailto URI: " __VA_ARGS__ )
+	
+#define _uri_parse_warning(LOG, ...) \
+	sieve_enotify_warning(LOG, "mailto URI: " __VA_ARGS__ )
+
+/* FIXME: much of this implementation will be common to other URI schemes. This
+ *        should be merged into a common implementation.
+ */
+
+static const char _qchar_lookup[256] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 00
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 10
+	0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0,  // 20
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,  // 30
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 40
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,  // 50
+	0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 60
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0,  // 70
+
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 80
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 90
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // A0
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // B0
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // C0
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // D0
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // E0
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // F0
+};
+
+static inline bool _is_qchar(unsigned char c)
+{
+	return _qchar_lookup[c];
+}
+  
+static inline int _decode_hex_digit(char digit)
+{
+	switch ( digit ) {
+	case '0': case '1': case '2': case '3': case '4': 
+	case '5': case '6': case '7': case '8': case '9': 
+		return (int) digit - '0';
+
+	case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
+		return (int) digit - 'a' + 0x0a;
+		
+	case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
+		return (int) digit - 'A' + 0x0A;
+	}
+	
+	return -1;
+}
+
+static bool _parse_hex_value(const char **in, char *out)
+{
+	char value;
+		
+	if ( **in == '\0' || (value=_decode_hex_digit(**in)) < 0 )
+		return FALSE;
+	
+	*out = value << 4;
+	(*in)++;
+	
+	if ( **in == '\0' || (value=_decode_hex_digit(**in)) < 0 )
+		return FALSE;	
+
+	*out |= value;
+	(*in)++;
+	return (*out != '\0');	
+}
+
+static bool _uri_add_valid_recipient
+(const struct sieve_enotify_log *nlog, ARRAY_TYPE(recipients) *recipients, 
+	string_t *recipient, bool cc)
+{
+	const char *error;
+	const char *normalized;
+	 
+	/* Verify recipient */
+	if ( (normalized=sieve_address_normalize(recipient, &error)) == NULL ) {
+		_uri_parse_error(nlog, "invalid recipient '%s': %s",
+			str_sanitize(str_c(recipient), 80), error);
+		return FALSE;
+	}
+					
+	/* Add recipient to the list */
+	if ( recipients != NULL ) {
+		struct ntfy_mailto_recipient *new_recipient;
+		struct ntfy_mailto_recipient *rcpts;
+		unsigned int count, i;
+		pool_t pool;
+
+		rcpts = array_get_modifiable(recipients, &count);
+		
+		/* Enforce limits */
+		if ( count >= NTFY_MAILTO_MAX_RECIPIENTS ) {
+			if ( count == NTFY_MAILTO_MAX_RECIPIENTS ) {
+				_uri_parse_warning(nlog, 
+					"more than the maximum %u recipients specified; "
+					"rest is discarded", NTFY_MAILTO_MAX_RECIPIENTS);
+			}
+			return TRUE;	
+		}
+		
+		/* Check for duplicate first */
+		for ( i = 0; i < count; i++ ) {
+			if ( sieve_address_compare(rcpts[i].normalized, normalized, TRUE) == 0 ) 
+				{
+				/* Upgrade existing Cc: recipient to a To: recipient if possible */
+				rcpts[i].carbon_copy = ( rcpts[i].carbon_copy && cc );
+				
+				_uri_parse_warning(nlog, "ignored duplicate recipient '%s'",
+					str_sanitize(str_c(recipient), 80));
+				return TRUE;
+			} 
+		}			
+
+		/* Add */
+		pool = array_get_pool(recipients);
+		new_recipient = array_append_space(recipients);
+		new_recipient->carbon_copy = cc;
+		new_recipient->full = p_strdup(pool, str_c(recipient));
+		new_recipient->normalized = p_strdup(pool, normalized);
+	}
+
+	return TRUE;
+}
+
+static bool _uri_parse_recipients
+(const struct sieve_enotify_log *nlog, const char **uri_p, 
+	ARRAY_TYPE(recipients) *recipients_r)
+{
+	string_t *to = t_str_new(128);
+	const char *p = *uri_p;
+	
+	if ( *p == '\0' || *p == '?' )
+		return TRUE;
+		
+	while ( *p != '\0' && *p != '?' ) {
+		if ( *p == '%' ) {
+			/* % encoded character */
+			char ch;
+			
+			p++;
+			
+			/* Parse 2-digit hex value */
+			if ( !_parse_hex_value(&p, &ch) ) {
+				_uri_parse_error(nlog, "invalid %% encoding");
+				return FALSE;
+			}
+
+			/* Check for delimiter */
+			if ( ch == ',' ) {
+				/* Verify and add recipient */
+				if ( !_uri_add_valid_recipient(nlog, recipients_r, to, FALSE) )
+					return FALSE;
+			
+				/* Reset for next recipient */
+				str_truncate(to, 0);
+			}	else {
+				/* Content character */
+				str_append_c(to, ch);
+			}
+		} else {
+			if ( *p == ':' || *p == ';' || *p == ',' || !_is_qchar(*p) ) {
+				_uri_parse_error
+					(nlog, "invalid character '%c' in 'to' part", *p);
+				return FALSE;
+			}
+
+			/* Content character */
+			str_append_c(to, *p);
+			p++;
+		}
+	}	
+	
+	/* Skip '?' */
+	if ( *p != '\0' ) p++;
+	
+	/* Verify and add recipient */
+	if ( !_uri_add_valid_recipient(nlog, recipients_r, to, FALSE) )
+		return FALSE;
+
+	*uri_p = p;
+	return TRUE;
+}
+
+static bool _uri_parse_header_recipients
+(const struct sieve_enotify_log *nlog, string_t *rcpt_header, 
+	ARRAY_TYPE(recipients) *recipients_r, bool cc)
+{
+	string_t *to = t_str_new(128);
+	const char *p = (const char *) str_data(rcpt_header);
+	const char *pend = p + str_len(rcpt_header);
+		
+	while ( p < pend ) {
+		if ( *p == ',' ) {
+			/* Verify and add recipient */
+			if ( !_uri_add_valid_recipient(nlog, recipients_r, to, cc) )
+				return FALSE;
+			
+			/* Reset for next recipient */
+			str_truncate(to, 0);
+		} else {
+			/* Content character */
+			str_append_c(to, *p);
+		}
+		p++;
+	}	
+	
+	/* Verify and add recipient */
+	if ( !_uri_add_valid_recipient(nlog, recipients_r, to, cc) )
+		return FALSE;
+
+	return TRUE;	
+}
+
+static bool _uri_header_is_duplicate
+(ARRAY_TYPE(headers) *headers, const char *field_name)
+{	
+	if ( _ntfy_mailto_header_unique(field_name) ) {
+		const struct ntfy_mailto_header_field *hdrs;
+		unsigned int count, i;
+
+		hdrs = array_get(headers, &count);	
+		for ( i = 0; i < count; i++ ) {
+			if ( strcasecmp(hdrs[i].name, field_name) == 0 ) 
+				return TRUE;
+		}
+	}
+	
+	return FALSE;
+}
+
+static bool _uri_parse_headers
+(const struct sieve_enotify_log *nlog, const char **uri_p, 
+	ARRAY_TYPE(headers) *headers_r, ARRAY_TYPE(recipients) *recipients_r,
+	const char **body, const char **subject)
+{
+	unsigned int header_count = 0;
+	string_t *field = t_str_new(128);
+	const char *p = *uri_p;
+	pool_t pool = NULL;
+
+	if ( body != NULL )
+		*body = NULL;
+		
+	if ( subject != NULL )
+		*subject = NULL;
+			
+	if ( headers_r != NULL )
+		pool = array_get_pool(headers_r);
+		
+	while ( *p != '\0' ) {
+		enum {
+			_HNAME_IGNORED, 
+			_HNAME_GENERIC,
+			_HNAME_TO,
+			_HNAME_CC,
+			_HNAME_SUBJECT, 
+			_HNAME_BODY 
+		} hname_type = _HNAME_GENERIC;
+		struct ntfy_mailto_header_field *hdrf = NULL;
+		const char *field_name;
+		
+		/* Parse field name */
+		while ( *p != '\0' && *p != '=' ) {
+			char ch = *p;
+			p++;
+			
+			if ( ch == '%' ) {
+				/* Encoded, parse 2-digit hex value */
+				if ( !_parse_hex_value(&p, &ch) ) {
+					_uri_parse_error(nlog, "invalid %% encoding");
+					return FALSE;
+				}
+			} else if ( ch != '=' && !_is_qchar(ch) ) {
+				_uri_parse_error
+					(nlog, "invalid character '%c' in header field name part", ch);
+				return FALSE;
+			}
+
+			str_append_c(field, ch);
+		}
+		if ( *p != '\0' ) p++;
+
+		/* Verify field name */
+		if ( !rfc2822_header_field_name_verify(str_c(field), str_len(field)) ) {
+			_uri_parse_error(nlog, "invalid header field name");
+			return FALSE;
+		}
+
+		if ( header_count >= NTFY_MAILTO_MAX_HEADERS ) {
+			/* Refuse to accept more headers than allowed by policy */
+			if ( header_count == NTFY_MAILTO_MAX_HEADERS ) {
+				_uri_parse_warning(nlog, "more than the maximum %u headers specified; "
+					"rest is discarded", NTFY_MAILTO_MAX_HEADERS);
+			}
+			
+			hname_type = _HNAME_IGNORED;
+		} else {
+			/* Add new header field to array and assign its name */
+			
+			field_name = str_c(field);
+			if ( strcasecmp(field_name, "to") == 0 )
+				hname_type = _HNAME_TO;
+			else if ( strcasecmp(field_name, "cc") == 0 )
+				hname_type = _HNAME_CC;
+			else if ( strcasecmp(field_name, "subject") == 0 )
+				hname_type = _HNAME_SUBJECT;
+			else if ( strcasecmp(field_name, "body") == 0 )
+				hname_type = _HNAME_BODY;
+			else if ( _ntfy_mailto_header_allowed(field_name) ) {
+				if ( headers_r != NULL ) {
+					if ( !_uri_header_is_duplicate(headers_r, field_name) ) {
+						hdrf = array_append_space(headers_r);
+						hdrf->name = p_strdup(pool, field_name);
+					} else {
+						_uri_parse_warning(nlog, 
+							"ignored duplicate for unique header field '%s'",
+							str_sanitize(field_name, 32));
+						hname_type = _HNAME_IGNORED;
+					}
+				} else {
+					hname_type = _HNAME_IGNORED;
+				}
+			} else {
+				_uri_parse_warning(nlog, "ignored reserved header field '%s'",
+					str_sanitize(field_name, 32));
+				hname_type = _HNAME_IGNORED;
+			}
+		}
+		
+		header_count++;
+			
+		/* Reset for field body */
+		str_truncate(field, 0);
+		
+		/* Parse field body */		
+		while ( *p != '\0' && *p != '&' ) {
+			char ch = *p;
+			p++;
+			
+			if ( ch == '%' ) {
+				/* Encoded, parse 2-digit hex value */
+				if ( !_parse_hex_value(&p, &ch) ) {
+					_uri_parse_error(nlog, "invalid %% encoding");
+					return FALSE;
+				}
+			} else if ( ch != '=' && !_is_qchar(ch) ) {
+				_uri_parse_error
+					(nlog, "invalid character '%c' in header field value part", ch);
+				return FALSE;
+			}
+			str_append_c(field, ch);
+		}
+		if ( *p != '\0' ) p++;
+		
+		/* Verify field body */
+		if ( hname_type == _HNAME_BODY ) {
+			// FIXME: verify body ... 
+		} else {
+			if ( !rfc2822_header_field_body_verify(str_c(field), str_len(field)) ) {
+				_uri_parse_error
+					(nlog, "invalid header field body");
+				return FALSE;
+			}
+		}
+		
+		/* Assign field body */
+
+		switch ( hname_type ) {
+		case _HNAME_IGNORED:
+			break;
+		case _HNAME_TO:
+			/* Gracefully allow duplicate To fields */
+			if ( !_uri_parse_header_recipients(nlog, field, recipients_r, FALSE) )
+				return FALSE;
+			break;
+		case _HNAME_CC:
+			/* Gracefully allow duplicate Cc fields */
+			if ( !_uri_parse_header_recipients(nlog, field, recipients_r, TRUE) )
+				return FALSE;
+			break;
+		case _HNAME_SUBJECT:
+			if ( subject != NULL ) {
+				/* Igore duplicate subject field */
+				if ( *subject == NULL )
+					*subject = p_strdup(pool, str_c(field));
+				else
+					_uri_parse_warning(nlog, "ignored duplicate subject field");
+			}
+			break;
+		case _HNAME_BODY:
+			if ( body != NULL ) {
+				/* Igore duplicate body field */
+				if ( *body == NULL )
+					*body = p_strdup(pool, str_c(field));
+				else 
+					_uri_parse_warning(nlog, "ignored duplicate body field");
+			}				
+			break;
+		case _HNAME_GENERIC:
+			if ( hdrf != NULL ) 
+				hdrf->body = p_strdup(pool, str_c(field));
+			break;
+		}
+			
+		/* Reset for next name */
+		str_truncate(field, 0);
+	}	
+	
+	/* Skip '&' */
+	if ( *p != '\0' ) p++;
+
+	*uri_p = p;
+	return TRUE;
+}
+
+static bool ntfy_mailto_parse_uri
+(const struct sieve_enotify_log *nlog, const char *uri_body, 
+	ARRAY_TYPE(recipients) *recipients_r, ARRAY_TYPE(headers) *headers_r,
+	const char **body, const char **subject)
+{
+	const char *p = uri_body;
+	
+	/* 
+	 * mailtoURI   = "mailto:" [ to ] [ hfields ]
+	 * to          = [ addr-spec *("%2C" addr-spec ) ]
+	 * hfields     = "?" hfield *( "&" hfield )
+	 * hfield      = hfname "=" hfvalue
+	 * hfname      = *qchar
+	 * hfvalue     = *qchar
+	 * addr-spec   = local-part "@" domain
+	 * local-part  = dot-atom / quoted-string
+	 * qchar       = unreserved / pct-encoded / some-delims
+	 * some-delims = "!" / "$" / "'" / "(" / ")" / "*"
+	 *               / "+" / "," / ";" / ":" / "@"
+	 *
+	 * to         ~= *tqchar
+	 * tqchar     ~= <qchar> without ";" and ":" 
+	 * 
+	 * Scheme 'mailto:' already parsed, starting parse after colon
+	 */
+
+	/* First extract to-part by searching for '?' and decoding % items
+	 */
+
+	if ( !_uri_parse_recipients(nlog, &p, recipients_r) )
+		return FALSE;	
+
+	/* Extract hfield items */	
+	
+	while ( *p != '\0' ) {		
+		/* Extract hfield item by searching for '&' and decoding '%' items */
+		if ( !_uri_parse_headers(nlog, &p, headers_r, recipients_r, body, subject) )
+			return FALSE;		
+	}
+	
+	return TRUE;
+}
+
+/*
+ * Validation
+ */
+
+static bool ntfy_mailto_compile_check_uri
+(const struct sieve_enotify_log *nlog, const char *uri ATTR_UNUSED,
+	const char *uri_body)
+{	
+	ARRAY_TYPE(recipients) recipients;
+	ARRAY_TYPE(headers) headers;
+	const char *body = NULL, *subject = NULL;
+
+	t_array_init(&recipients, NTFY_MAILTO_MAX_RECIPIENTS);
+	t_array_init(&headers, NTFY_MAILTO_MAX_HEADERS);
+	
+	if ( !ntfy_mailto_parse_uri
+		(nlog, uri_body, &recipients, &headers, &body, &subject) )
+		return FALSE;
+		
+	if ( array_count(&recipients) == 0 )
+		sieve_enotify_warning(nlog, "notification URI specifies no recipients");
+	
+	return TRUE;
+}
+
+static bool ntfy_mailto_compile_check_from
+(const struct sieve_enotify_log *nlog, string_t *from)
+{
+	const char *error;
+	bool result = FALSE;
+
+	T_BEGIN {
+		result = sieve_address_validate(from, &error);
+
+		if ( !result ) {
+			sieve_enotify_error(nlog,
+				"specified :from address '%s' is invalid for "
+				"the mailto method: %s",
+				str_sanitize(str_c(from), 128), error);
+		}
+	} T_END;
+
+	return result;
+}
+
+/*
+ * Runtime
+ */
+ 
+static const char *ntfy_mailto_runtime_get_notify_capability
+(const struct sieve_enotify_log *nlog ATTR_UNUSED, const char *uri ATTR_UNUSED, 
+	const char *uri_body, const char *capability)
+{
+	if ( !ntfy_mailto_parse_uri(NULL, uri_body, NULL, NULL, NULL, NULL) ) {
+		return NULL;
+	}
+	
+	if ( strcasecmp(capability, "online") == 0 ) 
+		return "maybe";
+	
+	return NULL;
+}
+
+static bool ntfy_mailto_runtime_check_uri
+(const struct sieve_enotify_log *nlog ATTR_UNUSED, const char *uri ATTR_UNUSED,
+	const char *uri_body)
+{
+	return ntfy_mailto_parse_uri(NULL, uri_body, NULL, NULL, NULL, NULL);
+}
+ 
+static bool ntfy_mailto_runtime_check_operands
+(const struct sieve_enotify_log *nlog, const char *uri ATTR_UNUSED,
+	const char *uri_body, string_t *message ATTR_UNUSED, string_t *from, 
+	pool_t context_pool, void **method_context)
+{
+	struct ntfy_mailto_context *mtctx;
+	const char *error, *normalized;
+
+	/* Need to create context before validation to have arrays present */
+	mtctx = p_new(context_pool, struct ntfy_mailto_context, 1);
+
+	/* Validate :from */
+	if ( from != NULL ) {
+		T_BEGIN {
+			normalized = sieve_address_normalize(from, &error);
+
+			if ( normalized == NULL ) {
+				sieve_enotify_error(nlog,
+					"specified :from address '%s' is invalid for "
+					"the mailto method: %s",
+					str_sanitize(str_c(from), 128), error);
+			} else 
+				mtctx->from_normalized = p_strdup(context_pool, normalized);
+		} T_END;
+
+		if ( !normalized ) return FALSE;
+	}
+
+	p_array_init(&mtctx->recipients, context_pool, NTFY_MAILTO_MAX_RECIPIENTS);
+	p_array_init(&mtctx->headers, context_pool, NTFY_MAILTO_MAX_HEADERS);
+
+	if ( !ntfy_mailto_parse_uri
+		(nlog, uri_body, &mtctx->recipients, &mtctx->headers, &mtctx->body, 
+			&mtctx->subject) ) {
+		return FALSE;
+	}
+
+	*method_context = (void *) mtctx;
+	return TRUE;	
+}
+
+/*
+ * Action duplicates
+ */
+
+static int ntfy_mailto_action_check_duplicates
+(const struct sieve_enotify_log *nlog ATTR_UNUSED, 
+	void *method_ctx1, void *method_ctx2,
+	const char *dupl_location ATTR_UNUSED)
+{
+	struct ntfy_mailto_context *mt_new = 
+		(struct ntfy_mailto_context *) method_ctx1;
+	struct ntfy_mailto_context *mt_old = 
+		(struct ntfy_mailto_context *) method_ctx2;
+	const struct ntfy_mailto_recipient *new_rcpts, *old_rcpts;
+	unsigned int new_count, old_count, i, j;
+	unsigned int del_start = 0, del_len = 0;
+
+	new_rcpts = array_get(&mt_new->recipients, &new_count);
+	old_rcpts = array_get(&mt_old->recipients, &old_count);
+
+	for ( i = 0; i < new_count; i++ ) {
+		for ( j = 0; j < old_count; j++ ) {
+			if ( sieve_address_compare
+				(new_rcpts[i].normalized, old_rcpts[j].normalized, TRUE) == 0 )
+				break;				
+		}
+
+		if ( j == old_count ) {
+			/* Not duplicate */
+			if ( del_len > 0 ) {
+				/* Perform pending deletion */
+				array_delete(&mt_new->recipients, del_start, del_len);
+
+				/* Make sure the loop integrity is maintained */
+				i -= del_len;
+				new_rcpts = array_get(&mt_new->recipients, &new_count);
+			}
+			del_len = 0;		
+		} else {
+			/* Mark deletion */
+			if ( del_len == 0 )
+				del_start = i;
+			del_len++;
+		}
+	}
+
+	/* Perform pending deletion */
+	if ( del_len > 0 ) {
+		array_delete(&mt_new->recipients, del_start, del_len);			
+	}
+
+	return ( array_count(&mt_new->recipients) > 0 ? 0 : 1 );
+}
+
+/*
+ * Action printing
+ */
+ 
+static void ntfy_mailto_action_print
+(const struct sieve_enotify_print_env *penv, 
+	const struct sieve_enotify_action *act)
+{
+	unsigned int count, i;
+	const struct ntfy_mailto_recipient *recipients;
+	const struct ntfy_mailto_header_field *headers;
+	struct ntfy_mailto_context *mtctx = 
+		(struct ntfy_mailto_context *) act->method_context;
+	
+	/* Print main method parameters */
+
+	sieve_enotify_method_printf
+		(penv,   "    => importance   : %d\n", act->importance);
+
+	if ( act->message != NULL )
+		sieve_enotify_method_printf
+			(penv, "    => subject      : %s\n", act->message);
+	else if ( mtctx->subject != NULL )
+		sieve_enotify_method_printf
+			(penv, "    => subject      : %s\n", mtctx->subject);
+
+	if ( act->from != NULL )
+		sieve_enotify_method_printf
+			(penv, "    => from         : %s\n", act->from);
+
+	/* Print mailto: recipients */
+
+	sieve_enotify_method_printf(penv,   "    => recipients   :\n" );
+
+	recipients = array_get(&mtctx->recipients, &count);
+	if ( count == 0 ) {
+		sieve_enotify_method_printf(penv,   "       NONE, action has no effect\n");
+	} else {
+		for ( i = 0; i < count; i++ ) {
+			if ( recipients[i].carbon_copy )
+				sieve_enotify_method_printf
+					(penv,   "       + Cc: %s\n", recipients[i].full);
+			else
+				sieve_enotify_method_printf
+					(penv,   "       + To: %s\n", recipients[i].full);
+		}
+	}
+
+	/* Print accepted headers for notification message */
+	
+	headers = array_get(&mtctx->headers, &count);
+	if ( count > 0 ) {
+		sieve_enotify_method_printf(penv,   "    => headers      :\n" );	
+		for ( i = 0; i < count; i++ ) {
+			sieve_enotify_method_printf(penv,   "       + %s: %s\n", 
+				headers[i].name, headers[i].body);
+		}
+	}
+
+	/* Print body for notification message */
+	
+	if ( mtctx->body != NULL )
+		sieve_enotify_method_printf
+			(penv, "    => body         : \n--\n%s\n--\n", mtctx->body);
+
+	/* Finish output with an empty line */
+
+	sieve_enotify_method_printf(penv,   "\n");
+}
+
+/*
+ * Action execution
+ */
+
+static bool _contains_8bit(const char *msg)
+{
+	const unsigned char *s = (const unsigned char *)msg;
+
+	for (; *s != '\0'; s++) {
+		if ((*s & 0x80) != 0)
+			return TRUE;
+	}
+	
+	return FALSE;
+}
+
+static bool ntfy_mailto_send
+(const struct sieve_enotify_exec_env *nenv, 
+	const struct sieve_enotify_action *act, const char *recipient)
+{ 
+	const struct sieve_enotify_log *nlog = nenv->notify_log;
+	const struct sieve_message_data *msgdata = nenv->msgdata;
+	const struct sieve_script_env *senv = nenv->scriptenv;
+	struct ntfy_mailto_context *mtctx = 
+		(struct ntfy_mailto_context *) act->method_context;	
+	const char *from = NULL, *from_smtp = NULL; 
+	const char *subject = mtctx->subject;
+	const char *body = mtctx->body;
+	string_t *to, *cc;
+	const struct ntfy_mailto_recipient *recipients;
+	void *smtp_handle;
+	unsigned int count, i;
+	FILE *f;
+	const char *outmsgid;
+
+	/* Get recipients */
+	recipients = array_get(&mtctx->recipients, &count);
+	if ( count == 0  ) {
+		sieve_enotify_warning(nlog, 
+			"notify mailto uri specifies no recipients; action has no effect");
+		return TRUE;
+	}
+
+	/* Just to be sure */
+	if ( senv->smtp_open == NULL || senv->smtp_close == NULL ) {
+		sieve_enotify_warning(nlog, 
+			"notify mailto method has no means to send mail");
+		return TRUE;
+	}
+	
+	/* Determine message from address */
+	if ( act->from == NULL ) {
+		from = t_strdup_printf("Postmaster <%s>", senv->postmaster_address);
+	} else {
+		from = act->from;
+	}
+
+	/* Determine SMTP from address */
+	if ( sieve_message_get_sender(nenv->msgctx) != NULL ) {
+		if ( mtctx->from_normalized == NULL ) {
+			from_smtp = senv->postmaster_address;
+		} else {
+			from_smtp = mtctx->from_normalized;
+		}
+	}
+	
+	/* Determine subject */
+	if ( act->message != NULL ) {
+		/* FIXME: handle UTF-8 */
+		subject = str_sanitize(act->message, NTFY_MAILTO_MAX_SUBJECT);
+	} else if ( subject == NULL ) {
+		const char *const *hsubject;
+		
+		/* Fetch subject from original message */
+		if ( mail_get_headers_utf8
+			(msgdata->mail, "subject", &hsubject) >= 0 )
+			subject = str_sanitize(t_strdup_printf("Notification: %s", hsubject[0]), 
+				NTFY_MAILTO_MAX_SUBJECT);
+		else
+			subject = "Notification: (no subject)";
+	}
+
+	/* Compose To and Cc headers */
+	to = NULL;
+	cc = NULL;
+	for ( i = 0; i < count; i++ ) {
+		if ( recipients[i].carbon_copy ) {
+			if ( cc == NULL ) {
+				cc = t_str_new(256);
+				str_append(cc, recipients[i].full);
+			} else {
+				str_append(cc, ", ");
+				str_append(cc, recipients[i].full);
+			}
+		} else {
+			if ( to == NULL ) {
+				to = t_str_new(256);
+				str_append(to, recipients[i].full);
+			} else {
+				str_append(to, ", ");
+				str_append(to, recipients[i].full);
+			}
+		}
+	}
+
+	/* Send message to all recipients */
+	for ( i = 0; i < count; i++ ) {
+		const struct ntfy_mailto_header_field *headers;
+		unsigned int h, hcount;
+
+		smtp_handle = senv->smtp_open(recipients[i].normalized, from_smtp, &f);
+		outmsgid = sieve_message_get_new_id(senv);
+	
+		rfc2822_header_field_write(f, "X-Sieve", SIEVE_IMPLEMENTATION);
+		rfc2822_header_field_write(f, "Message-ID", outmsgid);
+		rfc2822_header_field_write(f, "Date", message_date_create(ioloop_time));
+		rfc2822_header_field_write(f, "Subject", subject);
+
+		rfc2822_header_field_printf(f, "From", "%s", from);
+
+		if ( to != NULL )
+			rfc2822_header_field_printf(f, "To", "%s", str_c(to));
+		
+		if ( cc != NULL )
+			rfc2822_header_field_printf(f, "Cc", "%s", str_c(cc));
+			
+		rfc2822_header_field_printf(f, "Auto-Submitted", 
+			"auto-notified; owner-email=\"%s\"", recipient);
+		rfc2822_header_field_write(f, "Precedence", "bulk");
+
+		/* Set importance */
+		switch ( act->importance ) {
+		case 1:
+			rfc2822_header_field_write(f, "X-Priority", "1 (Highest)");
+			rfc2822_header_field_write(f, "Importance", "High");
+			break;
+		case 3:
+			rfc2822_header_field_write(f, "X-Priority", "5 (Lowest)");
+			rfc2822_header_field_write(f, "Importance", "Low");
+			break;
+		case 2:
+		default:
+			rfc2822_header_field_write(f, "X-Priority", "3 (Normal)");
+			rfc2822_header_field_write(f, "Importance", "Normal");
+			break;
+		}
+		
+		/* Add custom headers */
+		
+		headers = array_get(&mtctx->headers, &hcount);
+		for ( h = 0; h < hcount; h++ ) {
+			const char *name = rfc2822_header_field_name_sanitize(headers[h].name);
+		
+			rfc2822_header_field_write(f, name, headers[h].body);
+		}
+			
+		/* Generate message body */
+		if ( body != NULL ) {
+			if (_contains_8bit(body)) {
+				rfc2822_header_field_write(f, "MIME-Version", "1.0");
+				rfc2822_header_field_write
+					(f, "Content-Type", "text/plain; charset=UTF-8");
+				rfc2822_header_field_write(f, "Content-Transfer-Encoding", "8bit");
+			}
+			
+			fprintf(f, "\r\n");
+			fprintf(f, "%s\r\n", body);
+			
+		} else {
+			fprintf(f, "\r\n");
+			fprintf(f, "Notification of new message.\r\n");
+		}
+	
+		if ( senv->smtp_close(smtp_handle) ) {
+			sieve_enotify_log(nlog, 
+				"sent mail notification to <%s>", 
+				str_sanitize(recipients[i].normalized, 80));
+		} else {
+			sieve_enotify_error(nlog,
+				"failed to send mail notification to <%s> "
+				"(refer to system log for more information)", 
+				str_sanitize(recipients[i].normalized, 80));
+		}
+	}
+
+	return TRUE;
+}
+
+static bool ntfy_mailto_action_execute
+(const struct sieve_enotify_exec_env *nenv, 
+	const struct sieve_enotify_action *act)
+{
+	const char *const *headers;
+	const char *sender = sieve_message_get_sender(nenv->msgctx);
+	const char *recipient = sieve_message_get_recipient(nenv->msgctx);
+
+	/* Is the recipient unset? 
+	 */
+	if ( recipient == NULL ) {
+		sieve_enotify_warning(nenv->notify_log, 
+			"notify mailto action aborted: envelope recipient is <>");
+		return TRUE;
+	}
+	
+	/* Is the message an automatic reply ? */
+	if ( mail_get_headers
+		(nenv->msgdata->mail, "auto-submitted", &headers) >= 0 ) {
+		const char *const *hdsp = headers;
+
+		/* Theoretically multiple headers could exist, so lets make sure */
+		while ( *hdsp != NULL ) {
+			if ( strcasecmp(*hdsp, "no") != 0 ) {
+				sieve_enotify_log(nenv->notify_log, 
+					"not sending notification for auto-submitted message from <%s>", 
+					str_sanitize(sender, 128));	
+					return TRUE;				 
+			}
+			hdsp++;
+		}
+	}
+
+	return ntfy_mailto_send(nenv, act, recipient);
+}
+
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/enotify/sieve-ext-enotify.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/enotify/sieve-ext-enotify.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/enotify/sieve-ext-enotify.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/enotify/sieve-ext-enotify.h	2009-07-21 02:41:22.000000000 +0200
@@ -0,0 +1,139 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_EXT_ENOTIFY_H
+#define __SIEVE_EXT_ENOTIFY_H
+
+#include "lib.h"
+#include "compat.h"
+#include <stdarg.h>
+
+#include "sieve-common.h"
+#include "sieve-error.h"
+
+/*
+ * Forward declarations
+ */
+
+struct sieve_enotify_log;
+struct sieve_enotify_context; 
+struct sieve_enotify_action;
+struct sieve_enotify_print_env;
+struct sieve_enotify_exec_env;
+
+/*
+ * Notify context
+ */
+
+struct sieve_enotify_context {
+	struct sieve_error_handler *ehandler;
+	
+	/* Script location */
+	const struct sieve_script *script;
+	unsigned int source_line;
+
+	const struct sieve_message_data *msgdata;
+	pool_t pool;
+};
+
+/*
+ * Notify methods
+ */ 
+
+struct sieve_enotify_method {
+	const char *identifier;
+	
+	/* Validation */
+	bool (*compile_check_uri)
+		(const struct sieve_enotify_log *nlog, const char *uri,
+			const char *uri_body);
+	bool (*compile_check_message)
+		(const struct sieve_enotify_log *nlog, string_t *message);
+	bool (*compile_check_from)
+		(const struct sieve_enotify_log *nlog, string_t *from);
+	bool (*compile_check_option)
+		(const struct sieve_enotify_log *nlog, const char *option, 
+			const char *value);
+
+	/* Runtime */
+	bool (*runtime_check_uri)
+		(const struct sieve_enotify_log *nlog, const char *uri,
+			const char *uri_body);
+	const char *(*runtime_get_method_capability)
+		(const struct sieve_enotify_log *nlog, const char *uri, 
+			const char *uri_body, const char *capability);
+	bool (*runtime_check_operands)
+		(const struct sieve_enotify_log *nlog, const char *uri, 
+			const char *uri_body, string_t *message, string_t *from, 
+			pool_t context_pool, void **method_context);
+	bool (*runtime_set_option)
+		(const struct sieve_enotify_log *nlog, void *method_context,
+			const char *option, const char *value);
+
+	/* Action duplicates */
+	int (*action_check_duplicates)
+		(const struct sieve_enotify_log *nlog, void *method_ctx1, 
+			void *method_ctx2, const char *dupl_location);
+		
+	/* Action print */
+	void (*action_print)
+		(const struct sieve_enotify_print_env *penv, 
+			const struct sieve_enotify_action *act);	
+			
+	/* Action execution */
+	bool (*action_execute)
+		(const struct sieve_enotify_exec_env *nenv, 
+			const struct sieve_enotify_action *act);
+};
+
+void sieve_enotify_method_register(const struct sieve_enotify_method *method);
+
+/*
+ * Notify method printing
+ */
+
+void sieve_enotify_method_printf
+	(const struct sieve_enotify_print_env *penv, const char *fmt, ...)
+		ATTR_FORMAT(2, 3);
+
+/*
+ * Notify execution environment
+ */
+
+struct sieve_enotify_exec_env {
+	const struct sieve_enotify_log *notify_log;
+
+	const struct sieve_script_env *scriptenv;
+	const struct sieve_message_data *msgdata;
+	struct sieve_message_context *msgctx;
+};
+
+/*
+ * Notify action
+ */
+ 
+struct sieve_enotify_action {
+	const struct sieve_enotify_method *method;
+	void *method_context;
+	
+	sieve_number_t importance;
+	const char *message;
+	const char *from;
+};
+
+/*
+ * Logging
+ */
+
+void sieve_enotify_error
+	(const struct sieve_enotify_log *nlog, const char *fmt, ...) 
+		ATTR_FORMAT(2, 3);
+void sieve_enotify_warning
+	(const struct sieve_enotify_log *nlog, const char *fmt, ...) 
+		ATTR_FORMAT(2, 3);
+void sieve_enotify_log
+	(const struct sieve_enotify_log *nlog, const char *fmt, ...) 
+		ATTR_FORMAT(2, 3);
+
+#endif /* __SIEVE_EXT_ENOTIFY_H */
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/enotify/tst-notify-method-capability.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/enotify/tst-notify-method-capability.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/enotify/tst-notify-method-capability.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/enotify/tst-notify-method-capability.c	2009-07-30 00:45:16.000000000 +0200
@@ -0,0 +1,253 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include <stdio.h>
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+#include "ext-enotify-common.h"
+
+/* 
+ * String test 
+ *
+ * Syntax:
+ *   notify_method_capability [COMPARATOR] [MATCH-TYPE]
+ *     <notification-uri: string>
+ *     <notification-capability: string>
+ *     <key-list: string-list>
+ */
+
+static bool tst_notifymc_registered
+	(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg);
+static bool tst_notifymc_validate
+	(struct sieve_validator *validator, struct sieve_command_context *tst);
+static bool tst_notifymc_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command notify_method_capability_test = { 
+	"notify_method_capability", 
+	SCT_TEST, 
+	3, 0, FALSE, FALSE,
+	tst_notifymc_registered, 
+	NULL,
+	tst_notifymc_validate, 
+	tst_notifymc_generate, 
+	NULL 
+};
+
+/* 
+ * String operation
+ */
+
+static bool tst_notifymc_operation_dump
+	(const struct sieve_operation *op, 
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_notifymc_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation notify_method_capability_operation = { 
+	"NOTIFY_METHOD_CAPABILITY",
+	&enotify_extension, 
+	EXT_ENOTIFY_OPERATION_NOTIFY_METHOD_CAPABILITY, 
+	tst_notifymc_operation_dump, 
+	tst_notifymc_operation_execute 
+};
+
+/* 
+ * Optional arguments 
+ */
+
+enum tst_notifymc_optional {	
+	OPT_END,
+	OPT_COMPARATOR,
+	OPT_MATCH_TYPE
+};
+
+/* 
+ * Test registration 
+ */
+
+static bool tst_notifymc_registered
+	(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg) 
+{
+	/* The order of these is not significant */
+	sieve_comparators_link_tag(validator, cmd_reg, OPT_COMPARATOR);
+	sieve_match_types_link_tags(validator, cmd_reg, OPT_MATCH_TYPE);
+
+	return TRUE;
+}
+
+/* 
+ * Test validation 
+ */
+
+static bool tst_notifymc_validate
+	(struct sieve_validator *validator, struct sieve_command_context *tst) 
+{ 		
+	struct sieve_ast_argument *arg = tst->first_positional;
+	
+	if ( !sieve_validate_positional_argument
+		(validator, tst, arg, "notification-uri", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+	
+	if ( !sieve_validator_argument_activate(validator, tst, arg, FALSE) )
+		return FALSE;
+	
+	arg = sieve_ast_argument_next(arg);
+
+	if ( !sieve_validate_positional_argument
+		(validator, tst, arg, "notification-capability", 2, SAAT_STRING) ) {
+		return FALSE;
+	}
+	
+	if ( !sieve_validator_argument_activate(validator, tst, arg, FALSE) )
+		return FALSE;
+		
+	arg = sieve_ast_argument_next(arg);
+
+	if ( !sieve_validate_positional_argument
+		(validator, tst, arg, "key-list", 3, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+	
+	if ( !sieve_validator_argument_activate(validator, tst, arg, FALSE) )
+		return FALSE;
+
+	/* Validate the key argument to a specified match type */
+	return sieve_match_type_validate
+		(validator, tst, arg, &is_match_type, &i_ascii_casemap_comparator);
+}
+
+/* 
+ * Test generation 
+ */
+
+static bool tst_notifymc_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx) 
+{
+	sieve_operation_emit_code(cgenv->sbin, &notify_method_capability_operation);
+
+ 	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, ctx, NULL);
+}
+
+/* 
+ * Code dump 
+ */
+
+static bool tst_notifymc_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	int opt_code = 0;
+
+	sieve_code_dumpf(denv, "NOTIFY_METHOD_CAPABILITY");
+	sieve_code_descend(denv);
+
+	/* Handle any optional arguments */
+	if ( !sieve_match_dump_optional_operands(denv, address, &opt_code) )
+		return FALSE;
+
+	if ( opt_code != SIEVE_MATCH_OPT_END )
+		return FALSE;
+		
+	return
+		sieve_opr_string_dump(denv, address, "notify uri") &&
+		sieve_opr_string_dump(denv, address, "notify capability") &&
+		sieve_opr_stringlist_dump(denv, address, "key list");
+}
+
+/* 
+ * Code execution 
+ */
+
+static int tst_notifymc_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED, 
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	int ret, mret;
+	bool result = TRUE;
+	int opt_code = 0;
+	const struct sieve_comparator *cmp = &i_octet_comparator;
+	const struct sieve_match_type *mtch = &is_match_type;
+	struct sieve_match_context *mctx;
+	string_t *notify_uri, *notify_capability;
+	struct sieve_coded_stringlist *key_list;
+	const char *cap_value;
+	bool matched;
+
+	/*
+	 * Read operands 
+	 */
+	
+	/* Handle match-type and comparator operands */
+	if ( (ret=sieve_match_read_optional_operands
+		(renv, address, &opt_code, &cmp, &mtch)) <= 0 )
+		return ret;
+	
+	/* Check whether we neatly finished the list of optional operands */
+	if ( opt_code != SIEVE_MATCH_OPT_END) {
+		sieve_runtime_trace_error(renv, "invalid optional operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Read notify uri */
+	if ( !sieve_opr_string_read(renv, address, &notify_uri) ) {
+		sieve_runtime_trace_error(renv, "invalid notify-uri operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/* Read notify capability */
+	if ( !sieve_opr_string_read(renv, address, &notify_capability) ) {
+		sieve_runtime_trace_error(renv, "invalid notify-uri operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/* Read key-list */
+	if ( (key_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid key-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "NOTIFY_METHOD_CAPABILITY test");
+
+	cap_value = ext_enotify_runtime_get_method_capability
+		(renv, 0 /* FIXME */, notify_uri, str_c(notify_capability));
+
+	if ( cap_value != NULL ) {
+		mctx = sieve_match_begin(renv->interp, mtch, cmp, NULL, key_list); 	
+
+		if ( (mret=sieve_match_value(mctx, cap_value, strlen(cap_value))) < 0 )
+			result = FALSE;
+		matched = ( mret > 0 );		
+
+		if ( (mret=sieve_match_end(&mctx)) < 0 ) 
+			result = FALSE;
+		matched = ( mret > 0 ) || matched;		
+	} else {
+		matched = FALSE;
+	}
+	
+	if ( result ) {
+		sieve_interpreter_set_test_result(renv->interp, matched);
+		return SIEVE_EXEC_OK;
+	}
+	
+	sieve_runtime_trace_error(renv, "invalid string list item");
+	return SIEVE_EXEC_BIN_CORRUPT;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/enotify/tst-valid-notify-method.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/enotify/tst-valid-notify-method.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/enotify/tst-valid-notify-method.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/enotify/tst-valid-notify-method.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,148 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+#include "ext-enotify-common.h"
+
+/* 
+ * Valid_notify_method test 
+ *
+ * Syntax:
+ *   valid_notify_method <notification-uris: string-list>
+ */
+
+static bool tst_vnotifym_validate
+	(struct sieve_validator *validator, struct sieve_command_context *tst);
+static bool tst_vnotifym_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command valid_notify_method_test = { 
+	"valid_notify_method", 
+	SCT_TEST, 
+	1, 0, FALSE, FALSE,
+	NULL, NULL,
+	tst_vnotifym_validate, 
+	tst_vnotifym_generate, 
+	NULL 
+};
+
+/* 
+ * Valid_notify_method operation
+ */
+
+static bool tst_vnotifym_operation_dump
+	(const struct sieve_operation *op, 
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_vnotifym_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation valid_notify_method_operation = { 
+	"VALID_NOTIFY_METHOD",
+	&enotify_extension, 
+	EXT_ENOTIFY_OPERATION_VALID_NOTIFY_METHOD, 
+	tst_vnotifym_operation_dump, 
+	tst_vnotifym_operation_execute 
+};
+
+/* 
+ * Test validation 
+ */
+
+static bool tst_vnotifym_validate
+	(struct sieve_validator *validator, struct sieve_command_context *tst) 
+{ 		
+	struct sieve_ast_argument *arg = tst->first_positional;
+	
+	if ( !sieve_validate_positional_argument
+		(validator, tst, arg, "notification-uris", 1, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+	
+	return sieve_validator_argument_activate(validator, tst, arg, FALSE);
+}
+
+/* 
+ * Test generation 
+ */
+
+static bool tst_vnotifym_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx) 
+{
+	sieve_operation_emit_code(cgenv->sbin, &valid_notify_method_operation);
+
+ 	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, ctx, NULL);
+}
+
+/* 
+ * Code dump 
+ */
+
+static bool tst_vnotifym_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	sieve_code_dumpf(denv, "VALID_NOTIFY_METHOD");
+	sieve_code_descend(denv);
+		
+	return
+		sieve_opr_stringlist_dump(denv, address, "notify-uris");
+}
+
+/* 
+ * Code execution 
+ */
+
+static int tst_vnotifym_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED, 
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	struct sieve_coded_stringlist *notify_uris;
+	string_t *uri_item;
+	bool result = TRUE, all_valid = TRUE;
+
+	/*
+	 * Read operands 
+	 */
+	
+	/* Read notify uris */
+	if ( (notify_uris=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid notify-uris operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "VALID_NOTIFY_METHOD test");
+
+	uri_item = NULL;
+	while ( (result=sieve_coded_stringlist_next_item(notify_uris, &uri_item)) 
+		&& uri_item != NULL ) {
+		
+		if ( !ext_enotify_runtime_method_validate(renv, 0 /* FIXME */, uri_item) ) {
+			all_valid = FALSE;
+			break;
+		}
+	}
+	
+	if ( !result ) {
+		sieve_runtime_trace_error(renv, "invalid method uri item");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	sieve_interpreter_set_test_result(renv->interp, all_valid);
+	return SIEVE_EXEC_OK;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/enotify/vmodf-encodeurl.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/enotify/vmodf-encodeurl.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/enotify/vmodf-encodeurl.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/enotify/vmodf-encodeurl.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,84 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+
+#include "sieve-common.h"
+#include "sieve-code.h"
+
+#include "sieve-ext-variables.h"
+
+#include "ext-enotify-common.h"
+
+/*
+ * Encodeurl modifier
+ */
+ 
+bool mod_encodeurl_modify(string_t *in, string_t **result);
+ 
+const struct sieve_variables_modifier encodeurl_modifier = {
+	SIEVE_OBJECT("encodeurl", &encodeurl_operand, 0),
+	15,
+	mod_encodeurl_modify
+};
+ 
+/*
+ * Modifier operand
+ */
+
+static const struct sieve_extension_objects ext_enotify_modifiers =
+	SIEVE_VARIABLES_DEFINE_MODIFIER(encodeurl_modifier);
+
+const struct sieve_operand encodeurl_operand = { 
+	"modifier", 
+	&enotify_extension,
+	0, 
+	&sieve_variables_modifier_operand_class,
+	&ext_enotify_modifiers
+};
+
+/*
+ * Modifier implementation
+ */
+
+static const char _uri_reserved_lookup[256] = {
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 00
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 10
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1,  // 20
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,  // 30
+	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 40
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,  // 50
+	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 60
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1,  // 70
+
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 80
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 90
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // A0
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // B0
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // C0
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // D0
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // E0
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // F0
+};
+
+bool mod_encodeurl_modify(string_t *in, string_t **result)
+{	
+	unsigned int i;
+	const unsigned char *c;
+
+	*result = t_str_new(2*str_len(in));
+	c = str_data(in);
+	
+	for ( i = 0; i < str_len(in); i++, c++ ) {
+		if ( _uri_reserved_lookup[*c] ) {
+			str_printfa(*result, "%%%02X", *c);
+		} else {
+			str_append_c(*result, *c); 
+		}	
+	}
+
+	return TRUE;
+}
+ 
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/environment/ext-environment.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/environment/ext-environment.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/environment/ext-environment.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/environment/ext-environment.c	2009-04-13 21:35:39.000000000 +0200
@@ -0,0 +1,53 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension variables 
+ * -------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: RFC 5183
+ * Implementation: full
+ * Status: experimental, not thoroughly tested
+ *
+ */
+ 
+#include "lib.h"
+#include "str.h"
+#include "unichar.h"
+
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-binary.h"
+#include "sieve-interpreter.h"
+
+#include "sieve-validator.h"
+
+#include "ext-environment-common.h"
+
+/* 
+ * Extension 
+ */
+
+static bool ext_environment_validator_load(struct sieve_validator *validator);
+
+static int ext_my_id = -1;
+	
+const struct sieve_extension environment_extension = { 
+	"environment", 
+	&ext_my_id,
+	ext_environment_init, 
+	ext_environment_deinit,
+	ext_environment_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATION(tst_environment_operation), 
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+static bool ext_environment_validator_load
+	(struct sieve_validator *validator)
+{
+	sieve_validator_register_command(validator, &tst_environment);
+	
+	return TRUE;
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/environment/ext-environment-common.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/environment/ext-environment-common.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/environment/ext-environment-common.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/environment/ext-environment-common.c	2009-04-13 23:17:15.000000000 +0200
@@ -0,0 +1,168 @@
+#include "lib.h"
+#include "hash.h"
+
+#include "ext-environment-common.h"
+
+static struct hash_table *environment_items;
+
+/*
+ * Core environment items
+ */
+
+static const struct sieve_environment_item *core_env_items[] = {
+	&domain_env_item, 
+	&host_env_item, 
+	&location_env_item, 
+	&phase_env_item, 
+	&name_env_item, 
+	&version_env_item
+};
+
+static unsigned int core_env_items_count = N_ELEMENTS(core_env_items);
+
+/*
+ * Initialization
+ */
+
+bool ext_environment_init(void) 
+{
+	unsigned int i;
+
+	environment_items = hash_table_create
+		(default_pool, default_pool, 0, str_hash, (hash_cmp_callback_t *)strcmp);
+
+	for ( i = 0; i < core_env_items_count; i++ ) {
+		sieve_ext_environment_item_register(core_env_items[i]);
+	}
+
+	return TRUE;
+}
+
+void ext_environment_deinit(void)
+{
+	hash_table_destroy(&environment_items);
+}
+
+/*
+ * Registration
+ */
+
+void sieve_ext_environment_item_register
+(const struct sieve_environment_item *item)
+{
+	hash_table_insert
+		(environment_items, (void *) item->name, (void *) item);
+}
+
+/*
+ * Retrieval
+ */
+
+const char *ext_environment_item_get_value
+(const char *name, const struct sieve_script_env *senv)
+{
+	const struct sieve_environment_item *item = 
+		(const struct sieve_environment_item *) 
+			hash_table_lookup(environment_items, name);
+
+	if ( item == NULL )
+		return NULL;
+
+	if ( item->value != NULL )
+		return item->value;
+
+	if ( item->get_value != NULL ) 
+		return item->get_value(senv);
+
+	return NULL; 
+}
+
+/*
+ * Default environment items
+ */
+
+/* "domain":
+ *
+ *   The primary DNS domain associated with the Sieve execution context, usually 
+ *   but not always a proper suffix of the host name.
+ */
+const struct sieve_environment_item domain_env_item = {
+	"domain",
+	NULL,
+	NULL,
+};
+
+/* "host":
+ *
+ *   The fully-qualified domain name of the host where the Sieve script is 
+ *   executing.
+ */
+
+static const char *envit_host_get_value(const struct sieve_script_env *senv)
+{
+	return senv->hostname != NULL ? senv->hostname : "";
+}
+
+const struct sieve_environment_item host_env_item = {
+	"host",
+	NULL,
+	envit_host_get_value,
+};
+
+/* "location":
+ *
+ *   Sieve evaluation can be performed at various different points as messages 
+ *   are processed. This item provides additional information about the type of
+ *   service that is evaluating the script.  Possible values are:
+ *    "MTA" - the Sieve script is being evaluated by a Message Transfer Agent 
+ *    "MDA" - evaluation is being performed by a Mail Delivery Agent 
+ *    "MUA" - evaluation is being performed by a Mail User Agent
+ *    "MS"  - evaluation is being performed by a Message Store
+ */
+const struct sieve_environment_item location_env_item = {
+	"location",
+	NULL,
+	NULL,
+};
+
+/* "phase":
+ *
+ *   The point relative to final delivery where the Sieve script is being
+ *   evaluated.  Possible values are "pre", "during", and "post", referring 
+ *   respectively to processing before, during, and after final delivery has 
+ *   taken place.
+ */
+
+const struct sieve_environment_item phase_env_item = {
+	"phase",
+	NULL,
+	NULL,
+};
+
+/* "name":
+ *
+ *  The product name associated with the Sieve interpreter.
+ */
+const struct sieve_environment_item name_env_item = {
+	"name",
+	SIEVE_NAME,
+	NULL,
+};
+
+/* "version":
+ *
+ * The product version associated with the Sieve interpreter. The meaning of the 
+ * product version string is product-specific and should always be considered
+ * in the context of the product name given by the "name" item.
+ */
+
+const struct sieve_environment_item version_env_item = {
+	"version",
+	SIEVE_VERSION,
+	NULL,
+};
+
+
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/environment/ext-environment-common.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/environment/ext-environment-common.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/environment/ext-environment-common.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/environment/ext-environment-common.h	2009-04-13 21:35:39.000000000 +0200
@@ -0,0 +1,54 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_ENVIRONMENT_COMMON_H
+#define __EXT_ENVIRONMENT_COMMON_H
+
+#include "sieve-common.h"
+
+#include "sieve-ext-environment.h"
+
+/*
+ * Extension
+ */
+
+extern const struct sieve_extension environment_extension;
+
+/* 
+ * Commands 
+ */
+
+extern const struct sieve_command tst_environment;
+
+/*
+ * Operations
+ */
+
+extern const struct sieve_operation tst_environment_operation;
+
+/*
+ * Environment items
+ */
+
+extern const struct sieve_environment_item domain_env_item;
+extern const struct sieve_environment_item host_env_item;
+extern const struct sieve_environment_item location_env_item;
+extern const struct sieve_environment_item phase_env_item;
+extern const struct sieve_environment_item name_env_item;
+extern const struct sieve_environment_item version_env_item;
+
+/*
+ * Initialization
+ */
+
+bool ext_environment_init(void);
+void ext_environment_deinit(void);
+
+/*
+ * Environment item retrieval
+ */
+
+const char *ext_environment_item_get_value
+	(const char *name, const struct sieve_script_env *senv);
+
+#endif /* __EXT_VARIABLES_COMMON_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/environment/Makefile.am dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/environment/Makefile.am
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/environment/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/environment/Makefile.am	2009-04-13 21:35:39.000000000 +0200
@@ -0,0 +1,20 @@
+noinst_LTLIBRARIES = libsieve_ext_environment.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+tests = \
+	tst-environment.c
+
+libsieve_ext_environment_la_SOURCES = \
+	$(tests) \
+	ext-environment-common.c \
+	ext-environment.c
+
+noinst_HEADERS = \
+	ext-environment-common.h \
+	sieve-ext-environment.h
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/environment/Makefile.in dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/environment/Makefile.in
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/environment/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/environment/Makefile.in	2009-08-21 00:55:43.000000000 +0200
@@ -0,0 +1,470 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve/plugins/environment
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libsieve_ext_environment_la_LIBADD =
+am__objects_1 = tst-environment.lo
+am_libsieve_ext_environment_la_OBJECTS = $(am__objects_1) \
+	ext-environment-common.lo ext-environment.lo
+libsieve_ext_environment_la_OBJECTS =  \
+	$(am_libsieve_ext_environment_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_ext_environment_la_SOURCES)
+DIST_SOURCES = $(libsieve_ext_environment_la_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LTLIBRARIES = libsieve_ext_environment.la
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+tests = \
+	tst-environment.c
+
+libsieve_ext_environment_la_SOURCES = \
+	$(tests) \
+	ext-environment-common.c \
+	ext-environment.c
+
+noinst_HEADERS = \
+	ext-environment-common.h \
+	sieve-ext-environment.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/lib-sieve/plugins/environment/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  src/lib-sieve/plugins/environment/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve_ext_environment.la: $(libsieve_ext_environment_la_OBJECTS) $(libsieve_ext_environment_la_DEPENDENCIES) 
+	$(LINK)  $(libsieve_ext_environment_la_OBJECTS) $(libsieve_ext_environment_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-environment-common.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-environment.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-environment.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/environment/sieve-ext-environment.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/environment/sieve-ext-environment.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/environment/sieve-ext-environment.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/environment/sieve-ext-environment.h	2009-04-13 21:35:39.000000000 +0200
@@ -0,0 +1,16 @@
+#ifndef __SIEVE_EXT_ENVIRONMENT_H
+#define __SIEVE_EXT_ENVIRONMENT_H
+
+#include "sieve-common.h"
+
+struct sieve_environment_item {
+	const char *name;
+	
+	const char *value;
+	const char *(*get_value)(const struct sieve_script_env *senv);
+};
+
+void sieve_ext_environment_item_register
+	(const struct sieve_environment_item *item);
+
+#endif
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/environment/tst-environment.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/environment/tst-environment.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/environment/tst-environment.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/environment/tst-environment.c	2009-07-30 00:44:32.000000000 +0200
@@ -0,0 +1,226 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+#include "ext-environment-common.h"
+
+/* 
+ * Environment test 
+ *
+ * Syntax:
+ *   environment [COMPARATOR] [MATCH-TYPE]
+ *      <name: string> <key-list: string-list>
+ */
+
+static bool tst_environment_registered
+	(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg);
+static bool tst_environment_validate
+	(struct sieve_validator *validator, struct sieve_command_context *tst);
+static bool tst_environment_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command tst_environment = { 
+	"environment", 
+	SCT_TEST, 
+	2, 0, FALSE, FALSE,
+	tst_environment_registered, 
+	NULL,
+	tst_environment_validate, 
+	tst_environment_generate, 
+	NULL 
+};
+
+/* 
+ * Environment operation
+ */
+
+static bool tst_environment_operation_dump
+	(const struct sieve_operation *op, 
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_environment_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation tst_environment_operation = { 
+	"ENVIRONMENT",
+	&environment_extension, 
+	0, 
+	tst_environment_operation_dump, 
+	tst_environment_operation_execute 
+};
+
+/* 
+ * Test registration 
+ */
+
+static bool tst_environment_registered
+	(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg) 
+{
+	/* The order of these is not significant */
+	sieve_comparators_link_tag(validator, cmd_reg, SIEVE_MATCH_OPT_COMPARATOR);
+	sieve_match_types_link_tags(validator, cmd_reg, SIEVE_MATCH_OPT_MATCH_TYPE);
+
+	return TRUE;
+}
+
+/* 
+ * Test validation 
+ */
+
+static bool tst_environment_validate
+	(struct sieve_validator *validator, struct sieve_command_context *tst) 
+{ 		
+	struct sieve_ast_argument *arg = tst->first_positional;
+	
+	if ( !sieve_validate_positional_argument
+		(validator, tst, arg, "name", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+	
+	if ( !sieve_validator_argument_activate(validator, tst, arg, FALSE) )
+		return FALSE;
+	
+	arg = sieve_ast_argument_next(arg);
+
+	if ( !sieve_validate_positional_argument
+		(validator, tst, arg, "key list", 2, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+	
+	if ( !sieve_validator_argument_activate(validator, tst, arg, FALSE) )
+		return FALSE;
+
+	/* Validate the key argument to a specified match type */
+	return sieve_match_type_validate
+		(validator, tst, arg, &is_match_type, &i_octet_comparator);
+}
+
+/* 
+ * Test generation 
+ */
+
+static bool tst_environment_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx) 
+{
+	sieve_operation_emit_code(cgenv->sbin, &tst_environment_operation);
+
+ 	/* Generate arguments */
+	if ( !sieve_generate_arguments(cgenv, ctx, NULL) )
+		return FALSE;
+	
+	return TRUE;
+}
+
+/* 
+ * Code dump 
+ */
+
+static bool tst_environment_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	int opt_code = 0;
+
+	sieve_code_dumpf(denv, "ENVIRONMENT");
+	sieve_code_descend(denv);
+
+	/* Handle any optional arguments */
+	if ( !sieve_match_dump_optional_operands(denv, address, &opt_code) )
+		return FALSE;
+
+	if ( opt_code != SIEVE_MATCH_OPT_END )
+		return FALSE;
+		
+	return
+		sieve_opr_string_dump(denv, address, "name") &&
+		sieve_opr_stringlist_dump(denv, address, "key list");
+}
+
+/* 
+ * Code execution 
+ */
+
+static int tst_environment_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED, 
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	int ret, mret;
+	bool result = TRUE;
+	int opt_code = 0;
+	const struct sieve_comparator *cmp = &i_ascii_casemap_comparator;
+	const struct sieve_match_type *mtch = &is_match_type;
+	struct sieve_match_context *mctx;
+	string_t *name;
+	struct sieve_coded_stringlist *key_list;
+	const char *env_item;
+	bool matched = FALSE;
+
+	/*
+	 * Read operands 
+	 */
+	
+	/* Handle match-type and comparator operands */
+	if ( (ret=sieve_match_read_optional_operands
+		(renv, address, &opt_code, &cmp, &mtch)) <= 0 )
+		return ret;
+	
+	/* Check whether we neatly finished the list of optional operands*/
+	if ( opt_code != SIEVE_MATCH_OPT_END) {
+		sieve_runtime_trace_error(renv, "invalid optional operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Read source */
+	if ( !sieve_opr_string_read(renv, address, &name) ) {
+		sieve_runtime_trace_error(renv, "invalid name operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/* Read key-list */
+	if ( (key_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid key-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "ENVIRONMENT test");
+
+	env_item = ext_environment_item_get_value(str_c(name), renv->scriptenv);
+
+	if ( env_item != NULL ) {
+		mctx = sieve_match_begin(renv->interp, mtch, cmp, NULL, key_list); 	
+
+		if ( (mret=sieve_match_value(mctx, strlen(env_item) == 0 ? NULL : env_item, 
+			strlen(env_item))) < 0 ) {
+			result = FALSE;
+		} else {
+			matched = ( mret > 0 );				
+		}
+
+		if ( (mret=sieve_match_end(&mctx)) < 0 )
+			result = FALSE;
+		else
+			matched = ( mret > 0 || matched );
+	}
+	
+	if ( result ) {
+		sieve_interpreter_set_test_result(renv->interp, matched);
+		return SIEVE_EXEC_OK;
+	}
+	
+	sieve_runtime_trace_error(renv, "invalid key list item");
+	return SIEVE_EXEC_BIN_CORRUPT;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/cmd-flag.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/cmd-flag.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/cmd-flag.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/cmd-flag.c	2009-08-05 11:49:11.000000000 +0200
@@ -0,0 +1,268 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+
+#include "sieve-code.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h" 
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "ext-imap4flags-common.h"
+
+/*
+ * Commands
+ */
+
+/* Forward declarations */
+
+static bool cmd_flag_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+/* Setflag command 
+ *
+ * Syntax: 
+ *   setflag [<variablename: string>] <list-of-flags: string-list>
+ */
+ 
+const struct sieve_command cmd_setflag = { 
+	"setflag", 
+	SCT_COMMAND,
+	-1, /* We check positional arguments ourselves */
+	0, FALSE, FALSE, 
+	NULL, NULL,
+	ext_imap4flags_command_validate, 
+	cmd_flag_generate, 
+	NULL 
+};
+
+/* Addflag command 
+ *
+ * Syntax:
+ *   addflag [<variablename: string>] <list-of-flags: string-list>
+ */
+
+const struct sieve_command cmd_addflag = { 
+	"addflag", 
+	SCT_COMMAND,
+	-1, /* We check positional arguments ourselves */
+	0, FALSE, FALSE, 
+	NULL, NULL,
+	ext_imap4flags_command_validate, 
+	cmd_flag_generate, 
+	NULL 
+};
+
+
+/* Removeflag command 
+ *
+ * Syntax:
+ *   removeflag [<variablename: string>] <list-of-flags: string-list>
+ */
+
+const struct sieve_command cmd_removeflag = { 
+	"removeflag", 
+	SCT_COMMAND,
+	-1, /* We check positional arguments ourselves */
+	0, FALSE, FALSE, 
+	NULL, NULL,
+	ext_imap4flags_command_validate, 
+	cmd_flag_generate, 
+	NULL 
+};
+
+/*
+ * Operations
+ */
+
+/* Forward declarations */
+
+bool cmd_flag_operation_dump
+	(const struct sieve_operation *op,
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_flag_operation_execute
+	(const struct sieve_operation *op,	
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+/* Setflag operation */
+
+const struct sieve_operation setflag_operation = { 
+	"SETFLAG",
+	&imap4flags_extension,
+	ext_imap4flags_OPERATION_SETFLAG,
+	cmd_flag_operation_dump,
+	cmd_flag_operation_execute
+};
+
+/* Addflag operation */
+
+const struct sieve_operation addflag_operation = { 
+	"ADDFLAG",
+	&imap4flags_extension,
+	ext_imap4flags_OPERATION_ADDFLAG,
+	cmd_flag_operation_dump,	
+	cmd_flag_operation_execute
+};
+
+/* Removeflag operation */
+
+const struct sieve_operation removeflag_operation = { 
+	"REMOVEFLAG",
+	&imap4flags_extension,
+	ext_imap4flags_OPERATION_REMOVEFLAG,
+	cmd_flag_operation_dump, 
+	cmd_flag_operation_execute 
+};
+
+/* 
+ * Code generation 
+ */
+
+static bool cmd_flag_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx)
+{
+	const struct sieve_command *command = ctx->command;
+
+	/* Emit operation */
+	if ( command == &cmd_setflag ) 
+		sieve_operation_emit_code(cgenv->sbin, &setflag_operation);
+	else if ( command == &cmd_addflag ) 
+		sieve_operation_emit_code(cgenv->sbin, &addflag_operation);
+	else if ( command == &cmd_removeflag ) 
+		sieve_operation_emit_code(cgenv->sbin, &removeflag_operation);
+
+	/* Generate arguments */
+	if ( !sieve_generate_arguments(cgenv, ctx, NULL) )
+		return FALSE;	
+
+	return TRUE;
+}
+
+/*
+ * Code dump
+ */
+
+bool cmd_flag_operation_dump
+(const struct sieve_operation *op,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	const struct sieve_operand *operand;
+
+	sieve_code_dumpf(denv, "%s", op->mnemonic);
+	sieve_code_descend(denv);
+	
+	sieve_code_mark(denv);
+	operand = sieve_operand_read(denv->sbin, address);
+	if ( operand == NULL ) {
+		sieve_code_dumpf(denv, "ERROR: INVALID OPERAND");
+		return FALSE;
+	}
+
+	if ( sieve_operand_is_variable(operand) ) {	
+		return 
+			sieve_opr_string_dump_data(denv, operand, address, 
+				"variable name") &&
+			sieve_opr_stringlist_dump(denv, address, 
+				"list of flags");
+	}
+	
+	return 
+		sieve_opr_stringlist_dump_data(denv, operand, address,
+			"list of flags");
+}
+ 
+/*
+ * Code execution
+ */
+
+static int cmd_flag_operation_execute
+(const struct sieve_operation *op,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	const struct sieve_operand *operand;
+	sieve_size_t op_address = *address;
+	bool result = TRUE;
+	string_t *flag_item;
+	struct sieve_coded_stringlist *flag_list;
+	struct sieve_variable_storage *storage;
+	unsigned int var_index;
+	ext_imapflag_flag_operation_t flag_op;
+	int ret;
+		
+	/* 
+	 * Read operands 
+	 */
+
+	operand = sieve_operand_read(renv->sbin, address);
+	if ( operand == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+		
+	if ( sieve_operand_is_variable(operand) ) {		
+
+		/* Read the variable operand */
+		if ( !sieve_variable_operand_read_data
+			(renv, operand, address, &storage, &var_index) ) {
+			sieve_runtime_trace_error(renv, "invalid variable operand");
+			return SIEVE_EXEC_BIN_CORRUPT;
+		}
+		
+		/* Read flag list */
+		if ( (flag_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+			sieve_runtime_trace_error(renv, "invalid flag-list operand");
+			return SIEVE_EXEC_BIN_CORRUPT;
+		}
+
+	} else if ( sieve_operand_is_stringlist(operand) ) {	
+		storage = NULL;
+		var_index = 0;
+		
+		/* Read flag list */
+		if ( (flag_list=sieve_opr_stringlist_read_data
+			(renv, operand, op_address, address)) == NULL ) {
+			sieve_runtime_trace_error(renv, "invalid flag-list operand");
+			return SIEVE_EXEC_BIN_CORRUPT;
+		}
+
+	} else {
+		sieve_runtime_trace_error(renv, "unexpected operand '%s'", 
+			operand->name);
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/*
+	 * Perform operation
+	 */	
+	
+	sieve_runtime_trace(renv, "%s command", op->mnemonic);
+
+	/* Determine what to do */
+
+	if ( op == &setflag_operation )
+		flag_op = ext_imap4flags_set_flags;
+	else if ( op == &addflag_operation )
+		flag_op = ext_imap4flags_add_flags;
+	else if ( op == &removeflag_operation )
+		flag_op = ext_imap4flags_remove_flags;
+	else
+		i_unreached();
+
+	/* Iterate through all flags and perform requested operation */
+	
+	while ( (result=sieve_coded_stringlist_next_item(flag_list, &flag_item)) && 
+		flag_item != NULL ) {
+
+		if ( (ret=flag_op(renv, storage, var_index, flag_item)) <= 0)
+			return ret;
+	}
+
+	if ( !result ) {	
+		sieve_runtime_trace_error(renv, "invalid flag-list item");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	return SIEVE_EXEC_OK;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/ext-imap4flags.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/ext-imap4flags.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/ext-imap4flags.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/ext-imap4flags.c	2009-02-04 20:23:16.000000000 +0100
@@ -0,0 +1,88 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension imap4flags
+ * --------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: RFC 5232
+ * Implementation: full 
+ * Status: experimental, roughly tested
+ *
+ */
+ 
+#include "lib.h"
+#include "mempool.h"
+#include "str.h"
+
+#include "sieve-common.h"
+
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-actions.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+
+#include "ext-imap4flags-common.h"
+
+/* 
+ * Operations 
+ */
+
+const struct sieve_operation *imap4flags_operations[] = { 
+	&setflag_operation, 
+	&addflag_operation, 
+	&removeflag_operation,
+	&hasflag_operation 
+};
+
+/* 
+ * Extension
+ */
+
+static bool ext_imap4flags_validator_load(struct sieve_validator *valdtr);
+static bool ext_imap4flags_interpreter_load
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+int ext_imap4flags_my_id = -1;
+
+const struct sieve_extension imap4flags_extension = { 
+	"imap4flags", 
+	&ext_imap4flags_my_id,
+	NULL, NULL,
+	ext_imap4flags_validator_load, 
+	NULL, 
+	ext_imap4flags_interpreter_load, 
+	NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATIONS(imap4flags_operations), 
+	SIEVE_EXT_DEFINE_OPERAND(flags_side_effect_operand)
+};
+
+static bool ext_imap4flags_validator_load
+(struct sieve_validator *valdtr)
+{
+	/* Register commands */
+	sieve_validator_register_command(valdtr, &cmd_setflag);
+	sieve_validator_register_command(valdtr, &cmd_addflag);
+	sieve_validator_register_command(valdtr, &cmd_removeflag);
+	sieve_validator_register_command(valdtr, &tst_hasflag);
+	
+	ext_imap4flags_attach_flags_tag(valdtr, "keep");
+	ext_imap4flags_attach_flags_tag(valdtr, "fileinto");
+
+	return TRUE;
+}
+
+static bool ext_imap4flags_interpreter_load
+(const struct sieve_runtime_env *renv, sieve_size_t *address ATTR_UNUSED)
+{
+	sieve_interpreter_extension_register
+        (renv->interp, &imap4flags_interpreter_extension, NULL);
+
+	return TRUE;
+}
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/ext-imap4flags-common.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/ext-imap4flags-common.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/ext-imap4flags-common.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/ext-imap4flags-common.c	2009-08-05 12:41:48.000000000 +0200
@@ -0,0 +1,521 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "str-sanitize.h"
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-actions.h"
+#include "sieve-validator.h" 
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-result.h"
+#include "sieve-dump.h"
+
+#include "sieve-ext-variables.h"
+
+#include "ext-imap4flags-common.h"
+
+/*
+ * Forward declarations
+ */
+
+static bool flag_is_valid(const char *flag);
+
+/* 
+ * Tagged arguments 
+ */
+
+extern const struct sieve_argument tag_flags;
+extern const struct sieve_argument tag_flags_implicit;
+
+/* 
+ * Common command functions 
+ */
+
+bool ext_imap4flags_command_validate
+(struct sieve_validator *validator, struct sieve_command_context *cmd)
+{
+	struct sieve_ast_argument *arg = cmd->first_positional;
+	struct sieve_ast_argument *arg2;
+	
+	/* Check arguments */
+	
+	if ( arg == NULL ) {
+		sieve_command_validate_error(validator, cmd, 
+			"the %s %s expects at least one argument, but none was found", 
+			cmd->command->identifier, sieve_command_type_name(cmd->command));
+		return FALSE;
+	}
+	
+	if ( sieve_ast_argument_type(arg) != SAAT_STRING && 
+		sieve_ast_argument_type(arg) != SAAT_STRING_LIST ) 
+	{
+		sieve_argument_validate_error(validator, arg, 
+			"the %s %s expects either a string (variable name) or "
+			"a string-list (list of flags) as first argument, but %s was found", 
+			cmd->command->identifier, sieve_command_type_name(cmd->command),
+			sieve_ast_argument_name(arg));
+		return FALSE; 
+	}
+
+	arg2 = sieve_ast_argument_next(arg);
+	if ( arg2 != NULL ) {		
+		/* First, check syntax sanity */
+				
+		if ( sieve_ast_argument_type(arg) != SAAT_STRING ) 
+		{
+			if ( cmd->command == &tst_hasflag ) {
+				if ( sieve_ast_argument_type(arg) != SAAT_STRING_LIST ) {
+					sieve_argument_validate_error(validator, arg, 
+						"if a second argument is specified for the hasflag, the first "
+						"must be a string-list (variable-list), but %s was found",
+						sieve_ast_argument_name(arg));
+					return FALSE;
+				}
+			} else {
+				sieve_argument_validate_error(validator, arg, 
+					"if a second argument is specified for the %s %s, the first "
+					"must be a string (variable name), but %s was found",
+					cmd->command->identifier, sieve_command_type_name(cmd->command), 
+					sieve_ast_argument_name(arg));
+				return FALSE; 
+			}
+		}
+		
+		/* Then, check whether the second argument is permitted */
+		
+		if ( !sieve_ext_variables_is_active(validator) )	{
+			sieve_argument_validate_error(validator,arg, 
+				"the %s %s only allows for the specification of a "
+				"variable name when the variables extension is active",
+				cmd->command->identifier, sieve_command_type_name(cmd->command));
+			return FALSE;
+		}		
+		
+		if ( !sieve_variable_argument_activate(validator, cmd, arg, 
+			cmd->command != &tst_hasflag ) )
+			return FALSE;
+		
+		if ( sieve_ast_argument_type(arg2) != SAAT_STRING && 
+			sieve_ast_argument_type(arg2) != SAAT_STRING_LIST ) 
+		{
+			sieve_argument_validate_error(validator, arg2, 
+				"the %s %s expects a string list (list of flags) as "
+				"second argument when two arguments are specified, "
+				"but %s was found",
+				cmd->command->identifier, sieve_command_type_name(cmd->command),
+				sieve_ast_argument_name(arg2));
+			return FALSE; 
+		}
+	} else
+		arg2 = arg;
+
+	if ( !sieve_validator_argument_activate(validator, cmd, arg2, FALSE) )
+		return FALSE;
+
+	if ( cmd->command != &tst_hasflag && sieve_argument_is_string_literal(arg2) ) {
+		struct ext_imap4flags_iter fiter;
+		const char *flag;
+		
+		/* Warn the user about validity of verifiable flags */
+		ext_imap4flags_iter_init(&fiter, sieve_ast_argument_str(arg));
+
+		while ( (flag=ext_imap4flags_iter_get_flag(&fiter)) != NULL ) {
+			if ( !flag_is_valid(flag) ) {
+				sieve_argument_validate_warning(validator, arg,
+                	"IMAP flag '%s' specified for the %s command is invalid "
+					"and will be ignored (only first invalid is reported)",					
+					str_sanitize(flag, 64), cmd->command->identifier);
+				break;
+			}
+		}
+	}
+
+	return TRUE;
+}
+
+/* 
+ * Flags tag registration 
+ */
+
+void ext_imap4flags_attach_flags_tag
+(struct sieve_validator *valdtr, const char *command)
+{
+	/* Register :flags tag with the command and we don't care whether it is 
+	 * registered or even whether it will be registered at all. The validator 
+	 * handles either situation gracefully 
+	 */
+	 
+	/* Tag specified by user */
+	sieve_validator_register_external_tag
+		(valdtr, &tag_flags, command, SIEVE_OPT_SIDE_EFFECT);
+
+    /* Implicit tag if none is specified */
+	sieve_validator_register_persistent_tag
+		(valdtr, &tag_flags_implicit, command);
+}
+
+/* 
+ * Result context 
+ */
+
+struct ext_imap4flags_result_context {
+    string_t *internal_flags;
+};
+
+static void _get_initial_flags
+(struct sieve_result *result, string_t *flags)
+{
+	const struct sieve_message_data *msgdata = 
+		sieve_result_get_message_data(result);
+	enum mail_flags mail_flags;
+	const char *const *mail_keywords;
+
+	mail_flags = mail_get_flags(msgdata->mail);
+	mail_keywords = mail_get_keywords(msgdata->mail);	
+
+	if ( (mail_flags & MAIL_FLAGGED) > 0 )
+		str_printfa(flags, " \\flagged");
+
+	if ( (mail_flags & MAIL_ANSWERED) > 0 )
+		str_printfa(flags, " \\answered");
+
+	if ( (mail_flags & MAIL_DELETED) > 0 )
+		str_printfa(flags, " \\deleted");
+
+	if ( (mail_flags & MAIL_SEEN) > 0 )
+		str_printfa(flags, " \\seen");
+
+	if ( (mail_flags & MAIL_DRAFT) > 0 )
+		str_printfa(flags, " \\draft");
+
+	while ( *mail_keywords != NULL ) {
+		str_printfa(flags, " %s", *mail_keywords);
+		mail_keywords++;
+	}	
+}
+
+static inline struct ext_imap4flags_result_context *_get_result_context
+(struct sieve_result *result)
+{
+	struct ext_imap4flags_result_context *rctx =
+		(struct ext_imap4flags_result_context *) 
+		sieve_result_extension_get_context(result, &imap4flags_extension);
+
+	if ( rctx == NULL ) {
+		pool_t pool = sieve_result_pool(result);
+
+		rctx =p_new(pool, struct ext_imap4flags_result_context, 1);
+		rctx->internal_flags = str_new(pool, 32);
+		_get_initial_flags(result, rctx->internal_flags);
+
+		sieve_result_extension_set_context
+			(result, &imap4flags_extension, rctx);
+	}
+
+	return rctx;
+}
+
+static string_t *_get_flags_string
+(struct sieve_result *result)
+{
+	struct ext_imap4flags_result_context *ctx = 
+		_get_result_context(result);
+		
+	return ctx->internal_flags;
+}
+
+/* 
+ * Runtime initialization 
+ */
+
+static void ext_imap4flags_runtime_init
+(const struct sieve_runtime_env *renv, void *context ATTR_UNUSED)
+{	
+	sieve_result_add_implicit_side_effect
+		(renv->result, &act_store, &flags_side_effect, NULL);
+}
+
+const struct sieve_interpreter_extension imap4flags_interpreter_extension = {
+	&imap4flags_extension,
+	ext_imap4flags_runtime_init,
+	NULL,
+};
+
+/* 
+ * Flag operations 
+ */
+
+/* FIXME: This currently accepts a potentially unlimited number of 
+ * flags, making the internal or variable flag list indefinitely long
+ */
+static bool flag_is_valid(const char *flag)
+{	
+	if (*flag == '\\') {
+		/* System flag */
+		const char *atom = t_str_ucase(flag); 
+        
+		if (
+			(strcmp(atom, "\\ANSWERED") != 0) &&
+			(strcmp(atom, "\\FLAGGED") != 0) &&
+			(strcmp(atom, "\\DELETED") != 0) &&
+			(strcmp(atom, "\\SEEN") != 0) &&
+			(strcmp(atom, "\\DRAFT") != 0) )  
+		{           
+			return FALSE;
+		}
+	} else {
+		/* Custom keyword:
+		 *
+		 * The validity of the keyword cannot be validated until the 
+		 * target mailbox for the message is known. Meaning that the 
+		 * verfication of keyword can only be performed when the
+		 * action side effect is about to be executed.
+		 *
+		 * FIXME: technically this is nonsense, since we can simply parse
+		 * using the flag-keyword grammar provided by imap.
+		 */					
+	}
+
+	return TRUE;  
+}
+
+void ext_imap4flags_iter_init
+(struct ext_imap4flags_iter *iter, string_t *flags_list) 
+{
+	iter->flags_list = flags_list;
+	iter->offset = 0;
+	iter->last = 0;
+}
+
+const char *ext_imap4flags_iter_get_flag
+(struct ext_imap4flags_iter *iter) 
+{
+	unsigned int len = str_len(iter->flags_list);
+	const unsigned char *fp;
+	const unsigned char *fbegin;
+	const unsigned char *fstart;
+	const unsigned char *fend;
+	
+	if ( iter->offset >= len ) return NULL;
+	
+	fbegin = str_data(iter->flags_list);
+	fp = fbegin + iter->offset;
+	fstart = fp;
+	fend = fbegin + len;
+	for (;;) {
+		if ( fp >= fend || *fp == ' ' ) { 
+			if ( fp > fstart ) {
+				const char *flag = t_strdup_until(fstart, fp);
+				
+				iter->last = fstart - fbegin;
+				iter->offset = fp - fbegin;
+				return flag;
+			} 	
+			
+			fstart = fp+1;
+		}
+		
+		if ( fp >= fend ) break;
+				
+		fp++;
+	}
+	
+	iter->last = fstart - fbegin;
+	iter->offset = fp - fbegin;
+	return NULL;
+}
+
+static void ext_imap4flags_iter_delete_last
+(struct ext_imap4flags_iter *iter) 
+{
+	iter->offset++;
+	if ( iter->offset > str_len(iter->flags_list) )
+		iter->offset = str_len(iter->flags_list);
+	if ( iter->offset == str_len(iter->flags_list) )
+		iter->last--;
+
+	str_delete(iter->flags_list, iter->last, iter->offset - iter->last);	
+	
+	iter->offset = iter->last;
+}
+
+static bool flags_list_flag_exists
+(string_t *flags_list, const char *flag)
+{
+	const char *flg;
+	struct ext_imap4flags_iter flit;
+		
+	ext_imap4flags_iter_init(&flit, flags_list);
+	
+	while ( (flg=ext_imap4flags_iter_get_flag(&flit)) != NULL ) {
+		if ( strcasecmp(flg, flag) == 0 ) 
+			return TRUE; 	
+	}
+	
+	return FALSE;
+}
+
+static void flags_list_flag_delete
+(string_t *flags_list, const char *flag)
+{
+	const char *flg;
+	struct ext_imap4flags_iter flit;
+		
+	ext_imap4flags_iter_init(&flit, flags_list);
+	
+	while ( (flg=ext_imap4flags_iter_get_flag(&flit)) != NULL ) {
+		if ( strcasecmp(flg, flag) == 0 ) {
+			ext_imap4flags_iter_delete_last(&flit);
+		} 	
+	}
+}
+ 			
+static void flags_list_add_flags
+(string_t *flags_list, string_t *flags)
+{	
+	const char *flg;
+	struct ext_imap4flags_iter flit;
+		
+	ext_imap4flags_iter_init(&flit, flags);
+	
+	while ( (flg=ext_imap4flags_iter_get_flag(&flit)) != NULL ) {
+		if ( flag_is_valid(flg) && !flags_list_flag_exists(flags_list, flg) ) {
+			if ( str_len(flags_list) != 0 ) 
+				str_append_c(flags_list, ' '); 
+			str_append(flags_list, flg);
+		} 	
+	}
+}
+
+static void flags_list_remove_flags
+(string_t *flags_list, string_t *flags)
+{	
+	const char *flg;
+	struct ext_imap4flags_iter flit;
+		
+	ext_imap4flags_iter_init(&flit, flags);
+	
+	while ( (flg=ext_imap4flags_iter_get_flag(&flit)) != NULL ) {
+		flags_list_flag_delete(flags_list, flg); 	
+	}
+}
+
+static void flags_list_set_flags
+(string_t *flags_list, string_t *flags)
+{
+	str_truncate(flags_list, 0);
+	flags_list_add_flags(flags_list, flags);
+}
+
+/* 
+ * Flag registration 
+ */
+
+int ext_imap4flags_set_flags
+(const struct sieve_runtime_env *renv, struct sieve_variable_storage *storage,
+	unsigned int var_index, string_t *flags)
+{
+	string_t *cur_flags;
+	
+	if ( storage != NULL ) {
+		if ( !sieve_variable_get_modifiable(storage, var_index, &cur_flags) )
+			return SIEVE_EXEC_BIN_CORRUPT;
+	} else
+		cur_flags = _get_flags_string(renv->result);
+
+	if ( cur_flags != NULL )
+		flags_list_set_flags(cur_flags, flags);		
+
+	return SIEVE_EXEC_OK;
+}
+
+int ext_imap4flags_add_flags
+(const struct sieve_runtime_env *renv, struct sieve_variable_storage *storage,
+	unsigned int var_index, string_t *flags)
+{
+	string_t *cur_flags;
+	
+	if ( storage != NULL ) {
+		if ( !sieve_variable_get_modifiable(storage, var_index, &cur_flags) )
+			return SIEVE_EXEC_BIN_CORRUPT;
+	} else
+		cur_flags = _get_flags_string(renv->result);
+	
+	if ( cur_flags != NULL )
+		flags_list_add_flags(cur_flags, flags);
+	
+	return SIEVE_EXEC_OK;	
+}
+
+int ext_imap4flags_remove_flags
+(const struct sieve_runtime_env *renv, struct sieve_variable_storage *storage,
+	unsigned int var_index, string_t *flags)
+{
+	string_t *cur_flags;
+	
+	if ( storage != NULL ) {
+		if ( !sieve_variable_get_modifiable(storage, var_index, &cur_flags) )
+			return SIEVE_EXEC_BIN_CORRUPT;
+	} else
+		cur_flags = _get_flags_string(renv->result);
+	
+	if ( cur_flags != NULL )
+		flags_list_remove_flags(cur_flags, flags);		
+
+	return SIEVE_EXEC_OK;
+}
+
+int ext_imap4flags_get_flags_string
+(const struct sieve_runtime_env *renv, struct sieve_variable_storage *storage, 
+	unsigned int var_index, const char **flags)
+{
+	string_t *cur_flags;
+	
+	if ( storage != NULL ) {
+		if ( !sieve_variable_get_modifiable(storage, var_index, &cur_flags) )
+			return SIEVE_EXEC_BIN_CORRUPT;
+	} else
+		cur_flags = _get_flags_string(renv->result);
+	
+	if ( cur_flags == NULL )
+		*flags = "";
+	else 
+		*flags = str_c(cur_flags);
+
+	return SIEVE_EXEC_OK;
+}
+
+void ext_imap4flags_get_flags_init
+(struct ext_imap4flags_iter *iter, const struct sieve_runtime_env *renv,
+	string_t *flags_list)
+{
+	string_t *cur_flags;
+	
+	if ( flags_list != NULL ) {
+		cur_flags = t_str_new(256);
+		
+		flags_list_set_flags(cur_flags, flags_list);
+	}
+	else
+		cur_flags = _get_flags_string(renv->result);
+	
+	ext_imap4flags_iter_init(iter, cur_flags);		
+}
+
+void ext_imap4flags_get_implicit_flags_init
+(struct ext_imap4flags_iter *iter, struct sieve_result *result)
+{
+	string_t *cur_flags = _get_flags_string(result);
+	
+	ext_imap4flags_iter_init(iter, cur_flags);		
+}
+
+
+	
+	
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/ext-imap4flags-common.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/ext-imap4flags-common.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/ext-imap4flags-common.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/ext-imap4flags-common.h	2009-02-04 20:23:33.000000000 +0100
@@ -0,0 +1,118 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_IMAP4FLAGS_COMMON_H
+#define __EXT_IMAP4FLAGS_COMMON_H
+
+#include "lib.h"
+
+#include "sieve-common.h"
+#include "sieve-ext-variables.h"
+
+/*
+ * Extension
+ */
+ 
+extern const struct sieve_extension imap4flags_extension;
+extern const struct sieve_interpreter_extension 
+	imap4flags_interpreter_extension;
+
+/*
+ * Side effect
+ */
+
+extern const struct sieve_side_effect flags_side_effect;
+
+/*
+ * Operands
+ */
+
+extern const struct sieve_operand flags_side_effect_operand;
+
+/*
+ * Operations
+ */
+ 
+enum ext_imap4flags_opcode {
+	ext_imap4flags_OPERATION_SETFLAG,
+	ext_imap4flags_OPERATION_ADDFLAG,
+	ext_imap4flags_OPERATION_REMOVEFLAG,
+	ext_imap4flags_OPERATION_HASFLAG
+};
+
+extern const struct sieve_operation setflag_operation;
+extern const struct sieve_operation addflag_operation;
+extern const struct sieve_operation removeflag_operation;
+extern const struct sieve_operation hasflag_operation;
+
+/* 
+ * Commands 
+ */
+
+extern const struct sieve_command cmd_setflag;
+extern const struct sieve_command cmd_addflag;
+extern const struct sieve_command cmd_removeflag;
+
+extern const struct sieve_command tst_hasflag;
+
+/*
+ * Common command functions
+ */
+
+bool ext_imap4flags_command_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd);
+
+/*
+ * Flags tagged argument
+ */	
+	
+void ext_imap4flags_attach_flags_tag
+	(struct sieve_validator *valdtr, const char *command);
+
+/* 
+ * Flag management 
+ */
+
+struct ext_imap4flags_iter {
+	string_t *flags_list;
+	unsigned int offset;
+	unsigned int last;
+};
+
+void ext_imap4flags_iter_init
+	(struct ext_imap4flags_iter *iter, string_t *flags_list);
+	
+const char *ext_imap4flags_iter_get_flag
+	(struct ext_imap4flags_iter *iter);
+
+typedef int (*ext_imapflag_flag_operation_t)
+	(const struct sieve_runtime_env *renv, struct sieve_variable_storage *storage,
+		unsigned int var_index, string_t *flags);
+
+int ext_imap4flags_set_flags
+	(const struct sieve_runtime_env *renv, struct sieve_variable_storage *storage,
+		unsigned int var_index, string_t *flags);
+int ext_imap4flags_add_flags
+	(const struct sieve_runtime_env *renv, struct sieve_variable_storage *storage,
+		unsigned int var_index, string_t *flags);
+int ext_imap4flags_remove_flags
+	(const struct sieve_runtime_env *renv, struct sieve_variable_storage *storage,
+		unsigned int var_index, string_t *flags);
+
+/*
+ * Flags access
+ */
+
+int ext_imap4flags_get_flags_string
+(const struct sieve_runtime_env *renv, struct sieve_variable_storage *storage, 
+	unsigned int var_index, const char **flags);
+
+void ext_imap4flags_get_flags_init
+	(struct ext_imap4flags_iter *iter, const struct sieve_runtime_env *renv,
+		string_t *flags_list);
+void ext_imap4flags_get_implicit_flags_init
+	(struct ext_imap4flags_iter *iter, struct sieve_result *result);
+
+
+#endif /* __EXT_IMAP4FLAGS_COMMON_H */
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/ext-imapflags.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/ext-imapflags.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/ext-imapflags.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/ext-imapflags.c	2009-07-08 17:06:04.000000000 +0200
@@ -0,0 +1,175 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension imapflags
+ * --------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: draft-melnikov-sieve-imapflags-03.txt
+ * Implementation: deprecated; provided for backwards compatibility
+ * Status: deprecated
+ *
+ */
+ 
+#include "lib.h"
+#include "mempool.h"
+#include "str.h"
+
+#include "sieve-common.h"
+
+#include "sieve-ast.h"
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-actions.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+
+#include "ext-imap4flags-common.h"
+
+/*
+ * Commands
+ */
+
+static bool cmd_mark_validate
+	(struct sieve_validator *valdtr, struct sieve_command_context *cmd);
+
+/* Mark command
+ *
+ * Syntax:
+ *   mark
+ */
+
+static const struct sieve_command cmd_mark = {
+    "mark",
+    SCT_COMMAND,
+    0, 0, FALSE, FALSE,
+    NULL, NULL,
+    cmd_mark_validate,
+    NULL, NULL,
+};
+
+/* Unmark command
+ *
+ * Syntax:
+ *   unmark
+ */
+static const struct sieve_command cmd_unmark = {
+    "unmark",
+    SCT_COMMAND,
+    0, 0, FALSE, FALSE,
+    NULL, NULL,
+    cmd_mark_validate,
+    NULL, NULL,
+};
+
+/* 
+ * Extension
+ */
+
+static bool ext_imapflags_load(void);
+static bool ext_imapflags_validator_load(struct sieve_validator *valdtr);
+static bool ext_imapflags_interpreter_load
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+int ext_imapflags_my_id = -1;
+
+const struct sieve_extension imapflags_extension = { 
+	"imapflags", 
+	&ext_imapflags_my_id,
+	ext_imapflags_load, 
+	NULL,
+	ext_imapflags_validator_load, 
+	NULL,
+	ext_imapflags_interpreter_load, 
+	NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_NO_OPERATIONS, 
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+static bool ext_imapflags_load(void)
+{
+	/* Make sure real extension is registered, it is needed by the binary */
+	(void)sieve_extension_require(&imap4flags_extension);
+
+	return TRUE;
+}
+
+/*
+ * Validator
+ */
+
+static bool ext_imapflags_validator_extension_validate
+	(struct sieve_validator *valdtr, void *context, struct sieve_ast_argument *require_arg);
+
+const struct sieve_validator_extension imapflags_validator_extension = {
+	&imapflags_extension,
+	ext_imapflags_validator_extension_validate,
+	NULL
+};
+
+static bool ext_imapflags_validator_load
+(struct sieve_validator *valdtr)
+{
+	sieve_validator_extension_register
+	    (valdtr, &imapflags_validator_extension, NULL);
+
+	/* Register commands */
+	sieve_validator_register_command(valdtr, &cmd_setflag);
+	sieve_validator_register_command(valdtr, &cmd_addflag);
+	sieve_validator_register_command(valdtr, &cmd_removeflag);
+
+	sieve_validator_register_command(valdtr, &cmd_mark);
+	sieve_validator_register_command(valdtr, &cmd_unmark);	
+	
+	return TRUE;
+}
+
+static bool ext_imapflags_validator_extension_validate
+(struct sieve_validator *valdtr, void *context ATTR_UNUSED, 
+	struct sieve_ast_argument *require_arg)
+{
+	if ( sieve_validator_extension_loaded(valdtr, &imap4flags_extension) ) {
+		sieve_argument_validate_error(valdtr, require_arg,
+			"the (deprecated) imapflags extension cannot be used "
+			"together with the imap4flags extension");
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+/*
+ * Interpreter
+ */
+
+static bool ext_imapflags_interpreter_load
+(const struct sieve_runtime_env *renv, sieve_size_t *address ATTR_UNUSED)
+{
+    sieve_interpreter_extension_register
+        (renv->interp, &imap4flags_interpreter_extension, NULL);
+
+    return TRUE;
+}
+
+/*
+ * Command validation
+ */ 
+
+static bool cmd_mark_validate
+(struct sieve_validator *valdtr, struct sieve_command_context *cmd)
+{
+	if ( cmd->command == &cmd_mark )
+		cmd->command = &cmd_addflag;
+	else
+		cmd->command = &cmd_removeflag;
+
+	cmd->first_positional = sieve_ast_argument_cstring_create
+		(cmd->ast_node, "\\flagged", cmd->ast_node->source_line);
+
+	if ( !sieve_validator_argument_activate(valdtr, cmd, cmd->first_positional, FALSE) )
+        return FALSE;	
+		
+	return TRUE;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/Makefile.am dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/Makefile.am
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/Makefile.am	2009-02-04 20:43:56.000000000 +0100
@@ -0,0 +1,30 @@
+noinst_LTLIBRARIES = libsieve_ext_imap4flags.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+    -I../variables \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+commands = \
+	cmd-flag.c
+
+tests = \
+	tst-hasflag.c
+
+tags = \
+	tag-flags.c
+
+libsieve_ext_imap4flags_la_SOURCES = \
+	ext-imap4flags-common.c \
+	$(commands) \
+	$(tests) \
+	$(tags) \
+	ext-imap4flags.c \
+	ext-imapflags.c
+	
+
+noinst_HEADERS = \
+	ext-imap4flags-common.h
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/Makefile.in dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/Makefile.in
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/Makefile.in	2009-08-21 00:55:43.000000000 +0200
@@ -0,0 +1,485 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve/plugins/imap4flags
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libsieve_ext_imap4flags_la_LIBADD =
+am__objects_1 = cmd-flag.lo
+am__objects_2 = tst-hasflag.lo
+am__objects_3 = tag-flags.lo
+am_libsieve_ext_imap4flags_la_OBJECTS = ext-imap4flags-common.lo \
+	$(am__objects_1) $(am__objects_2) $(am__objects_3) \
+	ext-imap4flags.lo ext-imapflags.lo
+libsieve_ext_imap4flags_la_OBJECTS =  \
+	$(am_libsieve_ext_imap4flags_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_ext_imap4flags_la_SOURCES)
+DIST_SOURCES = $(libsieve_ext_imap4flags_la_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LTLIBRARIES = libsieve_ext_imap4flags.la
+AM_CPPFLAGS = \
+	-I../../ \
+    -I../variables \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+commands = \
+	cmd-flag.c
+
+tests = \
+	tst-hasflag.c
+
+tags = \
+	tag-flags.c
+
+libsieve_ext_imap4flags_la_SOURCES = \
+	ext-imap4flags-common.c \
+	$(commands) \
+	$(tests) \
+	$(tags) \
+	ext-imap4flags.c \
+	ext-imapflags.c
+
+noinst_HEADERS = \
+	ext-imap4flags-common.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/lib-sieve/plugins/imap4flags/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  src/lib-sieve/plugins/imap4flags/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve_ext_imap4flags.la: $(libsieve_ext_imap4flags_la_OBJECTS) $(libsieve_ext_imap4flags_la_DEPENDENCIES) 
+	$(LINK)  $(libsieve_ext_imap4flags_la_OBJECTS) $(libsieve_ext_imap4flags_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-flag.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-imap4flags-common.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-imap4flags.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-imapflags.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tag-flags.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-hasflag.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/tag-flags.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/tag-flags.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/tag-flags.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/tag-flags.c	2009-08-05 11:50:22.000000000 +0200
@@ -0,0 +1,426 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str-sanitize.h"
+#include "array.h"
+#include "mail-storage.h"
+
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-result.h"
+#include "sieve-validator.h" 
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-actions.h"
+#include "sieve-dump.h"
+
+#include "ext-imap4flags-common.h"
+
+#include <ctype.h>
+
+/* 
+ * Flags tagged argument
+ */
+
+static bool tag_flags_validate
+	(struct sieve_validator *validator,	struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+static bool tag_flags_validate_persistent
+	(struct sieve_validator *validator, struct sieve_command_context *cmd);
+static bool tag_flags_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+		struct sieve_command_context *cmd);
+
+const struct sieve_argument tag_flags = { 
+	"flags", 
+	NULL, NULL,
+	tag_flags_validate, 
+	NULL, 
+	tag_flags_generate 
+};
+
+const struct sieve_argument tag_flags_implicit = { 
+	"flags-implicit", 
+	NULL,
+	tag_flags_validate_persistent, 
+	NULL, NULL,
+	tag_flags_generate
+};
+
+/* 
+ * Side effect 
+ */
+
+static bool seff_flags_dump_context
+	(const struct sieve_side_effect *seffect,
+    	const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static bool seff_flags_read_context
+	(const struct sieve_side_effect *seffect, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address,
+		void **se_context);
+
+static int seff_flags_merge
+	(const struct sieve_runtime_env *renv, const struct sieve_action *action, 
+		const struct sieve_side_effect *seffect, 
+		void **old_context, void *new_context);
+static void seff_flags_print
+	(const struct sieve_side_effect *seffect, const struct sieve_action *action,
+		const struct sieve_result_print_env *rpenv, void *se_context, bool *keep);
+static bool seff_flags_pre_execute
+	(const struct sieve_side_effect *seffect, const struct sieve_action *action, 
+		const struct sieve_action_exec_env *aenv, 
+		void **se_context, void *tr_context);
+
+const struct sieve_side_effect flags_side_effect = {
+	SIEVE_OBJECT("flags", &flags_side_effect_operand, 0),
+	&act_store,
+
+	seff_flags_dump_context,
+	seff_flags_read_context,
+	seff_flags_merge,
+	seff_flags_print,
+	seff_flags_pre_execute, 
+	NULL, NULL, NULL
+};
+
+/*
+ * Operand
+ */
+
+static const struct sieve_extension_objects ext_side_effects =
+	SIEVE_EXT_DEFINE_SIDE_EFFECT(flags_side_effect);
+
+const struct sieve_operand flags_side_effect_operand = { 
+	"flags operand", 
+	&imap4flags_extension,
+	0, 
+	&sieve_side_effect_operand_class,
+	&ext_side_effects
+};
+
+/* 
+ * Tag validation 
+ */
+
+static bool tag_flags_validate_persistent
+(struct sieve_validator *validator ATTR_UNUSED, struct sieve_command_context *cmd)
+{
+	if ( sieve_command_find_argument(cmd, &tag_flags) == NULL ) {
+		sieve_command_add_dynamic_tag(cmd, &tag_flags_implicit, -1);
+	}
+	
+	return TRUE;
+}
+
+static bool tag_flags_validate
+(struct sieve_validator *validator,	struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd)
+{
+	struct sieve_ast_argument *tag = *arg;
+
+	/* Detach the tag itself */
+	*arg = sieve_ast_argument_next(*arg);
+	
+	/* Check syntax:
+	 *   :flags <list-of-flags: string-list>
+	 */
+	if ( !sieve_validate_tag_parameter
+		(validator, cmd, tag, *arg, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+	
+	tag->parameters = *arg;
+	
+	/* Detach parameter */
+	*arg = sieve_ast_arguments_detach(*arg,1);
+
+	return TRUE;
+}
+
+/* 
+ * Code generation 
+ */
+
+static bool tag_flags_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+	struct sieve_command_context *cmd)
+{
+	struct sieve_ast_argument *param;
+
+	if ( sieve_ast_argument_type(arg) != SAAT_TAG ) {
+		return FALSE;
+	}
+
+	sieve_opr_side_effect_emit(cgenv->sbin, &flags_side_effect);
+
+	if ( arg->argument == &tag_flags ) {
+		/* Explicit :flags tag */
+		param = arg->parameters;
+
+		/* Call the generation function for the argument */ 
+		if ( param->argument != NULL && param->argument->generate != NULL && 
+			!param->argument->generate(cgenv, param, cmd) ) 
+			return FALSE;
+
+	} else if ( arg->argument == &tag_flags_implicit ) {
+		/* Implicit flags */
+		sieve_opr_omitted_emit(cgenv->sbin);
+	
+	} else {
+		/* Something else?! */
+		i_unreached();
+	}
+	
+	return TRUE;
+}
+
+/* 
+ * Side effect implementation
+ */
+ 
+/* Context data */
+
+struct seff_flags_context {
+	ARRAY_DEFINE(keywords, const char *);
+	enum mail_flags flags;
+};
+
+/* Context coding */
+
+static bool seff_flags_dump_context
+(const struct sieve_side_effect *seffect ATTR_UNUSED, 
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+    const struct sieve_operand *operand;
+
+    operand = sieve_operand_read(denv->sbin, address);
+	if ( operand == NULL ) {
+		sieve_code_dumpf(denv, "ERROR: INVALID OPERAND");
+		return FALSE;
+	}
+
+
+    if ( sieve_operand_is_omitted(operand) ) {
+		sieve_code_dumpf(denv, "flags: INTERNAL");
+		return TRUE;
+    }
+
+    return sieve_opr_stringlist_dump_data(denv, operand, address,
+            "flags");
+}
+
+static struct seff_flags_context *seff_flags_get_implicit_context
+(struct sieve_result *result)
+{
+	pool_t pool = sieve_result_pool(result);
+	struct seff_flags_context *ctx;
+	const char *flag;
+	struct ext_imap4flags_iter flit;
+	
+	ctx = p_new(pool, struct seff_flags_context, 1);
+	p_array_init(&ctx->keywords, pool, 2);
+	
+	T_BEGIN {
+		
+		/* Unpack */
+		ext_imap4flags_get_implicit_flags_init(&flit, result);
+		while ( (flag=ext_imap4flags_iter_get_flag(&flit)) != NULL ) {		
+			if (flag != NULL && *flag != '\\') {
+				/* keyword */
+				const char *keyword = p_strdup(pool, flag);
+				array_append(&ctx->keywords, &keyword, 1);
+			} else {
+				/* system flag */
+				if (flag == NULL || strcasecmp(flag, "\\flagged") == 0)
+					ctx->flags |= MAIL_FLAGGED;
+				else if (strcasecmp(flag, "\\answered") == 0)
+					ctx->flags |= MAIL_ANSWERED;
+				else if (strcasecmp(flag, "\\deleted") == 0)
+					ctx->flags |= MAIL_DELETED;
+				else if (strcasecmp(flag, "\\seen") == 0)
+					ctx->flags |= MAIL_SEEN;
+				else if (strcasecmp(flag, "\\draft") == 0)
+					ctx->flags |= MAIL_DRAFT;
+			}
+		}
+
+	} T_END;
+	
+	return ctx;
+}
+
+static bool _seff_flags_read_context
+(const struct sieve_side_effect *seffect ATTR_UNUSED, 
+	const struct sieve_runtime_env *renv, sieve_size_t *address,
+	void **se_context)
+{
+	bool result = TRUE;
+	sieve_size_t op_address = *address;
+	const struct sieve_operand *operand;
+	pool_t pool = sieve_result_pool(renv->result);
+	struct seff_flags_context *ctx;
+	string_t *flags_item;
+	struct sieve_coded_stringlist *flag_list;
+	
+	ctx = p_new(pool, struct seff_flags_context, 1);
+	p_array_init(&ctx->keywords, pool, 2);	
+
+	/* Check whether explicit flag list operand is present */
+	operand = sieve_operand_read(renv->sbin, address);
+
+    if ( operand == NULL ) {
+        sieve_runtime_trace_error(renv, "invalid operand");
+        return FALSE;
+    }
+
+    if ( sieve_operand_is_omitted(operand) ) {
+		/* Flag list is omitted, use current value of internal 
+		 * variable to construct side effect context.
+		 */
+		*se_context = seff_flags_get_implicit_context(renv->result);
+		return TRUE;
+	}
+	
+	/* Read flag-list */
+	if ( (flag_list=sieve_opr_stringlist_read_data
+		(renv, operand, op_address, address)) == NULL ) {
+		return FALSE;
+	}
+	
+	/* Unpack */
+	flags_item = NULL;
+	while ( (result=sieve_coded_stringlist_next_item(flag_list, &flags_item)) && 
+		flags_item != NULL ) {
+		const char *flag;
+		struct ext_imap4flags_iter flit;
+
+		ext_imap4flags_iter_init(&flit, flags_item);
+	
+		while ( (flag=ext_imap4flags_iter_get_flag(&flit)) != NULL ) {		
+			if (flag != NULL && *flag != '\\') {
+				/* keyword */
+				const char *keyword = p_strdup(pool, flag);
+
+				/* FIXME: should check for duplicates (cannot trust variables) */
+				array_append(&ctx->keywords, &keyword, 1);
+
+			} else {
+				/* system flag */
+				if (flag == NULL || strcasecmp(flag, "\\flagged") == 0)
+					ctx->flags |= MAIL_FLAGGED;
+				else if (strcasecmp(flag, "\\answered") == 0)
+					ctx->flags |= MAIL_ANSWERED;
+				else if (strcasecmp(flag, "\\deleted") == 0)
+					ctx->flags |= MAIL_DELETED;
+				else if (strcasecmp(flag, "\\seen") == 0)
+					ctx->flags |= MAIL_SEEN;
+				else if (strcasecmp(flag, "\\draft") == 0)
+					ctx->flags |= MAIL_DRAFT;
+			}
+		}
+	}
+	
+	*se_context = (void *) ctx;
+	
+	return result;
+}
+
+static bool seff_flags_read_context
+(const struct sieve_side_effect *seffect, 
+	const struct sieve_runtime_env *renv, sieve_size_t *address,
+	void **se_context)
+{
+	bool result;
+	
+	T_BEGIN {
+		result = _seff_flags_read_context(seffect, renv, address, se_context);
+	} T_END;
+
+	return result;
+}
+
+
+/* Result verification */
+
+static int seff_flags_merge
+(const struct sieve_runtime_env *renv ATTR_UNUSED, 
+	const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_side_effect *seffect ATTR_UNUSED, 
+	void **old_context, void *new_context)
+{
+	*old_context = new_context;
+	
+	return 1;
+}
+
+/* Result printing */
+
+static void seff_flags_print
+(const struct sieve_side_effect *seffect ATTR_UNUSED, 
+	const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_result_print_env *rpenv,
+	void *se_context, bool *keep ATTR_UNUSED)
+{
+	struct sieve_result *result = rpenv->result;
+	struct seff_flags_context *ctx = (struct seff_flags_context *) se_context;
+	unsigned int i;
+	
+	if ( ctx == NULL )
+		ctx = seff_flags_get_implicit_context(result);
+	
+	if ( ctx->flags != 0 || array_count(&ctx->keywords) > 0 ) {
+		T_BEGIN {
+			string_t *flags = t_str_new(128);
+ 
+			if ( (ctx->flags & MAIL_FLAGGED) > 0 )
+				str_printfa(flags, " \\flagged");
+
+			if ( (ctx->flags & MAIL_ANSWERED) > 0 )
+				str_printfa(flags, " \\answered");
+		
+			if ( (ctx->flags & MAIL_DELETED) > 0 )
+				str_printfa(flags, " \\deleted");
+					
+			if ( (ctx->flags & MAIL_SEEN) > 0 )
+				str_printfa(flags, " \\seen");
+			
+			if ( (ctx->flags & MAIL_DRAFT) > 0 )
+				str_printfa(flags, " \\draft");
+
+			for ( i = 0; i < array_count(&ctx->keywords); i++ ) {
+				const char *const *keyword = array_idx(&ctx->keywords, i);
+				str_printfa(flags, " %s", str_sanitize(*keyword, 64));
+			}
+
+			sieve_result_seffect_printf(rpenv, "add IMAP flags:%s", str_c(flags));
+		} T_END;
+	}
+}
+
+/* Result execution */
+
+static bool seff_flags_pre_execute
+(const struct sieve_side_effect *seffect ATTR_UNUSED, 
+	const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_action_exec_env *aenv, 
+	void **se_context, void *tr_context)
+{	
+	struct seff_flags_context *ctx = (struct seff_flags_context *) *se_context;
+	const char *const *keywords;
+		
+	if ( ctx == NULL ) {
+		ctx = seff_flags_get_implicit_context(aenv->result);
+		*se_context = (void *) ctx;
+	}
+		
+	(void)array_append_space(&ctx->keywords);
+	keywords = array_idx(&ctx->keywords, 0);
+
+	sieve_act_store_add_flags(aenv, tr_context, keywords, ctx->flags);
+	
+	return TRUE;
+}
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/tst-hasflag.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/tst-hasflag.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/tst-hasflag.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/tst-hasflag.c	2009-07-30 00:44:14.000000000 +0200
@@ -0,0 +1,300 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#include "lib.h"
+
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h" 
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+#include "ext-imap4flags-common.h"
+
+/*
+ * Hasflag test
+ *
+ * Syntax: 
+ *   hasflag [MATCH-TYPE] [COMPARATOR] [<variable-list: string-list>]
+ *       <list-of-flags: string-list>
+ */
+
+static bool tst_hasflag_registered
+	(struct sieve_validator *validator,
+		struct sieve_command_registration *cmd_reg);
+static bool tst_hasflag_validate
+	(struct sieve_validator *validator,	struct sieve_command_context *ctx);
+static bool tst_hasflag_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+ 
+const struct sieve_command tst_hasflag = { 
+	"hasflag", 
+	SCT_TEST,
+	-1, /* We check positional arguments ourselves */
+	0, FALSE, FALSE, 
+	tst_hasflag_registered, 
+	NULL,
+	tst_hasflag_validate, 
+	tst_hasflag_generate, 
+	NULL 
+};
+
+/* 
+ * Hasflag operation 
+ */
+
+static bool tst_hasflag_operation_dump
+	(const struct sieve_operation *op,	
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_hasflag_operation_execute
+	(const struct sieve_operation *op,	
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation hasflag_operation = { 
+	"HASFLAG",
+	&imap4flags_extension,
+	ext_imap4flags_OPERATION_HASFLAG,
+	tst_hasflag_operation_dump,
+	tst_hasflag_operation_execute
+};
+
+/* 
+ * Optional arguments 
+ */
+
+enum tst_hasflag_optional {	
+	OPT_VARIABLES = SIEVE_MATCH_OPT_LAST,
+};
+
+/* 
+ * Tag registration 
+ */
+
+static bool tst_hasflag_registered
+(struct sieve_validator *validator, 
+	struct sieve_command_registration *cmd_reg) 
+{
+	/* The order of these is not significant */
+	sieve_comparators_link_tag(validator, cmd_reg, SIEVE_MATCH_OPT_COMPARATOR);
+	sieve_match_types_link_tags(validator, cmd_reg, SIEVE_MATCH_OPT_MATCH_TYPE);
+
+	return TRUE;
+}
+
+/* 
+ * Validation 
+ */
+
+static bool tst_hasflag_validate
+(struct sieve_validator *validator,	struct sieve_command_context *tst)
+{
+	struct sieve_ast_argument *vars = tst->first_positional;
+	struct sieve_ast_argument *keys = sieve_ast_argument_next(vars);
+		
+	if ( !ext_imap4flags_command_validate(validator, tst) )
+		return FALSE;
+	
+	if ( keys == NULL ) {
+		keys = vars;
+		vars = NULL;
+	} else {
+		vars->arg_id_code = OPT_VARIABLES;
+	}
+	
+	/* Validate the key argument to a specified match type */
+	return sieve_match_type_validate
+		(validator, tst, keys, &is_match_type, &i_ascii_casemap_comparator);
+}
+
+/*
+ * Code generation 
+ */
+
+static bool tst_hasflag_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx)
+{
+	sieve_operation_emit_code(cgenv->sbin, &hasflag_operation);
+
+	/* Generate arguments */
+	if ( !sieve_generate_arguments(cgenv, ctx, NULL) )
+		return FALSE;	
+
+	return TRUE;
+}
+
+/* 
+ * Code dump 
+ */
+ 
+static bool tst_hasflag_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,	
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	int opt_code = 0;
+
+	sieve_code_dumpf(denv, "HASFLAG");
+	sieve_code_descend(denv);
+
+	/* Handle any optional arguments */
+	do {
+		if ( !sieve_match_dump_optional_operands(denv, address, &opt_code) )
+			return FALSE;
+
+		switch ( opt_code ) {
+		case SIEVE_MATCH_OPT_END:
+			break;
+		case OPT_VARIABLES:
+			sieve_opr_stringlist_dump(denv, address, "variables");
+			break;
+		default:
+			return FALSE;
+		}
+	} while ( opt_code != SIEVE_MATCH_OPT_END );
+			
+	return 
+		sieve_opr_stringlist_dump(denv, address, "list of flags");
+}
+
+/*
+ * Interpretation
+ */
+ 
+static int _flag_key_extract_init
+(void **context, string_t *raw_key)
+{
+	struct ext_imap4flags_iter *iter = t_new(struct ext_imap4flags_iter, 1);
+	
+	ext_imap4flags_iter_init(iter, raw_key);
+	
+	*context = iter; 
+	
+	return TRUE;
+}
+
+static int _flag_key_extract
+(void *context, const char **key, size_t *size)
+{
+	struct ext_imap4flags_iter *iter = (struct ext_imap4flags_iter *) context;
+	
+	if ( (*key = ext_imap4flags_iter_get_flag(iter)) != NULL ) {
+		*size = strlen(*key); 
+		return TRUE;
+	}
+	
+	return FALSE;
+}
+
+static const struct sieve_match_key_extractor _flag_extractor = {
+	_flag_key_extract_init,
+	_flag_key_extract
+};
+
+static int tst_hasflag_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	int ret, mret;
+	bool result = TRUE;
+	int opt_code = 0;
+	const struct sieve_comparator *cmp = &i_ascii_casemap_comparator;
+	const struct sieve_match_type *mtch = &is_match_type;
+	struct sieve_match_context *mctx;
+	struct sieve_coded_stringlist *flag_list, *variables_list = NULL;
+	struct ext_imap4flags_iter iter;
+	const char *flag;
+	bool matched;
+	
+	/*
+	 * Read operands
+	 */
+
+	/* Handle match-type and comparator operands */
+	do {
+		if ( (ret=sieve_match_read_optional_operands
+			(renv, address, &opt_code, &cmp, &mtch)) <= 0 )
+			return ret;
+	
+		/* Check whether we neatly finished the list of optional operands*/
+		switch ( opt_code ) { 
+		case SIEVE_MATCH_OPT_END:
+			break;
+		case OPT_VARIABLES:
+			if ( (variables_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+					sieve_runtime_trace_error(renv, "invalid variables-list operand");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+			break;
+		default:
+			sieve_runtime_trace_error(renv, "invalid optional operand");
+			return SIEVE_EXEC_BIN_CORRUPT;
+		}
+	} while ( opt_code != SIEVE_MATCH_OPT_END );
+		
+	/* Read flag list */
+	if ( (flag_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid flag-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "HASFLAG test");
+
+	matched = FALSE;
+	mctx = sieve_match_begin
+		(renv->interp, mtch, cmp, &_flag_extractor, flag_list); 	
+
+	matched = FALSE;
+
+	if ( variables_list != NULL ) {
+		string_t *var_item = NULL;
+		
+		/* Iterate through all requested variables to match */
+		while ( result && !matched && 
+			(result=sieve_coded_stringlist_next_item(variables_list, &var_item)) 
+			&& var_item != NULL ) {
+		
+			ext_imap4flags_get_flags_init(&iter, renv, var_item);	
+			while ( !matched && (flag=ext_imap4flags_iter_get_flag(&iter)) != NULL ) {
+				if ( (mret=sieve_match_value(mctx, flag, strlen(flag))) < 0 ) {
+					result = FALSE;
+					break;
+				}
+
+				matched = ( mret > 0 ); 	
+			}
+		}
+	} else {
+		ext_imap4flags_get_flags_init(&iter, renv, NULL);	
+		while ( !matched && (flag=ext_imap4flags_iter_get_flag(&iter)) != NULL ) {
+			if ( (mret=sieve_match_value(mctx, flag, strlen(flag))) < 0 ) {
+				result = FALSE;
+				break;
+			}
+
+			matched = ( mret > 0 ); 	
+		}
+	}
+
+	if ( (mret=sieve_match_end(&mctx)) < 0 ) {
+		result = FALSE;
+	} else
+		matched = ( mret > 0 || matched ); 	
+	
+	/* Assign test result */
+	if ( result ) {
+		sieve_interpreter_set_test_result(renv->interp, matched);
+		return SIEVE_EXEC_OK;
+	}
+	
+	sieve_runtime_trace_error(renv, "invalid string list item");
+	return SIEVE_EXEC_BIN_CORRUPT;
+}
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/include/cmd-global.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/include/cmd-global.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/include/cmd-global.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/include/cmd-global.c	2009-04-10 15:11:38.000000000 +0200
@@ -0,0 +1,310 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+
+#include "sieve-common.h"
+#include "sieve-code.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h" 
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "sieve-ext-variables.h"
+
+#include "ext-include-common.h"
+#include "ext-include-binary.h"
+#include "ext-include-variables.h"
+
+/* 
+ * Commands 
+ */
+
+static bool cmd_global_validate
+  (struct sieve_validator *validator, struct sieve_command_context *cmd);
+static bool cmd_global_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *cmd);
+
+const struct sieve_command cmd_global = {
+    "global",
+    SCT_COMMAND,
+    1, 0, FALSE, FALSE,
+    NULL, NULL,
+    cmd_global_validate,
+    cmd_global_generate,
+    NULL
+};
+
+/* DEPRICATED:
+ */
+		
+/* Import command 
+ * 
+ * Syntax
+ *   import
+ */	
+const struct sieve_command cmd_import = { 
+	"import", 
+	SCT_COMMAND, 
+	1, 0, FALSE, FALSE,
+	NULL, NULL,
+	cmd_global_validate, 
+	cmd_global_generate, 
+	NULL
+};
+
+/* Export command 
+ * 
+ * Syntax
+ *   export
+ */	
+const struct sieve_command cmd_export = { 
+	"export", 
+	SCT_COMMAND, 
+	1, 0, FALSE, FALSE,
+	NULL, NULL, 
+	cmd_global_validate, 
+	cmd_global_generate, 
+	NULL
+};
+
+/*
+ * Operations
+ */
+
+static bool opc_global_dump
+	(const struct sieve_operation *op,	
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int opc_global_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+/* Global operation */
+
+const struct sieve_operation global_operation = { 
+	"global",
+	&include_extension,
+	EXT_INCLUDE_OPERATION_GLOBAL,
+	opc_global_dump, 
+	opc_global_execute
+};
+
+/*
+ * Validation
+ */
+
+static bool cmd_global_validate
+  (struct sieve_validator *validator, struct sieve_command_context *cmd) 
+{
+	struct sieve_ast_argument *arg = cmd->first_positional;
+	struct sieve_command_context *prev_context = 
+		sieve_command_prev_context(cmd);
+
+	/* Check valid command placement */
+	if ( !sieve_command_is_toplevel(cmd) ||
+		( !sieve_command_is_first(cmd) && prev_context != NULL &&
+			prev_context->command != &cmd_require ) ) {
+
+		if ( cmd->command == &cmd_global ) {
+			if ( prev_context->command != &cmd_global ) {
+				sieve_command_validate_error(validator, cmd, 
+					"a global command can only be placed at top level "
+					"at the beginning of the file after any require or other global commands");
+				return FALSE;
+			}
+		} else {
+			if ( prev_context->command != &cmd_import && prev_context->command != &cmd_export ) {
+                sieve_command_validate_error(validator, cmd,
+                    "the DEPRICATED %s command can only be placed at top level "
+                    "at the beginning of the file after any require or import/export commands",
+					cmd->command->identifier);
+                return FALSE;
+            }
+		}
+	}
+
+	/* Check for use of variables extension */	
+	if ( !sieve_ext_variables_is_active(validator) ) {
+		sieve_command_validate_error(validator, cmd, 
+			"%s command requires that variables extension is active",
+			cmd->command->identifier);
+		return FALSE;
+	}
+		
+	/* Register global variable */
+	if ( sieve_ast_argument_type(arg) == SAAT_STRING ) {
+		/* Single string */
+		const char *identifier = sieve_ast_argument_strc(arg);
+		struct sieve_variable *var;
+		
+		if ( (var=ext_include_variable_import_global
+			(validator, cmd, identifier)) == NULL )
+			return FALSE;
+			
+		arg->context = (void *) var;
+
+	} else if ( sieve_ast_argument_type(arg) == SAAT_STRING_LIST ) {
+		/* String list */
+		struct sieve_ast_argument *stritem = sieve_ast_strlist_first(arg);
+		
+		while ( stritem != NULL ) {
+			const char *identifier = sieve_ast_argument_strc(stritem);
+			struct sieve_variable *var;
+			
+			if ( (var=ext_include_variable_import_global
+				(validator, cmd, identifier)) == NULL )
+				return FALSE;
+
+			stritem->context = (void *) var;
+	
+			stritem = sieve_ast_strlist_next(stritem);
+		}
+	} else {
+		/* Something else */
+		sieve_argument_validate_error(validator, arg, 
+			"the %s command accepts a single string or string list argument, "
+			"but %s was found", cmd->command->identifier,
+			sieve_ast_argument_name(arg));
+		return FALSE;
+	}
+	
+	/* Join global commands with predecessors if possible */
+	if ( prev_context->command == cmd->command ) {
+		/* Join this command's string list with the previous one */
+		prev_context->first_positional = sieve_ast_stringlist_join
+			(prev_context->first_positional, cmd->first_positional);
+		
+		if ( prev_context->first_positional == NULL ) {
+			/* Not going to happen unless MAXINT stringlist items are specified */
+			sieve_command_validate_error(validator, cmd, 
+				"compiler reached AST limit (script too complex)");
+			return FALSE;
+		}
+
+		/* Detach this command node */
+		sieve_ast_node_detach(cmd->ast_node);
+	}
+		
+	return TRUE;
+}
+
+/*
+ * Code generation
+ */
+ 
+static bool cmd_global_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *cmd) 
+{
+	struct sieve_ast_argument *arg = cmd->first_positional;
+
+	sieve_operation_emit_code(cgenv->sbin, &global_operation);
+ 	 			
+	if ( sieve_ast_argument_type(arg) == SAAT_STRING ) {
+		/* Single string */
+		struct sieve_variable *var = (struct sieve_variable *) arg->context;
+		
+		(void)sieve_binary_emit_unsigned(cgenv->sbin, 1);
+		(void)sieve_binary_emit_unsigned(cgenv->sbin, var->index);
+		
+	} else if ( sieve_ast_argument_type(arg) == SAAT_STRING_LIST ) {
+		/* String list */
+		struct sieve_ast_argument *stritem = sieve_ast_strlist_first(arg);
+		
+		(void)sieve_binary_emit_unsigned(cgenv->sbin, sieve_ast_strlist_count(arg));
+						
+		while ( stritem != NULL ) {
+			struct sieve_variable *var = (struct sieve_variable *) stritem->context;
+			
+			(void)sieve_binary_emit_unsigned(cgenv->sbin, var->index);
+			
+			stritem = sieve_ast_strlist_next(stritem);
+		}
+	} else {
+		i_unreached();
+	}
+ 	 		
+	return TRUE;
+}
+
+/* 
+ * Code dump
+ */
+ 
+static bool opc_global_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	unsigned int count, i, var_count;
+	struct sieve_variable_scope *scope;
+	struct sieve_variable * const *vars;
+	
+	if ( !sieve_binary_read_unsigned(denv->sbin, address, &count) )
+		return FALSE;
+
+	sieve_code_dumpf(denv, "GLOBAL (count: %u):", count);
+
+	scope = ext_include_binary_get_global_scope(denv->sbin);
+	vars = sieve_variable_scope_get_variables(scope, &var_count);
+
+	sieve_code_descend(denv);
+
+	for ( i = 0; i < count; i++ ) {
+		unsigned int index;
+		
+		sieve_code_mark(denv);
+		if ( !sieve_binary_read_unsigned(denv->sbin, address, &index) ||
+			index >= var_count )
+			return FALSE;
+			
+		sieve_code_dumpf(denv, "VAR[%d]: '%s'", index, vars[index]->identifier); 
+	}
+	 
+	return TRUE;
+}
+
+/* 
+ * Execution
+ */
+ 
+static int opc_global_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	struct sieve_variable_scope *scope;	
+	struct sieve_variable_storage *storage;
+	struct sieve_variable * const *vars;
+	unsigned int var_count, count, i;
+		
+	if ( !sieve_binary_read_unsigned(renv->sbin, address, &count) ) {
+		sieve_runtime_trace_error(renv, "invalid count operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	scope = ext_include_binary_get_global_scope(renv->sbin);
+	vars = sieve_variable_scope_get_variables(scope, &var_count);
+	storage = ext_include_interpreter_get_global_variables(renv->interp);
+
+	for ( i = 0; i < count; i++ ) {
+		unsigned int index;
+		
+		if ( !sieve_binary_read_unsigned(renv->sbin, address, &index) ) {
+			sieve_runtime_trace_error(renv, "invalid global variable operand");
+			return SIEVE_EXEC_BIN_CORRUPT;
+		}
+		
+		if ( index >= var_count ) {
+			sieve_runtime_trace_error(renv, "invalid global variable index (%u > %u)",
+				index, var_count);
+			return SIEVE_EXEC_BIN_CORRUPT;
+		}
+		
+		/* Make sure variable is initialized (export) */
+		(void)sieve_variable_get_modifiable(storage, index, NULL); 
+	}
+
+	return SIEVE_EXEC_OK;
+}
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/include/cmd-include.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/include/cmd-include.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/include/cmd-include.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/include/cmd-include.c	2009-08-04 19:14:52.000000000 +0200
@@ -0,0 +1,360 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str-sanitize.h"
+
+#include "sieve-common.h"
+#include "sieve-script.h"
+#include "sieve-ast.h"
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-binary.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "ext-include-common.h"
+#include "ext-include-binary.h"
+
+/* 
+ * Include command 
+ *	
+ * Syntax: 
+ *   include [LOCATION] <value: string>
+ *
+ * [LOCATION]:      
+ *   ":personal" / ":global"
+ */
+
+static bool cmd_include_registered
+	(struct sieve_validator *validator, 
+		struct sieve_command_registration *cmd_reg);
+static bool cmd_include_pre_validate
+	(struct sieve_validator *validator ATTR_UNUSED, 
+		struct sieve_command_context *cmd);
+static bool cmd_include_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd);
+static bool cmd_include_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command cmd_include = { 
+	"include",
+	SCT_COMMAND, 
+	1, 0, FALSE, FALSE, 
+	cmd_include_registered,
+	cmd_include_pre_validate,  
+	cmd_include_validate, 
+	cmd_include_generate, 
+	NULL 
+};
+
+/* 
+ * Include operation 
+ */
+
+static bool opc_include_dump
+	(const struct sieve_operation *op,	
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int opc_include_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation include_operation = { 
+	"include",
+	&include_extension,
+	EXT_INCLUDE_OPERATION_INCLUDE,
+	opc_include_dump, 
+	opc_include_execute
+};
+
+/* 
+ * Context structures 
+ */
+
+struct cmd_include_context_data {
+	enum ext_include_script_location location;
+	bool location_assigned;
+	
+	bool include_once;
+	
+	struct sieve_script *script;
+};   
+
+/* 
+ * Tagged arguments
+ */
+
+static bool cmd_include_validate_location_tag
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+
+static const struct sieve_argument include_personal_tag = { 
+	"personal", 
+	NULL, NULL,
+	cmd_include_validate_location_tag, 
+	NULL, NULL 
+};
+
+static const struct sieve_argument include_global_tag = { 
+	"global", 
+	NULL, NULL,
+	cmd_include_validate_location_tag, 
+	NULL, NULL 
+};
+
+static bool cmd_include_validate_once_tag
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+
+static const struct sieve_argument include_once_tag = { 
+	"once", 
+	NULL, NULL,
+	cmd_include_validate_once_tag, 
+	NULL, NULL 
+};
+
+/* 
+ * Tag validation 
+ */
+
+static bool cmd_include_validate_location_tag
+(struct sieve_validator *validator,	struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd)
+{    
+	struct cmd_include_context_data *ctx_data = 
+		(struct cmd_include_context_data *) cmd->data;
+	
+	if ( ctx_data->location_assigned) {
+		sieve_argument_validate_error(validator, *arg, 
+			"include: cannot use location tags ':personal' and ':global' "
+			"multiple times");
+		return FALSE;
+	}
+	
+	if ( (*arg)->argument == &include_personal_tag )
+		ctx_data->location = EXT_INCLUDE_LOCATION_PERSONAL;
+	else if ( (*arg)->argument == &include_global_tag )
+		ctx_data->location = EXT_INCLUDE_LOCATION_GLOBAL;
+	else
+		return FALSE;
+	
+	ctx_data->location_assigned = TRUE;
+
+	/* Delete this tag (for now) */
+	*arg = sieve_ast_arguments_detach(*arg, 1);
+
+	return TRUE;
+}
+
+static bool cmd_include_validate_once_tag
+(struct sieve_validator *validator ATTR_UNUSED, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd)
+{    
+	struct cmd_include_context_data *ctx_data = 
+		(struct cmd_include_context_data *) cmd->data;
+
+	ctx_data->include_once = TRUE;
+	
+	/* Delete this tag (for now) */
+	*arg = sieve_ast_arguments_detach(*arg, 1);
+
+	return TRUE;
+}
+
+/* 
+ * Command registration 
+ */
+
+static bool cmd_include_registered
+	(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg) 
+{
+	sieve_validator_register_tag
+		(validator, cmd_reg, &include_personal_tag, 0); 	
+	sieve_validator_register_tag
+		(validator, cmd_reg, &include_global_tag, 0); 	
+	sieve_validator_register_tag
+		(validator, cmd_reg, &include_once_tag, 0); 	
+
+	return TRUE;
+}
+
+/* 
+ * Command validation 
+ */
+
+static bool cmd_include_pre_validate
+	(struct sieve_validator *validator ATTR_UNUSED, 
+		struct sieve_command_context *cmd)
+{
+	struct cmd_include_context_data *ctx_data;
+
+	/* Assign context */
+	ctx_data = p_new(sieve_command_pool(cmd), struct cmd_include_context_data, 1);
+	ctx_data->location = EXT_INCLUDE_LOCATION_PERSONAL;
+	cmd->data = ctx_data;
+	
+	return TRUE;
+}
+
+static bool cmd_include_validate(struct sieve_validator *validator, 
+	struct sieve_command_context *cmd) 
+{ 	
+	struct sieve_ast_argument *arg = cmd->first_positional;
+	struct cmd_include_context_data *ctx_data = 
+		(struct cmd_include_context_data *) cmd->data;
+	struct sieve_script *script;
+	const char *script_path, *script_name;
+	bool exists = TRUE;
+	
+	/* Check argument */
+	if ( !sieve_validate_positional_argument
+		(validator, cmd, arg, "value", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(validator, cmd, arg, FALSE) )
+		return FALSE;
+
+	/* 
+	 * Variables are not allowed.
+	 */
+	if ( !sieve_argument_is_string_literal(arg) ) {
+		sieve_argument_validate_error(validator, arg, 
+			"the include command requires a constant string for its value argument");
+		return FALSE;
+	}
+
+	/* Find the script */
+
+	script_name = sieve_ast_argument_strc(arg);
+
+	if ( strchr(script_name, '/') != NULL ) {
+ 		sieve_argument_validate_error(validator, arg,
+			"include: '/' not allowed in script name (%s)",
+			str_sanitize(script_name, 80));
+		return FALSE;
+	}
+		
+	script_path = ext_include_get_script_directory
+		(ctx_data->location, script_name);
+	if ( script_path == NULL ) {
+		sieve_argument_validate_error(validator, arg,
+			"include: %s location for included script '%s' is unavailable "
+			"(contact system administrator for more information)",
+			ext_include_script_location_name(ctx_data->location),
+			str_sanitize(script_name, 80));
+		return FALSE;
+	}
+	
+	/* Create script object */
+	script = sieve_script_create_in_directory(script_path, script_name, 
+		sieve_validator_error_handler(validator), &exists);
+	if ( script == NULL ) {
+		if ( !exists ) {
+			sieve_argument_validate_error(validator, arg, 
+				"included %s script '%s' does not exist", 
+				ext_include_script_location_name(ctx_data->location),
+				str_sanitize(script_name, 80));
+		}
+		return FALSE;
+	}
+
+	ext_include_ast_link_included_script(cmd->ast_node->ast, script);		
+	ctx_data->script = script;
+		
+	arg = sieve_ast_arguments_detach(arg, 1);
+	
+	return TRUE;
+}
+
+/*
+ * Code Generation
+ */
+ 
+static bool cmd_include_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *cmd) 
+{
+	struct cmd_include_context_data *ctx_data = 
+		(struct cmd_include_context_data *) cmd->data;
+	const struct ext_include_script_info *included;
+	unsigned int flags = ctx_data->include_once;
+
+	/* Compile (if necessary) and include the script into the binary.
+	 * This yields the id of the binary block containing the compiled byte code.  
+	 */
+	if ( !ext_include_generate_include
+		(cgenv, cmd, ctx_data->location, ctx_data->script, &included,
+			ctx_data->include_once) )
+ 		return FALSE;
+ 		
+ 	(void)sieve_operation_emit_code(cgenv->sbin, &include_operation);
+	(void)sieve_binary_emit_unsigned(cgenv->sbin, included->id); 
+	(void)sieve_binary_emit_byte(cgenv->sbin, flags); 
+ 	 		
+	return TRUE;
+}
+
+/* 
+ * Code dump
+ */
+ 
+static bool opc_include_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	const struct ext_include_script_info *included;
+	struct ext_include_binary_context *binctx;
+	unsigned int include_id, flags;
+
+	sieve_code_dumpf(denv, "INCLUDE:");
+	
+	sieve_code_mark(denv);
+	if ( !sieve_binary_read_unsigned(denv->sbin, address, &include_id) )
+		return FALSE;
+
+	if ( !sieve_binary_read_byte(denv->sbin, address, &flags) )
+		return FALSE;
+
+	binctx = ext_include_binary_get_context(denv->sbin);
+	included = ext_include_binary_script_get_included(binctx, include_id);
+	if ( included == NULL )
+		return FALSE;
+		
+	sieve_code_descend(denv);
+	sieve_code_dumpf(denv, "script: %s %s[ID: %d, BLOCK: %d]", 
+		sieve_script_filename(included->script), (flags & 0x01 ? "(once) " : ""),
+		include_id, included->block_id);
+
+	return TRUE;
+}
+
+/* 
+ * Execution
+ */
+ 
+static int opc_include_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	unsigned int include_id, flags;
+		
+	if ( !sieve_binary_read_unsigned(renv->sbin, address, &include_id) ) {
+		sieve_runtime_trace_error(renv, "invalid include-id operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	if ( !sieve_binary_read_unsigned(renv->sbin, address, &flags) ) {
+		sieve_runtime_trace_error(renv, "invalid flags operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	return ext_include_execute_include(renv, include_id, flags & 0x01);
+}
+
+
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/include/cmd-return.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/include/cmd-return.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/include/cmd-return.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/include/cmd-return.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,78 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+
+#include "sieve-code.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h" 
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+
+#include "ext-include-common.h"
+
+/* 
+ * Return command 
+ * 
+ * Syntax
+ *   return
+ */
+
+static bool cmd_return_generate
+	(const struct sieve_codegen_env *cgenv, 
+		struct sieve_command_context *ctx ATTR_UNUSED);
+	
+const struct sieve_command cmd_return = { 
+	"return", 
+	SCT_COMMAND, 
+	0, 0, FALSE, FALSE,
+	NULL, NULL, NULL, 
+	cmd_return_generate, 
+	NULL
+};
+
+/* 
+ * Return operation 
+ */
+
+static int opc_return_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation return_operation = { 
+	"return",
+	&include_extension,
+	EXT_INCLUDE_OPERATION_RETURN,
+	NULL, 
+	opc_return_execute 
+};
+
+/*
+ * Code generation
+ */
+
+static bool cmd_return_generate
+(const struct sieve_codegen_env *cgenv, 
+	struct sieve_command_context *ctx ATTR_UNUSED) 
+{
+	sieve_operation_emit_code(cgenv->sbin, &return_operation);
+
+	return TRUE;
+}
+
+/*
+ * Execution
+ */
+
+static int opc_return_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, 
+	sieve_size_t *address ATTR_UNUSED)
+{	
+	sieve_runtime_trace(renv, "RETURN command");
+
+	ext_include_execute_return(renv);
+	return SIEVE_EXEC_OK;
+}
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-binary.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-binary.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-binary.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-binary.c	2009-08-08 14:57:37.000000000 +0200
@@ -0,0 +1,425 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+
+#include "sieve-common.h"
+#include "sieve-error.h"
+#include "sieve-script.h"
+#include "sieve-binary.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "sieve-ext-variables.h"
+
+#include "ext-include-common.h"
+#include "ext-include-limits.h"
+#include "ext-include-variables.h"
+#include "ext-include-binary.h"
+
+/*
+ * Forward declarations
+ */
+ 
+static bool ext_include_binary_save(struct sieve_binary *sbin);
+static bool ext_include_binary_open(struct sieve_binary *sbin);
+static bool ext_include_binary_up_to_date(struct sieve_binary *sbin);
+static void ext_include_binary_free(struct sieve_binary *sbin);
+
+/* 
+ * Binary include extension
+ */
+ 
+const struct sieve_binary_extension include_binary_ext = {
+	&include_extension,
+	ext_include_binary_save,
+	ext_include_binary_open,
+	ext_include_binary_free,
+	ext_include_binary_up_to_date
+};
+
+/*
+ * Binary context management
+ */
+ 
+struct ext_include_binary_context {
+	struct sieve_binary *binary;
+	unsigned int dependency_block;
+	
+	struct hash_table *included_scripts;
+	ARRAY_DEFINE(include_index, struct ext_include_script_info *);
+
+	struct sieve_variable_scope *global_vars;
+};
+
+ 
+static struct ext_include_binary_context *ext_include_binary_create_context
+(struct sieve_binary *sbin)
+{
+	pool_t pool = sieve_binary_pool(sbin);
+	
+	struct ext_include_binary_context *ctx = 
+		p_new(pool, struct ext_include_binary_context, 1);
+	
+	ctx->binary = sbin;			
+	ctx->included_scripts = hash_table_create(default_pool, pool, 0, 
+		(hash_callback_t *) sieve_script_hash, 
+		(hash_cmp_callback_t *) sieve_script_cmp);
+	p_array_init(&ctx->include_index, pool, 128);
+
+	sieve_binary_extension_set(sbin, &include_binary_ext, ctx);
+
+	return ctx;
+}
+
+struct ext_include_binary_context *ext_include_binary_get_context
+(struct sieve_binary *sbin)
+{	
+	struct ext_include_binary_context *ctx = (struct ext_include_binary_context *)
+		sieve_binary_extension_get_context(sbin, &include_extension);
+	
+	if ( ctx == NULL )
+		ctx = ext_include_binary_create_context(sbin);
+	
+	return ctx;
+}
+ 
+struct ext_include_binary_context *ext_include_binary_init
+(struct sieve_binary *sbin, struct sieve_ast *ast)
+{
+	struct ext_include_ast_context *ast_ctx =
+		ext_include_get_ast_context(ast);
+	struct ext_include_binary_context *ctx;
+	
+	/* Get/create our context from the binary we are working on */
+	ctx = ext_include_binary_get_context(sbin);
+	
+	/* Create dependency block */
+	if ( ctx->dependency_block == 0 )
+		ctx->dependency_block = 
+			sieve_binary_extension_create_block(sbin, &include_extension);
+
+	if ( ctx->global_vars == NULL ) {
+		ctx->global_vars = ast_ctx->global_vars;
+		sieve_variable_scope_ref(ctx->global_vars);
+	}
+			
+	return ctx;
+}
+
+/*
+ * Script inclusion
+ */
+
+const struct ext_include_script_info *ext_include_binary_script_include
+(struct ext_include_binary_context *binctx, struct sieve_script *script,
+	enum ext_include_script_location location, unsigned int block_id)
+{
+	pool_t pool = sieve_binary_pool(binctx->binary);
+	struct ext_include_script_info *incscript;
+
+	incscript = p_new(pool, struct ext_include_script_info, 1);
+	incscript->id = array_count(&binctx->include_index)+1;
+	incscript->script = script;
+	incscript->location = location;
+	incscript->block_id = block_id;
+	
+	/* Unreferenced on binary_free */
+	sieve_script_ref(script);
+	
+	hash_table_insert(binctx->included_scripts, (void *) script, (void *) incscript);
+	array_append(&binctx->include_index, &incscript, 1);
+
+	return incscript;
+}
+
+bool ext_include_binary_script_is_included
+(struct ext_include_binary_context *binctx, struct sieve_script *script,
+	const struct ext_include_script_info **script_info_r)
+{
+	struct ext_include_script_info *incscript = (struct ext_include_script_info *)
+		hash_table_lookup(binctx->included_scripts, script);
+		
+	if ( incscript == NULL )
+		return FALSE;
+				
+	*script_info_r = incscript;
+	return TRUE;
+}
+
+const struct ext_include_script_info *ext_include_binary_script_get_included
+(struct ext_include_binary_context *binctx, unsigned int include_id)
+{		
+	if ( include_id > 0 && (include_id - 1) < array_count(&binctx->include_index) ) {
+		struct ext_include_script_info *const *sinfo =
+			array_idx(&binctx->include_index, include_id - 1);
+
+		return *sinfo;
+	}
+
+	return NULL;
+}
+
+const struct ext_include_script_info *ext_include_binary_script_get
+(struct ext_include_binary_context *binctx, struct sieve_script *script)
+{
+	return (struct ext_include_script_info *)
+		hash_table_lookup(binctx->included_scripts, script);
+}
+
+unsigned int ext_include_binary_script_get_count
+(struct ext_include_binary_context *binctx)
+{
+	return array_count(&binctx->include_index);
+}
+
+/*
+ * Variables 
+ */
+
+struct sieve_variable_scope *ext_include_binary_get_global_scope
+(struct sieve_binary *sbin)
+{
+	struct ext_include_binary_context *binctx = 
+		ext_include_binary_get_context(sbin);
+
+	return binctx->global_vars;
+}
+
+/*
+ * Binary extension
+ */
+
+static bool ext_include_binary_save(struct sieve_binary *sbin)
+{
+	struct ext_include_binary_context *binctx = 
+		ext_include_binary_get_context(sbin);
+	struct ext_include_script_info *const *scripts;
+	unsigned int script_count, i;
+	unsigned int prvblk;
+	bool result = TRUE;
+	
+	sieve_binary_block_clear(sbin, binctx->dependency_block);
+	if ( !sieve_binary_block_set_active(sbin, binctx->dependency_block, &prvblk) )	
+		return FALSE;
+
+	scripts = array_get(&binctx->include_index, &script_count);
+
+	sieve_binary_emit_unsigned(sbin, script_count);
+
+	for ( i = 0; i < script_count; i++ ) {
+		struct ext_include_script_info *incscript = scripts[i];
+
+		sieve_binary_emit_unsigned(sbin, incscript->block_id);
+		sieve_binary_emit_byte(sbin, incscript->location);
+		sieve_binary_emit_cstring(sbin, sieve_script_name(incscript->script));
+	}
+
+	result = ext_include_variables_save(sbin, binctx->global_vars);
+	
+	(void) sieve_binary_block_set_active(sbin, prvblk, NULL);
+
+	return result;
+}
+
+static bool ext_include_binary_open(struct sieve_binary *sbin)
+{
+	struct ext_include_binary_context *binctx; 
+	unsigned int block, prvblk, depcount, i;
+	sieve_size_t offset;
+	
+	block = sieve_binary_extension_get_block(sbin, &include_extension);
+	
+	if ( !sieve_binary_block_set_active(sbin, block, &prvblk) )
+		return FALSE; 
+		
+	offset = 0;	
+		
+	if ( !sieve_binary_read_unsigned(sbin, &offset, &depcount) ) {
+		sieve_sys_error("include: failed to read include count "
+			"for dependency block %d of binary %s", block, sieve_binary_path(sbin)); 
+		return FALSE;
+	}
+	
+	binctx = ext_include_binary_get_context(sbin);
+
+	/* Check include limit */	
+	if ( depcount > EXT_INCLUDE_MAX_INCLUDES ) {
+		sieve_sys_error("include: binary %s includes too many scripts (%u > %u)",
+			sieve_binary_path(sbin), depcount, EXT_INCLUDE_MAX_INCLUDES); 
+		return FALSE;
+	}
+	
+	/* Read dependencies */
+	for ( i = 0; i < depcount; i++ ) {
+		unsigned int block_id;
+		enum ext_include_script_location location;
+		string_t *script_name;
+		const char *script_dir;
+		struct sieve_script *script;
+		
+		if ( 
+			!sieve_binary_read_unsigned(sbin, &offset, &block_id) ||
+			!sieve_binary_read_byte(sbin, &offset, &location) ||
+			!sieve_binary_read_string(sbin, &offset, &script_name) ) {
+			/* Binary is corrupt, recompile */
+			sieve_sys_error("include: failed to read included script "
+				"from dependency block %d of binary %s", block, sieve_binary_path(sbin)); 
+			return FALSE;
+		}
+		
+		if ( location >= EXT_INCLUDE_LOCATION_INVALID ) {
+			/* Binary is corrupt, recompile */
+			sieve_sys_error("include: dependency block %d of binary %s "
+				"reports invalid script location (id %d)", 
+				block, sieve_binary_path(sbin), location); 
+			return FALSE;
+		}		
+		
+		/* Can we find/open the script dependency ? */
+		script_dir = ext_include_get_script_directory(location, str_c(script_name));		
+		if ( script_dir == NULL || 
+			!(script=sieve_script_create_in_directory
+				(script_dir, str_c(script_name), NULL, NULL)) ) {
+			/* No, recompile */
+			return FALSE;
+		}
+		
+		(void)ext_include_binary_script_include(binctx, script, location, block_id);
+				
+		sieve_script_unref(&script);
+	}
+
+	if ( !ext_include_variables_load(sbin, &offset, block, &binctx->global_vars) )
+		return FALSE;
+	
+	/* Restore previously active block */
+	(void)sieve_binary_block_set_active(sbin, prvblk, NULL);
+
+	return TRUE;	
+}
+
+static bool ext_include_binary_up_to_date(struct sieve_binary *sbin)
+{
+	struct ext_include_binary_context *binctx = 
+		ext_include_binary_get_context(sbin);
+	struct hash_iterate_context *hctx;
+	void *key, *value;
+		
+	/* Check all included scripts for changes */
+	hctx = hash_table_iterate_init(binctx->included_scripts);
+	while ( hash_table_iterate(hctx, &key, &value) ) {
+		struct ext_include_script_info *incscript = (struct ext_include_script_info *) value;
+		
+		/* Is the binary newer than this dependency? */
+		if ( !sieve_binary_script_older(sbin, incscript->script) ) {
+			/* No, recompile */
+			return FALSE;
+		}
+	}
+	hash_table_iterate_deinit(&hctx);
+
+	return TRUE;
+}
+
+static void ext_include_binary_free(struct sieve_binary *sbin)
+{
+	struct ext_include_binary_context *binctx = 
+		ext_include_binary_get_context(sbin);
+	struct hash_iterate_context *hctx;
+	void *key, *value;
+		
+	/* Release references to all included script objects */
+	hctx = hash_table_iterate_init(binctx->included_scripts);
+	while ( hash_table_iterate(hctx, &key, &value) ) {
+		struct ext_include_script_info *incscript = (struct ext_include_script_info *) value;
+		
+		sieve_script_unref(&incscript->script);
+	}
+	hash_table_iterate_deinit(&hctx);
+
+	hash_table_destroy(&binctx->included_scripts);
+
+	if ( binctx->global_vars != NULL ) 
+		sieve_variable_scope_unref(&binctx->global_vars);
+}
+
+/*
+ * Dumping the binary 
+ */
+
+inline static const char *_script_location
+(enum ext_include_script_location loc)
+{
+	switch ( loc ) {
+	case EXT_INCLUDE_LOCATION_PERSONAL:
+		return "personal";
+	case EXT_INCLUDE_LOCATION_GLOBAL:
+		return "global";
+	default:
+		break;
+	}
+	
+	return "<<INVALID LOCATION>>";
+}
+
+bool ext_include_binary_dump(struct sieve_dumptime_env *denv)
+{
+	struct sieve_binary *sbin = denv->sbin;
+	struct ext_include_binary_context *binctx = 
+		ext_include_binary_get_context(sbin);
+	struct hash_iterate_context *hctx;
+	void *key, *value;
+	unsigned int prvblk = 0;
+
+	if ( !ext_include_variables_dump(denv, binctx->global_vars) )
+		return FALSE;
+
+	hctx = hash_table_iterate_init(binctx->included_scripts);		
+	while ( hash_table_iterate(hctx, &key, &value) ) {
+		struct ext_include_script_info *incscript = (struct ext_include_script_info *) value;
+
+		sieve_binary_dump_sectionf(denv, "Included %s script '%s' (block: %d)", 
+			_script_location(incscript->location), 
+			sieve_script_name(incscript->script), incscript->block_id);
+			
+		if ( prvblk == 0 ) {
+			if ( !sieve_binary_block_set_active(sbin, incscript->block_id, &prvblk) )	
+				return FALSE;
+		} else {
+			if ( !sieve_binary_block_set_active(sbin, incscript->block_id, NULL) )	
+				return FALSE;
+		}
+				
+		denv->cdumper = sieve_code_dumper_create(denv);
+
+		if ( denv->cdumper == NULL )
+			return FALSE;
+
+		sieve_code_dumper_run(denv->cdumper);
+		sieve_code_dumper_free(&(denv->cdumper));
+	}
+	
+	if ( !sieve_binary_block_set_active(sbin, prvblk, NULL) ) 
+		return FALSE;
+	
+	hash_table_iterate_deinit(&hctx);
+	
+	return TRUE;
+}
+
+bool ext_include_code_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address ATTR_UNUSED)
+{
+	struct sieve_binary *sbin = denv->sbin;
+	struct ext_include_binary_context *binctx = 
+		ext_include_binary_get_context(sbin);
+	
+	sieve_ext_variables_dump_set_scope(denv, &include_extension, binctx->global_vars);
+
+	return TRUE;
+}
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-binary.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-binary.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-binary.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-binary.h	2009-07-29 01:52:02.000000000 +0200
@@ -0,0 +1,63 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_INCLUDE_BINARY_H
+#define __EXT_INCLUDE_BINARY_H
+
+#include "sieve-common.h"
+
+/*
+ * Binary context management
+ */
+
+struct ext_include_binary_context;
+
+struct ext_include_binary_context *ext_include_binary_init
+	(struct sieve_binary *sbin, struct sieve_ast *ast);
+struct ext_include_binary_context *ext_include_binary_get_context
+	(struct sieve_binary *sbin);
+
+/*
+ * Variables
+ */
+
+struct sieve_variable_scope *ext_include_binary_get_global_scope
+    (struct sieve_binary *sbin);
+
+/*
+ * Including scripts
+ */
+
+struct ext_include_script_info {
+    unsigned int id;
+
+    struct sieve_script *script;
+    enum ext_include_script_location location;
+
+    unsigned int block_id;
+};
+
+const struct ext_include_script_info *ext_include_binary_script_include
+	(struct ext_include_binary_context *binctx, struct sieve_script *script,
+		enum ext_include_script_location location, unsigned int block_id);
+bool ext_include_binary_script_is_included
+	(struct ext_include_binary_context *binctx, struct sieve_script *script,
+		const struct ext_include_script_info **script_info_r);
+
+const struct ext_include_script_info *ext_include_binary_script_get_included
+	(struct ext_include_binary_context *binctx, unsigned int include_id);
+const struct ext_include_script_info *ext_include_binary_script_get
+	(struct ext_include_binary_context *binctx, struct sieve_script *script);
+unsigned int ext_include_binary_script_get_count
+	(struct ext_include_binary_context *binctx);
+
+/*
+ * Dumping the binary
+ */
+
+bool ext_include_binary_dump(struct sieve_dumptime_env *denv);
+bool ext_include_code_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address ATTR_UNUSED);
+		
+#endif /* __EXT_INCLUDE_BINARY_H */
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include.c	2009-07-29 01:52:20.000000000 +0200
@@ -0,0 +1,109 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension include
+ * -----------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: draft-ietf-sieve-include-01
+ * Implementation: almost full; global namespace is missing. 
+ * Status: experimental
+ * 
+ */
+ 
+/* FIXME: Current include implementation does not allow for parts of the script
+ * to be located in external binaries; all included scripts are recompiled and
+ * the resulting byte code is imported into the main binary in separate blocks.
+ */
+ 
+#include "lib.h"
+
+#include "sieve-common.h"
+
+#include "sieve-extensions.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-binary.h"
+#include "sieve-dump.h"
+
+#include "ext-include-common.h"
+#include "ext-include-binary.h"
+
+/* 
+ * Operations 
+ */
+
+static const struct sieve_operation *ext_include_operations[] = { 
+	&include_operation, 
+	&return_operation,
+	&global_operation
+};
+
+/* 
+ * Extension
+ */
+ 
+/* Forward declaration */
+
+static bool ext_include_validator_load(struct sieve_validator *validator);
+static bool ext_include_generator_load(const struct sieve_codegen_env *cgenv);
+static bool ext_include_interpreter_load
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+static bool ext_include_binary_load(struct sieve_binary *binary);
+
+/* Extension objects */
+
+static int ext_my_id = -1;
+
+const struct sieve_extension include_extension = { 
+	"include", 
+	&ext_my_id,
+	NULL, NULL,
+	ext_include_validator_load, 
+	ext_include_generator_load,
+	ext_include_interpreter_load,
+	ext_include_binary_load,
+	ext_include_binary_dump,
+	ext_include_code_dump,
+	SIEVE_EXT_DEFINE_OPERATIONS(ext_include_operations),
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+/* Extension hooks */
+
+static bool ext_include_validator_load(struct sieve_validator *validator)
+{
+	/* Register new commands */
+	sieve_validator_register_command(validator, &cmd_include);
+	sieve_validator_register_command(validator, &cmd_return);
+	sieve_validator_register_command(validator, &cmd_global);
+
+	/* DEPRICATED */
+	sieve_validator_register_command(validator, &cmd_import);
+	sieve_validator_register_command(validator, &cmd_export);
+
+	return TRUE;
+}	
+
+static bool ext_include_generator_load(const struct sieve_codegen_env *cgenv)
+{
+	ext_include_register_generator_context(cgenv);
+
+	return TRUE;
+}
+
+static bool ext_include_interpreter_load
+(const struct sieve_runtime_env *renv, sieve_size_t *address ATTR_UNUSED)
+{
+	ext_include_interpreter_context_init(renv->interp);
+	
+	return TRUE;
+}
+
+static bool ext_include_binary_load(struct sieve_binary *sbin)
+{
+	(void)ext_include_binary_get_context(sbin);
+
+	return TRUE;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-common.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-common.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-common.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-common.c	2009-08-08 14:57:37.000000000 +0200
@@ -0,0 +1,711 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "array.h"
+#include "str-sanitize.h"
+#include "home-expand.h"
+
+#include "sieve-common.h"
+#include "sieve-error.h"
+#include "sieve-script.h"
+#include "sieve-ast.h"
+#include "sieve-binary.h"
+#include "sieve-commands.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+
+#include "ext-include-common.h"
+#include "ext-include-limits.h"
+#include "ext-include-binary.h"
+#include "ext-include-variables.h"
+
+#include <stdlib.h>
+
+/*
+ * Forward declarations
+ */
+
+/* Generator context */
+
+struct ext_include_generator_context {
+	unsigned int nesting_level;
+	struct sieve_script *script;
+	struct ext_include_generator_context *parent;
+};
+
+static inline struct ext_include_generator_context *
+	ext_include_get_generator_context
+	(struct sieve_generator *gentr);
+
+/* Interpreter context */
+
+struct ext_include_interpreter_global {
+	ARRAY_DEFINE(included_scripts, struct sieve_script *);
+
+	struct sieve_variable_storage *variables;
+};
+
+struct ext_include_interpreter_context {
+	struct ext_include_interpreter_context *parent;
+	struct ext_include_interpreter_global *global;
+
+	struct sieve_interpreter *interp;
+	pool_t pool;
+
+	unsigned int nesting_level;
+
+	struct sieve_script *script;
+	const struct ext_include_script_info *script_info;
+	
+	const struct ext_include_script_info *include;
+	bool returned;
+};
+
+/* 
+ * Script access 
+ */
+
+const char *ext_include_get_script_directory
+(enum ext_include_script_location location, const char *script_name)
+{
+	const char *home, *sieve_dir;
+
+	switch ( location ) {
+	case EXT_INCLUDE_LOCATION_PERSONAL:
+		sieve_dir = getenv("SIEVE_DIR");
+		home = getenv("HOME");
+
+		if (sieve_dir == NULL) {
+			if ( home == NULL )	{		
+				sieve_sys_error(
+					"include: sieve_dir and home not set for :personal script include "	
+					"(wanted script '%s')", str_sanitize(script_name, 80));
+				return NULL;
+			}
+
+			sieve_dir = "~/sieve"; 
+		}
+
+		if ( home != NULL )
+			sieve_dir = home_expand_tilde(sieve_dir, home);	
+
+		break;
+   	case EXT_INCLUDE_LOCATION_GLOBAL:
+		sieve_dir = getenv("SIEVE_GLOBAL_DIR");
+
+		if (sieve_dir == NULL) {
+			sieve_sys_error(
+				"include: sieve_global_dir not set for :global script include "	
+				"(wanted script '%s')", str_sanitize(script_name, 80));
+			return NULL;
+		}
+
+		break;
+	default:
+		return NULL;
+	}
+
+
+	return sieve_dir;
+}
+
+/*
+ * AST context management
+ */
+
+static void ext_include_ast_free
+(struct sieve_ast *ast ATTR_UNUSED, void *context)
+{
+	struct ext_include_ast_context *actx = 
+		(struct ext_include_ast_context *) context;
+	struct sieve_script **scripts;
+	unsigned int count, i;
+
+	/* Unreference included scripts */
+	scripts = array_get_modifiable(&actx->included_scripts, &count);
+	for ( i = 0; i < count; i++ ) {
+		sieve_script_unref(&scripts[i]);
+	}	
+
+	/* Unreference variable scopes */
+	if ( actx->global_vars != NULL )
+		sieve_variable_scope_unref(&actx->global_vars);
+}
+
+static const struct sieve_ast_extension include_ast_extension = {
+	&include_extension,
+	ext_include_ast_free
+};
+
+struct ext_include_ast_context *ext_include_create_ast_context
+(struct sieve_ast *ast, struct sieve_ast *parent)
+{
+	struct ext_include_ast_context *actx;
+
+	pool_t pool = sieve_ast_pool(ast);
+	actx = p_new(pool, struct ext_include_ast_context, 1);
+	p_array_init(&actx->included_scripts, pool, 32);
+
+	if ( parent != NULL ) {
+		struct ext_include_ast_context *parent_ctx =
+			(struct ext_include_ast_context *)
+				sieve_ast_extension_get_context(parent, &include_extension);
+		actx->global_vars = parent_ctx->global_vars;
+
+		i_assert( actx->global_vars != NULL );
+
+		sieve_variable_scope_ref(actx->global_vars);
+	} else
+		actx->global_vars = sieve_variable_scope_create(&include_extension);			
+
+	sieve_ast_extension_register(ast, &include_ast_extension, (void *) actx);
+
+	return actx;
+}
+
+struct ext_include_ast_context *ext_include_get_ast_context
+(struct sieve_ast *ast)
+{
+	struct ext_include_ast_context *actx = (struct ext_include_ast_context *)
+		sieve_ast_extension_get_context(ast, &include_extension);
+
+	if ( actx != NULL ) return actx;
+
+	return ext_include_create_ast_context(ast, NULL);
+}
+
+void ext_include_ast_link_included_script
+(struct sieve_ast *ast, struct sieve_script *script) 
+{
+	struct ext_include_ast_context *actx = ext_include_get_ast_context(ast);
+
+	array_append(&actx->included_scripts, &script, 1);
+}
+
+/* 
+ * Generator context management 
+ */
+ 
+static struct ext_include_generator_context *
+	ext_include_create_generator_context
+(struct sieve_generator *gentr, struct ext_include_generator_context *parent, 
+	struct sieve_script *script)
+{	
+	struct ext_include_generator_context *ctx;
+
+	pool_t pool = sieve_generator_pool(gentr);
+	ctx = p_new(pool, struct ext_include_generator_context, 1);
+	ctx->parent = parent;
+	ctx->script = script;
+	if ( parent == NULL ) {
+		ctx->nesting_level = 0;
+	} else {
+		ctx->nesting_level = parent->nesting_level + 1;
+	}
+	
+	return ctx;
+}
+
+static inline struct ext_include_generator_context *
+	ext_include_get_generator_context
+(struct sieve_generator *gentr)
+{
+	return (struct ext_include_generator_context *)
+		sieve_generator_extension_get_context(gentr, &include_extension);
+}
+
+static inline void ext_include_initialize_generator_context
+(struct sieve_generator *gentr, struct ext_include_generator_context *parent, 
+	struct sieve_script *script)
+{
+	sieve_generator_extension_set_context(gentr, &include_extension,
+		ext_include_create_generator_context(gentr, parent, script));
+}
+
+void ext_include_register_generator_context
+(const struct sieve_codegen_env *cgenv)
+{
+	struct ext_include_generator_context *ctx = 
+		ext_include_get_generator_context(cgenv->gentr);
+	
+	/* Initialize generator context if necessary */
+	if ( ctx == NULL ) {
+		ctx = ext_include_create_generator_context(
+			cgenv->gentr, NULL, cgenv->script);
+		
+		sieve_generator_extension_set_context
+			(cgenv->gentr, &include_extension, (void *) ctx);		
+	}
+
+	/* Initialize ast context if necessary */
+	(void)ext_include_get_ast_context(cgenv->ast);
+	(void)ext_include_binary_init(cgenv->sbin, cgenv->ast);
+}
+
+/*
+ * Runtime initialization
+ */
+
+static void ext_include_runtime_init
+    (const struct sieve_runtime_env *renv, void *context)
+{
+	struct ext_include_interpreter_context *ctx = 
+		(struct ext_include_interpreter_context *) context;
+
+	if ( ctx->parent == NULL ) {
+		ctx->global = p_new(ctx->pool, struct ext_include_interpreter_global, 1);
+		ctx->global->variables = sieve_variable_storage_create
+			(ctx->pool, ext_include_binary_get_global_scope(renv->sbin), 0);
+		p_array_init(&ctx->global->included_scripts, ctx->pool, 10);
+	} else {
+		ctx->global = ctx->parent->global;
+	}
+
+	sieve_ext_variables_set_storage
+		(renv->interp, ctx->global->variables, &include_extension);	
+}
+
+static struct sieve_interpreter_extension include_interpreter_extension = {
+	&include_extension,
+	ext_include_runtime_init,
+	NULL,
+};
+
+/* 
+ * Interpreter context management 
+ */
+
+static struct ext_include_interpreter_context *
+	ext_include_interpreter_context_create
+(struct sieve_interpreter *interp, 
+	struct ext_include_interpreter_context *parent, 
+	struct sieve_script *script, const struct ext_include_script_info *sinfo)
+{	
+	struct ext_include_interpreter_context *ctx;
+
+	pool_t pool = sieve_interpreter_pool(interp);
+	ctx = p_new(pool, struct ext_include_interpreter_context, 1);
+	ctx->pool = pool;
+	ctx->parent = parent;
+	ctx->interp = interp;
+	ctx->script = script;
+	ctx->script_info = sinfo;
+
+	if ( parent == NULL ) {
+		ctx->nesting_level = 0;
+	} else {
+		ctx->nesting_level = parent->nesting_level + 1;
+	}
+
+	return ctx;
+}
+
+static inline struct ext_include_interpreter_context *
+	ext_include_get_interpreter_context
+(struct sieve_interpreter *interp)
+{
+	return (struct ext_include_interpreter_context *)
+		sieve_interpreter_extension_get_context(interp, &include_extension);
+}
+
+static inline struct ext_include_interpreter_context *
+	ext_include_interpreter_context_init_child
+(struct sieve_interpreter *interp, 
+	struct ext_include_interpreter_context *parent, 
+	struct sieve_script *script, const struct ext_include_script_info *sinfo)
+{
+	struct ext_include_interpreter_context *ctx = 
+		ext_include_interpreter_context_create(interp, parent, script, sinfo);
+		
+	sieve_interpreter_extension_register
+		(interp, &include_interpreter_extension, ctx);
+	
+	return ctx;
+}
+
+void ext_include_interpreter_context_init
+(struct sieve_interpreter *interp)
+{
+	struct ext_include_interpreter_context *ctx = 
+		ext_include_get_interpreter_context(interp);
+
+	/* Is this is the top-level interpreter ? */	
+	if ( ctx == NULL ) {
+		struct sieve_script *script;
+
+		/* Initialize top context */
+		script = sieve_interpreter_script(interp);
+		ctx = ext_include_interpreter_context_create
+			(interp, NULL, script, NULL);
+		
+		sieve_interpreter_extension_register
+			(interp, &include_interpreter_extension, (void *) ctx);			
+	}
+}
+
+struct sieve_variable_storage *ext_include_interpreter_get_global_variables
+(struct sieve_interpreter *interp)
+{
+	struct ext_include_interpreter_context *ctx =
+		ext_include_get_interpreter_context(interp);
+		
+	return ctx->global->variables;
+}
+
+/* 
+ * Including a script during code generation 
+ */
+
+bool ext_include_generate_include
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *cmd,
+	enum ext_include_script_location location, struct sieve_script *script, 
+	const struct ext_include_script_info **included_r, bool once)
+{
+	bool result = TRUE;
+	struct sieve_ast *ast;
+	struct sieve_binary *sbin = cgenv->sbin;
+	struct sieve_generator *gentr = cgenv->gentr;
+	struct ext_include_binary_context *binctx;
+	struct sieve_generator *subgentr;
+	struct ext_include_generator_context *ctx =
+		ext_include_get_generator_context(gentr);
+	struct ext_include_generator_context *pctx;
+	struct sieve_error_handler *ehandler = sieve_generator_error_handler(gentr);
+	const struct ext_include_script_info *included;
+		
+	*included_r = NULL;
+
+	/* Just to be sure: do not include more scripts when errors have occured 
+	 * already. 
+	 */
+	if ( sieve_get_errors(ehandler) > 0 )
+		return FALSE;
+		
+	/* Limit nesting level */
+	if ( ctx->nesting_level >= EXT_INCLUDE_MAX_NESTING_LEVEL ) {
+		sieve_command_generate_error
+			(gentr, cmd, "cannot nest includes deeper than %d levels",
+				EXT_INCLUDE_MAX_NESTING_LEVEL);
+		return FALSE;
+	}
+	
+	/* Check for circular include */
+	if ( !once ) {
+		pctx = ctx;
+		while ( pctx != NULL ) {
+			if ( sieve_script_equals(pctx->script, script) ) {
+				sieve_command_generate_error(gentr, cmd, "circular include");
+				
+				return FALSE;
+			}
+		
+			pctx = pctx->parent;
+		}
+	}
+
+	/* Get binary context */
+	binctx = ext_include_binary_init(sbin, cgenv->ast);
+
+	/* Is the script already compiled into the current binary? */
+	if ( !ext_include_binary_script_is_included(binctx, script, &included) )	
+	{	
+		unsigned int inc_block_id, this_block_id;
+		const char *script_name = sieve_script_name(script);
+
+		/* Check whether include limit is exceeded */
+		if ( ext_include_binary_script_get_count(binctx) >= 
+			EXT_INCLUDE_MAX_INCLUDES ) {
+	 		sieve_command_generate_error(gentr, cmd, 
+	 			"failed to include script '%s': no more than %u includes allowed", 
+				str_sanitize(script_name, 80), EXT_INCLUDE_MAX_INCLUDES);
+	 		return FALSE;			
+		}
+		
+		/* No, allocate a new block in the binary and mark the script as included.
+		 */
+		inc_block_id = sieve_binary_block_create(sbin);
+		included = ext_include_binary_script_include
+			(binctx, script, location, inc_block_id);
+
+		/* Parse */
+		if ( (ast = sieve_parse(script, ehandler)) == NULL ) {
+	 		sieve_command_generate_error(gentr, cmd, 
+	 			"failed to parse included script '%s'", str_sanitize(script_name, 80));
+	 		return FALSE;
+		}
+		
+		/* Included scripts inherit global variable scope */
+		(void)ext_include_create_ast_context(ast, cmd->ast_node->ast);
+
+		/* Validate */
+		if ( !sieve_validate(ast, ehandler) ) {
+			sieve_command_generate_error(gentr, cmd, 
+				"failed to validate included script '%s'", str_sanitize(script_name, 80));
+	 		sieve_ast_unref(&ast);
+	 		return FALSE;
+	 	}
+
+		/* Generate 
+		 *
+		 * FIXME: It might not be a good idea to recurse code generation for 
+		 * included scripts.
+		 */
+		if ( sieve_binary_block_set_active(sbin, inc_block_id, &this_block_id) ) {
+		 	subgentr = sieve_generator_create(ast, ehandler);			
+			ext_include_initialize_generator_context(subgentr, ctx, script);
+				
+			if ( !sieve_generator_run(subgentr, &sbin) ) {
+				sieve_command_generate_error(gentr, cmd, 
+					"failed to generate code for included script '%s'", 
+					str_sanitize(script_name, 80));
+		 		result = FALSE;
+			}
+			
+			if ( sbin != NULL )		
+				(void) sieve_binary_block_set_active(sbin, this_block_id, NULL); 	
+			sieve_generator_free(&subgentr);
+		} else {
+			sieve_sys_error("include: failed to activate binary  block %d for "
+				"generating code for the included script", inc_block_id);
+			result = FALSE;
+		}
+		
+		/* Cleanup */
+		sieve_ast_unref(&ast);		
+	} 
+
+	if ( result ) *included_r = included;
+	
+	return result;
+}
+
+/* 
+ * Executing an included script during interpretation 
+ */
+
+static int ext_include_runtime_check_circular
+(struct ext_include_interpreter_context *ctx,
+	const struct ext_include_script_info *include)
+{
+	struct ext_include_interpreter_context *pctx;
+
+	pctx = ctx;
+	while ( pctx != NULL ) {
+
+		if ( sieve_script_equals(include->script, pctx->script) )
+			return TRUE;
+
+		pctx = pctx->parent;
+	}
+
+	return FALSE;
+}
+
+static bool ext_include_runtime_include_mark
+(struct ext_include_interpreter_context *ctx,
+	const struct ext_include_script_info *include, bool once)
+{
+	struct sieve_script *const *includes;
+	unsigned int count, i;
+	
+	includes = array_get(&ctx->global->included_scripts, &count);
+	for ( i = 0; i < count; i++ )	{
+		if ( sieve_script_equals(include->script, includes[i]) )
+			return ( !once );
+	}
+	
+	array_append(&ctx->global->included_scripts, &include->script, 1);
+
+	return TRUE;
+}
+
+int ext_include_execute_include
+(const struct sieve_runtime_env *renv, unsigned int include_id, bool once)
+{
+	int result = SIEVE_EXEC_OK;
+	struct ext_include_interpreter_context *ctx;
+	const struct ext_include_script_info *included;
+	struct ext_include_binary_context *binctx = 
+		ext_include_binary_get_context(renv->sbin);
+
+	/* Check for invalid include id (== corrupt binary) */
+	included = ext_include_binary_script_get_included(binctx, include_id);
+	if ( included == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid include id: %d", include_id);
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	ctx = ext_include_get_interpreter_context(renv->interp);
+	
+	sieve_runtime_trace(renv, 
+		"INCLUDE command (script: %s, id: %d block: %d) START::", 
+		sieve_script_name(included->script), include_id, included->block_id);
+
+	/* If :once modifier is specified, check for duplicate include */
+	if ( !ext_include_runtime_include_mark(ctx, included, once) ) {
+		/* skip */
+
+		sieve_runtime_trace(renv, 
+			"INCLUDE command (block: %d) SKIPPED ::", included->block_id);
+		return result;
+	}
+
+	/* Check circular include during interpretation as well. 
+	 * Let's not trust binaries.
+	 */
+	if ( ext_include_runtime_check_circular(ctx, included) ) {
+		sieve_runtime_trace_error(renv, 
+			"circular include for script: %s [%d]", 
+			sieve_script_name(included->script), included->block_id);
+
+		/* Situation has no valid way to emerge at runtime */
+		return SIEVE_EXEC_BIN_CORRUPT; 
+	}
+
+	if ( ctx->parent == NULL ) {
+		struct ext_include_interpreter_context *curctx = NULL;
+		struct sieve_error_handler *ehandler = 
+			sieve_interpreter_get_error_handler(renv->interp);
+		struct sieve_interpreter *subinterp;
+		unsigned int this_block_id;
+		bool interrupted = FALSE;	
+
+		/* We are the top-level interpreter instance */	
+		
+		/* Activate block for included script */
+		if ( !sieve_binary_block_set_active
+			(renv->sbin, included->block_id, &this_block_id) ) {			
+			sieve_runtime_trace_error(renv, "invalid block id: %d", 
+				included->block_id);
+			result = SIEVE_EXEC_BIN_CORRUPT;
+		}
+
+		if ( result == SIEVE_EXEC_OK ) {
+			/* Create interpreter for top-level included script
+			 * (first sub-interpreter) 
+			 */
+			subinterp = sieve_interpreter_create(renv->sbin, ehandler);
+
+			if ( subinterp != NULL ) {			
+				curctx = ext_include_interpreter_context_init_child
+					(subinterp, ctx, included->script, included);
+
+				/* Activate and start the top-level included script */
+				result = ( sieve_interpreter_start
+					(subinterp, renv->msgdata, renv->scriptenv, renv->result, 
+						&interrupted) == 1 );
+			} else
+				result = SIEVE_EXEC_BIN_CORRUPT;
+		}
+		
+		/* Included scripts can have includes of their own. This is not implemented
+		 * recursively. Rather, the sub-interpreter interrupts and defers the 
+		 * include to the top-level interpreter, which is here.
+		 */
+		if ( result == SIEVE_EXEC_OK && interrupted && !curctx->returned ) {
+			while ( result == SIEVE_EXEC_OK ) {
+
+				if ( ( (interrupted && curctx->returned) || (!interrupted) ) && 
+					curctx->parent != NULL ) {
+					
+					/* Sub-interpreter ended or executed return */
+					
+					sieve_runtime_trace(renv, "INCLUDE command (block: %d) END ::", 
+						curctx->script_info->block_id);
+
+					/* Ascend interpreter stack */
+					curctx = curctx->parent;
+					sieve_interpreter_free(&subinterp);
+					
+					/* This is the top-most sub-interpreter, bail out */
+					if ( curctx->parent == NULL ) break;
+					
+					/* Reactivate parent */
+					(void) sieve_binary_block_set_active
+						(renv->sbin, curctx->script_info->block_id, NULL);
+					subinterp = curctx->interp; 	
+					
+					/* Continue parent */
+					curctx->include = NULL;
+					curctx->returned = FALSE;
+
+					result = ( sieve_interpreter_continue(subinterp, &interrupted) == 1 );
+				} else {
+					if ( curctx->include != NULL ) {
+
+						/* Sub-include requested */
+															
+						/* Activate the sub-include's block */
+						if ( !sieve_binary_block_set_active
+							(renv->sbin, curctx->include->block_id, NULL) ) {
+							sieve_runtime_trace_error(renv, "invalid block id: %d", 
+								curctx->include->block_id);
+							result = SIEVE_EXEC_BIN_CORRUPT;
+						}
+				
+						if ( result == SIEVE_EXEC_OK ) {
+							/* Create sub-interpreter */
+							subinterp = sieve_interpreter_create(renv->sbin, ehandler);			
+
+							if ( subinterp != NULL ) {
+								curctx = ext_include_interpreter_context_init_child
+									(subinterp, curctx, curctx->include->script, 
+										curctx->include);
+
+								/* Start the sub-include's interpreter */
+								curctx->include = NULL;
+								curctx->returned = FALSE;
+								result = ( sieve_interpreter_start
+									(subinterp, renv->msgdata, renv->scriptenv, renv->result, 
+										&interrupted) == 1 );		 	
+							} else
+								result = SIEVE_EXEC_BIN_CORRUPT;
+						}
+					} else {
+						/* Sub-interpreter was interrupted outside this extension, probably
+						 * stop command was executed. Generate an interrupt ourselves, 
+						 * ending all script execution.
+						 */
+						sieve_interpreter_interrupt(renv->interp);
+						break;
+					}
+				}
+			}
+		} else 
+			sieve_runtime_trace(renv, "INCLUDE command (block: %d) END ::", 
+				curctx->script_info->block_id);
+
+		/* Free any sub-interpreters that might still be active */
+		while ( curctx != NULL && curctx->parent != NULL ) {
+			struct ext_include_interpreter_context *nextctx	= curctx->parent;
+			struct sieve_interpreter *killed_interp = curctx->interp;
+
+			/* This kills curctx too */
+			sieve_interpreter_free(&killed_interp);
+
+			/* Luckily we recorded the parent earlier */
+			curctx = nextctx;
+		}
+
+		/* Return to our own block */
+		(void) sieve_binary_block_set_active(renv->sbin, this_block_id, NULL); 	
+	} else {
+		/* We are an included script already, defer inclusion to main interpreter */
+
+		ctx->include = included;
+		sieve_interpreter_interrupt(renv->interp);
+	}
+	
+	return result;
+}
+
+void ext_include_execute_return(const struct sieve_runtime_env *renv)
+{
+	struct ext_include_interpreter_context *ctx =
+		ext_include_get_interpreter_context(renv->interp);
+	
+	ctx->returned = TRUE;
+	sieve_interpreter_interrupt(renv->interp);	
+}
+	
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-common.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-common.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-common.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-common.h	2009-08-08 14:57:37.000000000 +0200
@@ -0,0 +1,128 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_INCLUDE_COMMON_H
+#define __EXT_INCLUDE_COMMON_H
+
+#include "lib.h"
+#include "hash.h"
+
+#include "sieve-common.h"
+
+/* 
+ * Forward declarations
+ */
+
+struct ext_include_script_info;
+struct ext_include_binary_context;
+
+/* 
+ * Types 
+ */
+
+enum ext_include_script_location { 
+	EXT_INCLUDE_LOCATION_PERSONAL, 
+	EXT_INCLUDE_LOCATION_GLOBAL,
+	EXT_INCLUDE_LOCATION_INVALID 
+};
+
+static inline const char *ext_include_script_location_name
+(enum ext_include_script_location location)
+{
+	switch ( location ) {
+	case EXT_INCLUDE_LOCATION_PERSONAL:
+		return "personal";
+
+	case EXT_INCLUDE_LOCATION_GLOBAL:
+		return "global";
+
+	default:
+		break;
+	}
+
+	return "[INVALUD LOCATION]";
+}
+
+
+/* 
+ * Extension 
+ */
+
+extern const struct sieve_extension include_extension;
+extern const struct sieve_binary_extension include_binary_ext;
+
+/* 
+ * Commands 
+ */
+
+extern const struct sieve_command cmd_include;
+extern const struct sieve_command cmd_return;
+extern const struct sieve_command cmd_global;
+
+/* DEPRICATED */ 
+extern const struct sieve_command cmd_import;
+extern const struct sieve_command cmd_export;
+
+/*
+ * Operations
+ */
+ 
+enum ext_include_opcode {
+	EXT_INCLUDE_OPERATION_INCLUDE,
+	EXT_INCLUDE_OPERATION_RETURN,
+	EXT_INCLUDE_OPERATION_GLOBAL
+};
+ 
+extern const struct sieve_operation include_operation;
+extern const struct sieve_operation return_operation;
+extern const struct sieve_operation global_operation;
+
+/* 
+ * Script access 
+ */
+
+const char *ext_include_get_script_directory
+	(enum ext_include_script_location location, const char *script_name);
+
+/* 
+ * Context 
+ */
+ 
+/* AST Context */
+
+struct ext_include_ast_context {
+    struct sieve_variable_scope *global_vars;
+
+    ARRAY_DEFINE(included_scripts, struct sieve_script *);
+};
+
+struct ext_include_ast_context *ext_include_create_ast_context
+	(struct sieve_ast *ast, struct sieve_ast *parent);
+struct ext_include_ast_context *ext_include_get_ast_context
+	(struct sieve_ast *ast);
+
+void ext_include_ast_link_included_script
+	(struct sieve_ast *ast, struct sieve_script *script);
+
+/* Generator context */
+
+void ext_include_register_generator_context
+	(const struct sieve_codegen_env *cgenv);
+
+bool ext_include_generate_include
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *cmd,
+		enum ext_include_script_location location, struct sieve_script *script, 
+		const struct ext_include_script_info **included_r, bool once);
+
+/* Interpreter context */
+
+void ext_include_interpreter_context_init(struct sieve_interpreter *interp);
+
+int ext_include_execute_include
+	(const struct sieve_runtime_env *renv, unsigned int block_id, bool once);
+void ext_include_execute_return(const struct sieve_runtime_env *renv);
+
+struct sieve_variable_storage *ext_include_interpreter_get_global_variables
+	(struct sieve_interpreter *interp);
+
+#endif /* __EXT_INCLUDE_COMMON_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-limits.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-limits.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-limits.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-limits.h	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,12 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_INCLUDE_LIMITS_H
+#define __EXT_INCLUDE_LIMITS_H
+
+#include "sieve-common.h"
+
+#define EXT_INCLUDE_MAX_NESTING_LEVEL 10
+#define EXT_INCLUDE_MAX_INCLUDES      255
+
+#endif /* __EXT_INCLUDE_LIMITS_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-variables.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-variables.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-variables.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-variables.c	2009-07-29 01:23:49.000000000 +0200
@@ -0,0 +1,148 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-error.h"
+#include "sieve-script.h"
+#include "sieve-ast.h"
+#include "sieve-binary.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "sieve-ext-variables.h"
+
+#include "ext-include-common.h"
+#include "ext-include-binary.h"
+#include "ext-include-variables.h"
+
+/* 
+ * Variable import-export
+ */
+ 
+struct sieve_variable *ext_include_variable_import_global
+(struct sieve_validator *valdtr, struct sieve_command_context *cmd, 
+	const char *variable)
+{
+	struct sieve_ast *ast = cmd->ast_node->ast;
+	struct ext_include_ast_context *ctx = ext_include_get_ast_context(ast);
+	struct sieve_variable_scope *main_scope;
+	struct sieve_variable *var = NULL;
+
+	/* Sanity safeguard */	
+	i_assert ( ctx->global_vars != NULL );
+
+	/* Get/Declare the variable in the global scope */
+	var = sieve_variable_scope_get_variable(ctx->global_vars, variable, TRUE);
+
+	/* Check whether scope is over its size limit */
+	if ( var == NULL ) {
+		sieve_command_validate_error(valdtr, cmd,
+			"declaration of new global variable '%s' exceeds the limit "
+			"(max variables: %u)", 
+			variable, SIEVE_VARIABLES_MAX_SCOPE_SIZE);
+	}
+	
+	/* Import the global variable into the local script scope */
+	main_scope = sieve_ext_variables_get_main_scope(valdtr);
+	(void)sieve_variable_scope_import(main_scope, var);
+
+	return var;	
+}
+
+/*
+ * Binary symbol table
+ */
+ 
+bool ext_include_variables_save
+(struct sieve_binary *sbin, struct sieve_variable_scope *global_vars)
+{
+	unsigned int count = sieve_variable_scope_size(global_vars);
+
+	sieve_binary_emit_unsigned(sbin, count);
+
+	if ( count > 0 ) {
+		unsigned int size, i;
+		struct sieve_variable *const *vars = 
+			sieve_variable_scope_get_variables(global_vars, &size);
+
+		for ( i = 0; i < size; i++ ) {
+			sieve_binary_emit_cstring(sbin, vars[i]->identifier);
+		}
+	}
+
+	return TRUE;
+}
+
+bool ext_include_variables_load
+(struct sieve_binary *sbin, sieve_size_t *offset, unsigned int block,
+	struct sieve_variable_scope **global_vars_r)
+{
+	unsigned int count = 0;
+	unsigned int i;
+	pool_t pool;
+
+	/* Sanity assert */
+	i_assert( *global_vars_r == NULL );
+
+	if ( !sieve_binary_read_unsigned(sbin, offset, &count) ) {
+		sieve_sys_error("include: failed to read global variables count "
+			"from dependency block %d of binary %s", block, sieve_binary_path(sbin));
+		return FALSE;
+	}
+
+	if ( count > SIEVE_VARIABLES_MAX_SCOPE_SIZE ) {
+		sieve_sys_error("include: global variable scope size of binary %s "
+			"exceeds the limit (%u > %u)", sieve_binary_path(sbin),
+			count, SIEVE_VARIABLES_MAX_SCOPE_SIZE );
+		return FALSE;
+	}
+
+	*global_vars_r = sieve_variable_scope_create(&include_extension);
+	pool = sieve_variable_scope_pool(*global_vars_r);
+
+	/* Read global variable scope */
+	for ( i = 0; i < count; i++ ) {
+		struct sieve_variable *var;
+		string_t *identifier;
+
+		if ( !sieve_binary_read_string(sbin, offset, &identifier) ) {
+			/* Binary is corrupt, recompile */
+			sieve_sys_error("include: failed to read global variable specification "
+				"from dependency block %d of binary %s", block, sieve_binary_path(sbin));
+			return FALSE;
+		}
+		
+		var = sieve_variable_scope_declare(*global_vars_r, str_c(identifier));
+
+		i_assert( var != NULL );
+		i_assert( var->index == i );
+	}
+	
+	return TRUE;
+}
+
+bool ext_include_variables_dump
+(struct sieve_dumptime_env *denv, struct sieve_variable_scope *global_vars)
+{
+	unsigned int size;
+	struct sieve_variable *const *vars;
+
+	i_assert(global_vars != NULL);
+
+	vars = sieve_variable_scope_get_variables(global_vars, &size);
+
+	if ( size > 0 ) {
+		unsigned int i;
+
+		sieve_binary_dump_sectionf(denv, "Global variables");
+	
+		for ( i = 0; i < size; i++ ) {
+			sieve_binary_dumpf(denv, "%3d: '%s' \n", i, vars[i]->identifier);
+		}	
+	}
+
+	return TRUE;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-variables.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-variables.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-variables.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-variables.h	2009-04-10 14:54:25.000000000 +0200
@@ -0,0 +1,34 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_INCLUDE_VARIABLES_H
+#define __EXT_INCLUDE_VARIABLES_H
+
+#include "sieve-common.h"
+
+#include "sieve-ext-variables.h"
+
+#include "ext-include-common.h"
+
+/* 
+ * Variable import-export
+ */
+ 
+struct sieve_variable *ext_include_variable_import_global
+	(struct sieve_validator *valdtr, struct sieve_command_context *cmd, 
+		const char *variable);
+
+/*
+ * Binary symbol table
+ */
+
+bool ext_include_variables_save
+	(struct sieve_binary *sbin, struct sieve_variable_scope *global_vars);
+bool ext_include_variables_load
+	(struct sieve_binary *sbin, sieve_size_t *offset, unsigned int block,
+		struct sieve_variable_scope **global_vars_r);
+bool ext_include_variables_dump
+	(struct sieve_dumptime_env *denv, struct sieve_variable_scope *global_vars);
+		
+#endif /* __EXT_INCLUDE_VARIABLES_H */
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/include/Makefile.am dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/include/Makefile.am
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/include/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/include/Makefile.am	2009-04-10 14:32:03.000000000 +0200
@@ -0,0 +1,27 @@
+noinst_LTLIBRARIES = libsieve_ext_include.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I../variables \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage
+
+cmds = \
+	cmd-include.c \
+	cmd-return.c \
+	cmd-global.c
+
+libsieve_ext_include_la_SOURCES = \
+	$(cmds) \
+	ext-include-common.c \
+	ext-include-binary.c \
+	ext-include-variables.c \
+	ext-include.c
+
+noinst_HEADERS = \
+	ext-include-common.h \
+	ext-include-limits.h \
+	ext-include-binary.h \
+	ext-include-variables.h
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/include/Makefile.in dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/include/Makefile.in
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/include/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/include/Makefile.in	2009-08-21 00:55:43.000000000 +0200
@@ -0,0 +1,482 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve/plugins/include
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libsieve_ext_include_la_LIBADD =
+am__objects_1 = cmd-include.lo cmd-return.lo cmd-global.lo
+am_libsieve_ext_include_la_OBJECTS = $(am__objects_1) \
+	ext-include-common.lo ext-include-binary.lo \
+	ext-include-variables.lo ext-include.lo
+libsieve_ext_include_la_OBJECTS =  \
+	$(am_libsieve_ext_include_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_ext_include_la_SOURCES)
+DIST_SOURCES = $(libsieve_ext_include_la_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LTLIBRARIES = libsieve_ext_include.la
+AM_CPPFLAGS = \
+	-I../../ \
+	-I../variables \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage
+
+cmds = \
+	cmd-include.c \
+	cmd-return.c \
+	cmd-global.c
+
+libsieve_ext_include_la_SOURCES = \
+	$(cmds) \
+	ext-include-common.c \
+	ext-include-binary.c \
+	ext-include-variables.c \
+	ext-include.c
+
+noinst_HEADERS = \
+	ext-include-common.h \
+	ext-include-limits.h \
+	ext-include-binary.h \
+	ext-include-variables.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/lib-sieve/plugins/include/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  src/lib-sieve/plugins/include/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve_ext_include.la: $(libsieve_ext_include_la_OBJECTS) $(libsieve_ext_include_la_DEPENDENCIES) 
+	$(LINK)  $(libsieve_ext_include_la_OBJECTS) $(libsieve_ext_include_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-global.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-include.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-return.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-include-binary.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-include-common.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-include-variables.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-include.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/mailbox/cmd-mailboxexists.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/mailbox/cmd-mailboxexists.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/mailbox/cmd-mailboxexists.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/mailbox/cmd-mailboxexists.c	2009-08-02 09:44:14.000000000 +0200
@@ -0,0 +1,175 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "mail-storage.h"
+#include "mail-namespace.h"
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "ext-mailbox-common.h"
+
+/* 
+ * Mailboxexists command 
+ *
+ * Syntax:
+ *    mailboxexists <mailbox-names: string-list>
+ */
+
+static bool tst_mailboxexists_validate
+	(struct sieve_validator *validator, struct sieve_command_context *tst);
+static bool tst_mailboxexists_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command mailboxexists_test = { 
+	"mailboxexists", 
+	SCT_TEST, 
+	1, 0, FALSE, FALSE,
+	NULL, NULL,
+	tst_mailboxexists_validate, 
+	tst_mailboxexists_generate, 
+	NULL 
+};
+
+/* 
+ * Mailboxexists operation
+ */
+
+static bool tst_mailboxexists_operation_dump
+	(const struct sieve_operation *op, 
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_mailboxexists_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation mailboxexists_operation = { 
+	"MAILBOXEXISTS",
+	&mailbox_extension, 
+	0, 
+	tst_mailboxexists_operation_dump, 
+	tst_mailboxexists_operation_execute 
+};
+
+/* 
+ * Test validation 
+ */
+
+static bool tst_mailboxexists_validate
+	(struct sieve_validator *validator, struct sieve_command_context *tst) 
+{ 		
+	struct sieve_ast_argument *arg = tst->first_positional;
+	
+	if ( !sieve_validate_positional_argument
+		(validator, tst, arg, "mailbox-names", 1, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+	
+	return sieve_validator_argument_activate(validator, tst, arg, FALSE);
+}
+
+/* 
+ * Test generation 
+ */
+
+static bool tst_mailboxexists_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *tst) 
+{
+	sieve_operation_emit_code(cgenv->sbin, &mailboxexists_operation);
+
+ 	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, tst, NULL);
+}
+
+/* 
+ * Code dump 
+ */
+
+static bool tst_mailboxexists_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	sieve_code_dumpf(denv, "MAILBOXEXISTS");
+	sieve_code_descend(denv);
+		
+	return
+		sieve_opr_stringlist_dump(denv, address, "mailbox-names");
+}
+
+/* 
+ * Code execution 
+ */
+
+static int tst_mailboxexists_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED, 
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	struct sieve_coded_stringlist *mailbox_names;
+	string_t *mailbox_item;
+	bool result = TRUE, all_exist = TRUE;
+
+	/*
+	 * Read operands 
+	 */
+	
+	/* Read notify uris */
+	if ( (mailbox_names=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid mailbox-names operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "MAILBOXEXISTS command");
+
+	if ( renv->scriptenv->namespaces != NULL ) {
+		mailbox_item = NULL;
+		while ( (result=sieve_coded_stringlist_next_item
+			(mailbox_names, &mailbox_item)) 
+			&& mailbox_item != NULL ) {
+			struct mail_namespace *ns;
+			struct mail_storage *storage;
+			const char *mailbox = str_c(mailbox_item);
+			struct mailbox *box;
+
+			/* Find the namespace */	
+			ns = mail_namespace_find(renv->scriptenv->namespaces, &mailbox);
+			if ( ns == NULL) {
+				all_exist = FALSE;
+				break;
+			}
+
+			/* Open the box */
+			storage = ns->storage;
+			box = mailbox_open(&storage, mailbox, NULL, MAILBOX_OPEN_FAST);
+			if ( box == NULL ) {
+				all_exist = FALSE;
+				break;
+			}
+
+			/* Also fail when it is readonly */
+			if ( mailbox_is_readonly(box) )
+				all_exist = FALSE;
+
+			/* FIXME: check acl for 'p' or 'i' ACL permissions as required by RFC */
+
+			/* Close mailbox */
+			mailbox_close(&box);
+		}
+	}
+	
+	if ( !result ) {
+		sieve_runtime_trace_error(renv, "invalid mailbox name item");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	sieve_interpreter_set_test_result(renv->interp, all_exist);
+	return SIEVE_EXEC_OK;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/mailbox/ext-mailbox.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/mailbox/ext-mailbox.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/mailbox/ext-mailbox.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/mailbox/ext-mailbox.c	2009-08-05 12:42:59.000000000 +0200
@@ -0,0 +1,62 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension mailbox
+ * ------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: RFC 5490
+ * Implementation: almost full; acl support is missing for mailboxexists
+ * Status: experimental, largely untested
+ * 
+ */
+
+#include <stdio.h>
+
+#include "sieve-common.h"
+
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-actions.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-result.h"
+
+#include "ext-mailbox-common.h"
+
+/* 
+ * Extension
+ */
+
+static bool ext_mailbox_validator_load(struct sieve_validator *valdtr);
+
+static int ext_my_id = -1;
+
+const struct sieve_extension mailbox_extension = { 
+	"mailbox", 
+	&ext_my_id,
+	NULL, NULL,
+	ext_mailbox_validator_load, 
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATION(mailboxexists_operation),
+	SIEVE_EXT_DEFINE_OPERAND(mailbox_create_operand)
+};
+
+static bool ext_mailbox_validator_load(struct sieve_validator *valdtr)
+{
+	/* Register :create tag with fileinto command and we don't care whether this 
+	 * command is registered or even whether it will be registered at all. The 
+	 * validator handles either situation gracefully 
+	 */
+	sieve_validator_register_external_tag
+		(valdtr, &mailbox_create_tag, "fileinto", SIEVE_OPT_SIDE_EFFECT);
+
+	/* Register new test */
+	sieve_validator_register_command(valdtr, &mailboxexists_test);
+
+	return TRUE;
+}
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/mailbox/ext-mailbox-common.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/mailbox/ext-mailbox-common.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/mailbox/ext-mailbox-common.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/mailbox/ext-mailbox-common.h	2009-07-27 13:30:18.000000000 +0200
@@ -0,0 +1,40 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_MAILBOX_COMMON_H
+#define __EXT_MAILBOX_COMMON_H
+
+#include "sieve-common.h"
+
+/*
+ * Tagged arguments
+ */
+
+extern const struct sieve_argument mailbox_create_tag;
+
+/*
+ * Commands
+ */
+
+extern const struct sieve_command mailboxexists_test;
+
+/*
+ * Operands
+ */
+
+extern const struct sieve_operand mailbox_create_operand;
+
+/*
+ * Operations
+ */
+
+extern const struct sieve_operation mailboxexists_operation;
+
+/*
+ * Extension
+ */
+
+extern const struct sieve_extension mailbox_extension;
+
+#endif /* __EXT_MAILBOX_COMMON_H */
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/mailbox/Makefile.am dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/mailbox/Makefile.am
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/mailbox/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/mailbox/Makefile.am	2009-08-03 16:39:12.000000000 +0200
@@ -0,0 +1,22 @@
+noinst_LTLIBRARIES = libsieve_ext_mailbox.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+tags = \
+	tag-mailbox-create.c
+
+commands = \
+	cmd-mailboxexists.c
+
+libsieve_ext_mailbox_la_SOURCES = \
+	$(tags) \
+	$(commands) \
+	ext-mailbox.c
+
+noinst_HEADERS = \
+	ext-mailbox-common.h
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/mailbox/Makefile.in dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/mailbox/Makefile.in
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/mailbox/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/mailbox/Makefile.in	2009-08-21 00:55:43.000000000 +0200
@@ -0,0 +1,473 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve/plugins/mailbox
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libsieve_ext_mailbox_la_LIBADD =
+am__objects_1 = tag-mailbox-create.lo
+am__objects_2 = cmd-mailboxexists.lo
+am_libsieve_ext_mailbox_la_OBJECTS = $(am__objects_1) $(am__objects_2) \
+	ext-mailbox.lo
+libsieve_ext_mailbox_la_OBJECTS =  \
+	$(am_libsieve_ext_mailbox_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_ext_mailbox_la_SOURCES)
+DIST_SOURCES = $(libsieve_ext_mailbox_la_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LTLIBRARIES = libsieve_ext_mailbox.la
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+tags = \
+	tag-mailbox-create.c
+
+commands = \
+	cmd-mailboxexists.c
+
+libsieve_ext_mailbox_la_SOURCES = \
+	$(tags) \
+	$(commands) \
+	ext-mailbox.c
+
+noinst_HEADERS = \
+	ext-mailbox-common.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/lib-sieve/plugins/mailbox/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  src/lib-sieve/plugins/mailbox/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve_ext_mailbox.la: $(libsieve_ext_mailbox_la_OBJECTS) $(libsieve_ext_mailbox_la_DEPENDENCIES) 
+	$(LINK)  $(libsieve_ext_mailbox_la_OBJECTS) $(libsieve_ext_mailbox_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-mailboxexists.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-mailbox.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tag-mailbox-create.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/mailbox/tag-mailbox-create.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/mailbox/tag-mailbox-create.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/mailbox/tag-mailbox-create.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/mailbox/tag-mailbox-create.c	2009-07-30 01:00:42.000000000 +0200
@@ -0,0 +1,175 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "mail-storage.h"
+#include "mail-namespace.h"
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-actions.h"
+#include "sieve-result.h"
+#include "sieve-generator.h"
+
+#include "ext-mailbox-common.h"
+
+/* 
+ * Tagged argument 
+ */
+
+static bool tag_mailbox_create_validate
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+static bool tag_mailbox_create_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+    struct sieve_command_context *context);
+
+const struct sieve_argument mailbox_create_tag = { 
+	"create", 
+	NULL, NULL,
+	tag_mailbox_create_validate, 
+	NULL,
+	tag_mailbox_create_generate
+};
+
+/*
+ * Side effect 
+ */
+
+static void seff_mailbox_create_print
+	(const struct sieve_side_effect *seffect, const struct sieve_action *action, 
+		const struct sieve_result_print_env *rpenv, void *se_context, bool *keep);
+static bool seff_mailbox_create_pre_execute
+	(const struct sieve_side_effect *seffect, const struct sieve_action *action, 
+		const struct sieve_action_exec_env *aenv, void **se_context, 
+		void *tr_context);;
+
+const struct sieve_side_effect mailbox_create_side_effect = {
+	SIEVE_OBJECT("create", &mailbox_create_operand, 0),
+	&act_store,
+	NULL, NULL, NULL,
+	seff_mailbox_create_print,
+	seff_mailbox_create_pre_execute, 
+	NULL, NULL, NULL
+};
+
+/*
+ * Operand
+ */
+
+static const struct sieve_extension_objects ext_side_effects =
+	SIEVE_EXT_DEFINE_SIDE_EFFECT(mailbox_create_side_effect);
+
+const struct sieve_operand mailbox_create_operand = {
+	"create operand",
+	&mailbox_extension,
+	0,
+	&sieve_side_effect_operand_class,
+	&ext_side_effects
+};
+
+/* 
+ * Tag validation 
+ */
+
+static bool tag_mailbox_create_validate
+	(struct sieve_validator *validator ATTR_UNUSED, 
+	struct sieve_ast_argument **arg ATTR_UNUSED, 
+	struct sieve_command_context *cmd ATTR_UNUSED)
+{
+	*arg = sieve_ast_argument_next(*arg);
+
+	return TRUE;
+}
+
+/*
+ * Code generation 
+ */
+
+static bool tag_mailbox_create_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+    struct sieve_command_context *context ATTR_UNUSED)
+{
+	if ( sieve_ast_argument_type(arg) != SAAT_TAG ) {
+		return FALSE;
+	}
+
+	sieve_opr_side_effect_emit(cgenv->sbin, &mailbox_create_side_effect);
+
+	return TRUE;
+}
+
+/* 
+ * Side effect implementation
+ */
+
+static void seff_mailbox_create_print
+(const struct sieve_side_effect *seffect ATTR_UNUSED, 
+	const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_result_print_env *rpenv,
+	void *se_context ATTR_UNUSED, bool *keep ATTR_UNUSED)
+{
+	sieve_result_seffect_printf(rpenv, "create mailbox if it does not exist");
+}
+
+static bool seff_mailbox_create_pre_execute
+(const struct sieve_side_effect *seffect ATTR_UNUSED, 
+	const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_action_exec_env *aenv ATTR_UNUSED,
+	void **se_context ATTR_UNUSED, void *tr_context ATTR_UNUSED)
+{	
+	struct act_store_transaction *trans = 
+		(struct act_store_transaction *) tr_context;
+	struct mail_storage **storage = &(aenv->exec_status->last_storage);
+	enum mailbox_open_flags open_flags = 
+		MAILBOX_OPEN_FAST | MAILBOX_OPEN_KEEP_RECENT | 
+		MAILBOX_OPEN_SAVEONLY | MAILBOX_OPEN_POST_SESSION;
+	struct mailbox *box = NULL;
+	
+	/* Check whether creation is necessary */
+	if ( trans->box != NULL || trans->redundant || trans->disabled ) 
+		return TRUE;
+
+	/* Check availability of namespace and folder name */
+	if ( trans->namespace == NULL || trans->folder == NULL )
+		return FALSE;
+
+	/* Check whether creation has a chance of working */
+	if ( trans->error_code != MAIL_ERROR_NONE 
+		&& trans->error_code != MAIL_ERROR_NOTFOUND )
+		return FALSE;
+
+	*storage = trans->namespace->storage; 
+
+	/* Create mailbox */
+	if ( mail_storage_mailbox_create(*storage, trans->folder, FALSE) < 0 ) {
+		box = NULL;
+
+	} else {
+		/* Subscribe to it if necessary */
+		if ( aenv->scriptenv->mailbox_autosubscribe ) {
+			(void)mailbox_list_set_subscribed
+				(trans->namespace->list, trans->folder, TRUE);
+		}
+
+		/* Open it */
+		box = mailbox_open(storage, trans->folder, NULL, open_flags);
+    
+		if ( box != NULL && mailbox_sync(box, 0, 0, NULL) < 0 ) {
+			mailbox_close(&box);
+			box = NULL;
+		}
+	} 
+
+	/* Fetch error */
+	if ( box == NULL )
+		sieve_act_store_get_storage_error(aenv, trans);	
+
+	trans->box = box;
+	
+	return ( box != NULL );
+}
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/Makefile.am dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/Makefile.am
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/Makefile.am	2009-08-21 00:52:15.000000000 +0200
@@ -0,0 +1,22 @@
+if BUILD_UNFINISHED
+UNFINISHED =
+endif
+
+SUBDIRS = \
+	vacation \
+	subaddress \
+	comparator-i-ascii-numeric \
+	relational \
+	regex \
+	imap4flags \
+	copy \
+	include \
+	body \
+	variables \
+	enotify \
+	notify \
+	environment \
+	mailbox \
+	date \
+	$(UNFINISHED)
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/Makefile.in dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/Makefile.in
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/Makefile.in	2009-08-21 00:55:42.000000000 +0200
@@ -0,0 +1,511 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve/plugins
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+SOURCES =
+DIST_SOURCES =
+RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
+	html-recursive info-recursive install-data-recursive \
+	install-dvi-recursive install-exec-recursive \
+	install-html-recursive install-info-recursive \
+	install-pdf-recursive install-ps-recursive install-recursive \
+	installcheck-recursive installdirs-recursive pdf-recursive \
+	ps-recursive uninstall-recursive
+RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
+  distclean-recursive maintainer-clean-recursive
+ETAGS = etags
+CTAGS = ctags
+DIST_SUBDIRS = $(SUBDIRS)
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+@BUILD_UNFINISHED_TRUE@UNFINISHED = 
+SUBDIRS = \
+	vacation \
+	subaddress \
+	comparator-i-ascii-numeric \
+	relational \
+	regex \
+	imap4flags \
+	copy \
+	include \
+	body \
+	variables \
+	enotify \
+	notify \
+	environment \
+	mailbox \
+	date \
+	$(UNFINISHED)
+
+all: all-recursive
+
+.SUFFIXES:
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/lib-sieve/plugins/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  src/lib-sieve/plugins/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run `make' without going through this Makefile.
+# To change the values of `make' variables: instead of editing Makefiles,
+# (1) if the variable is set in `config.status', edit `config.status'
+#     (which will cause the Makefiles to be regenerated when you run `make');
+# (2) otherwise, pass the desired values on the `make' command line.
+$(RECURSIVE_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+$(RECURSIVE_CLEAN_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	rev=''; for subdir in $$list; do \
+	  if test "$$subdir" = "."; then :; else \
+	    rev="$$subdir $$rev"; \
+	  fi; \
+	done; \
+	rev="$$rev ."; \
+	target=`echo $@ | sed s/-recursive//`; \
+	for subdir in $$rev; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done && test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
+	done
+ctags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	  empty_fix=.; \
+	else \
+	  include_option=--include; \
+	  empty_fix=; \
+	fi; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test ! -f $$subdir/TAGS || \
+	      tags="$$tags $$include_option=$$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+	list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test -d "$(distdir)/$$subdir" \
+	    || $(MKDIR_P) "$(distdir)/$$subdir" \
+	    || exit 1; \
+	    distdir=`$(am__cd) $(distdir) && pwd`; \
+	    top_distdir=`$(am__cd) $(top_distdir) && pwd`; \
+	    (cd $$subdir && \
+	      $(MAKE) $(AM_MAKEFLAGS) \
+	        top_distdir="$$top_distdir" \
+	        distdir="$$distdir/$$subdir" \
+		am__remove_distdir=: \
+		am__skip_length_check=: \
+	        distdir) \
+	      || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-recursive
+all-am: Makefile
+installdirs: installdirs-recursive
+installdirs-am:
+install: install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-recursive
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-recursive
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-recursive
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-tags
+
+dvi: dvi-recursive
+
+dvi-am:
+
+html: html-recursive
+
+info: info-recursive
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-recursive
+
+install-exec-am:
+
+install-html: install-html-recursive
+
+install-info: install-info-recursive
+
+install-man:
+
+install-pdf: install-pdf-recursive
+
+install-ps: install-ps-recursive
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-recursive
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-recursive
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-recursive
+
+pdf-am:
+
+ps: ps-recursive
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) install-am \
+	install-strip
+
+.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
+	all all-am check check-am clean clean-generic clean-libtool \
+	ctags ctags-recursive distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs installdirs-am maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-recursive \
+	uninstall uninstall-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/notify/cmd-denotify.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/notify/cmd-denotify.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/notify/cmd-denotify.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/notify/cmd-denotify.c	2009-07-27 13:30:18.000000000 +0200
@@ -0,0 +1,306 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+
+#include "sieve-common.h"
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-ast.h"
+#include "sieve-commands.h"
+#include "sieve-match-types.h"
+#include "sieve-comparators.h"
+#include "sieve-actions.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-result.h"
+
+#include "ext-notify-common.h"
+ 
+/* 
+ * Denotify command (NOT IMPLEMENTED)
+ *
+ * Syntax:
+ *   denotify [MATCH-TYPE string] [<":low" / ":normal" / ":high">]
+ */
+
+static bool cmd_denotify_registered
+	(struct sieve_validator *valdtr, struct sieve_command_registration *cmd_reg);
+static bool cmd_denotify_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command cmd_denotify = {
+	"denotify",
+	SCT_COMMAND,
+	0, 0, FALSE, FALSE,
+	cmd_denotify_registered,
+	NULL,
+	NULL, 
+	cmd_denotify_generate, 
+	NULL
+};
+
+/*
+ * Tagged arguments
+ */
+
+/* Forward declarations */
+
+static bool tag_match_type_is_instance_of
+	(struct sieve_validator *validator, struct sieve_command_context *cmd,
+		struct sieve_ast_argument *arg);
+static bool tag_match_type_validate
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg,
+		struct sieve_command_context *cmd);
+
+/* Argument object */
+
+const struct sieve_argument denotify_match_tag = {
+	"MATCH-TYPE-STRING",
+	tag_match_type_is_instance_of,
+	NULL,
+	tag_match_type_validate,
+	NULL, NULL
+};
+
+/* Codes for optional operands */
+
+enum cmd_denotify_optional {
+  OPT_END,
+  OPT_IMPORTANCE,
+  OPT_MATCH_TYPE,
+	OPT_MATCH_KEY
+};
+
+/* 
+ * Denotify operation 
+ */
+
+static bool cmd_denotify_operation_dump
+	(const struct sieve_operation *op ATTR_UNUSED,
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_denotify_operation_execute
+	(const struct sieve_operation *op ATTR_UNUSED,
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation denotify_operation = { 
+	"DENOTIFY",
+	&notify_extension,
+	EXT_NOTIFY_OPERATION_DENOTIFY,
+	cmd_denotify_operation_dump,
+	cmd_denotify_operation_execute
+};
+
+/*
+ * Tag validation
+ */
+
+static bool tag_match_type_is_instance_of
+(struct sieve_validator *valdtr, struct sieve_command_context *cmd,
+	struct sieve_ast_argument *arg)
+{
+	return match_type_tag.is_instance_of(valdtr, cmd, arg);
+}
+
+static bool tag_match_type_validate
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+	struct sieve_command_context *cmd)
+{
+	struct sieve_ast_argument *tag = *arg;
+
+	if ( !match_type_tag.validate(valdtr, arg, cmd) )
+		return FALSE;
+
+	if ( *arg == NULL ) {
+		sieve_argument_validate_error(valdtr, tag, 
+			"the MATCH-TYPE argument (:%s) for the denotify command requires "
+			"an additional key-string paramterer, but no more arguments were found", 
+			sieve_ast_argument_tag(tag));
+		return FALSE;	
+	}
+	
+	if ( sieve_ast_argument_type(*arg) != SAAT_STRING ) 
+	{
+		sieve_argument_validate_error(valdtr, *arg, 
+			"the MATCH-TYPE argument (:%s) for the denotify command requires "
+			"an additional key-string parameter, but %s was found", 
+			sieve_ast_argument_tag(tag), sieve_ast_argument_name(*arg));
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(valdtr, cmd, *arg, FALSE) ) 
+		return FALSE;
+
+	if ( !sieve_match_type_validate
+		(valdtr, cmd, *arg, &is_match_type, &i_octet_comparator) )
+		return FALSE;
+
+	tag->argument = &match_type_tag;
+
+	(*arg)->arg_id_code = OPT_MATCH_KEY;
+
+	*arg = sieve_ast_argument_next(*arg);
+
+	return TRUE;
+}
+
+/*
+ * Command registration
+ */
+
+static bool cmd_denotify_registered
+(struct sieve_validator *valdtr, struct sieve_command_registration *cmd_reg)
+{
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, &denotify_match_tag, OPT_MATCH_TYPE);
+
+	ext_notify_register_importance_tags(valdtr, cmd_reg, OPT_IMPORTANCE);
+
+	return TRUE;
+}
+
+/*
+ * Code generation
+ */
+
+static bool cmd_denotify_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx)
+{
+	sieve_operation_emit_code(cgenv->sbin, &denotify_operation);
+
+	/* Emit source line */
+	sieve_code_source_line_emit(cgenv->sbin, sieve_command_source_line(ctx));
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, ctx, NULL);
+}
+
+/* 
+ * Code dump
+ */
+ 
+static bool cmd_denotify_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{	
+	int opt_code = 1;
+	
+	sieve_code_dumpf(denv, "%s", op->mnemonic);
+	sieve_code_descend(denv);	
+
+	/* Source line */
+	if ( !sieve_code_source_line_dump(denv, address) )
+		return FALSE;
+
+	/* Dump optional operands */
+	if ( sieve_operand_optional_present(denv->sbin, address) ) {
+		while ( opt_code != 0 ) {
+			sieve_code_mark(denv);
+			
+			if ( !sieve_operand_optional_read(denv->sbin, address, &opt_code) ) 
+				return FALSE;
+
+			switch ( opt_code ) {
+			case 0:
+				break;
+			case OPT_MATCH_KEY:
+				if ( !sieve_opr_string_dump(denv, address, "key-string") )
+					return FALSE;
+				break;
+			case OPT_MATCH_TYPE:
+				if ( !sieve_opr_match_type_dump(denv, address) )
+					return FALSE;
+				break;
+			case OPT_IMPORTANCE:
+				if ( !sieve_opr_number_dump(denv, address, "importance") )
+					return FALSE;
+				break;
+			default:
+				return FALSE;
+			}
+		}
+	}
+	
+	return TRUE;
+}
+
+/* 
+ * Code execution
+ */
+
+static int cmd_denotify_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{	
+	int opt_code = 1;
+	sieve_number_t importance = 1;
+	const struct sieve_match_type *match_type = NULL;
+	string_t *match_key = NULL; 
+	unsigned int source_line;
+
+	/*
+	 * Read operands
+	 */
+		
+	/* Source line */
+	if ( !sieve_code_source_line_read(renv, address, &source_line) ) {
+		sieve_runtime_trace_error(renv, "invalid source line");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/* Optional operands */	
+	if ( sieve_operand_optional_present(renv->sbin, address) ) {
+		while ( opt_code != 0 ) {
+			if ( !sieve_operand_optional_read(renv->sbin, address, &opt_code) ) {
+				sieve_runtime_trace_error(renv, "invalid optional operand");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+
+			switch ( opt_code ) {
+			case 0:
+				break;
+			case OPT_MATCH_TYPE:
+				if ( (match_type = sieve_opr_match_type_read(renv, address)) == NULL ) {
+					sieve_runtime_trace_error(renv, "invalid match type operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+				break;
+			case OPT_MATCH_KEY:
+				if ( !sieve_opr_string_read(renv, address, &match_key) ) {
+					sieve_runtime_trace_error(renv, "invalid from operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+				break;
+			case OPT_IMPORTANCE:
+				if ( !sieve_opr_number_read(renv, address, &importance) ) {
+					sieve_runtime_trace_error(renv, "invalid importance operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+	
+				/* Enforce 0 < importance < 4 (just to be sure) */
+				if ( importance < 1 ) 
+					importance = 1;
+				else if ( importance > 3 )
+					importance = 3;
+				break;
+			default:
+				sieve_runtime_trace_error(renv, "unknown optional operand: %d", 
+					opt_code);
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+		}
+	}
+		
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "DENOTIFY action");	
+
+	return SIEVE_EXEC_OK;
+}
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/notify/cmd-notify.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/notify/cmd-notify.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/notify/cmd-notify.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/notify/cmd-notify.c	2009-07-27 13:30:18.000000000 +0200
@@ -0,0 +1,915 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "array.h"
+#include "str.h"
+#include "ioloop.h"
+#include "str-sanitize.h"
+#include "message-date.h"
+#include "mail-storage.h"
+
+#include "rfc2822.h"
+
+#include "sieve-common.h"
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-actions.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-result.h"
+#include "sieve-address.h"
+#include "sieve-message.h"
+
+#include "ext-notify-common.h"
+#include "ext-notify-limits.h"
+
+#include <ctype.h>
+
+/* Notify command (DEPRECATED)
+ *
+ * Syntax:
+ *   notify [":method" string] [":id" string] [":options" string-list]
+ *          [<":low" / ":normal" / ":high">] ["message:" string]
+ *
+ */
+
+static bool cmd_notify_registered
+	(struct sieve_validator *valdtr,
+		struct sieve_command_registration *cmd_reg);
+static bool cmd_notify_pre_validate
+	(struct sieve_validator *valdtr, struct sieve_command_context *cmd);
+static bool cmd_notify_validate
+	(struct sieve_validator *valdtr, struct sieve_command_context *cmd);
+static bool cmd_notify_generate
+	(const struct sieve_codegen_env *cgenv, 
+		struct sieve_command_context *ctx);
+
+const struct sieve_command cmd_notify_old = {
+	"notify",
+	SCT_COMMAND,
+	0, 0, FALSE, FALSE,
+	cmd_notify_registered,
+	cmd_notify_pre_validate,
+	cmd_notify_validate,
+	cmd_notify_generate, 
+	NULL,
+};
+
+/*
+ * Tagged arguments
+ */
+
+/* Forward declarations */
+
+static bool cmd_notify_validate_string_tag
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+		struct sieve_command_context *cmd);
+static bool cmd_notify_validate_stringlist_tag
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+
+/* Argument objects */
+
+static const struct sieve_argument notify_method_tag = {
+	"method",
+	NULL, NULL,
+	cmd_notify_validate_string_tag,
+	NULL, NULL
+};
+
+static const struct sieve_argument notify_options_tag = { 
+	"options", 
+	NULL, NULL,
+	cmd_notify_validate_stringlist_tag, 
+	NULL, NULL 
+};
+
+static const struct sieve_argument notify_id_tag = {
+	"id",
+	NULL, NULL,
+	cmd_notify_validate_string_tag,
+	NULL, NULL
+};
+
+static const struct sieve_argument notify_message_tag = {
+	"message",
+	NULL, NULL,
+	cmd_notify_validate_string_tag,
+	NULL, NULL
+};
+
+/* 
+ * Notify operation 
+ */
+
+static bool cmd_notify_operation_dump
+	(const struct sieve_operation *op,	
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_notify_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation notify_old_operation = { 
+	"NOTIFY",
+	&notify_extension,
+	EXT_NOTIFY_OPERATION_NOTIFY,
+	cmd_notify_operation_dump, 
+	cmd_notify_operation_execute
+};
+
+/* Codes for optional operands */
+
+enum cmd_notify_optional {
+  OPT_END,
+  OPT_MESSAGE,
+  OPT_IMPORTANCE,
+  OPT_OPTIONS,
+  OPT_ID
+};
+
+/* 
+ * Notify action 
+ */
+
+/* Forward declarations */
+
+static int act_notify_check_duplicate
+	(const struct sieve_runtime_env *renv, 
+		const struct sieve_action_data *act,
+		const struct sieve_action_data *act_other);
+static void act_notify_print
+	(const struct sieve_action *action, const struct sieve_result_print_env *rpenv,
+		void *context, bool *keep);	
+static bool act_notify_commit
+	(const struct sieve_action *action,	const struct sieve_action_exec_env *aenv, 
+		void *tr_context, bool *keep);
+
+/* Action object */
+
+const struct sieve_action act_notify_old = {
+	"notify",
+	0,
+	NULL,
+	act_notify_check_duplicate, 
+	NULL,
+	act_notify_print,
+	NULL, NULL,
+	act_notify_commit,
+	NULL
+};
+
+/*
+ * Command validation context
+ */
+
+struct cmd_notify_context_data {
+	struct sieve_ast_argument *id;
+	struct sieve_ast_argument *method;
+	struct sieve_ast_argument *options;
+	struct sieve_ast_argument *message;
+};
+
+/*
+ * Tag validation
+ */
+
+static bool cmd_notify_validate_string_tag
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+    struct sieve_command_context *cmd)
+{
+	struct sieve_ast_argument *tag = *arg;
+	struct cmd_notify_context_data *ctx_data =
+		(struct cmd_notify_context_data *) cmd->data;
+
+	/* Detach the tag itself */
+	*arg = sieve_ast_arguments_detach(*arg, 1);
+
+	/* Check syntax:
+	 *   :id <string>
+	 *   :method <string>
+	 *   :message <string>
+	 */
+	if ( !sieve_validate_tag_parameter(valdtr, cmd, tag, *arg, SAAT_STRING) )
+		return FALSE;
+
+	if ( tag->argument == &notify_method_tag ) {
+		ctx_data->method = *arg;
+	
+		/* Removed */
+		*arg = sieve_ast_arguments_detach(*arg, 1);
+
+	} else if ( tag->argument == &notify_id_tag ) {
+		ctx_data->id = *arg;
+
+		/* Skip parameter */
+		*arg = sieve_ast_argument_next(*arg);
+
+	} else if ( tag->argument == &notify_message_tag ) {
+		ctx_data->message = *arg;
+
+		/* Skip parameter */
+		*arg = sieve_ast_argument_next(*arg);
+	}
+
+	return TRUE;
+}
+
+static bool cmd_notify_validate_stringlist_tag
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd)
+{
+	struct sieve_ast_argument *tag = *arg;
+	struct cmd_notify_context_data *ctx_data = 
+		(struct cmd_notify_context_data *) cmd->data; 
+
+	/* Detach the tag itself */
+	*arg = sieve_ast_arguments_detach(*arg,1);
+	
+	/* Check syntax:
+	 *   :options string-list
+	 */
+	if ( !sieve_validate_tag_parameter(valdtr, cmd, tag, *arg, SAAT_STRING_LIST) ) 
+		return FALSE;
+		
+	/* Assign context */
+	ctx_data->options = *arg;	
+	
+	/* Skip parameter */
+	*arg = sieve_ast_argument_next(*arg);
+
+	return TRUE;
+}
+
+/*
+ * Command registration
+ */
+
+static bool cmd_notify_registered
+(struct sieve_validator *valdtr, struct sieve_command_registration *cmd_reg)
+{
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, &notify_method_tag, 0);
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, &notify_id_tag, OPT_ID);
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, &notify_message_tag, OPT_MESSAGE);
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, &notify_options_tag, OPT_OPTIONS);
+
+	ext_notify_register_importance_tags(valdtr, cmd_reg, OPT_IMPORTANCE);
+
+	return TRUE;
+}
+
+/*
+ * Command validation
+ */
+
+static bool cmd_notify_pre_validate
+(struct sieve_validator *valdtr ATTR_UNUSED,
+	struct sieve_command_context *cmd)
+{
+	struct cmd_notify_context_data *ctx_data;
+	
+	/* Create context */
+	ctx_data = p_new(sieve_command_pool(cmd),	struct cmd_notify_context_data, 1);
+	cmd->data = ctx_data;
+
+	return TRUE;
+}
+
+static int cmd_notify_address_validate
+(void *context, struct sieve_ast_argument *arg)
+{
+	struct sieve_validator *valdtr = (struct sieve_validator *) context;
+
+	if ( sieve_argument_is_string_literal(arg) ) {
+		string_t *address = sieve_ast_argument_str(arg);
+		const char *error;
+		bool result = FALSE;
+
+		T_BEGIN {
+			result = sieve_address_validate(address, &error);
+
+			if ( !result ) {
+				sieve_argument_validate_error(valdtr, arg,
+					"specified :options address '%s' is invalid for "
+					"the mailto notify method: %s",
+					str_sanitize(str_c(address), 128), error);
+			}
+		} T_END;
+
+		return result;
+	}
+
+	return TRUE;
+}
+
+static bool cmd_notify_validate
+(struct sieve_validator *valdtr, struct sieve_command_context *cmd)
+{
+	struct cmd_notify_context_data *ctx_data =
+		(struct cmd_notify_context_data *) cmd->data;
+
+	/* Check :method argument */
+	if ( ctx_data->method != NULL )	{
+		const char *method = sieve_ast_argument_strc(ctx_data->method);
+		
+		if ( strcasecmp(method, "mailto") != 0 ) {
+			sieve_command_validate_error(valdtr, cmd,
+				"the notify command of the deprecated notify extension "
+				"only supports the 'mailto' notification method");
+			return FALSE;
+		}
+	}
+
+	/* Check :options argument */
+	if ( ctx_data->options != NULL ) {
+		struct sieve_ast_argument *option = ctx_data->options;
+		
+		/* Parse and check options */
+		if ( sieve_ast_stringlist_map
+			(&option, (void *) valdtr, cmd_notify_address_validate) <= 0 ) {
+			return FALSE;
+		}
+	} else {
+		sieve_command_validate_warning(valdtr, cmd,
+			"no :options (and hence recipients) specified for the notify command");
+	}
+
+	return TRUE;
+}
+
+/*
+ * Code generation
+ */
+
+static bool cmd_notify_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx)
+{
+	sieve_operation_emit_code(cgenv->sbin, &notify_old_operation);
+
+	/* Emit source line */
+	sieve_code_source_line_emit(cgenv->sbin, sieve_command_source_line(ctx));
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, ctx, NULL);
+}
+
+/* 
+ * Code dump
+ */
+ 
+static bool cmd_notify_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{	
+	int opt_code = 1;
+	
+	sieve_code_dumpf(denv, "NOTIFY");
+	sieve_code_descend(denv);	
+
+	/* Source line */
+	if ( !sieve_code_source_line_dump(denv, address) )
+		return FALSE;
+
+	/* Dump optional operands */
+	if ( sieve_operand_optional_present(denv->sbin, address) ) {
+		while ( opt_code != 0 ) {
+			sieve_code_mark(denv);
+			
+			if ( !sieve_operand_optional_read(denv->sbin, address, &opt_code) ) 
+				return FALSE;
+
+			switch ( opt_code ) {
+			case 0:
+				break;
+			case OPT_IMPORTANCE:
+				if ( !sieve_opr_number_dump(denv, address, "importance") )
+					return FALSE;
+				break;
+			case OPT_ID:
+				if ( !sieve_opr_string_dump(denv, address, "id") )
+					return FALSE;
+				break;
+			case OPT_OPTIONS:
+				if ( !sieve_opr_stringlist_dump(denv, address, "options") )
+					return FALSE;
+				break;
+			case OPT_MESSAGE:
+				if ( !sieve_opr_string_dump(denv, address, "message") )
+					return FALSE;
+				break;
+			default:
+				return FALSE;
+			}
+		}
+	}
+	
+	return TRUE;
+}
+
+/* 
+ * Code execution
+ */
+
+static void cmd_notify_construct_message
+(const struct sieve_runtime_env *renv, const char *msg_format, 
+	string_t *out_msg)
+{
+	const struct sieve_message_data *msgdata = renv->msgdata;
+  const char *p;
+
+  if ( msg_format == NULL )
+		msg_format = "$from$: $subject$";
+ 
+ 	/* Scan message for substitutions */
+	p = msg_format;
+  while ( *p != '\0' ) {
+		const char *const *header;
+
+		if ( strncasecmp(p, "$from$", 6) == 0 ) {
+			p += 6;
+		
+			/* Fetch sender from oriinal message */
+			if ( mail_get_headers_utf8(msgdata->mail, "from", &header) >= 0 )
+				 str_append(out_msg, header[0]); 
+
+		} else if ( strncasecmp(p, "$env-from$", 10) == 0 ) {
+			p += 10;
+
+			if ( msgdata->return_path != NULL ) 
+				str_append(out_msg, msgdata->return_path);
+
+		} else if ( strncasecmp(p, "$subject$", 9) == 0 ) {	
+			p += 9;
+
+			/* Fetch sender from oriinal message */
+			if ( mail_get_headers_utf8(msgdata->mail, "subject", &header) >= 0 )
+				 str_append(out_msg, header[0]); 
+			
+		} else if ( strncasecmp(p, "$text", 5) == 0 
+			&& (p[5] == '[' || p[5] == '$') ) {
+			size_t num = 0;
+			const char *begin = p;
+			bool valid = TRUE;
+
+    	p += 5;
+			if ( *p == '[' ) {
+				p += 1;
+
+				while ( i_isdigit(*p) ) {
+					num = num * 10 + (*p - '0');
+					p++;
+				}
+
+				if ( *p++ != ']' || *p++ != '$' ) {
+					str_append_n(out_msg, begin, p-begin);
+					valid = FALSE;										
+				}	    	
+			} else {
+				p += 1;			
+			}
+
+			if ( valid ) {
+				str_append(out_msg, "<body extraction not supported>");
+			}
+		} else {
+			size_t len;
+
+    	/* Find next substitution */
+    	len = strcspn(p + 1, "$") + 1; 
+
+	    /* Copy normal text */
+	    str_append_n(out_msg, p, len);
+	    p += len;
+		}
+  }
+}
+ 
+static int cmd_notify_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{	
+	struct ext_notify_action *act;
+	pool_t pool;
+	int opt_code = 1;
+	sieve_number_t importance = 1;
+	struct sieve_coded_stringlist *options = NULL;
+	string_t *message = NULL, *id = NULL; 
+	unsigned int source_line;
+
+	/*
+	 * Read operands
+	 */
+		
+	/* Source line */
+	if ( !sieve_code_source_line_read(renv, address, &source_line) ) {
+		sieve_runtime_trace_error(renv, "invalid source line");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/* Optional operands */	
+	if ( sieve_operand_optional_present(renv->sbin, address) ) {
+		while ( opt_code != 0 ) {
+			if ( !sieve_operand_optional_read(renv->sbin, address, &opt_code) ) {
+				sieve_runtime_trace_error(renv, "invalid optional operand");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+
+			switch ( opt_code ) {
+			case 0:
+				break;
+			case OPT_IMPORTANCE:
+				if ( !sieve_opr_number_read(renv, address, &importance) ) {
+					sieve_runtime_trace_error(renv, "invalid importance operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+	
+				/* Enforce 0 < importance < 4 (just to be sure) */
+				if ( importance < 1 ) 
+					importance = 1;
+				else if ( importance > 3 )
+					importance = 3;
+				break;
+			case OPT_ID:
+				if ( !sieve_opr_string_read(renv, address, &id) ) {
+					sieve_runtime_trace_error(renv, "invalid id operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+				break;
+			case OPT_MESSAGE:
+				if ( !sieve_opr_string_read(renv, address, &message) ) {
+					sieve_runtime_trace_error(renv, "invalid from operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+				break;
+			case OPT_OPTIONS:
+				if ( (options=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+					sieve_runtime_trace_error(renv, "invalid options operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+				break;
+			default:
+				sieve_runtime_trace_error(renv, "unknown optional operand: %d", 
+					opt_code);
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+		}
+	}
+		
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "NOTIFY action");	
+
+	/* Compose action */
+	if ( options != NULL ) {
+		string_t *raw_address;
+		string_t *out_message;
+		bool result;	
+
+		pool = sieve_result_pool(renv->result);
+		act = p_new(pool, struct ext_notify_action, 1);
+		if ( id != NULL )
+				act->id = p_strdup(pool, str_c(id));
+		act->importance = importance;		
+	
+		/* Process message */
+
+		out_message = t_str_new(1024);
+		cmd_notify_construct_message
+			(renv, (message == NULL ? NULL : str_c(message)), out_message);
+		act->message = p_strdup(pool, str_c(out_message));
+		
+		/* Normalize and verify all :options addresses */					
+
+		sieve_coded_stringlist_reset(options);
+			
+		p_array_init(&act->recipients, pool, 4);
+		
+		raw_address = NULL;
+		while ( (result=sieve_coded_stringlist_next_item(options, &raw_address))
+			&& raw_address != NULL ) {
+			const char *error = NULL;
+			const char *addr_norm = sieve_address_normalize(raw_address, &error);
+			
+			/* Add if valid address */
+			if ( addr_norm != NULL ) {
+				const struct ext_notify_recipient *rcpts;
+				unsigned int rcpt_count, i;
+
+				/* Prevent duplicates */
+				rcpts = array_get(&act->recipients, &rcpt_count);
+				
+				for ( i = 0; i < rcpt_count; i++ ) {
+					if ( sieve_address_compare
+						(rcpts[i].normalized, addr_norm, TRUE) == 0 )
+						break;
+				}
+	
+				/* Add only if unique */
+				if ( i != rcpt_count ) {
+					sieve_runtime_warning(renv, 
+						sieve_error_script_location(renv->script, source_line),
+						"duplicate recipient '%s' specified in the :options argument of "
+						"the deprecated notify command", 
+						str_sanitize(str_c(raw_address), 128));
+
+				}	else if 
+					( array_count(&act->recipients) >= EXT_NOTIFY_MAX_RECIPIENTS ) {
+					sieve_runtime_warning(renv, 
+						sieve_error_script_location(renv->script, source_line),
+						"more than the maximum %u recipients are specified "
+						"for the deprecated notify command; "
+						"the rest is discarded", EXT_NOTIFY_MAX_RECIPIENTS);
+					break;
+
+				} else {						
+					struct ext_notify_recipient recipient;			
+
+					recipient.full = p_strdup(pool, str_c(raw_address));
+					recipient.normalized = p_strdup(pool, addr_norm);
+		
+					array_append(&act->recipients, &recipient, 1);
+				}		
+			} else {
+				sieve_runtime_error(renv, 
+					sieve_error_script_location(renv->script, source_line),
+					"specified :options address '%s' is invalid for "
+					"the deprecated notify command: %s", 
+					str_sanitize(str_c(raw_address), 128), error);
+				return SIEVE_EXEC_FAILURE;
+			}
+		}
+		
+		if ( !result ) {
+			sieve_runtime_trace_error(renv, "invalid options stringlist");
+			return SIEVE_EXEC_BIN_CORRUPT;
+		}
+		
+		return ( sieve_result_add_action
+			(renv, &act_notify_old, NULL, source_line, (void *) act, 0) >= 0 );
+	}
+
+	return SIEVE_EXEC_OK;
+}
+
+/*
+ * Action
+ */
+
+/* Runtime verification */
+
+static int act_notify_check_duplicate
+(const struct sieve_runtime_env *renv ATTR_UNUSED, 
+	const struct sieve_action_data *act ATTR_UNUSED,
+	const struct sieve_action_data *act_other ATTR_UNUSED)
+{
+	struct ext_notify_action *new_nact, *old_nact;
+	const struct ext_notify_recipient *new_rcpts;
+	const struct ext_notify_recipient *old_rcpts;
+	unsigned int new_count, old_count, i, j;
+	unsigned int del_start = 0, del_len = 0;
+		
+	if ( act->context == NULL || act_other->context == NULL )
+		return 0;
+
+	new_nact = (struct ext_notify_action *) act->context;
+	old_nact = (struct ext_notify_action *) act_other->context;
+
+	new_rcpts = array_get(&new_nact->recipients, &new_count);
+	old_rcpts = array_get(&old_nact->recipients, &old_count);
+
+	for ( i = 0; i < new_count; i++ ) {
+		for ( j = 0; j < old_count; j++ ) {
+			if ( sieve_address_compare
+				(new_rcpts[i].normalized, old_rcpts[j].normalized, TRUE) == 0 )
+				break;				
+		}
+
+		if ( j == old_count ) {
+			/* Not duplicate */
+			if ( del_len > 0 ) {
+				/* Perform pending deletion */
+				array_delete(&new_nact->recipients, del_start, del_len);
+
+				/* Make sure the loop integrity is maintained */
+				i -= del_len;
+				new_rcpts = array_get(&new_nact->recipients, &new_count);
+			}
+
+			del_len = 0;		
+		} else {
+			/* Mark deletion */
+			if ( del_len == 0 )
+				del_start = i;
+			del_len++;
+		}
+	}
+
+	/* Perform pending deletion */
+	if ( del_len > 0 ) {
+		array_delete(&new_nact->recipients, del_start, del_len);			
+	}
+
+	return ( array_count(&new_nact->recipients) > 0 ? 0 : 1 );
+}
+
+/* Result printing */
+ 
+static void act_notify_print
+(const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_result_print_env *rpenv, void *context, 
+	bool *keep ATTR_UNUSED)	
+{
+	const struct ext_notify_action *act = 
+		(const struct ext_notify_action *) context;
+	const struct ext_notify_recipient *recipients;
+	unsigned int count, i;
+
+	sieve_result_action_printf
+		( rpenv, "send (depricated) notification with method 'mailto':");
+	
+	/* Print main method parameters */
+
+	sieve_result_printf
+		( rpenv, "    => importance    : %d\n", act->importance);
+
+	if ( act->message != NULL )
+		sieve_result_printf
+			( rpenv, "    => message       : %s\n", act->message);
+
+	if ( act->id != NULL )
+		sieve_result_printf
+			( rpenv, "    => id            : %s \n", act->id);
+
+	/* Print mailto: recipients */
+
+	sieve_result_printf
+		( rpenv, "    => recipients    :\n" );
+
+	recipients = array_get(&act->recipients, &count);
+	if ( count == 0 ) {
+		sieve_result_printf(rpenv, "       NONE, action has no effect\n");
+	} else {
+		for ( i = 0; i < count; i++ ) {
+			sieve_result_printf
+				( rpenv, "       + To: %s\n", recipients[i].full);
+		}
+	}
+
+	/* Finish output with an empty line */
+
+	sieve_result_printf(rpenv, "\n");
+}
+
+/* Result execution */
+
+static bool contains_8bit(const char *msg)
+{
+	const unsigned char *s = (const unsigned char *)msg;
+
+	for (; *s != '\0'; s++) {
+		if ((*s & 0x80) != 0)
+			return TRUE;
+	}
+	return FALSE;
+}
+
+static bool act_notify_send
+(const struct sieve_action_exec_env *aenv, 
+	const struct ext_notify_action *act)
+{ 
+	const struct sieve_message_data *msgdata = aenv->msgdata;
+	const struct sieve_script_env *senv = aenv->scriptenv;
+	const struct ext_notify_recipient *recipients;
+	void *smtp_handle;
+	unsigned int count, i;
+	FILE *f;
+	const char *outmsgid;
+
+	/* Get recipients */
+	recipients = array_get(&act->recipients, &count);
+	if ( count == 0  ) {
+		sieve_result_warning(aenv, 
+			"notify action specifies no recipients; action has no effect");
+		return TRUE;
+	}
+
+	/* Just to be sure */
+	if ( senv->smtp_open == NULL || senv->smtp_close == NULL ) {
+		sieve_result_warning(aenv, 
+			"notify action has no means to send mail");
+		return TRUE;
+	}
+	
+	/* Send message to all recipients */
+	for ( i = 0; i < count; i++ ) {
+
+		if ( msgdata->return_path != NULL )
+			smtp_handle = senv->smtp_open(recipients[i].normalized, 
+				senv->postmaster_address, &f);
+		else		
+			smtp_handle = senv->smtp_open(recipients[i].normalized, NULL, &f);
+
+		outmsgid = sieve_message_get_new_id(senv);
+	
+		rfc2822_header_field_write(f, "X-Sieve", SIEVE_IMPLEMENTATION);
+		rfc2822_header_field_write(f, "Message-ID", outmsgid);
+		rfc2822_header_field_write(f, "Date", message_date_create(ioloop_time));
+
+		/* Set importance */
+		switch ( act->importance ) {
+		case 1:
+			rfc2822_header_field_write(f, "X-Priority", "1 (Highest)");
+			rfc2822_header_field_write(f, "Importance", "High");
+			break;
+		case 3:
+			rfc2822_header_field_write(f, "X-Priority", "5 (Lowest)");
+			rfc2822_header_field_write(f, "Importance", "Low");
+			break;
+		case 2:
+		default:
+			rfc2822_header_field_write(f, "X-Priority", "3 (Normal)");
+			rfc2822_header_field_write(f, "Importance", "Normal");
+			break;
+		}
+
+		rfc2822_header_field_printf(f, "From", "%s", 
+			t_strdup_printf("Postmaster <%s>", senv->postmaster_address));
+
+		rfc2822_header_field_printf(f, "To", "%s", recipients[i].full);
+
+		rfc2822_header_field_write(f, "Subject", "[SIEVE] New mail notification");
+
+		rfc2822_header_field_write(f, "Auto-Submitted", "auto-generated (notify)");
+		rfc2822_header_field_write(f, "Precedence", "bulk");
+
+		if (contains_8bit(act->message)) {
+			rfc2822_header_field_write(f, "MIME-Version", "1.0");
+			rfc2822_header_field_write(f, 
+				"Content-Type", "text/plain; charset=UTF-8");
+			rfc2822_header_field_write(f, "Content-Transfer-Encoding", "8bit");
+		}
+
+		/* Generate message body */
+		fprintf(f, "\r\n");
+		fprintf(f, "%s\r\n", act->message);
+			
+		if ( senv->smtp_close(smtp_handle) ) {
+			sieve_result_log(aenv, 
+				"sent mail notification to <%s>", 
+				str_sanitize(recipients[i].normalized, 80));
+		} else {
+			sieve_result_error(aenv,
+				"failed to send mail notification to <%s> "
+				"(refer to system log for more information)", 
+				str_sanitize(recipients[i].normalized, 80));
+		}
+	}
+
+	return TRUE;
+}
+
+static bool act_notify_commit
+(const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_action_exec_env *aenv, void *tr_context, 
+	bool *keep ATTR_UNUSED)
+{
+	const struct ext_notify_action *act = 
+		(const struct ext_notify_action *) tr_context;
+	const struct sieve_message_data *msgdata = aenv->msgdata;
+	const char *const *headers;
+
+	/* Is the message an automatic reply ? */
+	if ( mail_get_headers
+		(msgdata->mail, "auto-submitted", &headers) >= 0 ) {
+		const char *const *hdsp = headers;
+
+		/* Theoretically multiple headers could exist, so lets make sure */
+		while ( *hdsp != NULL ) {
+			if ( strcasecmp(*hdsp, "no") != 0 ) {
+				sieve_result_log(aenv, 
+					"not sending notification for auto-submitted message from <%s>", 
+					str_sanitize(msgdata->return_path, 128));	
+					return TRUE;				 
+			}
+			hdsp++;
+		}
+	}
+
+	return act_notify_send(aenv, act);
+}
+
+
+
+
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/notify/ext-notify.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/notify/ext-notify.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/notify/ext-notify.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/notify/ext-notify.c	2009-07-27 13:30:18.000000000 +0200
@@ -0,0 +1,109 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension notify
+ * ----------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: draft-ietf-sieve-notify-00.txt
+ * Implementation: deprecated; provided for backwards compatibility
+ * Status: deprecated
+ * 
+ */
+
+/* FIXME: Currently the following CMUSieve features are not supported:
+ * 
+ * (*) The $text$ substitution is not available for the :message argument.
+ */
+	
+#include <stdio.h>
+
+#include "sieve-common.h"
+
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-actions.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-result.h"
+
+#include "ext-notify-common.h"
+
+/*
+ * Operations
+ */
+
+const struct sieve_operation *ext_notify_operations[] = {
+	&notify_old_operation,
+	&denotify_operation
+};
+
+/* 
+ * Extension
+ */
+
+static bool ext_notify_validator_load(struct sieve_validator *valdtr);
+
+static int ext_notify_my_id = -1;
+
+const struct sieve_extension notify_extension = { 
+	"notify", 
+	&ext_notify_my_id,
+	NULL,
+	NULL,
+	ext_notify_validator_load, 
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATIONS(ext_notify_operations),
+	SIEVE_EXT_DEFINE_NO_OPERANDS,
+};
+
+/*
+ * Extension validation
+ */
+
+static bool ext_notify_validator_extension_validate
+	(struct sieve_validator *valdtr, void *context, 
+		struct sieve_ast_argument *require_arg);
+
+const struct sieve_validator_extension notify_validator_extension = {
+	&notify_extension,
+	ext_notify_validator_extension_validate,
+	NULL
+};
+
+static bool ext_notify_validator_load(struct sieve_validator *valdtr)
+{
+	/* Register validator extension to check for conflict with enotify */
+	sieve_validator_extension_register
+		(valdtr, &notify_validator_extension, NULL);
+
+	/* Register new commands */
+	sieve_validator_register_command(valdtr, &cmd_notify_old);
+	sieve_validator_register_command(valdtr, &cmd_denotify);
+	
+	return TRUE;
+}
+
+static bool ext_notify_validator_extension_validate
+(struct sieve_validator *valdtr, void *context ATTR_UNUSED,
+    struct sieve_ast_argument *require_arg)
+{
+	const struct sieve_extension *ext;
+
+	if ( (ext=sieve_extension_get_by_name("enotify")) != NULL ) {
+
+		/* Check for conflict with enotify */
+		if ( sieve_validator_extension_loaded(valdtr, ext) ) {
+			sieve_argument_validate_error(valdtr, require_arg,
+				"the (deprecated) notify extension cannot be used "
+				"together with the enotify extension");
+			return FALSE;
+		}
+	}
+
+	return TRUE;
+}
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/notify/ext-notify-common.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/notify/ext-notify-common.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/notify/ext-notify-common.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/notify/ext-notify-common.c	2009-07-27 13:30:18.000000000 +0200
@@ -0,0 +1,77 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+
+#include "sieve-common.h"
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-actions.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-result.h"
+
+#include "ext-notify-common.h"
+
+/*
+ * Importance argument
+ */
+
+static bool tag_importance_validate
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+		struct sieve_command_context *cmd);
+
+static const struct sieve_argument importance_low_tag = {
+	"low",
+	NULL, NULL,
+	tag_importance_validate,
+	NULL, NULL
+};
+
+static const struct sieve_argument importance_normal_tag = {
+	"normal",
+	NULL, NULL,
+	tag_importance_validate,
+	NULL, NULL
+};
+
+static const struct sieve_argument importance_high_tag = {
+	"high",
+	NULL, NULL,
+	tag_importance_validate,
+	NULL, NULL
+};
+
+static bool tag_importance_validate
+(struct sieve_validator *valdtr ATTR_UNUSED, struct sieve_ast_argument **arg,
+	struct sieve_command_context *cmd ATTR_UNUSED)
+{
+	struct sieve_ast_argument *tag = *arg;
+
+	if ( tag->argument == &importance_low_tag )
+		sieve_ast_argument_number_substitute(tag, 3);
+	else if ( tag->argument == &importance_normal_tag )
+		sieve_ast_argument_number_substitute(tag, 2);
+	else
+		sieve_ast_argument_number_substitute(tag, 1);
+
+	tag->argument = &number_argument;
+
+	/* Skip parameter */
+	*arg = sieve_ast_argument_next(*arg);
+
+	return TRUE;
+}
+
+void ext_notify_register_importance_tags
+(struct sieve_validator *valdtr, struct sieve_command_registration *cmd_reg,
+	unsigned int id_code)
+{
+	sieve_validator_register_tag(valdtr, cmd_reg, &importance_low_tag, id_code);
+	sieve_validator_register_tag(valdtr, cmd_reg, &importance_normal_tag, id_code);
+	sieve_validator_register_tag(valdtr, cmd_reg, &importance_high_tag, id_code);
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/notify/ext-notify-common.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/notify/ext-notify-common.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/notify/ext-notify-common.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/notify/ext-notify-common.h	2009-07-27 13:30:18.000000000 +0200
@@ -0,0 +1,57 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_NOTIFY_COMMON_H
+#define __EXT_NOTIFY_COMMON_H
+
+/*
+ * Extension
+ */
+
+extern const struct sieve_extension notify_extension;
+
+/*
+ * Commands
+ */
+
+extern const struct sieve_command cmd_notify_old;
+extern const struct sieve_command cmd_denotify;
+
+/*
+ * Arguments
+ */
+
+void ext_notify_register_importance_tags
+	(struct sieve_validator *valdtr, struct sieve_command_registration *cmd_reg,
+		unsigned int id_code);
+
+/*
+ * Operations
+ */
+
+extern const struct sieve_operation notify_old_operation;
+extern const struct sieve_operation denotify_operation;
+
+enum ext_notify_opcode {
+	EXT_NOTIFY_OPERATION_NOTIFY,
+	EXT_NOTIFY_OPERATION_DENOTIFY,
+};
+
+/* Action context */
+
+struct ext_notify_recipient {
+	const char *full;
+	const char *normalized;
+};
+
+ARRAY_DEFINE_TYPE(recipients, struct ext_notify_recipient);
+		
+struct ext_notify_action {
+	const char *id;
+	const char *message;
+	sieve_number_t importance;
+
+	ARRAY_TYPE(recipients) recipients;
+};
+
+#endif /* __EXT_NOTIFY_COMMON_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/notify/ext-notify-limits.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/notify/ext-notify-limits.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/notify/ext-notify-limits.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/notify/ext-notify-limits.h	2009-07-19 15:54:39.000000000 +0200
@@ -0,0 +1,10 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#ifndef __EXT_NOTIFY_LIMITS_H
+#define __EXT_NOTIFY_LIMITS_H
+
+#define EXT_NOTIFY_MAX_RECIPIENTS  8
+#define EXT_NOTIFY_MAX_MESSAGE     256
+
+#endif /* __EXT_NOTIFY_LIMITS_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/notify/Makefile.am dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/notify/Makefile.am
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/notify/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/notify/Makefile.am	2009-07-27 13:30:18.000000000 +0200
@@ -0,0 +1,23 @@
+noinst_LTLIBRARIES = libsieve_ext_notify.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I../variables \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+commands = \
+	cmd-notify.c \
+	cmd-denotify.c
+
+libsieve_ext_notify_la_SOURCES = \
+	ext-notify.c \
+	ext-notify-common.c \
+	$(commands)
+
+noinst_HEADERS = \
+	ext-notify-common.h \
+	ext-notify-limits.h
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/notify/Makefile.in dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/notify/Makefile.in
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/notify/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/notify/Makefile.in	2009-08-21 00:55:43.000000000 +0200
@@ -0,0 +1,472 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve/plugins/notify
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libsieve_ext_notify_la_LIBADD =
+am__objects_1 = cmd-notify.lo cmd-denotify.lo
+am_libsieve_ext_notify_la_OBJECTS = ext-notify.lo ext-notify-common.lo \
+	$(am__objects_1)
+libsieve_ext_notify_la_OBJECTS = $(am_libsieve_ext_notify_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_ext_notify_la_SOURCES)
+DIST_SOURCES = $(libsieve_ext_notify_la_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LTLIBRARIES = libsieve_ext_notify.la
+AM_CPPFLAGS = \
+	-I../../ \
+	-I../variables \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+commands = \
+	cmd-notify.c \
+	cmd-denotify.c
+
+libsieve_ext_notify_la_SOURCES = \
+	ext-notify.c \
+	ext-notify-common.c \
+	$(commands)
+
+noinst_HEADERS = \
+	ext-notify-common.h \
+	ext-notify-limits.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/lib-sieve/plugins/notify/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  src/lib-sieve/plugins/notify/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve_ext_notify.la: $(libsieve_ext_notify_la_OBJECTS) $(libsieve_ext_notify_la_DEPENDENCIES) 
+	$(LINK)  $(libsieve_ext_notify_la_OBJECTS) $(libsieve_ext_notify_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-denotify.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-notify.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-notify-common.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-notify.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/regex/ext-regex.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/regex/ext-regex.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/regex/ext-regex.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/regex/ext-regex.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,67 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension regex 
+ * ---------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: draft-murchison-sieve-regex-07
+ * Implementation: full, but suboptimal
+ * Status: experimental, largely untested
+ *
+ * FIXME: Regular expressions are compiled during compilation and 
+ * again during interpretation. This is suboptimal and should be 
+ * changed. This requires dumping the compiled regex to the binary. 
+ * Most likely, this will only be possible when we implement regular
+ * expressions ourselves. 
+ * 
+ */
+
+#include "lib.h"
+#include "mempool.h"
+#include "buffer.h"
+
+#include "sieve-common.h"
+
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+
+#include "ext-regex-common.h"
+
+#include <sys/types.h>
+#include <regex.h>
+
+/* 
+ * Extension
+ */
+
+static bool ext_regex_validator_load(struct sieve_validator *validator);
+
+static int ext_my_id = -1;
+
+const struct sieve_extension regex_extension = { 
+	"regex", 
+	&ext_my_id,
+	NULL, NULL,
+	ext_regex_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_NO_OPERATIONS, 
+	SIEVE_EXT_DEFINE_OPERAND(regex_match_type_operand)
+};
+
+static bool ext_regex_validator_load(struct sieve_validator *validator)
+{
+	sieve_match_type_register(validator, &regex_match_type); 
+
+	return TRUE;
+}
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/regex/ext-regex-common.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/regex/ext-regex-common.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/regex/ext-regex-common.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/regex/ext-regex-common.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,23 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-match-types.h"
+
+#include "ext-regex-common.h"
+
+/* 
+ * Regex match type operand
+ */
+
+static const struct sieve_extension_objects ext_match_types =
+    SIEVE_EXT_DEFINE_MATCH_TYPE(regex_match_type);
+
+const struct sieve_operand regex_match_type_operand = {
+    "regex match",
+    &regex_extension,
+    0,
+    &sieve_match_type_operand_class,
+    &ext_match_types
+};
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/regex/ext-regex-common.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/regex/ext-regex-common.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/regex/ext-regex-common.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/regex/ext-regex-common.h	2009-02-24 13:42:43.000000000 +0100
@@ -0,0 +1,27 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_REGEX_COMMON_H
+#define __EXT_REGEX_COMMON_H
+
+/*
+ * Extension
+ */
+
+extern const struct sieve_extension regex_extension;
+
+/*
+ * Operand
+ */
+
+extern const struct sieve_operand regex_match_type_operand;
+
+/*
+ * Match type
+ */
+
+extern const struct sieve_match_type regex_match_type;
+
+#endif /* __EXT_REGEX_COMMON_H */
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/regex/Makefile.am dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/regex/Makefile.am
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/regex/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/regex/Makefile.am	2008-10-20 01:35:49.000000000 +0200
@@ -0,0 +1,16 @@
+noinst_LTLIBRARIES = libsieve_ext_regex.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+libsieve_ext_regex_la_SOURCES = \
+	mcht-regex.c \
+	ext-regex-common.c \
+	ext-regex.c
+
+noinst_HEADERS = \
+	ext-regex-common.h
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/regex/Makefile.in dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/regex/Makefile.in
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/regex/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/regex/Makefile.in	2009-08-21 00:55:43.000000000 +0200
@@ -0,0 +1,464 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve/plugins/regex
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libsieve_ext_regex_la_LIBADD =
+am_libsieve_ext_regex_la_OBJECTS = mcht-regex.lo ext-regex-common.lo \
+	ext-regex.lo
+libsieve_ext_regex_la_OBJECTS = $(am_libsieve_ext_regex_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_ext_regex_la_SOURCES)
+DIST_SOURCES = $(libsieve_ext_regex_la_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LTLIBRARIES = libsieve_ext_regex.la
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+libsieve_ext_regex_la_SOURCES = \
+	mcht-regex.c \
+	ext-regex-common.c \
+	ext-regex.c
+
+noinst_HEADERS = \
+	ext-regex-common.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/lib-sieve/plugins/regex/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  src/lib-sieve/plugins/regex/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve_ext_regex.la: $(libsieve_ext_regex_la_OBJECTS) $(libsieve_ext_regex_la_DEPENDENCIES) 
+	$(LINK)  $(libsieve_ext_regex_la_OBJECTS) $(libsieve_ext_regex_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-regex-common.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-regex.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mcht-regex.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/regex/mcht-regex.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/regex/mcht-regex.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/regex/mcht-regex.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/regex/mcht-regex.c	2009-07-30 01:14:02.000000000 +0200
@@ -0,0 +1,323 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Match-type ':regex'
+ */
+
+#include "lib.h"
+#include "mempool.h"
+#include "buffer.h"
+#include "array.h"
+#include "str.h"
+
+#include "sieve-common.h"
+#include "sieve-limits.h"
+#include "sieve-ast.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-match.h"
+
+#include "ext-regex-common.h"
+
+#include <sys/types.h>
+#include <regex.h>
+#include <ctype.h>
+
+/*
+ * Configuration
+ */
+
+#define MCHT_REGEX_MAX_SUBSTITUTIONS SIEVE_MAX_MATCH_VALUES
+
+/* 
+ * Match type
+ */
+ 
+bool mcht_regex_validate_context
+(struct sieve_validator *validator, struct sieve_ast_argument *arg,
+    struct sieve_match_type_context *ctx, struct sieve_ast_argument *key_arg);
+
+static void mcht_regex_match_init(struct sieve_match_context *mctx);
+static int mcht_regex_match
+	(struct sieve_match_context *mctx, const char *val, size_t val_size,
+    	const char *key, size_t key_size, int key_index);
+static int mcht_regex_match_deinit(struct sieve_match_context *mctx);
+
+const struct sieve_match_type regex_match_type = {
+	SIEVE_OBJECT("regex", &regex_match_type_operand, 0),
+	TRUE, FALSE,
+	NULL,
+	mcht_regex_validate_context,
+	mcht_regex_match_init,
+	mcht_regex_match,
+	mcht_regex_match_deinit
+};
+
+/* 
+ * Match type validation 
+ */
+
+/* Wrapper around the regerror function for easy access */
+static const char *_regexp_error(regex_t *regexp, int errorcode)
+{
+	size_t errsize = regerror(errorcode, regexp, NULL, 0); 
+
+	if ( errsize > 0 ) {
+		char *errbuf;
+
+		buffer_t *error_buf = 
+			buffer_create_dynamic(pool_datastack_create(), errsize);
+		errbuf = buffer_get_space_unsafe(error_buf, 0, errsize);
+
+		errsize = regerror(errorcode, regexp, errbuf, errsize);
+	 
+		/* We don't want the error to start with a capital letter */
+		errbuf[0] = i_tolower(errbuf[0]);
+
+		buffer_append_space_unsafe(error_buf, errsize);
+
+		return str_c(error_buf);
+	}
+
+	return "";
+}
+
+static int mcht_regex_validate_regexp
+(struct sieve_validator *validator, 
+	struct sieve_match_type_context *ctx ATTR_UNUSED,
+	struct sieve_ast_argument *key, int cflags) 
+{
+	int ret;
+	regex_t regexp;
+
+	if ( (ret=regcomp(&regexp, sieve_ast_argument_strc(key), cflags)) != 0 ) {
+		sieve_argument_validate_error(validator, key,
+			"invalid regular expression for regex match: %s", 
+			_regexp_error(&regexp, ret));
+
+		regfree(&regexp);	
+		return FALSE;
+	}
+
+	regfree(&regexp);
+	return TRUE;
+}
+
+struct _regex_key_context {
+	struct sieve_validator *valdtr;
+	struct sieve_match_type_context *mctx;
+	int cflags;
+};
+
+static int mcht_regex_validate_key_argument
+(void *context, struct sieve_ast_argument *key)
+{
+	struct _regex_key_context *keyctx = (struct _regex_key_context *) context;
+
+	/* FIXME: We can currently only handle string literal argument, so
+	 * variables are not allowed.
+	 */
+	if ( !sieve_argument_is_string_literal(key) ) {
+		sieve_argument_validate_error(keyctx->valdtr, key,
+			"this Sieve implementation currently only accepts a literal string "
+			"for a regular expression");
+		return FALSE;
+	}
+
+	return mcht_regex_validate_regexp
+		(keyctx->valdtr, keyctx->mctx, key, keyctx->cflags);
+}
+	
+bool mcht_regex_validate_context
+(struct sieve_validator *validator, struct sieve_ast_argument *arg ATTR_UNUSED,
+	struct sieve_match_type_context *ctx, struct sieve_ast_argument *key_arg)
+{
+	const struct sieve_comparator *cmp = ctx->comparator;
+	int cflags = REG_EXTENDED | REG_NOSUB;
+	struct _regex_key_context keyctx;
+	struct sieve_ast_argument *kitem;
+
+	if ( cmp != NULL ) { 
+		if ( cmp == &i_ascii_casemap_comparator )
+			cflags =  REG_EXTENDED | REG_NOSUB | REG_ICASE;
+		else if ( cmp == &i_octet_comparator )
+			cflags =  REG_EXTENDED | REG_NOSUB;
+		else {
+			sieve_argument_validate_error(validator, ctx->match_type_arg, 
+				"regex match type only supports "
+				"i;octet and i;ascii-casemap comparators" );
+			return FALSE;	
+		}
+	}
+
+	/* Validate regular expression keys */
+
+	keyctx.valdtr = validator;
+	keyctx.mctx = ctx;
+	keyctx.cflags = cflags;
+
+	kitem = key_arg;
+	if ( !sieve_ast_stringlist_map(&kitem, (void *) &keyctx,
+		mcht_regex_validate_key_argument) )
+		return FALSE;
+
+	return TRUE;
+}
+
+/* 
+ * Match type implementation 
+ */
+
+struct mcht_regex_context {
+	ARRAY_DEFINE(reg_expressions, regex_t);
+	int value_index;
+	regmatch_t *pmatch;
+	size_t nmatch;
+};
+
+static void mcht_regex_match_init
+(struct sieve_match_context *mctx)
+{
+	pool_t pool = mctx->pool;
+	struct mcht_regex_context *ctx;
+
+	/* Create context */	
+	ctx = p_new(pool, struct mcht_regex_context, 1);
+	p_array_init(&ctx->reg_expressions, pool, 4);
+	ctx->value_index = -1;
+
+	/* Create storage for match values if match values are requested */
+	if ( sieve_match_values_are_enabled(mctx->interp) ) {
+		ctx->pmatch = p_new(pool, regmatch_t, MCHT_REGEX_MAX_SUBSTITUTIONS);
+		ctx->nmatch = MCHT_REGEX_MAX_SUBSTITUTIONS;
+	} else {
+		ctx->pmatch = NULL;
+		ctx->nmatch = 0;
+	}
+	
+	/* Assign context */
+	mctx->data = (void *) ctx;
+}
+
+static regex_t *mcht_regex_get
+(struct mcht_regex_context *ctx,
+	const struct sieve_comparator *cmp, 
+	const char *key, unsigned int key_index)
+{
+	int ret;
+	int cflags;
+	regex_t *regexp;
+	
+	/* If this is the first matched value, the regexes are not compiled
+	 * yet.
+	 */
+	if ( ctx->value_index <= 0 ) {
+		/* Allocate space */
+		array_idx_clear(&ctx->reg_expressions, key_index);
+		regexp = array_idx_modifiable(&ctx->reg_expressions, key_index);
+
+		/* Configure case-sensitivity according to comparator */
+		if ( cmp == &i_octet_comparator ) 
+			cflags =  REG_EXTENDED;
+		else if ( cmp ==  &i_ascii_casemap_comparator )
+			cflags =  REG_EXTENDED | REG_ICASE;
+		else
+			return NULL; /* Not supported */
+			
+		/* Indicate whether match values need to be produced */
+		if ( ctx->nmatch == 0 ) cflags |= REG_NOSUB;
+
+		/* Compile regular expression */
+		if ( (ret=regcomp(regexp, key, cflags)) != 0 ) {
+			/* FIXME: Do something useful, i.e. report error somewhere */
+			return NULL;
+		}
+	} else {
+		/* Get compiled regex from cache */
+		regexp = array_idx_modifiable(&ctx->reg_expressions, key_index);
+	}
+
+	return regexp;
+}
+
+static int mcht_regex_match
+(struct sieve_match_context *mctx, 
+	const char *val, size_t val_size ATTR_UNUSED, 
+	const char *key, size_t key_size ATTR_UNUSED, int key_index)
+{
+	struct mcht_regex_context *ctx = (struct mcht_regex_context *) mctx->data;
+	regex_t *regexp;
+
+	if ( val == NULL ) {
+		val = "";
+		val_size = 0;
+	}
+
+	if ( key_index < 0 ) return FALSE;
+
+	if ( key_index == 0 ) ctx->value_index++;
+
+	/* Get compiled regex */
+	if ( (regexp=mcht_regex_get(ctx, mctx->comparator, key, key_index)) == NULL )
+		return FALSE;
+
+	/* Execute regex */
+	if ( regexec(regexp, val, ctx->nmatch, ctx->pmatch, 0) == 0 ) {
+
+		/* Handle match values if necessary */
+		if ( ctx->nmatch > 0 ) {
+			struct sieve_match_values *mvalues;
+			size_t i;
+			int skipped = 0;
+			string_t *subst = t_str_new(32);
+
+			/* Start new list of match values */
+			mvalues = sieve_match_values_start(mctx->interp);
+
+			i_assert( mvalues != NULL );
+
+			/* Add match values from regular expression */
+			for ( i = 0; i < ctx->nmatch; i++ ) {
+				str_truncate(subst, 0);
+			
+				if ( ctx->pmatch[i].rm_so != -1 ) {
+					if ( skipped > 0 ) {
+						sieve_match_values_skip(mvalues, skipped);
+						skipped = 0;
+					}
+					
+					str_append_n(subst, val + ctx->pmatch[i].rm_so, 
+						ctx->pmatch[i].rm_eo - ctx->pmatch[i].rm_so);
+					sieve_match_values_add(mvalues, subst);
+				} else 
+					skipped++;
+			}
+
+			/* Substitute the new match values */
+			sieve_match_values_commit(mctx->interp, &mvalues);
+		}
+
+		return TRUE;
+	}
+	
+	return FALSE;
+}
+
+int mcht_regex_match_deinit
+(struct sieve_match_context *mctx)
+{
+	struct mcht_regex_context *ctx = (struct mcht_regex_context *) mctx->data;
+	regex_t *regexps;
+	unsigned int count, i;
+
+	/* Clean up compiled regular expressions */
+	regexps = array_get_modifiable(&ctx->reg_expressions, &count);
+	for ( i = 0; i < count; i++ ) {
+		regfree(&regexps[i]);
+	}
+
+	return FALSE;
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/relational/ext-relational.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/relational/ext-relational.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/relational/ext-relational.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/relational/ext-relational.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,57 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension relational 
+ * --------------------
+ *
+ * Author: Stephan Bosch
+ * Specification: RFC 3431
+ * Implementation: full
+ * Status: experimental, largely untested
+ * 
+ */
+
+#include "lib.h"
+#include "str.h"
+
+#include "sieve-common.h"
+
+#include "sieve-ast.h"
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+
+#include "ext-relational-common.h"
+
+/* 
+ * Extension
+ */
+
+static bool ext_relational_validator_load(struct sieve_validator *validator);
+
+int ext_relational_my_id = -1;
+
+const struct sieve_extension relational_extension = { 
+	"relational", 
+	&ext_relational_my_id,
+	NULL, NULL,
+	ext_relational_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_NO_OPERATIONS, 
+	SIEVE_EXT_DEFINE_OPERAND(rel_match_type_operand)
+};
+
+static bool ext_relational_validator_load(struct sieve_validator *validator)
+{
+	sieve_match_type_register(validator, &value_match_type); 
+	sieve_match_type_register(validator, &count_match_type); 
+
+	return TRUE;
+}
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/relational/ext-relational-common.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/relational/ext-relational-common.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/relational/ext-relational-common.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/relational/ext-relational-common.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,160 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Syntax:
+ *   MATCH-TYPE =/ COUNT / VALUE
+ *   COUNT = ":count" relational-match
+ *   VALUE = ":value" relational-match
+ *   relational-match = DQUOTE ( "gt" / "ge" / "lt"
+ *                             / "le" / "eq" / "ne" ) DQUOTE
+ */ 
+
+#include "lib.h"
+#include "str.h"
+#include "str-sanitize.h"
+
+#include "sieve-common.h"
+#include "sieve-ast.h"
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+
+#include "ext-relational-common.h"
+
+/*
+ * Forward declarations
+ */
+
+const struct sieve_match_type *rel_match_types[];
+
+/* 
+ * Validation 
+ */
+
+bool mcht_relational_validate
+(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+	struct sieve_match_type_context *ctx)
+{	
+	enum relational_match rel_match = REL_MATCH_INVALID;
+	string_t *rel_match_ident;
+
+	/* Check syntax:
+	 *   relational-match = DQUOTE ( "gt" / "ge" / "lt"	
+ 	 *                             / "le" / "eq" / "ne" ) DQUOTE
+ 	 *
+	 * So, actually this must be a constant string and it is implemented as such 
+	 */
+	 
+	/* Did we get a string in the first place ? */ 
+	if ( (*arg)->type != SAAT_STRING ) {
+		sieve_argument_validate_error(validator, *arg, 
+			"the :%s match-type requires a constant string argument being "
+			"one of \"gt\", \"ge\", \"lt\", \"le\", \"eq\" or \"ne\", "
+			"but %s was found", 
+			ctx->match_type->object.identifier, sieve_ast_argument_name(*arg));
+		return FALSE;
+	}
+	
+	/* Check the relational match id */
+	
+	rel_match_ident = sieve_ast_argument_str(*arg);
+	if ( str_len(rel_match_ident) == 2 ) {
+		const char *rel_match_id = str_c(rel_match_ident);
+
+		switch ( rel_match_id[0] ) {
+		/* "gt" or "ge" */
+		case 'g':
+			switch ( rel_match_id[1] ) {
+			case 't': 
+				rel_match = REL_MATCH_GREATER; 
+				break;
+			case 'e': 
+				rel_match = REL_MATCH_GREATER_EQUAL; 
+				break;
+			default: 
+				rel_match = REL_MATCH_INVALID;
+			}
+			break;
+		/* "lt" or "le" */
+		case 'l':
+			switch ( rel_match_id[1] ) {
+			case 't': 
+				rel_match = REL_MATCH_LESS; 
+				break;
+			case 'e': 
+				rel_match = REL_MATCH_LESS_EQUAL; 
+				break;
+			default: 
+				rel_match = REL_MATCH_INVALID;
+			}
+			break;
+		/* "eq" */
+		case 'e':
+			if ( rel_match_id[1] == 'q' )
+				rel_match = REL_MATCH_EQUAL;
+			else	
+				rel_match = REL_MATCH_INVALID;		
+			break;
+		/* "ne" */
+		case 'n':
+			if ( rel_match_id[1] == 'e' )
+				rel_match = REL_MATCH_NOT_EQUAL;
+			else	
+				rel_match = REL_MATCH_INVALID;
+			break;
+		/* invalid */
+		default:
+			rel_match = REL_MATCH_INVALID;
+		}
+	}
+	
+	if ( rel_match >= REL_MATCH_INVALID ) {
+		sieve_argument_validate_error(validator, *arg, 
+			"the :%s match-type requires a constant string argument being "
+			"one of \"gt\", \"ge\", \"lt\", \"le\", \"eq\" or \"ne\", "
+			"but \"%s\" was found", 
+			ctx->match_type->object.identifier, 
+			str_sanitize(str_c(rel_match_ident), 32));
+		return FALSE;
+	}
+	
+	/* Delete argument */
+	*arg = sieve_ast_arguments_detach(*arg, 1);
+
+	/* Not used just yet */
+	ctx->ctx_data = (void *) rel_match;
+
+	/* Override the actual match type with a parameter-specific one */
+	ctx->match_type = rel_match_types
+		[REL_MATCH_INDEX(ctx->match_type->object.code, rel_match)];
+
+	return TRUE;
+}
+
+/*
+ * Relational match-type operand
+ */
+
+const const struct sieve_match_type *rel_match_types[] = {
+    &rel_match_value_gt, &rel_match_value_ge, &rel_match_value_lt,
+    &rel_match_value_le, &rel_match_value_eq, &rel_match_value_ne,
+    &rel_match_count_gt, &rel_match_count_ge, &rel_match_count_lt,
+    &rel_match_count_le, &rel_match_count_eq, &rel_match_count_ne
+};
+
+static const struct sieve_extension_objects ext_match_types =
+	SIEVE_EXT_DEFINE_MATCH_TYPES(rel_match_types);
+
+const struct sieve_operand rel_match_type_operand = {
+    "relational match",
+    &relational_extension,
+    0,
+    &sieve_match_type_operand_class,
+    &ext_match_types
+};
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/relational/ext-relational-common.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/relational/ext-relational-common.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/relational/ext-relational-common.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/relational/ext-relational-common.h	2009-02-24 13:42:08.000000000 +0100
@@ -0,0 +1,96 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#ifndef __EXT_RELATIONAL_COMMON_H
+#define __EXT_RELATIONAL_COMMON_H
+
+#include "lib.h"
+#include "str.h"
+
+#include "sieve-common.h"
+
+/* 
+ * Types 
+ */
+
+enum ext_relational_match_type {
+	RELATIONAL_VALUE,
+	RELATIONAL_COUNT
+};
+
+enum relational_match {
+	REL_MATCH_GREATER,
+	REL_MATCH_GREATER_EQUAL,
+	REL_MATCH_LESS,
+	REL_MATCH_LESS_EQUAL,
+	REL_MATCH_EQUAL,
+	REL_MATCH_NOT_EQUAL,
+	REL_MATCH_INVALID
+};
+
+#define REL_MATCH_INDEX(type, match) \
+	(type * REL_MATCH_INVALID + match)
+#define REL_MATCH_TYPE(index) \
+	(index / REL_MATCH_INVALID)
+#define REL_MATCH(index) \
+	(index % REL_MATCH_INVALID)
+
+/* 
+ * Extension definitions 
+ */
+
+extern int ext_relational_my_id;
+
+extern const struct sieve_extension relational_extension;
+extern const struct sieve_match_type_extension relational_match_extension;
+
+/*
+ * Match types
+ */
+ 
+/* Registered for validation */ 
+
+extern const struct sieve_match_type value_match_type;
+extern const struct sieve_match_type count_match_type;
+
+/* Used in byte code */
+
+extern const struct sieve_match_type rel_match_count_gt;
+extern const struct sieve_match_type rel_match_count_ge;
+extern const struct sieve_match_type rel_match_count_lt;
+extern const struct sieve_match_type rel_match_count_le;
+extern const struct sieve_match_type rel_match_count_eq;
+extern const struct sieve_match_type rel_match_count_ne;
+
+extern const struct sieve_match_type rel_match_value_gt;
+extern const struct sieve_match_type rel_match_value_ge;
+extern const struct sieve_match_type rel_match_value_lt;
+extern const struct sieve_match_type rel_match_value_le;
+extern const struct sieve_match_type rel_match_value_eq;
+extern const struct sieve_match_type rel_match_value_ne;
+
+/*
+ * Operand
+ */
+ 
+extern const struct sieve_operand rel_match_type_operand;
+
+
+/*
+ * Match type validation
+ */
+
+bool mcht_relational_validate
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_match_type_context *ctx);
+		
+/*
+ * Value match function (also used by :count)
+ */
+ 
+int mcht_value_match
+    (struct sieve_match_context *mctx, const char *val, size_t val_size,
+        const char *key, size_t key_size, int key_index);
+
+
+#endif /* __EXT_RELATIONAL_COMMON_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/relational/Makefile.am dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/relational/Makefile.am
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/relational/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/relational/Makefile.am	2008-10-20 01:35:49.000000000 +0200
@@ -0,0 +1,17 @@
+noinst_LTLIBRARIES = libsieve_ext_relational.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+libsieve_ext_relational_la_SOURCES = \
+	ext-relational-common.c \
+	mcht-value.c \
+	mcht-count.c \
+	ext-relational.c 
+
+noinst_HEADERS = \
+	ext-relational-common.h
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/relational/Makefile.in dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/relational/Makefile.in
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/relational/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/relational/Makefile.in	2009-08-21 00:55:43.000000000 +0200
@@ -0,0 +1,467 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve/plugins/relational
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libsieve_ext_relational_la_LIBADD =
+am_libsieve_ext_relational_la_OBJECTS = ext-relational-common.lo \
+	mcht-value.lo mcht-count.lo ext-relational.lo
+libsieve_ext_relational_la_OBJECTS =  \
+	$(am_libsieve_ext_relational_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_ext_relational_la_SOURCES)
+DIST_SOURCES = $(libsieve_ext_relational_la_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LTLIBRARIES = libsieve_ext_relational.la
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+libsieve_ext_relational_la_SOURCES = \
+	ext-relational-common.c \
+	mcht-value.c \
+	mcht-count.c \
+	ext-relational.c 
+
+noinst_HEADERS = \
+	ext-relational-common.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/lib-sieve/plugins/relational/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  src/lib-sieve/plugins/relational/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve_ext_relational.la: $(libsieve_ext_relational_la_OBJECTS) $(libsieve_ext_relational_la_DEPENDENCIES) 
+	$(LINK)  $(libsieve_ext_relational_la_OBJECTS) $(libsieve_ext_relational_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-relational-common.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-relational.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mcht-count.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mcht-value.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/relational/mcht-count.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/relational/mcht-count.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/relational/mcht-count.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/relational/mcht-count.c	2009-07-30 00:39:12.000000000 +0200
@@ -0,0 +1,136 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+/* Match-type ':count' 
+ */
+
+#include "lib.h"
+#include "str.h"
+
+#include "sieve-common.h"
+#include "sieve-ast.h"
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-match.h"
+
+#include "ext-relational-common.h"
+
+/* 
+ * Forward declarations
+ */
+
+static void mcht_count_match_init(struct sieve_match_context *mctx);
+static int mcht_count_match
+	(struct sieve_match_context *mctx, const char *val, size_t val_size, 
+		const char *key, size_t key_size, int key_index);
+static int mcht_count_match_deinit(struct sieve_match_context *mctx);
+
+/* 
+ * Match-type objects
+ */
+ 
+const struct sieve_match_type count_match_type = {
+	SIEVE_OBJECT("count", &rel_match_type_operand, RELATIONAL_COUNT),
+	FALSE, FALSE,
+	mcht_relational_validate,
+	NULL, NULL, NULL, NULL
+};
+
+#define COUNT_MATCH_TYPE(name, rel_match)                     \
+const struct sieve_match_type rel_match_count_ ## name = {    \
+	SIEVE_OBJECT(                                             \
+		"count-" #name, &rel_match_type_operand,              \
+		REL_MATCH_INDEX(RELATIONAL_COUNT, rel_match)),        \
+	FALSE, FALSE,                                             \
+	NULL, NULL,                                               \
+	mcht_count_match_init,                                    \
+	mcht_count_match,                                         \
+	mcht_count_match_deinit                                   \
+}
+	
+COUNT_MATCH_TYPE(gt, REL_MATCH_GREATER);
+COUNT_MATCH_TYPE(ge, REL_MATCH_GREATER_EQUAL);
+COUNT_MATCH_TYPE(lt, REL_MATCH_LESS);
+COUNT_MATCH_TYPE(le, REL_MATCH_LESS_EQUAL);
+COUNT_MATCH_TYPE(eq, REL_MATCH_EQUAL);
+COUNT_MATCH_TYPE(ne, REL_MATCH_NOT_EQUAL);
+
+/* 
+ * Match-type implementation 
+ */
+
+struct mcht_count_context {
+	unsigned int count;
+};
+
+static void mcht_count_match_init(struct sieve_match_context *mctx)
+{
+	struct mcht_count_context *cctx = p_new(mctx->pool, struct mcht_count_context, 1);
+
+	cctx->count = 0;
+	mctx->data = (void *) cctx;
+}
+
+static int mcht_count_match
+(struct sieve_match_context *mctx, 
+	const char *val ATTR_UNUSED, size_t val_size ATTR_UNUSED, 
+	const char *key ATTR_UNUSED, size_t key_size ATTR_UNUSED,
+	int key_index) 
+{
+	if ( val == NULL )
+		return FALSE;
+
+	/* Count values */
+	if ( key_index == -1 ) {
+		struct mcht_count_context *cctx = 
+			(struct mcht_count_context *) mctx->data;
+
+		cctx->count++;
+	}
+
+	return FALSE;
+}
+
+static int mcht_count_match_deinit(struct sieve_match_context *mctx)
+{
+	struct mcht_count_context *cctx =
+            (struct mcht_count_context *) mctx->data;
+	int key_index;
+	string_t *key_item;
+    sieve_coded_stringlist_reset(mctx->key_list);
+	bool ok = TRUE;
+
+	string_t *value = t_str_new(20);
+	str_printfa(value, "%d", cctx->count);
+
+    /* Match to all key values */
+    key_index = 0;
+    key_item = NULL;
+    while ( (ok=sieve_coded_stringlist_next_item(mctx->key_list, &key_item)) 
+		&& key_item != NULL )
+    {
+		int ret = mcht_value_match
+			(mctx, str_c(value), str_len(value), str_c(key_item), 
+				str_len(key_item), key_index);
+        
+		if ( ret > 0 )   
+			return TRUE;
+	
+		if ( ret < 0 )
+			return ret;
+
+        key_index++;
+    }
+
+	return ( ok ? FALSE : -1 );
+}
+
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/relational/mcht-value.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/relational/mcht-value.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/relational/mcht-value.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/relational/mcht-value.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,92 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+
+#include "sieve-common.h"
+
+#include "sieve-ast.h"
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-match.h"
+
+#include "ext-relational-common.h"
+
+/*
+ * Match-type objects
+ */
+
+const struct sieve_match_type value_match_type = {
+	SIEVE_OBJECT("value", &rel_match_type_operand, RELATIONAL_VALUE), 
+	TRUE, TRUE,
+	mcht_relational_validate,
+	NULL, NULL, NULL, NULL
+};
+
+#define VALUE_MATCH_TYPE(name, rel_match)                   \
+const struct sieve_match_type rel_match_value_ ## name = {  \
+	SIEVE_OBJECT(                                           \
+		"value-" #name, &rel_match_type_operand,            \
+		REL_MATCH_INDEX(RELATIONAL_VALUE, rel_match)),      \
+	TRUE, TRUE,                                             \
+	NULL, NULL, NULL,                                       \
+	mcht_value_match,                                       \
+	NULL                                                    \
+}
+
+VALUE_MATCH_TYPE(gt, REL_MATCH_GREATER);
+VALUE_MATCH_TYPE(ge, REL_MATCH_GREATER_EQUAL); 
+VALUE_MATCH_TYPE(lt, REL_MATCH_LESS);
+VALUE_MATCH_TYPE(le, REL_MATCH_LESS_EQUAL); 
+VALUE_MATCH_TYPE(eq, REL_MATCH_EQUAL);
+VALUE_MATCH_TYPE(ne, REL_MATCH_NOT_EQUAL);
+
+/* 
+ * Match-type implementation 
+ */
+
+int mcht_value_match
+(struct sieve_match_context *mctx, const char *val, size_t val_size, 
+	const char *key, size_t key_size, int key_index ATTR_UNUSED)
+{
+	const struct sieve_match_type *mtch = mctx->match_type;
+	unsigned int rel_match = REL_MATCH(mtch->object.code);	
+	int cmp_result;
+
+	if ( val == NULL ) {
+		val = "";
+		val_size = 0;
+	}
+
+	cmp_result = mctx->comparator->
+		compare(mctx->comparator, val, val_size, key, key_size);
+
+	switch ( rel_match ) {
+	case REL_MATCH_GREATER:
+		return ( cmp_result > 0 );
+	case REL_MATCH_GREATER_EQUAL:
+		return ( cmp_result >= 0 );
+	case REL_MATCH_LESS:
+		return ( cmp_result < 0 );
+	case REL_MATCH_LESS_EQUAL:
+		return ( cmp_result <= 0 );
+	case REL_MATCH_EQUAL:
+		return ( cmp_result == 0 );
+	case REL_MATCH_NOT_EQUAL:
+		return ( cmp_result != 0 );
+	case REL_MATCH_INVALID:
+ 	default:
+		break;
+	}	
+	
+	return FALSE;
+}
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/subaddress/ext-subaddress.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/subaddress/ext-subaddress.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/subaddress/ext-subaddress.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/subaddress/ext-subaddress.c	2009-04-10 13:53:54.000000000 +0200
@@ -0,0 +1,163 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension subaddress 
+ * --------------------
+ *
+ * Author: Stephan Bosch
+ * Specification: RFC 3598
+ * Implementation: full, but not configurable
+ * Status: experimental, largely untested
+ * 
+ * FIXME: This extension is not configurable in any way. The separation 
+ * character is currently only configurable for compilation and not at runtime. 
+ *
+ */
+ 
+#include "sieve-common.h"
+
+#include "sieve-code.h"
+#include "sieve-address.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-address-parts.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+
+#include <stdlib.h>
+#include <string.h>
+
+/* 
+ * Configuration 
+ */
+
+#define SUBADDRESS_DEFAULT_SEP "+"
+
+static const char *sieve_subaddress_sep = SUBADDRESS_DEFAULT_SEP;
+
+/*
+ * Forward declarations 
+ */
+
+const struct sieve_address_part user_address_part;
+const struct sieve_address_part detail_address_part;
+
+static struct sieve_operand subaddress_operand;
+
+/*
+ * Extension
+ */
+
+static bool ext_subaddress_load(void);
+static bool ext_subaddress_validator_load(struct sieve_validator *validator);
+
+static int ext_my_id = -1;
+
+const struct sieve_extension subaddress_extension = { 
+	"subaddress", 
+	&ext_my_id,
+	ext_subaddress_load, 
+	NULL,
+	ext_subaddress_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_NO_OPERATIONS, 
+	SIEVE_EXT_DEFINE_OPERAND(subaddress_operand)
+};
+
+static bool ext_subaddress_load(void)
+{
+	sieve_subaddress_sep = getenv("SIEVE_SUBADDRESS_SEP");
+
+	if ( sieve_subaddress_sep == NULL )
+		sieve_subaddress_sep = SUBADDRESS_DEFAULT_SEP;
+
+	return TRUE;
+}
+
+static bool ext_subaddress_validator_load(struct sieve_validator *validator)
+{
+	sieve_address_part_register(validator, &user_address_part); 
+	sieve_address_part_register(validator, &detail_address_part); 
+
+	return TRUE;
+}
+
+/*
+ * Address parts
+ */
+ 
+enum ext_subaddress_address_part {
+  SUBADDRESS_USER,
+  SUBADDRESS_DETAIL
+};
+
+/* Forward declarations */
+
+static const char *subaddress_user_extract_from
+	(const struct sieve_address *address);
+static const char *subaddress_detail_extract_from
+	(const struct sieve_address *address);
+
+
+/* Address part objects */	
+
+const struct sieve_address_part user_address_part = {
+	SIEVE_OBJECT("user", &subaddress_operand, SUBADDRESS_USER),
+	subaddress_user_extract_from
+};
+
+const struct sieve_address_part detail_address_part = {
+	SIEVE_OBJECT("detail", &subaddress_operand, SUBADDRESS_DETAIL),
+	subaddress_detail_extract_from
+};
+
+/* Address part implementation */
+
+static const char *subaddress_user_extract_from
+	(const struct sieve_address *address)
+{
+	const char *sep;
+
+	sep = strstr(address->local_part, sieve_subaddress_sep);
+	
+	if ( sep == NULL ) return address->local_part;
+	
+	return t_strdup_until(address->local_part, sep);
+}
+
+static const char *subaddress_detail_extract_from
+	(const struct sieve_address *address)
+{
+	const char *sep;
+
+	if ( (sep=strstr(address->local_part, sieve_subaddress_sep)) == NULL )
+		return NULL; 
+
+	sep += strlen(sieve_subaddress_sep);
+
+	/* Just to be sure */
+	if ( sep > (address->local_part + strlen(address->local_part)) ) 
+		return NULL;
+
+	return sep;
+}
+
+/*
+ * Operand 
+ */
+
+const struct sieve_address_part *ext_subaddress_parts[] = {
+	&user_address_part, &detail_address_part
+};
+
+static const struct sieve_extension_objects ext_address_parts =
+	SIEVE_EXT_DEFINE_ADDRESS_PARTS(ext_subaddress_parts);
+
+static struct sieve_operand subaddress_operand = { 
+	"address-part", 
+	&subaddress_extension, 0,
+	&sieve_address_part_operand_class,
+	&ext_address_parts
+};
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/subaddress/Makefile.am dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/subaddress/Makefile.am
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/subaddress/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/subaddress/Makefile.am	2008-10-20 01:35:49.000000000 +0200
@@ -0,0 +1,11 @@
+noinst_LTLIBRARIES = libsieve_ext_subaddress.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+libsieve_ext_subaddress_la_SOURCES = \
+	ext-subaddress.c
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/subaddress/Makefile.in dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/subaddress/Makefile.in
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/subaddress/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/subaddress/Makefile.in	2009-08-21 00:55:44.000000000 +0200
@@ -0,0 +1,454 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve/plugins/subaddress
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libsieve_ext_subaddress_la_LIBADD =
+am_libsieve_ext_subaddress_la_OBJECTS = ext-subaddress.lo
+libsieve_ext_subaddress_la_OBJECTS =  \
+	$(am_libsieve_ext_subaddress_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_ext_subaddress_la_SOURCES)
+DIST_SOURCES = $(libsieve_ext_subaddress_la_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LTLIBRARIES = libsieve_ext_subaddress.la
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+libsieve_ext_subaddress_la_SOURCES = \
+	ext-subaddress.c
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/lib-sieve/plugins/subaddress/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  src/lib-sieve/plugins/subaddress/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve_ext_subaddress.la: $(libsieve_ext_subaddress_la_OBJECTS) $(libsieve_ext_subaddress_la_DEPENDENCIES) 
+	$(LINK)  $(libsieve_ext_subaddress_la_OBJECTS) $(libsieve_ext_subaddress_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-subaddress.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/vacation/cmd-vacation.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/vacation/cmd-vacation.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/vacation/cmd-vacation.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/vacation/cmd-vacation.c	2009-07-21 03:09:40.000000000 +0200
@@ -0,0 +1,1129 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "strfuncs.h"
+#include "md5.h"
+#include "hostpid.h"
+#include "str-sanitize.h"
+#include "message-address.h"
+#include "message-date.h"
+#include "ioloop.h"
+
+#include "rfc2822.h"
+
+#include "sieve-common.h"
+#include "sieve-code.h"
+#include "sieve-address.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-actions.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-result.h"
+#include "sieve-message.h"
+
+#include "ext-vacation-common.h"
+
+#include <stdio.h>
+
+/* 
+ * Forward declarations 
+ */
+ 
+static const struct sieve_argument vacation_days_tag;
+static const struct sieve_argument vacation_subject_tag;
+static const struct sieve_argument vacation_from_tag;
+static const struct sieve_argument vacation_addresses_tag;
+static const struct sieve_argument vacation_mime_tag;
+static const struct sieve_argument vacation_handle_tag;
+
+/* 
+ * Vacation command 
+ *	
+ * Syntax: 
+ *    vacation [":days" number] [":subject" string]
+ *                 [":from" string] [":addresses" string-list]
+ *                 [":mime"] [":handle" string] <reason: string>
+ */
+
+static bool cmd_vacation_registered
+	(struct sieve_validator *validator, 
+		struct sieve_command_registration *cmd_reg);
+static bool cmd_vacation_pre_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd); 
+static bool cmd_vacation_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd);
+static bool cmd_vacation_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command vacation_command = { 
+	"vacation",
+	SCT_COMMAND, 
+	1, 0, FALSE, FALSE, 
+	cmd_vacation_registered,
+	cmd_vacation_pre_validate, 
+	cmd_vacation_validate, 
+	cmd_vacation_generate, 
+	NULL 
+};
+
+/*
+ * Vacation command tags
+ */
+
+/* Forward declarations */
+
+static bool cmd_vacation_validate_number_tag
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+static bool cmd_vacation_validate_string_tag
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+static bool cmd_vacation_validate_stringlist_tag
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+static bool cmd_vacation_validate_mime_tag
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+
+/* Argument objects */
+
+static const struct sieve_argument vacation_days_tag = { 
+	"days", 
+	NULL, NULL,
+	cmd_vacation_validate_number_tag, 
+	NULL, NULL 
+};
+
+static const struct sieve_argument vacation_subject_tag = { 
+	"subject", 
+	NULL, NULL,
+	cmd_vacation_validate_string_tag, 
+	NULL, NULL 
+};
+
+static const struct sieve_argument vacation_from_tag = { 
+	"from", 
+	NULL, NULL,
+	cmd_vacation_validate_string_tag, 
+	NULL, NULL 
+};
+
+static const struct sieve_argument vacation_addresses_tag = { 
+	"addresses", 
+	NULL, NULL,
+	cmd_vacation_validate_stringlist_tag, 
+	NULL, NULL 
+};
+
+static const struct sieve_argument vacation_mime_tag = { 
+	"mime",	
+	NULL, NULL, 
+	cmd_vacation_validate_mime_tag,
+	NULL, NULL
+};
+
+static const struct sieve_argument vacation_handle_tag = { 
+	"handle", 
+	NULL, NULL, 
+	cmd_vacation_validate_string_tag, 
+	NULL, NULL 
+};
+
+/* Codes for optional arguments */
+
+enum cmd_vacation_optional {
+	OPT_END,
+	OPT_DAYS,
+	OPT_SUBJECT,
+	OPT_FROM,
+	OPT_ADDRESSES,
+	OPT_MIME
+};
+
+/* 
+ * Vacation operation 
+ */
+
+static bool ext_vacation_operation_dump
+	(const struct sieve_operation *op,	
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int ext_vacation_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation vacation_operation = { 
+	"VACATION",
+	&vacation_extension,
+	0,
+	ext_vacation_operation_dump, 
+	ext_vacation_operation_execute
+};
+
+/* 
+ * Vacation action 
+ */
+
+/* Forward declarations */
+
+static int act_vacation_check_duplicate
+	(const struct sieve_runtime_env *renv, 
+		const struct sieve_action_data *act, 
+		const struct sieve_action_data *act_other);
+int act_vacation_check_conflict
+	(const struct sieve_runtime_env *renv, 
+		const struct sieve_action_data *act, 
+		const struct sieve_action_data *act_other);
+static void act_vacation_print
+	(const struct sieve_action *action, 
+		const struct sieve_result_print_env *rpenv, void *context, bool *keep);	
+static bool act_vacation_commit
+	(const struct sieve_action *action,	const struct sieve_action_exec_env *aenv, 
+		void *tr_context, bool *keep);
+
+/* Action object */
+
+const struct sieve_action act_vacation = {
+	"vacation",
+	SIEVE_ACTFLAG_SENDS_RESPONSE,
+	NULL,
+	act_vacation_check_duplicate, 
+	act_vacation_check_conflict,
+	act_vacation_print,
+	NULL, NULL,
+	act_vacation_commit,
+	NULL
+};
+
+/* Action context information */
+		
+struct act_vacation_context {
+	const char *reason;
+
+	sieve_number_t days;
+	const char *subject;
+	const char *handle;
+	bool mime;
+	const char *from;
+	const char *from_normalized;	
+	const char *const *addresses;
+};
+
+/*
+ * Command validation context
+ */
+ 
+struct cmd_vacation_context_data {
+	string_t *from;
+	string_t *subject;
+	
+	bool mime;
+	
+	string_t *handle;
+};
+
+/* 
+ * Tag validation 
+ */
+
+static bool cmd_vacation_validate_number_tag
+(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd)
+{
+	struct sieve_ast_argument *tag = *arg;
+	
+	/* Detach the tag itself */
+	*arg = sieve_ast_arguments_detach(*arg,1);
+	
+	/* Check syntax:
+	 *   :days number
+	 */
+	if ( !sieve_validate_tag_parameter
+		(validator, cmd, tag, *arg, SAAT_NUMBER) ) {
+		return FALSE;
+	}
+
+	/* Enforce :days > 0 */
+	if ( sieve_ast_argument_number(*arg) == 0 ) {
+		sieve_ast_argument_number_set(*arg, 1);
+	}
+
+	/* Skip parameter */
+	*arg = sieve_ast_argument_next(*arg);
+	
+	return TRUE;
+}
+
+static bool cmd_vacation_validate_string_tag
+(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd)
+{
+	struct sieve_ast_argument *tag = *arg;
+	struct cmd_vacation_context_data *ctx_data = 
+		(struct cmd_vacation_context_data *) cmd->data; 
+
+	/* Detach the tag itself */
+	*arg = sieve_ast_arguments_detach(*arg,1);
+	
+	/* Check syntax:
+	 *   :subject string
+	 *   :from string
+	 *   :handle string
+	 */
+	if ( !sieve_validate_tag_parameter
+		(validator, cmd, tag, *arg, SAAT_STRING) ) {
+		return FALSE;
+	}
+
+	if ( tag->argument == &vacation_from_tag ) {
+		if ( sieve_argument_is_string_literal(*arg) ) {
+			string_t *address = sieve_ast_argument_str(*arg);
+			const char *error;
+	 		bool result;
+	 		
+	 		T_BEGIN {
+	 			result = sieve_address_validate(address, &error);
+	 
+				if ( !result ) {
+					sieve_argument_validate_error(validator, *arg, 
+						"specified :from address '%s' is invalid for vacation action: %s", 
+						str_sanitize(str_c(address), 128), error);
+				}
+			} T_END;
+		
+			if ( !result )
+				return FALSE;
+		}
+		
+		ctx_data->from = sieve_ast_argument_str(*arg);
+		
+		/* Skip parameter */
+		*arg = sieve_ast_argument_next(*arg);
+		
+	} else if ( tag->argument == &vacation_subject_tag ) {
+		ctx_data->subject = sieve_ast_argument_str(*arg);
+		
+		/* Skip parameter */
+		*arg = sieve_ast_argument_next(*arg);
+		
+	} else if ( tag->argument == &vacation_handle_tag ) {
+		ctx_data->handle = sieve_ast_argument_str(*arg);
+		
+		/* Detach optional argument (emitted as mandatory) */
+		*arg = sieve_ast_arguments_detach(*arg,1);
+	}
+			
+	return TRUE;
+}
+
+static bool cmd_vacation_validate_stringlist_tag
+(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd)
+{
+	struct sieve_ast_argument *tag = *arg;
+
+	/* Detach the tag itself */
+	*arg = sieve_ast_arguments_detach(*arg,1);
+	
+	/* Check syntax:
+	 *   :addresses string-list
+	 */
+	if ( !sieve_validate_tag_parameter
+		(validator, cmd, tag, *arg, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+	
+	/* Skip parameter */
+	*arg = sieve_ast_argument_next(*arg);
+
+	return TRUE;
+}
+
+static bool cmd_vacation_validate_mime_tag
+(struct sieve_validator *validator ATTR_UNUSED, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd)
+{
+	struct cmd_vacation_context_data *ctx_data = 
+		(struct cmd_vacation_context_data *) cmd->data; 
+
+	ctx_data->mime = TRUE;
+
+	/* Skip tag */
+	*arg = sieve_ast_argument_next(*arg);
+	
+	return TRUE;
+}
+
+/* 
+ * Command registration 
+ */
+
+static bool cmd_vacation_registered
+(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg) 
+{
+	sieve_validator_register_tag
+		(validator, cmd_reg, &vacation_days_tag, OPT_DAYS); 	
+	sieve_validator_register_tag
+		(validator, cmd_reg, &vacation_subject_tag, OPT_SUBJECT); 	
+	sieve_validator_register_tag
+		(validator, cmd_reg, &vacation_from_tag, OPT_FROM); 	
+	sieve_validator_register_tag
+		(validator, cmd_reg, &vacation_addresses_tag, OPT_ADDRESSES); 	
+	sieve_validator_register_tag
+		(validator, cmd_reg, &vacation_mime_tag, OPT_MIME); 	
+	sieve_validator_register_tag
+		(validator, cmd_reg, &vacation_handle_tag, 0); 	
+
+	return TRUE;
+}
+
+/* 
+ * Command validation 
+ */
+ 
+static bool cmd_vacation_pre_validate
+(struct sieve_validator *validator ATTR_UNUSED, 
+	struct sieve_command_context *cmd) 
+{
+	struct cmd_vacation_context_data *ctx_data;
+	
+	/* Assign context */
+	ctx_data = p_new(sieve_command_pool(cmd), 
+		struct cmd_vacation_context_data, 1);
+	cmd->data = ctx_data;
+
+	return TRUE;
+}
+
+static const char _handle_empty_subject[] = "<default-subject>";
+static const char _handle_empty_from[] = "<default-from>";
+static const char _handle_mime_enabled[] = "<MIME>";
+static const char _handle_mime_disabled[] = "<NO-MIME>";
+
+static bool cmd_vacation_validate
+(struct sieve_validator *validator, struct sieve_command_context *cmd) 
+{ 	
+	struct sieve_ast_argument *arg = cmd->first_positional;
+	struct cmd_vacation_context_data *ctx_data = 
+		(struct cmd_vacation_context_data *) cmd->data; 
+
+	if ( !sieve_validate_positional_argument
+		(validator, cmd, arg, "reason", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+	
+	if ( !sieve_validator_argument_activate(validator, cmd, arg, FALSE) )
+		return FALSE;
+		
+	/* Construct handle if not set explicitly */
+	if ( ctx_data->handle == NULL ) {
+		string_t *reason = sieve_ast_argument_str(arg);
+		unsigned int size = str_len(reason);
+		
+		/* Precalculate the size of it all */
+		size += ctx_data->subject == NULL ? 
+			sizeof(_handle_empty_subject) - 1 : str_len(ctx_data->subject);
+		size += ctx_data->from == NULL ? 
+			sizeof(_handle_empty_from) - 1 : str_len(ctx_data->from); 
+		size += ctx_data->mime ? 
+			sizeof(_handle_mime_enabled) - 1 : sizeof(_handle_mime_disabled) - 1; 
+			
+		/* Construct the string */
+		ctx_data->handle = str_new(sieve_command_pool(cmd), size);
+		str_append_str(ctx_data->handle, reason);
+		
+		if ( ctx_data->subject != NULL )
+			str_append_str(ctx_data->handle, ctx_data->subject);
+		else
+			str_append(ctx_data->handle, _handle_empty_subject);
+		
+		if ( ctx_data->from != NULL )
+			str_append_str(ctx_data->handle, ctx_data->from);
+		else
+			str_append(ctx_data->handle, _handle_empty_from);
+			
+		str_append(ctx_data->handle, 
+			ctx_data->mime ? _handle_mime_enabled : _handle_mime_disabled );
+	}
+	
+	return TRUE;
+}
+
+/*
+ * Code generation
+ */
+ 
+static bool cmd_vacation_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx) 
+{
+	struct cmd_vacation_context_data *ctx_data = 
+		(struct cmd_vacation_context_data *) ctx->data;
+		 
+	sieve_operation_emit_code(cgenv->sbin, &vacation_operation);
+
+	/* Emit source line */
+	sieve_code_source_line_emit(cgenv->sbin, sieve_command_source_line(ctx));
+
+	/* Generate arguments */
+	if ( !sieve_generate_arguments(cgenv, ctx, NULL) )
+		return FALSE;	
+
+	/* FIXME: this will not allow the handle to be a variable */
+	sieve_opr_string_emit(cgenv->sbin, ctx_data->handle);
+		
+	return TRUE;
+}
+
+/* 
+ * Code dump
+ */
+ 
+static bool ext_vacation_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{	
+	int opt_code = 1;
+	
+	sieve_code_dumpf(denv, "VACATION");
+	sieve_code_descend(denv);	
+
+	/* Source line */
+	if ( !sieve_code_source_line_dump(denv, address) )
+		return FALSE;
+
+	/* Dump optional operands */
+	if ( sieve_operand_optional_present(denv->sbin, address) ) {
+		while ( opt_code != 0 ) {
+			sieve_code_mark(denv);
+			
+			if ( !sieve_operand_optional_read(denv->sbin, address, &opt_code) ) 
+				return FALSE;
+
+			switch ( opt_code ) {
+			case 0:
+				break;
+			case OPT_DAYS:
+				if ( !sieve_opr_number_dump(denv, address, "days") )
+					return FALSE;
+				break;
+			case OPT_SUBJECT:
+				if ( !sieve_opr_string_dump(denv, address, "subject") )
+					return FALSE;
+				break;
+			case OPT_FROM:
+				if ( !sieve_opr_string_dump(denv, address, "from") )
+					return FALSE;
+				break;
+			case OPT_ADDRESSES:
+				if ( !sieve_opr_stringlist_dump(denv, address, "addresses") )
+					return FALSE;
+				break;
+			case OPT_MIME:
+				sieve_code_dumpf(denv, "mime");	
+				break;
+			
+			default:
+				return FALSE;
+			}
+		}
+	}
+	
+	/* Dump reason and handle operands */
+	return 
+		sieve_opr_string_dump(denv, address, "reason") &&
+		sieve_opr_string_dump(denv, address, "handle");
+}
+
+/* 
+ * Code execution
+ */
+ 
+static int ext_vacation_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{	
+	struct sieve_side_effects_list *slist = NULL;
+	struct act_vacation_context *act;
+	pool_t pool;
+	int opt_code = 1;
+	sieve_number_t days = 7;
+	bool mime = FALSE;
+	struct sieve_coded_stringlist *addresses = NULL;
+	string_t *reason, *subject = NULL, *from = NULL, *handle = NULL; 
+	unsigned int source_line;
+	const char *from_normalized = NULL;
+
+	/*
+	 * Read operands
+	 */
+		
+	/* Source line */
+	if ( !sieve_code_source_line_read(renv, address, &source_line) ) {
+		sieve_runtime_trace_error(renv, "invalid source line");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/* Optional operands */	
+	if ( sieve_operand_optional_present(renv->sbin, address) ) {
+		while ( opt_code != 0 ) {
+			if ( !sieve_operand_optional_read(renv->sbin, address, &opt_code) ) {
+				sieve_runtime_trace_error(renv, "invalid optional operand");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+
+			switch ( opt_code ) {
+			case 0:
+				break;
+			case OPT_DAYS:
+				if ( !sieve_opr_number_read(renv, address, &days) ) {
+					sieve_runtime_trace_error(renv, 
+						"invalid days operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+	
+				/* Enforce days > 0 (just to be sure) */
+				if ( days == 0 )
+					days = 1;
+				break;
+			case OPT_SUBJECT:
+				if ( !sieve_opr_string_read(renv, address, &subject) ) {
+					sieve_runtime_trace_error(renv, 
+						"invalid subject operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+				break;
+			case OPT_FROM:
+				if ( !sieve_opr_string_read(renv, address, &from) ) {
+					sieve_runtime_trace_error(renv, 
+						"invalid from address operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+				break;
+			case OPT_ADDRESSES:
+				if ( (addresses=sieve_opr_stringlist_read(renv, address))
+					== NULL ) {
+					sieve_runtime_trace_error(renv, 
+						"invalid addresses operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+				break;
+			case OPT_MIME:
+				mime = TRUE;
+				break;
+			default:
+				sieve_runtime_trace_error(renv, 
+					"unknown optional operand");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+		}
+	}
+	
+	/* Reason operand */
+	if ( !sieve_opr_string_read(renv, address, &reason) ) {
+		sieve_runtime_trace_error(renv, "invalid reason operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/* Handle operand */
+	if ( !sieve_opr_string_read(renv, address, &handle) ) {
+		sieve_runtime_trace_error(renv, "invalid handle operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "VACATION action");	
+
+	/* Check and normalize :from address */
+	if ( from != NULL ) {
+		const char *error;
+
+		from_normalized = sieve_address_normalize(from, &error);
+	
+		if ( from_normalized == NULL) {
+			sieve_runtime_error(renv, 
+				sieve_error_script_location(renv->script, source_line),
+				"specified :from address '%s' is invalid for vacation action: %s",
+				str_sanitize(str_c(from), 128), error);
+   		}
+	}
+
+	/* Add vacation action to the result */
+
+	pool = sieve_result_pool(renv->result);
+	act = p_new(pool, struct act_vacation_context, 1);
+	act->reason = p_strdup(pool, str_c(reason));
+	act->handle = p_strdup(pool, str_c(handle));
+	act->days = days;
+	act->mime = mime;
+	if ( subject != NULL )
+		act->subject = p_strdup(pool, str_c(subject));
+	if ( from != NULL ) {
+		act->from = p_strdup(pool, str_c(from));
+		act->from_normalized = p_strdup(pool, from_normalized);
+	}
+
+	/* Normalize all addresses */
+	if ( addresses != NULL ) {
+		ARRAY_DEFINE(norm_addresses, const char *);
+		string_t *raw_address;
+		bool result = FALSE;
+		
+		sieve_coded_stringlist_reset(addresses);
+			
+		p_array_init(&norm_addresses, pool, 4);
+		
+		raw_address = NULL;
+		while ( (result=sieve_coded_stringlist_next_item(addresses, &raw_address))
+			&& raw_address != NULL ) {
+			const char *error;
+			const char *addr_norm = sieve_address_normalize(raw_address, &error);
+			
+			if ( addr_norm != NULL ) {
+				addr_norm = p_strdup(pool, addr_norm);
+		
+				array_append(&norm_addresses, &addr_norm, 1);			
+			} else {
+				/* FIXME: report proper warning */
+			}
+		}
+		
+		if ( !result ) {
+			sieve_runtime_trace_error(renv, "invalid addresses stringlist");
+			return SIEVE_EXEC_BIN_CORRUPT;
+		}
+		
+		(void)array_append_space(&norm_addresses);
+		act->addresses = array_idx(&norm_addresses, 0);
+	}	
+		
+	return ( sieve_result_add_action
+		(renv, &act_vacation, slist, source_line, (void *) act, 0) >= 0 );
+}
+
+/*
+ * Action
+ */
+
+/* Runtime verification */
+
+static int act_vacation_check_duplicate
+(const struct sieve_runtime_env *renv ATTR_UNUSED,
+	const struct sieve_action_data *act, 
+	const struct sieve_action_data *act_other)
+{
+	if ( !act_other->executed ) {
+		sieve_runtime_error(renv, act->location, 
+			"duplicate vacation action not allowed "
+			"(previously triggered one was here: %s)", act_other->location);
+		return -1;
+	}
+
+	/* Not an error if executed in preceeding script */
+	return 1;
+}
+
+int act_vacation_check_conflict
+(const struct sieve_runtime_env *renv,
+	const struct sieve_action_data *act, 
+	const struct sieve_action_data *act_other)
+{
+	if ( (act_other->action->flags & SIEVE_ACTFLAG_SENDS_RESPONSE) > 0 ) {
+		if ( !act_other->executed && !act->executed) {
+			sieve_runtime_error(renv, act->location, 
+				"vacation action conflicts with other action: "
+				"the %s action (%s) also sends a response back to the sender",	
+				act_other->action->name, act_other->location);
+			return -1;
+		} else {
+			/* Not an error if executed in preceeding script */
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+/* Result printing */
+ 
+static void act_vacation_print
+(const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_result_print_env *rpenv, void *context, 
+	bool *keep ATTR_UNUSED)	
+{
+	struct act_vacation_context *ctx = (struct act_vacation_context *) context;
+	
+	sieve_result_action_printf( rpenv, "send vacation message:");
+	sieve_result_printf(rpenv, "    => days   : %d\n", ctx->days);
+	if ( ctx->subject != NULL )
+		sieve_result_printf(rpenv, "    => subject: %s\n", ctx->subject);
+	if ( ctx->from != NULL )
+		sieve_result_printf(rpenv, "    => from   : %s\n", ctx->from);
+	if ( ctx->handle != NULL )
+		sieve_result_printf(rpenv, "    => handle : %s\n", ctx->handle);
+	sieve_result_printf(rpenv, "\nSTART MESSAGE\n%s\nEND MESSAGE\n", ctx->reason);
+}
+
+/* Result execution */
+
+/* Headers known to be associated with mailing lists 
+ */
+static const char * const _list_headers[] = {
+	"list-id",
+	"list-owner",
+	"list-subscribe",
+	"list-post",	
+	"list-unsubscribe",
+	"list-help",
+	"list-archive",
+	NULL
+};
+
+/* Headers that should be searched for the user's own mail address(es) 
+ */
+
+static const char * const _my_address_headers[] = {
+	"to",
+	"cc",
+	"bcc",
+	"resent-to",	
+	"resent-cc",
+	"resent-bcc",
+	NULL
+};
+
+static inline bool _is_system_address(const char *address)
+{
+	if ( strncasecmp(address, "MAILER-DAEMON", 13) == 0 )
+		return TRUE;
+
+	if ( strncasecmp(address, "LISTSERV", 8) == 0 )
+		return TRUE;
+
+	if ( strncasecmp(address, "majordomo", 9) == 0 )
+		return TRUE;
+
+	if ( strstr(address, "-request@") != NULL )
+		return TRUE;
+
+	if ( strncmp(address, "owner-", 6) == 0 )
+		return TRUE;
+
+	return FALSE;
+}
+
+static inline bool _contains_my_address
+	(const char * const *headers, const char *my_address)
+{
+	const char *const *hdsp = headers;
+	bool result = FALSE;
+	
+	while ( *hdsp != NULL && !result ) {
+		const struct message_address *addr;
+
+		T_BEGIN {
+	
+			addr = message_address_parse
+				(pool_datastack_create(), (const unsigned char *) *hdsp, 
+					strlen(*hdsp), 256, FALSE);
+
+			while ( addr != NULL && !result ) {
+				if (addr->domain != NULL) {
+					const char *hdr_address; 
+					
+					i_assert(addr->mailbox != NULL);
+
+					hdr_address = t_strconcat(addr->mailbox, "@", addr->domain, NULL);
+					if ( sieve_address_compare(hdr_address, my_address, TRUE) == 0 ) {
+						result = TRUE;
+						break;
+					}
+				}
+
+				addr = addr->next;
+			}
+		} T_END;
+		
+		hdsp++;
+	}
+	
+	return result;
+}
+
+static bool act_vacation_send	
+(const struct sieve_action_exec_env *aenv, struct act_vacation_context *ctx,
+	const char *sender, const char *recipient)
+{
+	const struct sieve_message_data *msgdata = aenv->msgdata;
+	const struct sieve_script_env *senv = aenv->scriptenv;
+	void *smtp_handle;
+	FILE *f;
+ 	const char *outmsgid;
+ 	const char *const *headers;
+	int ret;
+
+	/* Check smpt functions just to be sure */
+
+	if ( senv->smtp_open == NULL || senv->smtp_close == NULL ) {
+		sieve_result_warning(aenv, "vacation action has no means to send mail");
+		return TRUE;
+	}
+
+	/* Open smtp session */
+
+	smtp_handle = senv->smtp_open(sender, NULL, &f);
+	outmsgid = sieve_message_get_new_id(senv);
+
+	/* Produce a proper reply */
+
+	rfc2822_header_field_write(f, "X-Sieve", SIEVE_IMPLEMENTATION);    
+	rfc2822_header_field_write(f, "Message-ID", outmsgid);
+	rfc2822_header_field_write(f, "Date", message_date_create(ioloop_time));
+
+	if ( ctx->from != NULL && *(ctx->from) != '\0' )
+		rfc2822_header_field_printf(f, "From", "%s", ctx->from);
+	else if ( recipient != NULL ) 
+		rfc2822_header_field_printf(f, "From", "<%s>", recipient);
+	else
+		rfc2822_header_field_printf(f, "From", "Postmaster <%s>", senv->postmaster_address);
+		
+	/* FIXME: If From header of message has same address, we should use that in 
+	 * stead properly include the phrase part.
+	 */
+	rfc2822_header_field_printf(f, "To", "<%s>", sender);
+
+	rfc2822_header_field_printf(f, "Subject", "%s", 
+		str_sanitize(ctx->subject, 256));
+
+	/* Compose proper in-reply-to and references headers */
+	
+	ret = mail_get_headers
+		(aenv->msgdata->mail, "references", &headers);
+			
+	if ( msgdata->id != NULL ) {
+		rfc2822_header_field_write(f, "In-Reply-To", msgdata->id);
+	
+		if ( ret >= 0 && headers[0] != NULL )
+			rfc2822_header_field_write
+				(f, "References", t_strconcat(headers[0], " ", msgdata->id, NULL));
+		else
+			rfc2822_header_field_write(f, "References", msgdata->id);
+	} else if ( ret >= 0 && headers[0] != NULL ) {
+		rfc2822_header_field_write(f, "References", headers[0]);
+	}
+			
+	rfc2822_header_field_write(f, "Auto-Submitted", "auto-replied (vacation)");
+	rfc2822_header_field_write(f, "Precedence", "bulk");
+	
+	rfc2822_header_field_write(f, "MIME-Version", "1.0");
+    
+	if ( !ctx->mime ) {
+		rfc2822_header_field_write(f, "Content-Type", "text/plain; charset=utf-8");
+		rfc2822_header_field_write(f, "Content-Transfer-Encoding", "8bit");
+		fprintf(f, "\r\n");
+	}
+
+	fprintf(f, "%s\r\n", ctx->reason);
+
+	/* Close smtp session */    
+	if ( !senv->smtp_close(smtp_handle) ) {
+		sieve_result_error(aenv, 
+			"failed to send vacation response to <%s> "
+			"(refer to server log for more information)", 
+			str_sanitize(sender, 128));	
+		return TRUE;
+	}
+	
+	return TRUE;
+}
+
+static void act_vacation_hash
+(struct act_vacation_context *vctx, const char *sender, unsigned char hash_r[])
+{
+	const char *rpath = t_str_lcase(sender);
+	struct md5_context ctx;
+
+	md5_init(&ctx);
+	md5_update(&ctx, rpath, strlen(rpath));
+
+	md5_update(&ctx, vctx->handle, strlen(vctx->handle));
+	
+	md5_final(&ctx, hash_r);
+}
+
+static bool act_vacation_commit
+(const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_action_exec_env *aenv, void *tr_context, 
+	bool *keep ATTR_UNUSED)
+{
+	const char *const *hdsp;
+	const struct sieve_message_data *msgdata = aenv->msgdata;
+	const struct sieve_script_env *senv = aenv->scriptenv;
+	struct act_vacation_context *ctx = (struct act_vacation_context *) tr_context;
+	unsigned char dupl_hash[MD5_RESULTLEN];
+	const char *const *headers;
+	const char *sender = sieve_message_get_sender(aenv->msgctx);
+	const char *recipient = sieve_message_get_recipient(aenv->msgctx);
+	pool_t pool;
+
+	/* Is the recipient unset? 
+	 */
+	if ( recipient == NULL ) {
+		sieve_result_warning(aenv, "vacation action aborted: envelope recipient is <>");
+		return TRUE;
+	}
+
+	/* Is the return path unset ?
+	 */
+	if ( sender == NULL ) {
+		sieve_result_log(aenv, "discarded vacation reply to <>");
+		return TRUE;
+	}    
+	
+	/* Are we perhaps trying to respond to ourselves ? 
+	 * (FIXME: verify this to :addresses as well?)
+	 */
+	if ( sieve_address_compare(sender, recipient, TRUE) 
+		== 0 ) {
+		sieve_result_log(aenv, "discarded vacation reply to own address");	
+		return TRUE;
+	}
+	
+	/* Did whe respond to this user before? */
+	if ( senv->duplicate_check != NULL ) {
+		act_vacation_hash(ctx, sender, dupl_hash);
+	
+		if ( senv->duplicate_check(dupl_hash, sizeof(dupl_hash), senv->username) ) 
+		{
+			sieve_result_log(aenv, "discarded duplicate vacation response to <%s>",
+				str_sanitize(sender, 128));
+			return TRUE;
+		}
+	}
+	
+	/* Are we trying to respond to a mailing list ? */
+	hdsp = _list_headers;
+	while ( *hdsp != NULL ) {
+		if ( mail_get_headers
+			(msgdata->mail, *hdsp, &headers) >= 0 && headers[0] != NULL ) {	
+			/* Yes, bail out */
+			sieve_result_log(aenv, 
+				"discarding vacation response to mailinglist recipient <%s>", 
+				str_sanitize(sender, 128));	
+			return TRUE;				 
+		}
+		hdsp++;
+	}
+	
+	/* Is the message that we are replying to an automatic reply ? */
+	if ( mail_get_headers
+		(msgdata->mail, "auto-submitted", &headers) >= 0 ) {
+		/* Theoretically multiple headers could exist, so lets make sure */
+		hdsp = headers;
+		while ( *hdsp != NULL ) {
+			if ( strcasecmp(*hdsp, "no") != 0 ) {
+				sieve_result_log(aenv, 
+					"discardig vacation response to auto-submitted message from <%s>", 
+					str_sanitize(sender, 128));	
+					return TRUE;				 
+			}
+			hdsp++;
+		}
+	}
+	
+	/* Check for the (non-standard) precedence header */
+	if ( mail_get_headers
+		(msgdata->mail, "precedence", &headers) >= 0 ) {
+		/* Theoretically multiple headers could exist, so lets make sure */
+		hdsp = headers;
+		while ( *hdsp != NULL ) {
+			if ( strcasecmp(*hdsp, "junk") == 0 || strcasecmp(*hdsp, "bulk") == 0 ||
+				strcasecmp(*hdsp, "list") == 0 ) {
+				sieve_result_log(aenv, 
+					"discarding vacation response to precedence=%s message from <%s>", 
+					*hdsp, str_sanitize(sender, 128));	
+					return TRUE;				 
+			}
+			hdsp++;
+		}
+	}
+	
+	/* Do not reply to system addresses */
+	if ( _is_system_address(sender) ) {
+		sieve_result_log(aenv, 
+			"not sending vacation response to system address <%s>", 
+			str_sanitize(sender, 128));	
+		return TRUE;				
+	} 
+	
+	/* Is the original message directly addressed to the user or the addresses
+	 * specified using the :addresses tag? 
+	 */
+	hdsp = _my_address_headers;
+	while ( *hdsp != NULL ) {
+		if ( mail_get_headers_utf8
+			(msgdata->mail, *hdsp, &headers) >= 0 && headers[0] != NULL ) {	
+			
+			if ( _contains_my_address(headers, recipient) ) 
+				break;
+			
+			if ( ctx->addresses != NULL ) {
+				bool found = FALSE;
+				const char * const *my_address = ctx->addresses;
+		
+				while ( !found && *my_address != NULL ) {
+					found = _contains_my_address(headers, *my_address);
+					my_address++;
+				}
+				
+				if ( found ) break;
+			}
+		}
+		hdsp++;
+	}	
+
+	if ( *hdsp == NULL ) {
+		/* No, bail out */
+		sieve_result_log(aenv, 
+			"discarding vacation response for message implicitly delivered to <%s>",
+			recipient );	
+		return TRUE;				 
+	}	
+		
+	/* Make sure we have a subject for our reply */
+	if ( ctx->subject == NULL || *(ctx->subject) == '\0' ) {
+		if ( mail_get_headers_utf8
+			(msgdata->mail, "subject", &headers) >= 0 && headers[0] != NULL ) {
+			pool = sieve_result_pool(aenv->result);
+			ctx->subject = p_strconcat(pool, "Auto: ", headers[0], NULL);
+		}	else {
+			ctx->subject = "Automated reply";
+		}
+	}	
+	
+	/* Send the message */
+	
+	if ( act_vacation_send(aenv, ctx, sender, recipient) ) {
+		sieve_result_log(aenv, "sent vacation response to <%s>", 
+			str_sanitize(sender, 128));	
+
+		/* Mark as replied */
+		if ( senv->duplicate_mark != NULL )
+			senv->duplicate_mark(dupl_hash, sizeof(dupl_hash), senv->username,
+				ioloop_time + ctx->days * (24 * 60 * 60));
+
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/vacation/ext-vacation.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/vacation/ext-vacation.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/vacation/ext-vacation.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/vacation/ext-vacation.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,52 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension vacation
+ * ------------------
+ *
+ * Authors: Stephan Bosch <stephan@rename-it.nl>
+ * Specification: RFC 5230
+ * Implementation: almost complete; the required sopport for Refences header 
+ *   is missing.
+ * Status: experimental, largely untested
+ * 
+ */
+
+#include "lib.h"
+
+#include "sieve-common.h"
+
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "ext-vacation-common.h"
+
+/* 
+ * Extension
+ */
+
+static bool ext_vacation_validator_load(struct sieve_validator *validator);
+
+static int ext_my_id = -1;
+
+const struct sieve_extension vacation_extension = { 
+	"vacation",
+	&ext_my_id,
+	NULL, NULL,
+	ext_vacation_validator_load, 
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATION(vacation_operation),
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+static bool ext_vacation_validator_load(struct sieve_validator *validator)
+{
+	/* Register new command */
+	sieve_validator_register_command(validator, &vacation_command);
+
+	return TRUE;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/vacation/ext-vacation-common.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/vacation/ext-vacation-common.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/vacation/ext-vacation-common.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/vacation/ext-vacation-common.h	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,25 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_VACATION_COMMON_H
+#define __EXT_VACATION_COMMON_H
+
+#include "sieve-common.h"
+
+/* 
+ * Commands 
+ */
+
+extern const struct sieve_command vacation_command;
+
+/* 
+ * Operations 
+ */
+
+extern const struct sieve_operation vacation_operation;
+
+/* Extension */
+
+extern const struct sieve_extension vacation_extension;
+
+#endif /* __EXT_VACATION_COMMON_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/vacation/Makefile.am dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/vacation/Makefile.am
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/vacation/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/vacation/Makefile.am	2008-10-20 01:35:49.000000000 +0200
@@ -0,0 +1,19 @@
+noinst_LTLIBRARIES = libsieve_ext_vacation.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+cmds = \
+	cmd-vacation.c
+
+libsieve_ext_vacation_la_SOURCES = \
+	$(cmds) \
+	ext-vacation.c
+
+noinst_HEADERS = \
+	ext-vacation-common.h
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/vacation/Makefile.in dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/vacation/Makefile.in
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/vacation/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/vacation/Makefile.in	2009-08-21 00:55:44.000000000 +0200
@@ -0,0 +1,466 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve/plugins/vacation
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libsieve_ext_vacation_la_LIBADD =
+am__objects_1 = cmd-vacation.lo
+am_libsieve_ext_vacation_la_OBJECTS = $(am__objects_1) ext-vacation.lo
+libsieve_ext_vacation_la_OBJECTS =  \
+	$(am_libsieve_ext_vacation_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_ext_vacation_la_SOURCES)
+DIST_SOURCES = $(libsieve_ext_vacation_la_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LTLIBRARIES = libsieve_ext_vacation.la
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+cmds = \
+	cmd-vacation.c
+
+libsieve_ext_vacation_la_SOURCES = \
+	$(cmds) \
+	ext-vacation.c
+
+noinst_HEADERS = \
+	ext-vacation-common.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/lib-sieve/plugins/vacation/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  src/lib-sieve/plugins/vacation/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve_ext_vacation.la: $(libsieve_ext_vacation_la_OBJECTS) $(libsieve_ext_vacation_la_DEPENDENCIES) 
+	$(LINK)  $(libsieve_ext_vacation_la_OBJECTS) $(libsieve_ext_vacation_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-vacation.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-vacation.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/cmd-set.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/cmd-set.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/cmd-set.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/cmd-set.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,368 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "array.h"
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+
+#include "sieve-code.h"
+#include "sieve-ast.h"
+#include "sieve-commands.h"
+#include "sieve-binary.h"
+
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "ext-variables-common.h"
+#include "ext-variables-modifiers.h"
+
+/* 
+ * Set command 
+ *	
+ * Syntax: 
+ *    set [MODIFIER] <name: string> <value: string>
+ */
+
+static bool cmd_set_registered
+	(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg);
+static bool cmd_set_pre_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd);
+static bool cmd_set_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd);
+static bool cmd_set_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command cmd_set = { 
+	"set",
+	SCT_COMMAND, 
+	2, 0, FALSE, FALSE, 
+	cmd_set_registered,
+	cmd_set_pre_validate,  
+	cmd_set_validate, 
+	cmd_set_generate, 
+	NULL 
+};
+
+/* 
+ * Set operation 
+ */
+
+static bool cmd_set_operation_dump
+	(const struct sieve_operation *op,	
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_set_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation cmd_set_operation = { 
+	"SET",
+	&variables_extension,
+	EXT_VARIABLES_OPERATION_SET,
+	cmd_set_operation_dump, 
+	cmd_set_operation_execute
+};
+
+/* 
+ * Compiler context 
+ */
+
+struct cmd_set_context {
+	ARRAY_DEFINE(modifiers, const struct sieve_variables_modifier *);
+};
+
+/* 
+ * Set modifier tag
+ *
+ * [MODIFIER]:
+ *   ":lower" / ":upper" / ":lowerfirst" / ":upperfirst" /
+ *             ":quotewildcard" / ":length"
+ */
+
+/* Forward declarations */
+ 
+static bool tag_modifier_is_instance_of
+	(struct sieve_validator *validator, struct sieve_command_context *cmdctx,	
+		struct sieve_ast_argument *arg);	
+static bool tag_modifier_validate
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+
+/* Modifier tag object */
+
+const struct sieve_argument modifier_tag = { 
+	"MODIFIER",
+	tag_modifier_is_instance_of, 
+	NULL,
+	tag_modifier_validate, 
+	NULL, NULL
+};
+ 
+/* Modifier tag implementation */ 
+ 
+static bool tag_modifier_is_instance_of
+(struct sieve_validator *validator ATTR_UNUSED, 
+	struct sieve_command_context *cmdctx ATTR_UNUSED,	
+	struct sieve_ast_argument *arg)
+{	
+	const struct sieve_variables_modifier *modf = ext_variables_modifier_find
+		(validator, sieve_ast_argument_tag(arg));
+
+	arg->context = (void *) modf;
+		
+	return ( modf != NULL );
+}
+
+static bool tag_modifier_validate
+(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd)
+{
+	unsigned int i;
+	bool inserted;
+	const struct sieve_variables_modifier *modf = 
+		(const struct sieve_variables_modifier *) (*arg)->context;
+	struct cmd_set_context *sctx = (struct cmd_set_context *) cmd->data;
+	
+	inserted = FALSE;
+	for ( i = 0; i < array_count(&sctx->modifiers) && !inserted; i++ ) {
+		const struct sieve_variables_modifier * const *smdf =
+			array_idx(&sctx->modifiers, i);
+	
+		if ( (*smdf)->precedence == modf->precedence ) {
+			sieve_argument_validate_error(validator, *arg, 
+				"modifiers :%s and :%s specified for the set command conflict "
+				"having equal precedence", 
+				(*smdf)->object.identifier, modf->object.identifier);
+			return FALSE;
+		}
+			
+		if ( (*smdf)->precedence < modf->precedence ) {
+			array_insert(&sctx->modifiers, i, &modf, 1);
+			inserted = TRUE;
+		}
+	}
+	
+	if ( !inserted )
+		array_append(&sctx->modifiers, &modf, 1);
+	
+	/* Added to modifier list; self-destruct to prevent duplicate generation */
+	*arg = sieve_ast_arguments_detach(*arg, 1);
+	
+	return TRUE;
+}
+
+/* Command registration */
+
+static bool cmd_set_registered
+	(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg) 
+{
+	sieve_validator_register_tag(validator, cmd_reg, &modifier_tag, 0); 	
+
+	return TRUE;
+}
+
+/* 
+ * Command validation 
+ */
+
+static bool cmd_set_pre_validate
+(struct sieve_validator *validator ATTR_UNUSED, 
+	struct sieve_command_context *cmd)
+{
+	pool_t pool = sieve_command_pool(cmd);
+	struct cmd_set_context *sctx = p_new(pool, struct cmd_set_context, 1);
+	
+	/* Create an array for the sorted list of modifiers */
+	p_array_init(&sctx->modifiers, pool, 2);
+
+	cmd->data = (void *) sctx;
+	
+	return TRUE;
+} 
+
+static bool cmd_set_validate(struct sieve_validator *validator, 
+	struct sieve_command_context *cmd) 
+{ 
+	struct sieve_ast_argument *arg = cmd->first_positional;
+		
+	if ( !sieve_validate_positional_argument
+		(validator, cmd, arg, "name", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+	
+	if ( !sieve_variable_argument_activate(validator, cmd, arg, TRUE) ) {
+		return FALSE;
+	}
+
+	arg = sieve_ast_argument_next(arg);
+	
+	if ( !sieve_validate_positional_argument
+		(validator, cmd, arg, "value", 2, SAAT_STRING) ) {
+		return FALSE;
+	}
+	
+	return sieve_validator_argument_activate(validator, cmd, arg, FALSE);	
+}
+
+/*
+ * Code generation
+ */
+ 
+static bool cmd_set_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx) 
+{
+	struct sieve_binary *sbin = cgenv->sbin;
+	struct cmd_set_context *sctx = (struct cmd_set_context *) ctx->data;
+	unsigned int i;	
+
+	sieve_operation_emit_code(sbin, &cmd_set_operation); 
+
+	/* Generate arguments */
+	if ( !sieve_generate_arguments(cgenv, ctx, NULL) )
+		return FALSE;	
+		
+	/* Generate modifiers (already sorted during validation) */
+	sieve_binary_emit_byte(sbin, array_count(&sctx->modifiers));
+	for ( i = 0; i < array_count(&sctx->modifiers); i++ ) {
+		const struct sieve_variables_modifier * const * modf =
+			array_idx(&sctx->modifiers, i);
+			
+		ext_variables_opr_modifier_emit(sbin, *modf);
+	}
+
+	return TRUE;
+}
+
+/* 
+ * Code dump
+ */
+ 
+static bool cmd_set_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{	
+	unsigned int mdfs, i;
+	
+	sieve_code_dumpf(denv, "SET");
+	sieve_code_descend(denv);
+	
+	/* Print both variable name and string value */
+	if ( !sieve_opr_string_dump(denv, address, "variable") ||
+		!sieve_opr_string_dump(denv, address, "value") )
+		return FALSE;
+	
+	/* Read the number of applied modifiers we need to read */
+	if ( !sieve_binary_read_byte(denv->sbin, address, &mdfs) ) 
+		return FALSE;
+	
+	/* Print all modifiers (sorted during code generation already) */
+	for ( i = 0; i < mdfs; i++ ) {
+		if ( !ext_variables_opr_modifier_dump(denv, address) )
+			return FALSE;
+	}
+	
+	return TRUE;
+}
+
+/* 
+ * Code execution
+ */
+ 
+static int cmd_set_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{	
+	struct sieve_variable_storage *storage;
+	unsigned int var_index, mdfs, i;
+	string_t *value;
+	int ret = SIEVE_EXEC_OK;
+
+	/*
+	 * Read the normal operands
+	 */
+		
+	/* Read the variable */
+	if ( !sieve_variable_operand_read
+		(renv, address, &storage, &var_index) ) {
+		sieve_runtime_trace_error(renv, "invalid variable operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+		
+	/* Read the raw string value */
+	if ( !sieve_opr_string_read(renv, address, &value) ) {
+		sieve_runtime_trace_error(renv, "invalid string operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+		
+	/* Read the number of modifiers used */
+	if ( !sieve_binary_read_byte(renv->sbin, address, &mdfs) ) {
+		sieve_runtime_trace_error(renv, "invalid modifier count");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/* 
+	 * Determine and assign the value 
+	 */
+
+	sieve_runtime_trace(renv, "SET action");
+
+	/* Hold value within limits */
+	if ( str_len(value) > SIEVE_VARIABLES_MAX_VARIABLE_SIZE )
+		str_truncate(value, SIEVE_VARIABLES_MAX_VARIABLE_SIZE);
+
+	T_BEGIN {
+		/* Apply modifiers if necessary (sorted during code generation already) */
+		if ( str_len(value) > 0 ) {
+			for ( i = 0; i < mdfs; i++ ) {
+				string_t *new_value;
+				const struct sieve_variables_modifier *modf =
+					ext_variables_opr_modifier_read(renv, address);
+
+				if ( modf == NULL ) {
+					value = NULL;
+
+					sieve_runtime_trace_error(renv, "invalid modifier operand");
+					ret = SIEVE_EXEC_BIN_CORRUPT;
+					break;
+				}
+				
+				if ( modf->modify != NULL ) {
+					if ( !modf->modify(value, &new_value) ) {
+						value = NULL;
+						ret = SIEVE_EXEC_FAILURE;
+						break;
+					}
+
+					value = new_value;
+					if ( value == NULL )
+						break;
+
+					/* Hold value within limits */
+					if ( str_len(value) > SIEVE_VARIABLES_MAX_VARIABLE_SIZE )
+						str_truncate(value, SIEVE_VARIABLES_MAX_VARIABLE_SIZE);
+				}
+			}
+		}	
+		
+		/* Actually assign the value if all is well */
+		if ( value != NULL ) {
+			if ( !sieve_variable_assign(storage, var_index, value) )
+				ret = SIEVE_EXEC_BIN_CORRUPT;
+		}	
+	} T_END;
+			
+	if ( ret <= 0 ) 
+		return ret;		
+
+	return ( value != NULL );
+}
+
+
+
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-arguments.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-arguments.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-arguments.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-arguments.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,438 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "str-sanitize.h"
+#include "array.h"
+
+#include "sieve-common.h"
+#include "sieve-ast.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-dump.h"
+
+#include "ext-variables-common.h"
+#include "ext-variables-limits.h"
+#include "ext-variables-name.h"
+#include "ext-variables-arguments.h"
+
+/*
+ * Common error messages
+ */
+
+static inline void _ext_variables_scope_size_error
+(struct sieve_validator *valdtr, struct sieve_ast_argument *arg,
+	const char *variable)
+{
+	sieve_argument_validate_error(valdtr, arg, 
+		"(implicit) declaration of new variable '%s' exceeds the limit "
+		"(max variables: %u)", variable, 
+		SIEVE_VARIABLES_MAX_SCOPE_SIZE);
+}
+
+static inline void _ext_variables_match_index_error
+(struct sieve_validator *valdtr, struct sieve_ast_argument *arg,
+	unsigned int variable_index)
+{
+	sieve_argument_validate_error(valdtr, arg, 
+		"match value index %u out of range (max: %u)", variable_index, 
+		SIEVE_VARIABLES_MAX_MATCH_INDEX);
+}
+
+/* 
+ * Variable argument 
+ */
+
+static bool arg_variable_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+		struct sieve_command_context *context);
+
+const struct sieve_argument variable_argument = { 
+	"@variable", 
+	NULL, NULL, NULL, NULL,
+	arg_variable_generate 
+};
+
+static struct sieve_ast_argument *ext_variables_variable_argument_create
+(struct sieve_validator *validator, struct sieve_ast *ast, 
+	unsigned int source_line, const char *variable)
+{
+	struct sieve_variable *var;
+	struct sieve_ast_argument *arg;
+	
+	var = ext_variables_validator_get_variable(validator, variable, TRUE);
+
+	if ( var == NULL ) 
+		return NULL;
+	
+	arg = sieve_ast_argument_create(ast, source_line);
+	arg->type = SAAT_STRING;
+	arg->argument = &variable_argument;
+	arg->context = (void *) var;
+	
+	return arg;
+}
+
+static bool _sieve_variable_argument_activate
+(struct sieve_validator *validator, struct sieve_command_context *cmd ATTR_UNUSED, 
+	struct sieve_ast_argument *arg, bool assignment)
+{
+	bool result = FALSE;
+	struct sieve_variable *var;
+	string_t *variable;
+	const char *varstr, *varend;
+	ARRAY_TYPE(ext_variable_name) vname;	
+	int nelements = 0;
+
+	T_BEGIN {
+		t_array_init(&vname, 2);			
+	
+		variable = sieve_ast_argument_str(arg);
+		varstr = str_c(variable);
+		varend = PTR_OFFSET(varstr, str_len(variable));
+		nelements = ext_variable_name_parse(&vname, &varstr, varend);
+
+		/* Check whether name parsing succeeded */	
+		if ( nelements < 0 || varstr != varend ) {
+			/* Parse failed */
+			sieve_argument_validate_error(validator, arg, 
+				"invalid variable name '%s'", str_sanitize(str_c(variable),80));
+		} else if ( nelements == 1 ) {
+			/* Normal (match) variable */
+
+			const struct ext_variable_name *cur_element = 
+				array_idx(&vname, 0);
+
+			if ( cur_element->num_variable < 0 ) {
+				/* Variable */
+				var = ext_variables_validator_get_variable
+					(validator, str_c(cur_element->identifier), TRUE);
+
+				if ( var == NULL ) {
+					_ext_variables_scope_size_error
+						(validator, arg, str_c(cur_element->identifier));
+				} else {
+					arg->argument = &variable_argument;
+					arg->context = (void *) var;
+				
+					result = TRUE;
+				}
+			} else {
+				/* Match value */
+				if ( !assignment ) {
+					if ( cur_element->num_variable > SIEVE_VARIABLES_MAX_MATCH_INDEX ) {
+						_ext_variables_match_index_error
+							(validator, arg, cur_element->num_variable);
+					} else {
+						arg->argument = &match_value_argument;
+						arg->context = POINTER_CAST(cur_element->num_variable);
+										
+						result = TRUE;
+					}
+				} else {		
+					sieve_argument_validate_error(validator, arg, 
+						"cannot assign to match variable");
+				}
+			}
+		} else {
+			/* Namespace variable */
+
+			const struct ext_variable_name *cur_element = 
+				array_idx(&vname, 0);
+
+			/* FIXME: Variable namespaces unsupported. */
+	
+			/* References to namespaces without a prior require statement for 
+			 * the relevant extension MUST cause an error.
+			 */
+
+			sieve_argument_validate_error(validator, arg, 
+				"cannot %s to variable in unknown namespace '%s'", 
+				assignment ? "assign" : "refer", str_c(cur_element->identifier));
+		}
+	} T_END;
+
+	return result;
+}
+
+bool sieve_variable_argument_activate
+(struct sieve_validator *validator, struct sieve_command_context *cmd, 
+	struct sieve_ast_argument *arg, bool assignment)
+{
+	if ( sieve_ast_argument_type(arg) == SAAT_STRING ) {
+		/* Single string */
+		return _sieve_variable_argument_activate(validator, cmd, arg, assignment);
+		
+	} else if ( sieve_ast_argument_type(arg) == SAAT_STRING_LIST ) {
+		/* String list */
+		struct sieve_ast_argument *stritem;
+		
+		i_assert ( !assignment );
+		
+		stritem = sieve_ast_strlist_first(arg);
+		while ( stritem != NULL ) {
+			if ( !_sieve_variable_argument_activate
+				(validator, cmd, stritem, assignment) )
+				return FALSE;
+			
+			stritem = sieve_ast_strlist_next(stritem);
+
+		}
+		
+		arg->argument = &string_list_argument;
+		
+		return TRUE;
+	} 
+	
+	return FALSE;
+}
+
+static bool arg_variable_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+	struct sieve_command_context *context ATTR_UNUSED)
+{
+	struct sieve_variable *var = (struct sieve_variable *) arg->context;
+	
+	ext_variables_opr_variable_emit(cgenv->sbin, var);
+
+	return TRUE;
+}
+
+/* 
+ * Match value argument 
+ */
+
+static bool arg_match_value_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+	struct sieve_command_context *context ATTR_UNUSED);
+
+const struct sieve_argument match_value_argument = { 
+	"@match_value", 
+	NULL, NULL, NULL, NULL,
+	arg_match_value_generate 
+};
+
+static struct sieve_ast_argument *ext_variables_match_value_argument_create
+(struct sieve_validator *validator ATTR_UNUSED, struct sieve_ast *ast, 
+	unsigned int source_line,	unsigned int index)
+{
+	struct sieve_ast_argument *arg;
+	
+	arg = sieve_ast_argument_create(ast, source_line);
+	arg->type = SAAT_STRING;
+	arg->argument = &match_value_argument;
+	arg->context = POINTER_CAST(index);
+	
+	return arg;
+}
+
+static bool arg_match_value_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+	struct sieve_command_context *context ATTR_UNUSED)
+{
+	unsigned int index = POINTER_CAST_TO(arg->context, unsigned int);
+	
+	ext_variables_opr_match_value_emit(cgenv->sbin, index);
+
+	return TRUE;
+}
+
+/* 
+ * Variable string argument 
+ */
+
+static bool arg_variable_string_validate
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *context);
+
+const struct sieve_argument variable_string_argument = { 
+	"@variable-string", 
+	NULL, NULL,
+	arg_variable_string_validate, 
+	NULL, 
+	sieve_arg_catenated_string_generate,
+};
+
+static bool arg_variable_string_validate
+(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd)
+{
+	enum { ST_NONE, ST_OPEN, ST_VARIABLE, ST_CLOSE } state = ST_NONE;
+	pool_t pool = sieve_ast_pool((*arg)->ast);
+	struct sieve_arg_catenated_string *catstr = NULL;
+	string_t *str = sieve_ast_argument_str(*arg);
+	const char *p, *strstart, *substart = NULL;
+	const char *strval = (const char *) str_data(str);
+	const char *strend = strval + str_len(str);
+	bool result = TRUE;
+
+	ARRAY_TYPE(ext_variable_name) substitution;	
+	int nelements = 0;
+	
+	T_BEGIN {
+		/* Initialize substitution structure */
+		t_array_init(&substitution, 2);		
+	
+		p = strval;
+		strstart = p;
+		while ( result && p < strend ) {
+			switch ( state ) {
+
+			/* Nothing found yet */
+			case ST_NONE:
+				if ( *p == '$' ) {
+					substart = p;
+					state = ST_OPEN;
+				}
+				p++;
+				break;
+
+			/* Got '$' */
+			case ST_OPEN:
+				if ( *p == '{' ) {
+					state = ST_VARIABLE;
+					p++;
+				} else 
+					state = ST_NONE;
+				break;
+
+			/* Got '${' */ 
+			case ST_VARIABLE:
+				nelements = ext_variable_name_parse(&substitution, &p, strend);
+			
+				if ( nelements < 0 )
+					state = ST_NONE;
+				else 
+					state = ST_CLOSE;
+			
+				break;
+
+			/* Finished parsing name, expecting '}' */
+			case ST_CLOSE:
+				if ( *p == '}' ) {				
+					struct sieve_ast_argument *strarg;
+				
+					/* We now know that the substitution is valid */	
+					
+					if ( catstr == NULL ) {
+						catstr = sieve_arg_catenated_string_create(*arg);
+					}
+				
+					/* Add the substring that is before the substitution to the 
+					 * variable-string AST.
+					 *
+					 * FIXME: For efficiency, if the variable is not found we should 
+					 * coalesce this substring with the one after the substitution.
+					 */
+					if ( substart > strstart ) {
+						string_t *newstr = str_new(pool, substart - strstart);
+						str_append_n(newstr, strstart, substart - strstart); 
+						
+						strarg = sieve_ast_argument_string_create_raw
+							((*arg)->ast, newstr, (*arg)->source_line);
+						sieve_arg_catenated_string_add_element(catstr, strarg);
+					
+						/* Give other substitution extensions a chance to do their work */
+						if ( !sieve_validator_argument_activate_super
+							(validator, cmd, strarg, FALSE) ) {
+							result = FALSE;
+							break;
+						}
+					}
+				
+					/* Find the variable */
+					if ( nelements == 1 ) {
+						const struct ext_variable_name *cur_element = 
+							array_idx(&substitution, 0);
+						
+						if ( cur_element->num_variable == -1 ) {
+							/* Add variable argument '${identifier}' */
+							string_t *cur_ident = cur_element->identifier; 
+						
+							strarg = ext_variables_variable_argument_create
+								(validator, (*arg)->ast, (*arg)->source_line, str_c(cur_ident));
+							if ( strarg != NULL )
+								sieve_arg_catenated_string_add_element(catstr, strarg);
+							else {
+								_ext_variables_scope_size_error
+									(validator, *arg, str_c(cur_element->identifier));
+								result = FALSE;
+								break;
+							}
+						} else {
+							/* Add match value argument '${000}' */
+							if ( cur_element->num_variable > SIEVE_VARIABLES_MAX_MATCH_INDEX ) {
+								_ext_variables_match_index_error
+									(validator, *arg, cur_element->num_variable);
+								result = FALSE;
+								break;
+							}
+
+							strarg = ext_variables_match_value_argument_create
+								(validator, (*arg)->ast, (*arg)->source_line, 
+								cur_element->num_variable);
+							if ( strarg != NULL )
+								sieve_arg_catenated_string_add_element(catstr, strarg);
+						}
+					} else {
+						const struct ext_variable_name *cur_element = 
+							array_idx(&substitution, 0);
+
+						/* FIXME: Namespaces are not supported. */
+
+						/* References to namespaces without a prior require 
+						 * statement for thecrelevant extension MUST cause an error.
+					 	 */
+						sieve_argument_validate_error(validator, *arg, 
+							"referring to variable in unknown namespace '%s'", 
+							str_c(cur_element->identifier));
+						result = FALSE;
+						break;
+					}
+				
+					strstart = p + 1;
+					substart = strstart;
+
+					p++;	
+				}
+		
+				/* Finished, reset for the next substitution */	
+				state = ST_NONE;
+			}
+		}
+	} T_END;
+
+	/* Bail out early if substitution is invalid */
+	if ( !result ) return FALSE;
+	
+	/* Check whether any substitutions were found */
+	if ( catstr == NULL ) {
+		/* No substitutions in this string, pass it on to any other substution
+		 * extension.
+		 */
+		return sieve_validator_argument_activate_super(validator, cmd, *arg, TRUE);
+	}
+	
+	/* Add the final substring that comes after the last substitution to the 
+	 * variable-string AST.
+	 */
+	if ( strend > strstart ) {
+		struct sieve_ast_argument *strarg;
+		string_t *newstr = str_new(pool, strend - strstart);
+		str_append_n(newstr, strstart, strend - strstart); 
+
+		strarg = sieve_ast_argument_string_create_raw
+			((*arg)->ast, newstr, (*arg)->source_line);
+		sieve_arg_catenated_string_add_element(catstr, strarg);
+			
+		/* Give other substitution extensions a chance to do their work */	
+		if ( !sieve_validator_argument_activate_super
+			(validator, cmd, strarg, FALSE) )
+			return FALSE;
+	}	
+	
+	return TRUE;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-arguments.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-arguments.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-arguments.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-arguments.h	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,27 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_VARIABLES_ARGUMENTS_H
+#define __EXT_VARIABLES_ARGUMENTS_H
+
+#include "sieve-common.h"
+
+/* 
+ * Variable argument 
+ */
+
+extern const struct sieve_argument variable_argument;
+
+/* 
+ * Match value argument 
+ */
+
+extern const struct sieve_argument match_value_argument;
+
+/* 
+ * Variable string argument 
+ */
+
+extern const struct sieve_argument variable_string_argument;
+
+#endif /* __EXT_VARIABLES_ARGUMENTS_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,90 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension variables 
+ * -------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: RFC 5229
+ * Implementation: mostly full; no support for future namespaces
+ * Status: experimental, not thoroughly tested
+ *
+ */
+ 
+/* FIXME: This implementation of the variables extension does not support 
+ * namespaces. It recognizes them, but there is currently no support to let
+ * an extension register a new namespace. Currently no such extension exists 
+ * and therefore this support has a very low implementation priority.
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "unichar.h"
+
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-binary.h"
+#include "sieve-interpreter.h"
+
+#include "sieve-validator.h"
+
+#include "ext-variables-common.h"
+#include "ext-variables-arguments.h"
+#include "ext-variables-operands.h"
+#include "ext-variables-modifiers.h"
+#include "ext-variables-dump.h"
+
+/* 
+ * Operations 
+ */
+
+const struct sieve_operation *ext_variables_operations[] = {
+	&cmd_set_operation, 
+	&tst_string_operation
+};
+
+/* 
+ * Operands 
+ */
+
+const struct sieve_operand *ext_variables_operands[] = {
+	&variable_operand, 
+	&match_value_operand,
+	&modifier_operand
+};
+
+/* 
+ * Extension 
+ */
+
+static bool ext_variables_validator_load(struct sieve_validator *validator);
+
+static int ext_my_id = -1;
+	
+const struct sieve_extension variables_extension = { 
+	"variables", 
+	&ext_my_id,
+	NULL, NULL,
+	ext_variables_validator_load, 
+	ext_variables_generator_load,
+	ext_variables_interpreter_load,
+	NULL, NULL, 
+	ext_variables_code_dump,
+	SIEVE_EXT_DEFINE_OPERATIONS(ext_variables_operations), 
+	SIEVE_EXT_DEFINE_OPERANDS(ext_variables_operands)
+};
+
+static bool ext_variables_validator_load
+	(struct sieve_validator *validator)
+{
+	sieve_validator_argument_override(validator, SAT_VAR_STRING, 
+		&variable_string_argument); 
+		
+	sieve_validator_register_command(validator, &cmd_set);
+	sieve_validator_register_command(validator, &tst_string);
+	
+	ext_variables_validator_initialize(validator);
+
+	return TRUE;
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-common.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-common.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-common.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-common.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,567 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "hash.h"
+#include "str.h"
+#include "array.h"
+
+#include "sieve-common.h"
+
+#include "sieve-ast.h"
+#include "sieve-binary.h"
+#include "sieve-code.h"
+#include "sieve-objects.h"
+#include "sieve-match-types.h"
+
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-dump.h"
+#include "sieve-interpreter.h"
+
+#include "ext-variables-common.h"
+#include "ext-variables-name.h"
+#include "ext-variables-modifiers.h"
+
+/*
+ * Variable scope 
+ */
+
+struct sieve_variable_scope {
+	pool_t pool;
+	int refcount;
+
+	struct sieve_variable *error_var;
+
+	const struct sieve_extension *ext;
+
+	struct hash_table *variables;
+	ARRAY_DEFINE(variable_index, struct sieve_variable *);
+};
+
+struct sieve_variable_scope_iter {
+	struct sieve_variable_scope *scope;
+	struct hash_iterate_context *hctx;
+};
+
+struct sieve_variable_scope *sieve_variable_scope_create
+	(const struct sieve_extension *ext) 
+{
+	struct sieve_variable_scope *scope;
+	pool_t pool;
+
+	pool = pool_alloconly_create("sieve_variable_scope", 4096);
+	scope = p_new(pool, struct sieve_variable_scope, 1);
+	scope->pool = pool;
+	scope->refcount = 1;
+
+	scope->ext = ext;
+	scope->variables = hash_table_create
+		(default_pool, pool, 0, strcase_hash, (hash_cmp_callback_t *)strcasecmp);
+	p_array_init(&scope->variable_index, pool, 128);
+		
+	return scope;
+}
+
+void sieve_variable_scope_ref(struct sieve_variable_scope *scope)
+{
+	scope->refcount++;
+}
+
+void sieve_variable_scope_unref(struct sieve_variable_scope **scope)
+{
+	i_assert((*scope)->refcount > 0);
+
+	if (--(*scope)->refcount != 0)
+		return;
+
+	hash_table_destroy(&(*scope)->variables);
+
+	pool_unref(&(*scope)->pool);
+    *scope = NULL;
+}
+
+pool_t sieve_variable_scope_pool(struct sieve_variable_scope *scope)
+{
+	return scope->pool;
+}
+
+struct sieve_variable *sieve_variable_scope_declare
+(struct sieve_variable_scope *scope, const char *identifier)
+{
+	struct sieve_variable *new_var;
+
+	new_var = p_new(scope->pool, struct sieve_variable, 1);
+	new_var->ext = scope->ext;
+
+	if ( array_count(&scope->variable_index) >= SIEVE_VARIABLES_MAX_SCOPE_SIZE ) {
+		if ( scope->error_var == NULL ) {
+			new_var->identifier = "@ERROR@";
+			new_var->index = 0;
+			
+			scope->error_var = new_var;
+			return NULL;
+		}
+
+		return scope->error_var;
+	}
+	
+	new_var->identifier = p_strdup(scope->pool, identifier);
+	new_var->index = array_count(&scope->variable_index);
+
+	hash_table_insert(scope->variables, (void *) new_var->identifier, (void *) new_var);
+	array_append(&scope->variable_index, &new_var, 1);
+	
+	return new_var;
+}
+
+struct sieve_variable *sieve_variable_scope_get_variable
+(struct sieve_variable_scope *scope, const char *identifier, bool declare)
+{
+	struct sieve_variable *var = 
+		(struct sieve_variable *) hash_table_lookup(scope->variables, identifier);
+
+	if ( var == NULL && declare ) {
+		var = sieve_variable_scope_declare(scope, identifier);
+	}
+
+	return var;
+}
+
+struct sieve_variable *sieve_variable_scope_import
+(struct sieve_variable_scope *scope, struct sieve_variable *var)
+{
+	struct sieve_variable *new_var = p_new(scope->pool, struct sieve_variable, 1);
+	memcpy(new_var, var, sizeof(struct sieve_variable));
+		
+	hash_table_insert(scope->variables, (void *) new_var->identifier, (void *) new_var);
+	
+	/* Not entered into the index because it is an external variable 
+	 * (This can be done unlimited; only limited by the size of the external scope)
+	 */
+
+	return new_var;
+}
+
+struct sieve_variable_scope_iter *sieve_variable_scope_iterate_init
+(struct sieve_variable_scope *scope)
+{
+	struct sieve_variable_scope_iter *iter = t_new(struct sieve_variable_scope_iter, 1);
+	iter->scope = scope;
+	iter->hctx = hash_table_iterate_init(scope->variables);
+
+	return iter;
+}
+
+bool sieve_variable_scope_iterate
+(struct sieve_variable_scope_iter *iter, struct sieve_variable **var_r)
+{
+	void *key, *value;
+
+	if ( !hash_table_iterate(iter->hctx, &key, &value) )
+		return FALSE; 
+	
+	*var_r = (struct sieve_variable *) value;
+	return TRUE;
+}
+
+void sieve_variable_scope_iterate_deinit
+(struct sieve_variable_scope_iter **iter)
+{
+	hash_table_iterate_deinit(&(*iter)->hctx);
+	*iter = NULL;
+}
+
+unsigned int sieve_variable_scope_declarations
+(struct sieve_variable_scope *scope)
+{
+	return hash_table_count(scope->variables);
+}
+
+unsigned int sieve_variable_scope_size
+(struct sieve_variable_scope *scope)
+{
+	return array_count(&scope->variable_index);
+}
+
+struct sieve_variable * const *sieve_variable_scope_get_variables
+(struct sieve_variable_scope *scope, unsigned int *size_r)
+{
+	return array_get(&scope->variable_index, size_r);
+}
+
+struct sieve_variable *sieve_variable_scope_get_indexed
+(struct sieve_variable_scope *scope, unsigned int index)
+{
+	struct sieve_variable * const *var;
+	
+	if ( index >= array_count(&scope->variable_index) ) 
+		return NULL;
+		
+	var = array_idx(&scope->variable_index, index); 
+	
+	return *var;
+}
+
+/* 
+ * Variable storage 
+ */
+
+struct sieve_variable_storage {
+	pool_t pool;
+	struct sieve_variable_scope *scope;
+	unsigned int max_size;
+	ARRAY_DEFINE(var_values, string_t *); 
+};
+
+struct sieve_variable_storage *sieve_variable_storage_create
+(pool_t pool, struct sieve_variable_scope *scope, unsigned int max_size)
+{
+	struct sieve_variable_storage *storage;
+	
+	storage = p_new(pool, struct sieve_variable_storage, 1);
+	storage->pool = pool;
+	storage->scope = scope;
+	
+	if ( scope != NULL )
+		storage->max_size = sieve_variable_scope_size(scope);
+	else
+		storage->max_size = max_size;
+		
+	p_array_init(&storage->var_values, pool, 4);
+
+	return storage;
+}
+
+static inline bool sieve_variable_valid
+(struct sieve_variable_storage *storage, unsigned int index)
+{
+	if ( storage->scope == NULL ) return TRUE;
+
+	return ( index < storage->max_size );
+}
+
+bool sieve_variable_get_identifier
+(struct sieve_variable_storage *storage, unsigned int index, const char **identifier)
+{
+	struct sieve_variable * const *var;
+	*identifier = NULL;
+
+	if ( storage->scope == NULL ) return TRUE;
+
+	/* FIXME: direct invasion of the scope object is a bit ugly */
+	if ( index >= array_count(&storage->scope->variable_index) )
+		return FALSE;
+
+	var = array_idx(&storage->scope->variable_index, index);
+
+	if ( *var != NULL )
+		*identifier = (*var)->identifier;
+
+	return TRUE;
+}
+
+bool sieve_variable_get
+(struct sieve_variable_storage *storage, unsigned int index, string_t **value)
+{
+	*value = NULL;
+	
+	if  ( index < array_count(&storage->var_values) ) {
+		string_t * const *varent;
+			
+		varent = array_idx(&storage->var_values, index);
+		
+		*value = *varent;
+	} else if ( !sieve_variable_valid(storage, index) )
+		return FALSE;
+
+	return TRUE;
+} 
+
+bool sieve_variable_get_modifiable
+(struct sieve_variable_storage *storage, unsigned int index, string_t **value)
+{
+	string_t *dummy;
+	
+	if ( value == NULL ) value = &dummy;
+	
+	if ( !sieve_variable_get(storage, index, value) )
+		return FALSE;
+	
+	if ( *value == NULL ) {
+		*value = str_new(storage->pool, 256);
+		array_idx_set(&storage->var_values, index, value);	
+	}
+
+	return TRUE; 
+}
+
+bool sieve_variable_assign
+(struct sieve_variable_storage *storage, unsigned int index, 
+	const string_t *value)
+{
+	string_t *varval;
+	
+	if ( !sieve_variable_get_modifiable(storage, index, &varval) ) 
+		return FALSE;
+
+	str_truncate(varval, 0);
+	str_append_str(varval, value);
+
+	/* Just a precaution, caller should prevent this in the first place */
+	if ( str_len(varval) > SIEVE_VARIABLES_MAX_VARIABLE_SIZE )
+		str_truncate(varval, SIEVE_VARIABLES_MAX_VARIABLE_SIZE);
+
+	return TRUE;
+}
+
+/*
+ * AST Context
+ */
+
+static void ext_variables_ast_free
+(struct sieve_ast *ast ATTR_UNUSED, void *context)
+{
+	struct sieve_variable_scope *main_scope =
+		(struct sieve_variable_scope *) context;
+
+	/* Unreference main variable scope */
+	sieve_variable_scope_unref(&main_scope);
+}
+
+static const struct sieve_ast_extension variables_ast_extension = {
+    &variables_extension,
+    ext_variables_ast_free
+};
+
+static struct sieve_variable_scope *ext_variables_create_main_scope
+(struct sieve_ast *ast)
+{
+	struct sieve_variable_scope *scope;
+
+	scope = sieve_variable_scope_create(NULL);
+
+	sieve_ast_extension_register(ast, &variables_ast_extension, (void *) scope);
+
+	return scope;
+}
+
+static struct sieve_variable_scope *ext_variables_ast_get_main_scope
+(struct sieve_ast *ast)
+{
+	struct sieve_variable_scope *main_scope =
+		(struct sieve_variable_scope *) sieve_ast_extension_get_context
+		(ast, &variables_extension);
+	
+	return main_scope;
+}
+
+/*
+ * Validator context 
+ */
+
+static struct ext_variables_validator_context *
+ext_variables_validator_context_create(struct sieve_validator *valdtr)
+{		
+	pool_t pool = sieve_validator_pool(valdtr);
+	struct ext_variables_validator_context *ctx;
+	struct sieve_ast *ast = sieve_validator_ast(valdtr);
+	
+	ctx = p_new(pool, struct ext_variables_validator_context, 1);
+	ctx->modifiers = sieve_validator_object_registry_create(valdtr);
+	ctx->main_scope = ext_variables_create_main_scope(ast);
+
+	sieve_validator_extension_set_context
+		(valdtr, &variables_extension, (void *) ctx);
+
+	return ctx;
+}
+
+struct ext_variables_validator_context *ext_variables_validator_context_get
+(struct sieve_validator *valdtr)
+{
+	struct ext_variables_validator_context *ctx = 
+		(struct ext_variables_validator_context *)
+		sieve_validator_extension_get_context(valdtr, &variables_extension);
+	
+	if ( ctx == NULL ) {
+		ctx = ext_variables_validator_context_create(valdtr);
+	}
+	
+	return ctx;
+}
+
+void ext_variables_validator_initialize(struct sieve_validator *validator)
+{
+	struct ext_variables_validator_context *ctx;
+	
+	/* Create our context */
+	ctx = ext_variables_validator_context_get(validator);
+	
+	ext_variables_register_core_modifiers(ctx);
+	
+	ctx->active = TRUE;
+}
+
+struct sieve_variable *ext_variables_validator_get_variable
+(struct sieve_validator *validator, const char *variable, bool declare)
+{
+	struct ext_variables_validator_context *ctx = 
+		ext_variables_validator_context_get(validator);
+		
+	return sieve_variable_scope_get_variable(ctx->main_scope, variable, declare);
+}
+
+struct sieve_variable_scope *sieve_ext_variables_get_main_scope
+(struct sieve_validator *validator)
+{
+	struct ext_variables_validator_context *ctx = 
+		ext_variables_validator_context_get(validator);
+		
+	return ctx->main_scope;
+}
+
+bool sieve_ext_variables_is_active(struct sieve_validator *valdtr)
+{
+	struct ext_variables_validator_context *ctx = 
+		ext_variables_validator_context_get(valdtr);
+		
+	return ( ctx != NULL && ctx->active );
+}
+
+/*
+ * Code generation
+ */
+ 
+bool ext_variables_generator_load(const struct sieve_codegen_env *cgenv)
+{
+	struct sieve_variable_scope *main_scope = 
+		ext_variables_ast_get_main_scope(cgenv->ast);
+	unsigned int count = sieve_variable_scope_size(main_scope);
+	sieve_size_t jump;
+
+	sieve_binary_emit_unsigned(cgenv->sbin, count);
+
+	jump = sieve_binary_emit_offset(cgenv->sbin, 0);
+
+	if ( count > 0 ) {
+		unsigned int size, i;
+		struct sieve_variable *const *vars = 
+			sieve_variable_scope_get_variables(main_scope, &size);
+
+		for ( i = 0; i < size; i++ ) {			
+			sieve_binary_emit_cstring(cgenv->sbin, vars[i]->identifier);
+		}
+	}
+	
+	sieve_binary_resolve_offset(cgenv->sbin, jump);
+		
+	return TRUE;
+}
+
+/* 
+ * Interpreter context 
+ */
+
+struct ext_variables_interpreter_context {
+	struct sieve_variable_storage *local_storage;
+	ARRAY_DEFINE(ext_storages, struct sieve_variable_storage *);
+};
+
+static struct ext_variables_interpreter_context *
+ext_variables_interpreter_context_create
+(struct sieve_interpreter *interp, unsigned int max_size)
+{		
+	pool_t pool = sieve_interpreter_pool(interp);
+	struct ext_variables_interpreter_context *ctx;
+	
+	ctx = p_new(pool, struct ext_variables_interpreter_context, 1);
+	ctx->local_storage = sieve_variable_storage_create(pool, NULL, max_size);
+	p_array_init(&ctx->ext_storages, pool, sieve_extensions_get_count());
+
+	sieve_interpreter_extension_set_context
+		(interp, &variables_extension, (void *) ctx);
+
+	return ctx;
+}
+
+bool ext_variables_interpreter_load
+	(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	struct ext_variables_interpreter_context *ctx;
+	unsigned int scope_size;
+	sieve_size_t pc;
+	int end_offset;
+		
+	if ( !sieve_binary_read_unsigned(renv->sbin, address, &scope_size) ) {
+		sieve_sys_error("variables: failed to read main scope size");
+		return FALSE;
+	}
+
+	if ( scope_size > SIEVE_VARIABLES_MAX_SCOPE_SIZE ) {
+		sieve_sys_error("variables: scope size exceeds the limit (%u > %u)", 
+			scope_size, SIEVE_VARIABLES_MAX_SCOPE_SIZE );
+		return FALSE;
+	}
+	
+	pc = *address;
+	if ( !sieve_binary_read_offset(renv->sbin, address, &end_offset) )
+		return NULL;
+	*address = pc + end_offset;
+	
+	/* Create our context */
+	ctx = ext_variables_interpreter_context_create(renv->interp, scope_size);
+
+	/* Enable support for match values */
+	(void) sieve_match_values_set_enabled(renv->interp, TRUE);
+	
+	return TRUE;
+}
+
+static inline struct ext_variables_interpreter_context *
+ext_variables_interpreter_context_get(struct sieve_interpreter *interp)
+{
+	return (struct ext_variables_interpreter_context *)
+		sieve_interpreter_extension_get_context(interp, &variables_extension);
+}
+
+struct sieve_variable_storage *sieve_ext_variables_get_storage
+(struct sieve_interpreter *interp, const struct sieve_extension *ext)
+{
+	struct ext_variables_interpreter_context *ctx = 
+		ext_variables_interpreter_context_get(interp);
+	struct sieve_variable_storage * const *storage;
+	int ext_id;
+		
+	if ( ext == NULL )
+		return ctx->local_storage;
+
+	ext_id = SIEVE_EXT_ID(ext);
+	if ( ext_id >= (int) array_count(&ctx->ext_storages) ) {
+		storage = NULL;
+	} else {
+		storage = array_idx(&ctx->ext_storages, ext_id);
+	}
+	
+	if ( storage == NULL || *storage == NULL ) 
+		return NULL;
+	
+	return *storage;
+}
+
+void sieve_ext_variables_set_storage
+(struct sieve_interpreter *interp, struct sieve_variable_storage *storage,
+	const struct sieve_extension *ext)
+{
+	struct ext_variables_interpreter_context *ctx = 
+		ext_variables_interpreter_context_get(interp);
+		
+	if ( ctx == NULL || ext == NULL || storage == NULL )
+		return;
+		
+	array_idx_set(&ctx->ext_storages, (unsigned int) SIEVE_EXT_ID(ext), &storage);
+}
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-common.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-common.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-common.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-common.h	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,100 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_VARIABLES_COMMON_H
+#define __EXT_VARIABLES_COMMON_H
+
+#include "sieve-common.h"
+#include "sieve-validator.h"
+
+#include "sieve-ext-variables.h"
+
+/*
+ * Extension
+ */
+
+extern const struct sieve_extension variables_extension;
+
+/* 
+ * Commands 
+ */
+
+extern const struct sieve_command cmd_set;
+extern const struct sieve_command tst_string;
+
+/* 
+ * Operands
+ */
+
+enum ext_variables_operand {
+	EXT_VARIABLES_OPERAND_VARIABLE,
+	EXT_VARIABLES_OPERAND_MATCH_VALUE,
+	EXT_VARIABLES_OPERAND_MODIFIER
+};
+
+/*
+ * Operations
+ */
+
+extern const struct sieve_operation cmd_set_operation;
+extern const struct sieve_operation tst_string_operation;
+
+enum ext_variables_opcode {
+	EXT_VARIABLES_OPERATION_SET,
+	EXT_VARIABLES_OPERATION_STRING
+};
+
+/* 
+ * Validator context 
+ */
+
+struct ext_variables_validator_context {
+	bool active;
+	
+	struct sieve_validator_object_registry *modifiers;
+	
+	struct sieve_variable_scope *main_scope;
+};
+
+void ext_variables_validator_initialize(struct sieve_validator *validator);
+	
+struct ext_variables_validator_context *ext_variables_validator_context_get
+	(struct sieve_validator *valdtr);
+
+struct sieve_variable *ext_variables_validator_get_variable
+	(struct sieve_validator *validator, const char *variable, bool declare);
+
+/*
+ * Code generation
+ */
+ 
+bool ext_variables_generator_load
+	(const struct sieve_codegen_env *cgenv);
+
+/*
+ * Interpreter context
+ */	
+
+bool ext_variables_interpreter_load
+(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+/* 
+ * Variable coding 
+ */
+
+void ext_variables_opr_variable_emit
+	(struct sieve_binary *sbin, struct sieve_variable *var);
+void ext_variables_opr_match_value_emit
+	(struct sieve_binary *sbin, unsigned int index);
+bool ext_variables_opr_variable_read
+	(const struct sieve_runtime_env *renv, sieve_size_t *address, 
+		struct sieve_variable_storage **storage, unsigned int *var_index);
+
+void ext_variables_opr_variable_string_emit
+	(struct sieve_binary *sbin, unsigned int elements);
+
+bool ext_variables_variable_assignment_activate
+(struct sieve_validator *validator, struct sieve_ast_argument *arg,
+	struct sieve_command_context *cmd);
+	
+#endif /* __EXT_VARIABLES_COMMON_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-dump.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-dump.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-dump.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-dump.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,156 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#include "lib.h"
+#include "str.h"
+ 
+#include "sieve-common.h"
+#include "sieve-dump.h"
+#include "sieve-binary.h"
+#include "sieve-code.h"
+
+#include "ext-variables-common.h"
+#include "ext-variables-dump.h"
+
+/*
+ * Code dumper extension
+ */
+
+static void ext_variables_code_dumper_free
+	(struct sieve_code_dumper *dumper, void *context);
+
+const struct sieve_code_dumper_extension variables_dump_extension = {
+	&variables_extension,
+	ext_variables_code_dumper_free
+};
+
+/*
+ * Code dump context
+ */
+ 
+struct ext_variables_dump_context {
+	struct sieve_variable_scope *main_scope;
+	ARRAY_DEFINE(ext_scopes, struct sieve_variable_scope *);
+};
+
+static void ext_variables_code_dumper_free
+(struct sieve_code_dumper *dumper ATTR_UNUSED, void *context)
+{
+	struct ext_variables_dump_context *dctx = 
+		(struct ext_variables_dump_context *) context;
+
+	if ( dctx == NULL || dctx->main_scope == NULL )
+		return;
+
+	sieve_variable_scope_unref(&dctx->main_scope);
+}
+
+static struct ext_variables_dump_context *ext_variables_dump_get_context
+	(const struct sieve_dumptime_env *denv)
+{
+	struct sieve_code_dumper *dumper = denv->cdumper;
+	struct ext_variables_dump_context *dctx = sieve_dump_extension_get_context
+		(dumper, &variables_extension);
+	pool_t pool;
+
+	if ( dctx == NULL ) {
+		/* Create dumper context */
+		pool = sieve_code_dumper_pool(dumper);
+		dctx = p_new(pool, struct ext_variables_dump_context, 1);
+		p_array_init(&dctx->ext_scopes, pool, sieve_extensions_get_count());
+	
+		sieve_dump_extension_set_context(dumper, &variables_extension, dctx);
+	}
+
+	return dctx;
+} 
+ 
+bool ext_variables_code_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	struct ext_variables_dump_context *dctx;
+	struct sieve_variable_scope *main_scope;
+	unsigned int i, scope_size;
+	sieve_size_t pc;
+	int end_offset;
+	
+	sieve_code_mark(denv);
+	if ( !sieve_binary_read_unsigned(denv->sbin, address, &scope_size) )
+		return FALSE;
+		
+	pc = *address;	
+	if ( !sieve_binary_read_offset(denv->sbin, address, &end_offset) )
+		return FALSE;
+	
+	main_scope = sieve_variable_scope_create(NULL);
+	
+	sieve_code_dumpf(denv, "SCOPE [%u] (end: %08x)", 
+		scope_size, (unsigned int) (pc + end_offset));
+	
+	/* Read main variable scope */
+	
+	for ( i = 0; i < scope_size; i++ ) {
+		string_t *identifier;
+
+		sieve_code_mark(denv);
+		if (!sieve_binary_read_string(denv->sbin, address, &identifier) ) {
+			return FALSE;
+		}
+		
+		sieve_code_dumpf(denv, "%3d: '%s'", i, str_c(identifier));
+		
+		(void) sieve_variable_scope_declare(main_scope, str_c(identifier));
+	}
+	
+	dctx = ext_variables_dump_get_context(denv);
+	dctx->main_scope = main_scope;
+	
+	return TRUE;
+}
+
+/*
+ * Scope registry
+ */
+
+void sieve_ext_variables_dump_set_scope
+(const struct sieve_dumptime_env *denv, const struct sieve_extension *ext, 
+	struct sieve_variable_scope *scope)
+{
+	struct ext_variables_dump_context *dctx = ext_variables_dump_get_context(denv);
+
+	array_idx_set(&dctx->ext_scopes, (unsigned int) SIEVE_EXT_ID(ext), &scope);	
+}
+
+/*
+ * Variable identifier dump
+ */
+
+const char *ext_variables_dump_get_identifier
+(const struct sieve_dumptime_env *denv, const struct sieve_extension *ext,
+	unsigned int index)
+{
+	struct ext_variables_dump_context *dctx = ext_variables_dump_get_context(denv);	
+	struct sieve_variable_scope *scope;
+	struct sieve_variable *var;
+
+	if ( ext == NULL )
+		scope = dctx->main_scope;
+	else {
+		struct sieve_variable_scope *const *ext_scope;
+		int ext_id = SIEVE_EXT_ID(ext);
+
+		if  ( ext_id < 0 || ext_id >= (int) array_count(&dctx->ext_scopes) )
+			return NULL;
+	
+		ext_scope = array_idx(&dctx->ext_scopes, (unsigned int) ext_id);
+		scope = *ext_scope;			
+	}
+
+	if ( scope == NULL )
+		return NULL;
+			
+	var = sieve_variable_scope_get_indexed(scope, index);
+	
+	return var->identifier;
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-dump.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-dump.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-dump.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-dump.h	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,24 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_VARIABLES_DUMP_H
+#define __EXT_VARIABLES_DUMP_H
+
+#include "sieve-common.h"
+
+/*
+ * Code dump context
+ */
+ 
+bool ext_variables_code_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+
+/*
+ * Variable identifier dump
+ */
+ 
+const char *ext_variables_dump_get_identifier
+(const struct sieve_dumptime_env *denv, const struct sieve_extension *ext,
+	unsigned int index);
+
+#endif /* __EXT_VARIABLES_DUMP_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-limits.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-limits.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-limits.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-limits.h	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,34 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_VARIABLES_LIMITS_H
+#define __EXT_VARIABLES_LIMITS_H
+
+#include "sieve-limits.h"
+
+/* From RFC 5229:
+ * 
+ * 6.  Implementation Limits
+ *
+ *  An implementation of this document MUST support at least 128 distinct
+ *  variables.  The supported length of variable names MUST be at least
+ *  32 characters.  Each variable MUST be able to hold at least 4000
+ *  characters.  Attempts to set the variable to a value larger than what
+ *  the implementation supports SHOULD be reported as an error at
+ *  compile-time if possible.  If the attempt is discovered during run-
+ *  time, the value SHOULD be truncated, and it MUST NOT be treated as an
+ *  error.
+
+ *  Match variables ${1} through ${9} MUST be supported.  References to
+ *  higher indices than those the implementation supports MUST be treated
+ *  as a syntax error, which SHOULD be discovered at compile-time.
+ */
+
+#define SIEVE_VARIABLES_MAX_SCOPE_SIZE              255
+#define SIEVE_VARIABLES_MAX_VARIABLE_NAME_LEN       64
+#define SIEVE_VARIABLES_MAX_VARIABLE_SIZE           (4 * 1024)
+#define SIEVE_VARIABLES_MAX_NAMESPACE_ELEMENTS      4
+
+#define SIEVE_VARIABLES_MAX_MATCH_INDEX             SIEVE_MAX_MATCH_VALUES
+
+#endif /* __EXT_VARIABLES_LIMITS_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-modifiers.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-modifiers.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-modifiers.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-modifiers.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,241 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+
+#include "ext-variables-common.h"
+#include "ext-variables-modifiers.h"
+
+#include <ctype.h>
+
+/*
+ * Core modifiers
+ */
+ 
+extern const struct sieve_variables_modifier lower_modifier;
+extern const struct sieve_variables_modifier upper_modifier;
+extern const struct sieve_variables_modifier lowerfirst_modifier;
+extern const struct sieve_variables_modifier upperfirst_modifier;
+extern const struct sieve_variables_modifier quotewildcard_modifier;
+extern const struct sieve_variables_modifier length_modifier;
+
+enum ext_variables_modifier_code {
+    EXT_VARIABLES_MODIFIER_LOWER,
+    EXT_VARIABLES_MODIFIER_UPPER,
+    EXT_VARIABLES_MODIFIER_LOWERFIRST,
+    EXT_VARIABLES_MODIFIER_UPPERFIRST,
+    EXT_VARIABLES_MODIFIER_QUOTEWILDCARD,
+    EXT_VARIABLES_MODIFIER_LENGTH
+};
+
+const struct sieve_variables_modifier *ext_variables_core_modifiers[] = {
+	&lower_modifier,
+	&upper_modifier,
+	&lowerfirst_modifier,
+	&upperfirst_modifier,
+	&quotewildcard_modifier,
+	&length_modifier
+};
+
+const unsigned int ext_variables_core_modifiers_count =
+    N_ELEMENTS(ext_variables_core_modifiers);
+
+/*
+ * Modifier registry
+ */
+
+void sieve_variables_modifier_register
+(struct sieve_validator *valdtr, const struct sieve_variables_modifier *smodf) 
+{
+	struct ext_variables_validator_context *ctx = 
+		ext_variables_validator_context_get(valdtr);
+	
+	sieve_validator_object_registry_add(ctx->modifiers, &smodf->object);
+}
+
+const struct sieve_variables_modifier *ext_variables_modifier_find
+(struct sieve_validator *valdtr, const char *identifier)
+{
+	struct ext_variables_validator_context *ctx = 
+		ext_variables_validator_context_get(valdtr);
+		
+	const struct sieve_object *object = 
+		sieve_validator_object_registry_find(ctx->modifiers, identifier);
+
+	return (const struct sieve_variables_modifier *) object;
+}
+
+void ext_variables_register_core_modifiers
+(struct ext_variables_validator_context *ctx)
+{
+	unsigned int i;
+	
+	/* Register core modifiers*/
+	for ( i = 0; i < ext_variables_core_modifiers_count; i++ ) {
+		sieve_validator_object_registry_add
+			(ctx->modifiers, &(ext_variables_core_modifiers[i]->object));
+	}
+}
+
+/*
+ * Modifier coding
+ */
+ 
+const struct sieve_operand_class sieve_variables_modifier_operand_class = 
+	{ "modifier" };
+	
+static const struct sieve_extension_objects core_modifiers =
+	SIEVE_VARIABLES_DEFINE_MODIFIERS(ext_variables_core_modifiers);
+
+const struct sieve_operand modifier_operand = { 
+	"modifier", 
+	&variables_extension,
+	EXT_VARIABLES_OPERAND_MODIFIER, 
+	&sieve_variables_modifier_operand_class,
+	&core_modifiers
+};
+
+/* 
+ * Core modifiers 
+ */
+ 
+/* Forward declarations */
+
+bool mod_lower_modify(string_t *in, string_t **result);
+bool mod_upper_modify(string_t *in, string_t **result);
+bool mod_lowerfirst_modify(string_t *in, string_t **result);
+bool mod_upperfirst_modify(string_t *in, string_t **result);
+bool mod_length_modify(string_t *in, string_t **result);
+bool mod_quotewildcard_modify(string_t *in, string_t **result);
+
+/* Modifier objects */
+
+const struct sieve_variables_modifier lower_modifier = {
+	SIEVE_OBJECT("lower", &modifier_operand, EXT_VARIABLES_MODIFIER_LOWER),
+	40,
+	mod_lower_modify
+};
+
+const struct sieve_variables_modifier upper_modifier = {
+	SIEVE_OBJECT("upper", &modifier_operand, EXT_VARIABLES_MODIFIER_UPPER),
+	40,
+	mod_upper_modify
+};
+
+const struct sieve_variables_modifier lowerfirst_modifier = {
+	SIEVE_OBJECT
+		("lowerfirst", &modifier_operand, EXT_VARIABLES_MODIFIER_LOWERFIRST),
+	30,
+	mod_lowerfirst_modify
+};
+
+const struct sieve_variables_modifier upperfirst_modifier = {
+	SIEVE_OBJECT
+		("upperfirst", &modifier_operand,	EXT_VARIABLES_MODIFIER_UPPERFIRST),
+	30,
+	mod_upperfirst_modify
+};
+
+const struct sieve_variables_modifier quotewildcard_modifier = {
+	SIEVE_OBJECT
+		("quotewildcard", &modifier_operand, EXT_VARIABLES_MODIFIER_QUOTEWILDCARD),
+	20,
+	mod_quotewildcard_modify
+};
+
+const struct sieve_variables_modifier length_modifier = {
+	SIEVE_OBJECT("length", &modifier_operand, EXT_VARIABLES_MODIFIER_LENGTH),
+	10,
+	mod_length_modify
+};
+
+/* Modifier implementations */
+
+bool mod_upperfirst_modify(string_t *in, string_t **result)
+{
+	char *content;
+	
+	*result = t_str_new(str_len(in));
+	str_append_str(*result, in);
+		
+	content = str_c_modifiable(*result);
+	content[0] = i_toupper(content[0]);
+
+	return TRUE;
+}
+
+bool mod_lowerfirst_modify(string_t *in, string_t **result)
+{
+	char *content;
+	
+	*result = t_str_new(str_len(in));
+	str_append_str(*result, in);
+		
+	content = str_c_modifiable(*result);
+	content[0] = i_tolower(content[0]);
+
+	return TRUE;
+}
+
+bool mod_upper_modify(string_t *in, string_t **result)
+{
+	char *content;
+	
+	*result = t_str_new(str_len(in));
+	str_append_str(*result, in);
+
+	content = str_c_modifiable(*result);
+	content = str_ucase(content);
+	
+	return TRUE;
+}
+
+bool mod_lower_modify(string_t *in, string_t **result)
+{
+	char *content;
+	
+	*result = t_str_new(str_len(in));
+	str_append_str(*result, in);
+
+	content = str_c_modifiable(*result);
+	content = str_lcase(content);
+
+	return TRUE;
+}
+
+bool mod_length_modify(string_t *in, string_t **result)
+{
+	*result = t_str_new(64);
+	str_printfa(*result, "%llu", (unsigned long long) str_len(in));
+
+	return TRUE;
+}
+
+bool mod_quotewildcard_modify(string_t *in, string_t **result)
+{
+	unsigned int i;
+	const char *content;
+	
+	*result = t_str_new(str_len(in) * 2);
+	content = (const char *) str_data(in);
+	
+	for ( i = 0; i < str_len(in); i++ ) {
+		if ( content[i] == '*' || content[i] == '?' || content[i] == '\\' ) {
+			str_append_c(*result, '\\');
+		}
+		str_append_c(*result, content[i]);
+	}
+	
+	return TRUE;
+}
+
+
+
+
+
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-modifiers.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-modifiers.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-modifiers.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-modifiers.h	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,47 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_VARIABLES_MODIFIERS_H
+#define __EXT_VARIABLES_MODIFIERS_H
+
+#include "ext-variables-common.h"
+#include "sieve-ext-variables.h"
+
+/*
+ * Modifier registry
+ */
+
+const struct sieve_variables_modifier *ext_variables_modifier_find
+	(struct sieve_validator *validator, const char *identifier);
+
+void ext_variables_register_core_modifiers
+	(struct ext_variables_validator_context *ctx);
+	
+/*
+ * Modifier operand
+ */
+
+extern const struct sieve_operand modifier_operand;
+
+static inline void ext_variables_opr_modifier_emit
+(struct sieve_binary *sbin, const struct sieve_variables_modifier *modf)
+{ 
+	sieve_opr_object_emit(sbin, &modf->object);
+}
+
+static inline const struct sieve_variables_modifier *
+	ext_variables_opr_modifier_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	return (const struct sieve_variables_modifier *) sieve_opr_object_read
+		(renv, &sieve_variables_modifier_operand_class, address);
+}
+
+static inline bool ext_variables_opr_modifier_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	return sieve_opr_object_dump
+		(denv, &sieve_variables_modifier_operand_class, address, NULL);
+}
+	
+#endif /* __EXT_VARIABLES_MODIFIERS_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-name.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-name.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-name.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-name.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,88 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "array.h"
+
+#include "sieve-common.h"
+
+#include "ext-variables-common.h"
+#include "ext-variables-limits.h"
+#include "ext-variables-name.h"
+
+#include <ctype.h>
+
+int ext_variable_name_parse
+(ARRAY_TYPE(ext_variable_name) *vname, const char **str, const char *strend)
+{
+	const char *p = *str;
+	int nspace_used = 0;
+				
+	for (;;) { 
+		struct ext_variable_name *cur_element;
+		string_t *cur_ident;
+
+		/* Acquire current position in the substitution structure or allocate 
+		 * a new one if this substitution consists of more elements than before.
+		 */
+		if ( nspace_used < (int) array_count(vname) ) {
+			cur_element = array_idx_modifiable
+				(vname, (unsigned int) nspace_used);
+			cur_ident = cur_element->identifier;
+		} else {
+			if ( nspace_used >= SIEVE_VARIABLES_MAX_NAMESPACE_ELEMENTS )
+				return -1;
+			cur_element = array_append_space(vname);
+			cur_ident = cur_element->identifier = t_str_new(32);
+		}
+
+		/* Identifier */
+		if ( *p == '_' || i_isalpha(*p) ) {
+			cur_element->num_variable = -1;
+			str_truncate(cur_ident, 0);
+			str_append_c(cur_ident, *p);
+			p++;
+		
+			while ( p < strend && (*p == '_' || i_isalnum(*p)) ) {
+				if ( str_len(cur_ident) >= SIEVE_VARIABLES_MAX_VARIABLE_NAME_LEN )
+					return -1;
+				str_append_c(cur_ident, *p);
+				p++;
+			}
+		
+		/* Num-variable */
+		} else if ( i_isdigit(*p) ) {
+			cur_element->num_variable = *p - '0';
+			p++;
+			
+			while ( p < strend && i_isdigit(*p) ) {
+				cur_element->num_variable = cur_element->num_variable*10 + (*p - '0');
+				p++;
+			} 
+
+			/* If a num-variable is first, no more elements can follow because no
+			 * namespace is specified.
+			 */
+			if ( nspace_used == 0 ) {
+				*str = p;
+				return 1;
+			}
+		} else {
+			*str = p;
+			return -1;
+		}
+		
+		nspace_used++;
+		
+		if ( p < strend && *p == '.' ) 
+			p++;
+		else
+			break;
+	}
+	
+	*str = p;
+	return nspace_used;
+} 
+ 
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-name.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-name.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-name.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-name.h	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,57 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_VARIABLES_NAME
+#define __EXT_VARIABLES_NAME
+
+/* Variable Substitution
+ * ---------------------
+ * 
+ * The variable strings are preprocessed into an AST list consisting of variable 
+ * substitutions and constant parts of the string. The variables to which
+ * the substitutions link are looked up and their index in their scope storage
+ * is what is added to the list and eventually emitted as byte code. So in byte
+ * code a variable string will look as a series of substrings interrupted by
+ * integer operands that refer to variables. During execution the strings and 
+ * the looked-up variables are concatenated to obtain the desired result. The 
+ * the variable references are simple indexes into an array of variables, so
+ * looking these up during execution is a trivial process.
+ * 
+ * However (RFC 5229):
+ *   Tests or actions in future extensions may need to access the
+ *   unexpanded version of the string argument and, e.g., do the expansion
+ *   after setting variables in its namespace.  The design of the
+ *   implementation should allow this.
+ *
+ * Various options exist to provide this feature. If the extension is entirely
+ * namespace-based there is actually not very much of a problem. The variable
+ * list can easily be extended with new argument-types that refer to a variable
+ * identifier in stead of an index in the variable's storage. 
+ */
+
+#include "lib.h"
+#include "array.h"
+
+#include "sieve-common.h"
+
+#include "ext-variables-common.h"
+
+/*
+ * Types
+ */ 
+
+struct ext_variable_name {
+	string_t *identifier;
+	int num_variable;
+};
+
+ARRAY_DEFINE_TYPE(ext_variable_name, struct ext_variable_name);
+
+/*
+ * Variable name parsing
+ */
+ 
+int ext_variable_name_parse
+	(ARRAY_TYPE(ext_variable_name) *vname, const char **str, const char *strend);
+
+#endif /* __EXT_VARIABLES_NAME */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-operands.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-operands.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-operands.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-operands.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,238 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "hash.h"
+#include "str.h"
+#include "array.h"
+
+#include "sieve-common.h"
+
+#include "sieve-ast.h"
+#include "sieve-binary.h"
+#include "sieve-code.h"
+#include "sieve-match-types.h"
+
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-dump.h"
+#include "sieve-interpreter.h"
+
+#include "ext-variables-common.h"
+#include "ext-variables-name.h"
+#include "ext-variables-dump.h"
+
+/* 
+ * Variable operand 
+ */
+
+static bool opr_variable_read_value
+	(const struct sieve_runtime_env *renv, sieve_size_t *address, string_t **str);
+static bool opr_variable_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address, 
+		const char *field_name);
+
+const struct sieve_opr_string_interface variable_interface = { 
+	opr_variable_dump,
+	opr_variable_read_value
+};
+		
+const struct sieve_operand variable_operand = { 
+	"variable", 
+	&variables_extension, 
+	EXT_VARIABLES_OPERAND_VARIABLE,
+	&string_class,
+	&variable_interface
+};
+
+void ext_variables_opr_variable_emit
+(struct sieve_binary *sbin, struct sieve_variable *var) 
+{
+	if ( var->ext == NULL ) {
+		/* Default variable storage */
+		(void) sieve_operand_emit_code(sbin, &variable_operand);
+		(void) sieve_binary_emit_byte(sbin, 0);
+		(void) sieve_binary_emit_unsigned(sbin, var->index);
+		return;
+	} 
+
+	(void) sieve_operand_emit_code(sbin, &variable_operand);
+	(void) sieve_binary_emit_extension(sbin, var->ext, 1);
+	(void) sieve_binary_emit_unsigned(sbin, var->index);
+}
+
+static bool opr_variable_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+	const char *field_name) 
+{
+	unsigned int index = 0;
+	const struct sieve_extension *ext;
+	unsigned int code = 1; /* Initially set to offset value */
+	const char *identifier;
+
+	if ( !sieve_binary_read_extension(denv->sbin, address, &code, &ext) )
+		return FALSE;
+	
+	if ( !sieve_binary_read_unsigned(denv->sbin, address, &index) )
+		return FALSE;
+		
+	identifier = ext_variables_dump_get_identifier(denv, ext, index);
+	identifier = identifier == NULL ? "??" : identifier;
+
+	if ( ext == NULL ) {		
+		if ( field_name != NULL ) 
+			sieve_code_dumpf(denv, "%s: VAR ${%s} (%ld)", 
+				field_name, identifier, (long) index);
+		else
+			sieve_code_dumpf(denv, "VAR ${%s} (%ld)", 
+				identifier, (long) index);
+	} else {
+		if ( field_name != NULL ) 
+			sieve_code_dumpf(denv, "%s: VAR [%s] ${%s} (%ld)", 
+				field_name, ext->name, identifier, (long) index);
+		else
+			sieve_code_dumpf(denv, "VAR [%s] ${%s} (%ld)", 
+				ext->name, identifier, (long) index);
+	}
+	return TRUE;
+}
+
+static bool opr_variable_read_value
+(const struct sieve_runtime_env *renv, sieve_size_t *address, string_t **str)
+{ 
+	const struct sieve_extension *ext;
+	unsigned int code = 1; /* Initially set to offset value */
+	struct sieve_variable_storage *storage;
+	unsigned int index = 0;
+	
+	if ( !sieve_binary_read_extension(renv->sbin, address, &code, &ext) )
+		return FALSE;
+
+	storage = sieve_ext_variables_get_storage(renv->interp, ext);
+	if ( storage == NULL ) 
+		return FALSE;
+	
+	if (sieve_binary_read_unsigned(renv->sbin, address, &index) ) {
+		/* Parameter str can be NULL if we are requested to only skip and not 
+		 * actually read the argument.
+		 */
+		if ( str != NULL ) {
+			if ( !sieve_variable_get(storage, index, str) )
+				return FALSE;
+		
+			if ( *str == NULL ) *str = t_str_new(0);
+		}
+		return TRUE;
+	}
+	
+	return FALSE;
+}
+		
+bool sieve_variable_operand_read_data
+(const struct sieve_runtime_env *renv, const struct sieve_operand *operand, 
+	sieve_size_t *address, struct sieve_variable_storage **storage, 
+	unsigned int *var_index)
+{
+	const struct sieve_extension *ext;
+	unsigned int code = 1; /* Initially set to offset value */
+	unsigned int idx = 0;
+
+	if ( operand != &variable_operand ) {
+		return FALSE;
+	}
+
+	if ( !sieve_binary_read_extension(renv->sbin, address, &code, &ext) )
+        return FALSE;
+		
+	*storage = sieve_ext_variables_get_storage(renv->interp, ext);
+	if ( *storage == NULL )	
+		return FALSE;
+	
+	if ( !sieve_binary_read_unsigned(renv->sbin, address, &idx) )
+		return FALSE;		
+
+	*var_index = idx;
+	return TRUE;
+}
+
+bool sieve_variable_operand_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address, 
+	struct sieve_variable_storage **storage, unsigned int *var_index)
+{
+	const struct sieve_operand *operand = sieve_operand_read(renv->sbin, address);
+
+	return sieve_variable_operand_read_data
+		(renv, operand, address, storage, var_index);
+}
+	
+/* 
+ * Match value operand 
+ */
+
+static bool opr_match_value_read
+	(const struct sieve_runtime_env *renv, sieve_size_t *address, string_t **str);
+static bool opr_match_value_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address, 
+		const char *field_name);
+
+const struct sieve_opr_string_interface match_value_interface = { 
+	opr_match_value_dump,
+	opr_match_value_read
+};
+		
+const struct sieve_operand match_value_operand = { 
+	"match-value", 
+	&variables_extension, 
+	EXT_VARIABLES_OPERAND_MATCH_VALUE,
+	&string_class,
+	&match_value_interface
+};	
+
+void ext_variables_opr_match_value_emit
+(struct sieve_binary *sbin, unsigned int index) 
+{
+	(void) sieve_operand_emit_code(sbin, &match_value_operand);
+	(void) sieve_binary_emit_unsigned(sbin, index);
+}
+
+static bool opr_match_value_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+	const char *field_name) 
+{
+	unsigned int index = 0;
+	
+	if (sieve_binary_read_unsigned(denv->sbin, address, &index) ) {
+		if ( field_name != NULL )
+			sieve_code_dumpf(denv, "%s: MATCHVAL %lu", field_name, (unsigned long) index);
+		else
+			sieve_code_dumpf(denv, "MATCHVAL %lu", (unsigned long) index);
+
+		return TRUE;
+	}
+	
+	return FALSE;
+}
+
+static bool opr_match_value_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address, string_t **str)
+{ 
+	unsigned int index = 0;
+			
+	if (sieve_binary_read_unsigned(renv->sbin, address, &index) ) {
+		/* Parameter str can be NULL if we are requested to only skip and not 
+		 * actually read the argument.
+		 	*/
+		if ( str != NULL ) {
+			sieve_match_values_get(renv->interp, index, str);
+		
+			if ( *str == NULL ) 
+				*str = t_str_new(0);
+			else if ( str_len(*str) > SIEVE_VARIABLES_MAX_VARIABLE_SIZE ) 
+				str_truncate(*str, SIEVE_VARIABLES_MAX_VARIABLE_SIZE);
+		}
+		return TRUE;
+	}
+	
+	return FALSE;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-operands.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-operands.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-operands.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-operands.h	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,34 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_VARIABLES_OPERANDS_H
+#define __EXT_VARIABLES_OPERANDS_H
+
+#include "lib.h"
+#include "hash.h"
+#include "str.h"
+#include "array.h"
+
+#include "sieve-common.h"
+#include "ext-variables-common.h"
+
+/* 
+ * Variable operand 
+ */
+		
+extern const struct sieve_operand variable_operand;	
+
+void ext_variables_opr_variable_emit
+	(struct sieve_binary *sbin, struct sieve_variable *var);
+
+/* 
+ * Match value operand 
+ */
+		
+extern const struct sieve_operand match_value_operand;	
+
+void ext_variables_opr_match_value_emit
+	(struct sieve_binary *sbin, unsigned int index);
+	
+#endif /* __EXT_VARIABLES_OPERANDS_H */
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/Makefile.am dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/Makefile.am
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/Makefile.am	2008-10-20 01:35:49.000000000 +0200
@@ -0,0 +1,35 @@
+noinst_LTLIBRARIES = libsieve_ext_variables.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+cmds = \
+	cmd-set.c
+
+tsts = \
+	tst-string.c
+
+libsieve_ext_variables_la_SOURCES = \
+	ext-variables-common.c \
+	ext-variables-name.c \
+	ext-variables-arguments.c \
+	ext-variables-operands.c \
+	ext-variables-modifiers.c \
+	ext-variables-dump.c \
+	$(cmds) \
+	$(tsts) \
+	ext-variables.c
+
+noinst_HEADERS = \
+	ext-variables-common.h \
+	ext-variables-limits.h \
+	ext-variables-name.h \
+	ext-variables-arguments.h \
+	ext-variables-operands.h \
+	ext-variables-modifiers.h \
+	ext-variables-dump.h \
+	sieve-ext-variables.h 
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/Makefile.in dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/Makefile.in
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/Makefile.in	2009-08-21 00:55:44.000000000 +0200
@@ -0,0 +1,495 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve/plugins/variables
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libsieve_ext_variables_la_LIBADD =
+am__objects_1 = cmd-set.lo
+am__objects_2 = tst-string.lo
+am_libsieve_ext_variables_la_OBJECTS = ext-variables-common.lo \
+	ext-variables-name.lo ext-variables-arguments.lo \
+	ext-variables-operands.lo ext-variables-modifiers.lo \
+	ext-variables-dump.lo $(am__objects_1) $(am__objects_2) \
+	ext-variables.lo
+libsieve_ext_variables_la_OBJECTS =  \
+	$(am_libsieve_ext_variables_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_ext_variables_la_SOURCES)
+DIST_SOURCES = $(libsieve_ext_variables_la_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LTLIBRARIES = libsieve_ext_variables.la
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+cmds = \
+	cmd-set.c
+
+tsts = \
+	tst-string.c
+
+libsieve_ext_variables_la_SOURCES = \
+	ext-variables-common.c \
+	ext-variables-name.c \
+	ext-variables-arguments.c \
+	ext-variables-operands.c \
+	ext-variables-modifiers.c \
+	ext-variables-dump.c \
+	$(cmds) \
+	$(tsts) \
+	ext-variables.c
+
+noinst_HEADERS = \
+	ext-variables-common.h \
+	ext-variables-limits.h \
+	ext-variables-name.h \
+	ext-variables-arguments.h \
+	ext-variables-operands.h \
+	ext-variables-modifiers.h \
+	ext-variables-dump.h \
+	sieve-ext-variables.h 
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/lib-sieve/plugins/variables/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  src/lib-sieve/plugins/variables/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve_ext_variables.la: $(libsieve_ext_variables_la_OBJECTS) $(libsieve_ext_variables_la_DEPENDENCIES) 
+	$(LINK)  $(libsieve_ext_variables_la_OBJECTS) $(libsieve_ext_variables_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-set.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-variables-arguments.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-variables-common.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-variables-dump.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-variables-modifiers.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-variables-name.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-variables-operands.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-variables.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-string.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/sieve-ext-variables.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/sieve-ext-variables.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/sieve-ext-variables.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/sieve-ext-variables.h	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,164 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* 
+ * Public interface for other extensions to use 
+ */
+ 
+#ifndef __SIEVE_EXT_VARIABLES_H
+#define __SIEVE_EXT_VARIABLES_H
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-objects.h"
+
+#include "ext-variables-limits.h"
+
+/*
+ * Variable scope
+ */
+
+struct sieve_variable {
+	const char *identifier;
+	unsigned int index;
+
+	const struct sieve_extension *ext;
+	void *context;
+};
+
+struct sieve_variable_scope;
+
+struct sieve_variable_scope *sieve_variable_scope_create
+	(const struct sieve_extension *ext);
+void sieve_variable_scope_ref
+	(struct sieve_variable_scope *scope);
+void sieve_variable_scope_unref
+	(struct sieve_variable_scope **scope);
+pool_t sieve_variable_scope_pool
+	(struct sieve_variable_scope *scope);
+
+struct sieve_variable *sieve_variable_scope_declare
+	(struct sieve_variable_scope *scope, const char *identifier);
+struct sieve_variable *sieve_variable_scope_import
+	(struct sieve_variable_scope *scope, struct sieve_variable *var);
+struct sieve_variable *sieve_variable_scope_get_variable
+	(struct sieve_variable_scope *scope, const char *identifier, bool create);
+struct sieve_variable *sieve_variable_scope_get_indexed
+	(struct sieve_variable_scope *scope, unsigned int index);
+
+/* Iteration over all declared variables */
+
+struct sieve_variable_scope_iter;
+
+struct sieve_variable_scope_iter *sieve_variable_scope_iterate_init
+	(struct sieve_variable_scope *scope);
+bool sieve_variable_scope_iterate
+	(struct sieve_variable_scope_iter *iter, struct sieve_variable **var_r);
+void sieve_variable_scope_iterate_deinit
+	(struct sieve_variable_scope_iter **iter);
+
+/* Statistics */
+
+unsigned int sieve_variable_scope_declarations
+	(struct sieve_variable_scope *scope);
+unsigned int sieve_variable_scope_size
+	(struct sieve_variable_scope *scope);
+
+/* Get all native variables */
+
+struct sieve_variable * const *sieve_variable_scope_get_variables
+	(struct sieve_variable_scope *scope, unsigned int *size_r);
+
+/* 
+ * Variable storage
+ */	
+	
+struct sieve_variable_storage;
+
+struct sieve_variable_storage *sieve_variable_storage_create
+	(pool_t pool, struct sieve_variable_scope *scope, unsigned int max_size);
+bool sieve_variable_get
+	(struct sieve_variable_storage *storage, unsigned int index, 
+		string_t **value);
+bool sieve_variable_get_modifiable
+	(struct sieve_variable_storage *storage, unsigned int index, 
+		string_t **value);
+bool sieve_variable_assign
+	(struct sieve_variable_storage *storage, unsigned int index, 
+		const string_t *value);
+bool sieve_variable_get_identifier
+	(struct sieve_variable_storage *storage, unsigned int index, 
+		const char **identifier);
+
+/*
+ * Variables access
+ */
+
+bool sieve_ext_variables_is_active(struct sieve_validator *valdtr);
+
+struct sieve_variable_scope *sieve_ext_variables_get_main_scope
+	(struct sieve_validator *validator);
+	
+struct sieve_variable_storage *sieve_ext_variables_get_storage
+	(struct sieve_interpreter *interp, const struct sieve_extension *ext);
+void sieve_ext_variables_set_storage
+	(struct sieve_interpreter *interp, struct sieve_variable_storage *storage,
+		const struct sieve_extension *ext);	
+		
+/* 
+ * Variable arguments 
+ */
+
+bool sieve_variable_argument_activate
+(struct sieve_validator *validator, struct sieve_command_context *cmd, 
+	struct sieve_ast_argument *arg, bool assignment);
+	
+/* 
+ * Variable operands 
+ */
+
+extern const struct sieve_operand variable_operand;
+
+bool sieve_variable_operand_read_data
+	(const struct sieve_runtime_env *renv, const struct sieve_operand *operand, 
+		sieve_size_t *address, struct sieve_variable_storage **storage, 
+		unsigned int *var_index);
+bool sieve_variable_operand_read
+	(const struct sieve_runtime_env *renv, sieve_size_t *address, 
+		struct sieve_variable_storage **storage, unsigned int *var_index);
+		
+static inline bool sieve_operand_is_variable
+(const struct sieve_operand *operand)
+{
+	return ( operand != NULL && operand == &variable_operand );
+}	
+
+/* 
+ * Modifiers 
+ */
+
+struct sieve_variables_modifier {
+	struct sieve_object object;
+	
+	unsigned int precedence;
+	
+	bool (*modify)(string_t *in, string_t **result);
+};
+
+extern const struct sieve_operand_class sieve_variables_modifier_operand_class;
+
+#define SIEVE_VARIABLES_DEFINE_MODIFIER(OP) SIEVE_EXT_DEFINE_OBJECT(OP)
+#define SIEVE_VARIABLES_DEFINE_MODIFIERS(OPS) SIEVE_EXT_DEFINE_OBJECTS(OPS)
+
+void sieve_variables_modifier_register
+	(struct sieve_validator *valdtr, const struct sieve_variables_modifier *smodf);
+
+/*
+ * Code dumping
+ */
+
+void sieve_ext_variables_dump_set_scope
+(const struct sieve_dumptime_env *denv, const struct sieve_extension *ext, 
+	struct sieve_variable_scope *scope);
+
+#endif /* __SIEVE_EXT_VARIABLES_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/tst-string.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/tst-string.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/plugins/variables/tst-string.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/plugins/variables/tst-string.c	2009-07-30 00:44:58.000000000 +0200
@@ -0,0 +1,242 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+#include "ext-variables-common.h"
+
+/* 
+ * String test 
+ *
+ * Syntax:
+ *   string [COMPARATOR] [MATCH-TYPE]
+ *     <source: string-list> <key-list: string-list>
+ */
+
+static bool tst_string_registered
+	(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg);
+static bool tst_string_validate
+	(struct sieve_validator *validator, struct sieve_command_context *tst);
+static bool tst_string_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command tst_string = { 
+	"string", 
+	SCT_TEST, 
+	2, 0, FALSE, FALSE,
+	tst_string_registered, 
+	NULL,
+	tst_string_validate, 
+	tst_string_generate, 
+	NULL 
+};
+
+/* 
+ * String operation
+ */
+
+static bool tst_string_operation_dump
+	(const struct sieve_operation *op, 
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_string_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation tst_string_operation = { 
+	"STRING",
+	&variables_extension, 
+	EXT_VARIABLES_OPERATION_STRING, 
+	tst_string_operation_dump, 
+	tst_string_operation_execute 
+};
+
+/* 
+ * Optional arguments 
+ */
+
+enum tst_string_optional {	
+	OPT_END,
+	OPT_COMPARATOR,
+	OPT_MATCH_TYPE
+};
+
+/* 
+ * Test registration 
+ */
+
+static bool tst_string_registered
+	(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg) 
+{
+	/* The order of these is not significant */
+	sieve_comparators_link_tag(validator, cmd_reg, OPT_COMPARATOR);
+	sieve_match_types_link_tags(validator, cmd_reg, OPT_MATCH_TYPE);
+
+	return TRUE;
+}
+
+/* 
+ * Test validation 
+ */
+
+static bool tst_string_validate
+	(struct sieve_validator *validator, struct sieve_command_context *tst) 
+{ 		
+	struct sieve_ast_argument *arg = tst->first_positional;
+	
+	if ( !sieve_validate_positional_argument
+		(validator, tst, arg, "source", 1, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+	
+	if ( !sieve_validator_argument_activate(validator, tst, arg, FALSE) )
+		return FALSE;
+	
+	arg = sieve_ast_argument_next(arg);
+
+	if ( !sieve_validate_positional_argument
+		(validator, tst, arg, "key list", 2, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+	
+	if ( !sieve_validator_argument_activate(validator, tst, arg, FALSE) )
+		return FALSE;
+
+	/* Validate the key argument to a specified match type */
+	return sieve_match_type_validate
+		(validator, tst, arg, &is_match_type, &i_octet_comparator);
+}
+
+/* 
+ * Test generation 
+ */
+
+static bool tst_string_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx) 
+{
+	sieve_operation_emit_code(cgenv->sbin, &tst_string_operation);
+
+ 	/* Generate arguments */
+	if ( !sieve_generate_arguments(cgenv, ctx, NULL) )
+		return FALSE;
+	
+	return TRUE;
+}
+
+/* 
+ * Code dump 
+ */
+
+static bool tst_string_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	int opt_code = 0;
+
+	sieve_code_dumpf(denv, "STRING-TEST");
+	sieve_code_descend(denv);
+
+	/* Handle any optional arguments */
+	if ( !sieve_match_dump_optional_operands(denv, address, &opt_code) )
+		return FALSE;
+
+	if ( opt_code != SIEVE_MATCH_OPT_END )
+		return FALSE;
+		
+	return
+		sieve_opr_stringlist_dump(denv, address, "source") &&
+		sieve_opr_stringlist_dump(denv, address, "key list");
+}
+
+/* 
+ * Code execution 
+ */
+
+static int tst_string_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED, 
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	int ret, mret;
+	bool result = TRUE;
+	int opt_code = 0;
+	const struct sieve_comparator *cmp = &i_octet_comparator;
+	const struct sieve_match_type *mtch = &is_match_type;
+	struct sieve_match_context *mctx;
+	struct sieve_coded_stringlist *source;
+	struct sieve_coded_stringlist *key_list;
+	string_t *src_item;
+	bool matched;
+
+	/*
+	 * Read operands 
+	 */
+	
+	/* Handle match-type and comparator operands */
+	if ( (ret=sieve_match_read_optional_operands
+		(renv, address, &opt_code, &cmp, &mtch)) <= 0 )
+		return ret;
+	
+	/* Check whether we neatly finished the list of optional operands*/
+	if ( opt_code != SIEVE_MATCH_OPT_END) {
+		sieve_runtime_trace_error(renv, "invalid optional operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Read source */
+	if ( (source=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid source operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/* Read key-list */
+	if ( (key_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid key-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "STRING test");
+
+	mctx = sieve_match_begin(renv->interp, mtch, cmp, NULL, key_list); 	
+
+	/* Iterate through all requested strings to match */
+	src_item = NULL;
+	matched = FALSE;
+	while ( result && !matched && 
+		(result=sieve_coded_stringlist_next_item(source, &src_item)) 
+		&& src_item != NULL ) {
+		const char *src = str_len(src_item) > 0 ? str_c(src_item) : NULL;
+
+		if ( (mret=sieve_match_value
+			(mctx, src, str_len(src_item))) < 0 ) {
+			result = FALSE;
+			break;
+		}
+		
+		matched = ( mret > 0 );				
+	}
+
+	if ( (mret=sieve_match_end(&mctx)) < 0 ) 
+		result = FALSE;
+	else
+		matched = ( mret > 0 || matched ); 	
+	
+	if ( result ) {
+		sieve_interpreter_set_test_result(renv->interp, matched);
+		return SIEVE_EXEC_OK;
+	}
+	
+	sieve_runtime_trace_error(renv, "invalid string list item");
+	return SIEVE_EXEC_BIN_CORRUPT;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/rfc2822.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/rfc2822.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/rfc2822.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/rfc2822.c	2009-07-15 19:34:45.000000000 +0200
@@ -0,0 +1,207 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+
+/* NOTE: much of the functionality implemented here should eventually appear
+ * somewhere in Dovecot itself.
+ */
+
+#include "lib.h"
+#include "str.h"
+
+#include "rfc2822.h"
+
+#include <stdio.h>
+#include <ctype.h>
+ 
+bool rfc2822_header_field_name_verify
+(const char *field_name, unsigned int len) 
+{
+	const char *p = field_name;
+	const char *pend = p + len;
+
+	/* field-name   =   1*ftext
+	 * ftext        =   %d33-57 /               ; Any character except
+	 *                  %d59-126                ;  controls, SP, and
+	 *                                          ;  ":".
+	 */
+	 
+	while ( p < pend ) {
+		if ( *p < 33 || *p == ':' )
+			return FALSE;
+
+		p++;
+	}	
+	
+	return TRUE;
+}
+
+bool rfc2822_header_field_body_verify
+(const char *field_body, unsigned int len) 
+{
+	const char *p = field_body;
+	const char *pend = p + len;
+
+	/* unstructured    =       *([FWS] utext) [FWS]
+	 * FWS             =       ([*WSP CRLF] 1*WSP) /   ; Folding white space
+	 *                         obs-FWS
+	 * utext           =       NO-WS-CTL /     ; Non white space controls
+	 *                         %d33-126 /      ; The rest of US-ASCII
+	 *                         obs-utext
+	 * NO-WS-CTL       =       %d1-8 /         ; US-ASCII control characters
+	 *                         %d11 /          ;  that do not include the
+	 *                         %d12 /          ;  carriage return, line feed,
+	 *                         %d14-31 /       ;  and white space characters
+	 *                         %d127
+	 * WSP             =  SP / HTAB
+	 */
+
+	/* This verification does not allow content to be folded. This should done
+	 * automatically upon message composition.
+	 */
+
+	while ( p < pend ) {
+		if ( *p == '\0' || *p == '\r' || *p == '\n' || ((unsigned char)*p) > 127 )
+			return FALSE;
+
+		p++;
+	}	
+	
+	return TRUE;
+}
+
+/*
+ *
+ */
+
+const char *rfc2822_header_field_name_sanitize(const char *name)
+{
+	char *result = t_strdup_noconst(name);
+	char *p;
+	
+	/* Make the whole name lower case ... */
+	result = str_lcase(result);
+
+	/* ... except for the first letter and those that follow '-' */
+	p = result;
+	*p = i_toupper(*p);
+	while ( *p != '\0' ) {
+		if ( *p == '-' ) {
+			p++;
+			
+			if ( *p != '\0' )
+				*p = i_toupper(*p);
+			
+			continue;
+		}
+		
+		p++;
+	}
+	
+	return result;
+}
+
+/*
+ * Message construction
+ */
+ 
+/* FIXME: This should be collected into a Dovecot API for composing internet
+ * mail messages. These functions now use FILE * output streams, but this should
+ * be changed to proper dovecot streams.
+ */
+
+static inline bool rfc2822_write(FILE *f, const char *data, size_t len)
+{
+	return ( fwrite(data, len, 1, f) == 1 );
+}
+
+int rfc2822_header_field_write
+(FILE *f, const char *name, const char *body)
+{
+	static const unsigned int max_line = 80;
+	
+	const char *bp = body;  /* Pointer */ 
+	const char *sp = body;  /* Start pointer */
+	const char *wp = NULL;  /* Whitespace pointer */ 
+	const char *nlp = NULL; /* New-line pointer */
+	unsigned int line_len = strlen(name);
+	int len = 0;
+	
+	/* Write header field name first */
+	if ( !rfc2822_write(f, name, line_len) || !rfc2822_write(f, ": ", 2) )
+		return -1;
+
+	line_len +=  2;
+	len += line_len;
+		
+	/* Add field body; fold it if necessary and account for existing folding */
+	while ( *bp != '\0' ) {
+		while ( *bp != '\0' && nlp == NULL && (wp == NULL || line_len < max_line) ) {
+			if ( *bp == ' ' || *bp == '\t' ) {
+			 	wp = bp;
+			} else if ( *bp == '\r' || *bp == '\n' ) {
+				nlp = bp;			
+				break;
+			}
+
+			bp++; line_len++;
+		}
+		
+		if ( *bp == '\0' ) break;
+		
+		/* Existing newline ? */
+		if ( nlp != NULL ) {
+			/* Replace any sort of newline with LF */
+			while ( *bp == '\r' || *bp == '\n' )
+				bp++;
+			
+			if ( !rfc2822_write(f, sp, nlp-sp) )
+				return -1;
+			len += nlp-sp;
+			
+			if ( *bp != '\0' && *bp != ' ' && *bp != '\t' ) {
+				if ( !rfc2822_write(f, "\r\n\t", 3) )
+					return -1;
+				len += 3;
+			} else {
+				if ( !rfc2822_write(f, "\r\n", 2) )
+					return -1;
+				len += 2;
+			}
+
+			sp = bp;
+		} else {
+			/* Insert newline at last whitespace within the max_line limit */
+			if ( !rfc2822_write(f, sp, wp-sp) || !rfc2822_write(f, "\r\n", 2) )
+				return -1;
+			len += (wp-sp) + 2;
+		
+			sp = wp;
+		}
+		
+		line_len = bp - sp;		
+		wp = NULL;
+		nlp = NULL;
+	}
+	
+	if ( bp != sp ) {
+		if ( !rfc2822_write(f, sp, bp-sp) || !rfc2822_write(f, "\r\n", 2) )
+			return -1;
+		len += (bp-sp) + 2;
+	}
+
+	return len;
+}
+
+int rfc2822_header_field_printf
+(FILE *f, const char *name, const char *body_fmt, ...)
+{
+	string_t *body = t_str_new(256);
+	va_list args;
+
+	va_start(args, body_fmt);
+	str_vprintfa(body, body_fmt, args);
+	va_end(args);
+	
+	return rfc2822_header_field_write(f, name, str_c(body));
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/rfc2822.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/rfc2822.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/rfc2822.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/rfc2822.h	2009-07-15 19:32:31.000000000 +0200
@@ -0,0 +1,36 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+
+#ifndef __RFC2822_H
+#define __RFC2822_H
+
+#include "lib.h"
+
+#include <stdio.h>
+
+/*
+ * Verification
+ */ 
+ 
+bool rfc2822_header_field_name_verify
+	(const char *field_name, unsigned int len);
+bool rfc2822_header_field_body_verify
+(const char *field_body, unsigned int len);
+
+/*
+ *
+ */
+
+const char *rfc2822_header_field_name_sanitize(const char *name);
+
+/*
+ * Message composition
+ */
+
+int rfc2822_header_field_write
+	(FILE *f, const char *name, const char *body);
+	
+int rfc2822_header_field_printf
+	(FILE *f, const char *name, const char *body_fmt, ...) ATTR_FORMAT(3, 4);
+
+#endif /* __RFC2822_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-actions.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-actions.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-actions.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-actions.c	2009-07-27 13:30:18.000000000 +0200
@@ -0,0 +1,604 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+
+#include "lib.h"
+#include "strfuncs.h"
+#include "str-sanitize.h"
+#include "mail-storage.h"
+#include "mail-namespace.h"
+
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-binary.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-result.h"
+#include "sieve-actions.h"
+
+#include <ctype.h>
+
+/*
+ * Action execution environment
+ */
+
+const char *sieve_action_get_location(const struct sieve_action_exec_env *aenv)
+{
+	return t_strdup_printf("msgid=%s", aenv->msgdata->id == NULL ?
+		"unspecified" : str_sanitize(aenv->msgdata->id, 80));
+}
+
+/*
+ * Side-effect operand
+ */
+ 
+const struct sieve_operand_class sieve_side_effect_operand_class = 
+	{ "SIDE-EFFECT" };
+
+bool sieve_opr_side_effect_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	const struct sieve_object *obj;
+	const struct sieve_side_effect *seffect;
+	
+	if ( !sieve_opr_object_dump
+		(denv, &sieve_side_effect_operand_class, address, &obj) )
+		return FALSE;
+	
+	seffect = (const struct sieve_side_effect *) obj;
+
+	if ( seffect->dump_context != NULL ) {
+		sieve_code_descend(denv);
+		if ( !seffect->dump_context(seffect, denv, address) ) {
+			return FALSE;	
+		}
+		sieve_code_ascend(denv);
+	}
+
+	return TRUE;
+}
+
+/*
+ * Store action
+ */
+ 
+/* Forward declarations */
+
+static bool act_store_equals
+	(const struct sieve_script_env *senv, const void *ctx1, const void *ctx2);
+	
+static int act_store_check_duplicate
+	(const struct sieve_runtime_env *renv, 
+		const struct sieve_action_data *act, 
+		const struct sieve_action_data *act_other);
+static void act_store_print
+	(const struct sieve_action *action, 
+		const struct sieve_result_print_env *rpenv, void *context, bool *keep);
+
+static bool act_store_start
+	(const struct sieve_action *action,
+		const struct sieve_action_exec_env *aenv, void *context, void **tr_context);
+static bool act_store_execute
+	(const struct sieve_action *action, 
+		const struct sieve_action_exec_env *aenv, void *tr_context);
+static bool act_store_commit
+	(const struct sieve_action *action, 
+		const struct sieve_action_exec_env *aenv, void *tr_context, bool *keep);
+static void act_store_rollback
+	(const struct sieve_action *action, 
+		const struct sieve_action_exec_env *aenv, void *tr_context, bool success);
+		
+/* Action object */
+
+const struct sieve_action act_store = {
+	"store",
+	SIEVE_ACTFLAG_TRIES_DELIVER,
+	act_store_equals,
+	act_store_check_duplicate, 
+	NULL, 
+	act_store_print,
+	act_store_start,
+	act_store_execute,
+	act_store_commit,
+	act_store_rollback,
+};
+
+/* API */
+
+int sieve_act_store_add_to_result
+(const struct sieve_runtime_env *renv, 
+	struct sieve_side_effects_list *seffects, const char *mailbox,
+	unsigned int source_line)
+{
+	pool_t pool;
+	struct act_store_context *act;
+	
+	/* Add redirect action to the result */
+	pool = sieve_result_pool(renv->result);
+	act = p_new(pool, struct act_store_context, 1);
+	act->mailbox = p_strdup(pool, mailbox);
+
+	return sieve_result_add_action(renv, &act_store, seffects, 
+		source_line, (void *) act, 0);
+}
+
+void sieve_act_store_add_flags
+(const struct sieve_action_exec_env *aenv, void *tr_context,
+	const char *const *keywords, enum mail_flags flags)
+{
+	struct act_store_transaction *trans = 
+		(struct act_store_transaction *) tr_context;
+
+	/* Assign mail keywords for subsequent mailbox_copy() */
+	if ( *keywords != NULL ) {
+		const char *const *kw;
+
+		if ( !array_is_created(&trans->keywords) ) {
+			pool_t pool = sieve_result_pool(aenv->result); 
+			p_array_init(&trans->keywords, pool, 2);
+		}
+		
+		kw = keywords;
+		while ( *kw != NULL ) {
+
+			const char *kw_error;
+
+			if ( trans->box != NULL ) {
+				if ( mailbox_keyword_is_valid(trans->box, *kw, &kw_error) )
+					array_append(&trans->keywords, kw, 1);
+				else {
+					char *error = "";
+					if ( kw_error != NULL && *kw_error != '\0' ) {
+						error = t_strdup_noconst(kw_error);
+						error[0] = i_tolower(error[0]);
+					}
+				
+					sieve_result_warning(aenv, 
+						"specified IMAP keyword '%s' is invalid (ignored): %s", 
+						str_sanitize(*kw, 64), error);
+				}
+			}
+
+			kw++;
+		}
+	}
+
+	/* Assign mail flags for subsequent mailbox_copy() */
+	trans->flags |= flags;
+
+	trans->flags_altered = TRUE;
+}
+
+void sieve_act_store_get_storage_error
+(const struct sieve_action_exec_env *aenv, struct act_store_transaction *trans)
+{
+	pool_t pool = sieve_result_pool(aenv->result);
+	
+	trans->error = p_strdup(pool, 
+		mail_storage_get_last_error(trans->namespace->storage, &trans->error_code));
+}
+
+
+/* Equality */
+
+static bool act_store_equals
+(const struct sieve_script_env *senv, const void *ctx1, const void *ctx2)
+{
+	struct act_store_context *st_ctx1 = (struct act_store_context *) ctx1;
+	struct act_store_context *st_ctx2 = (struct act_store_context *) ctx2;
+	const char *mailbox1, *mailbox2;
+	
+	/* FIXME: consider namespace aliases */
+
+	if ( st_ctx1 == NULL && st_ctx2 == NULL )
+		return TRUE;
+		
+	mailbox1 = ( st_ctx1 == NULL ? 
+		SIEVE_SCRIPT_DEFAULT_MAILBOX(senv) : st_ctx1->mailbox );
+	mailbox2 = ( st_ctx2 == NULL ? 
+		SIEVE_SCRIPT_DEFAULT_MAILBOX(senv) : st_ctx2->mailbox );
+	
+	if ( strcmp(mailbox1, mailbox2) == 0 ) 
+		return TRUE;
+		
+	return 
+		( strcasecmp(mailbox1, "INBOX") == 0 && strcasecmp(mailbox2, "INBOX") == 0 ); 
+
+}
+
+/* Result verification */
+
+static int act_store_check_duplicate
+(const struct sieve_runtime_env *renv,
+	const struct sieve_action_data *act, 
+	const struct sieve_action_data *act_other)
+{
+	return ( act_store_equals(renv->scriptenv, act->context, act_other->context)
+		? 1 : 0 );
+}
+
+/* Result printing */
+
+static void act_store_print
+(const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_result_print_env *rpenv, void *context, bool *keep)	
+{
+	struct act_store_context *ctx = (struct act_store_context *) context;
+	const char *mailbox;
+
+	mailbox = ( ctx == NULL ? 
+		SIEVE_SCRIPT_DEFAULT_MAILBOX(rpenv->scriptenv) : ctx->mailbox );	
+
+	sieve_result_action_printf(rpenv, "store message in folder: %s", 
+		str_sanitize(mailbox, 128));
+	
+	*keep = FALSE;
+}
+
+/* Action implementation */
+
+static struct mailbox *act_store_mailbox_open
+(const struct sieve_action_exec_env *aenv, const char **mailbox,
+	struct mail_namespace **ns_r, const char **folder_r)
+{
+	struct mail_storage **storage = &(aenv->exec_status->last_storage);
+	enum mailbox_open_flags open_flags = 
+		MAILBOX_OPEN_FAST | MAILBOX_OPEN_KEEP_RECENT | 
+		MAILBOX_OPEN_SAVEONLY | MAILBOX_OPEN_POST_SESSION;
+	struct mailbox *box;
+	enum mail_error error;
+
+	if (strcasecmp(*mailbox, "INBOX") == 0) {
+		/* Deliveries to INBOX must always succeed, regardless of ACLs */
+		open_flags |= MAILBOX_OPEN_IGNORE_ACLS;
+	}
+
+	*folder_r = *mailbox;
+	*ns_r = mail_namespace_find(aenv->scriptenv->namespaces, folder_r);
+	if ( *ns_r == NULL) {
+		*storage = NULL;
+		return NULL;
+	}
+
+	*storage = (*ns_r)->storage;
+
+	if ( **folder_r == '\0' ) {
+		/* Delivering to a namespace prefix means we actually want to
+		 * deliver to the INBOX instead 
+		 */
+		*folder_r = *mailbox = "INBOX";
+		open_flags |= MAILBOX_OPEN_IGNORE_ACLS;
+
+		*ns_r = mail_namespace_find(aenv->scriptenv->namespaces, folder_r);
+		if ( *ns_r == NULL) {
+			*storage = NULL;
+			return NULL;
+		}
+
+		*storage = (*ns_r)->storage;
+	}
+
+	box = mailbox_open(storage, *folder_r, NULL, open_flags);
+		
+	if ( box == NULL && aenv->scriptenv->mailbox_autocreate ) {	
+		(void)mail_storage_get_last_error(*storage, &error);
+		if ( error != MAIL_ERROR_NOTFOUND )
+			return NULL;
+
+		/* Try creating it */
+		if ( mail_storage_mailbox_create(*storage, *folder_r, FALSE) < 0 )
+			return NULL;
+   
+		if ( aenv->scriptenv->mailbox_autosubscribe ) {
+			/* Subscribe to it */
+			(void)mailbox_list_set_subscribed((*ns_r)->list, *folder_r, TRUE);
+		}
+
+		/* Try opening again */
+		box = mailbox_open(storage, *folder_r, NULL, open_flags);
+    
+		if (box == NULL)
+			return NULL;
+
+		if (mailbox_sync(box, 0, 0, NULL) < 0) {
+			mailbox_close(&box);
+			return NULL;
+		}
+	}
+
+	return box;
+}
+
+static bool act_store_start
+(const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_action_exec_env *aenv, void *context, void **tr_context)
+{  
+	struct act_store_context *ctx = (struct act_store_context *) context;
+	const struct sieve_script_env *senv = aenv->scriptenv;
+	const struct sieve_message_data *msgdata = aenv->msgdata;
+	struct act_store_transaction *trans;
+	struct mail_namespace *ns = NULL;
+	struct mailbox *box = NULL;
+	const char *folder;
+	pool_t pool = sieve_result_pool(aenv->result);
+	bool disabled = FALSE, redundant = FALSE;
+
+	/* If context is NULL, the store action is the result of (implicit) keep */	
+	if ( ctx == NULL ) {
+		ctx = p_new(pool, struct act_store_context, 1);
+		ctx->mailbox = p_strdup(pool, SIEVE_SCRIPT_DEFAULT_MAILBOX(senv));
+	}
+
+	/* Open the requested mailbox */
+
+	/* NOTE: The caller of the sieve library is allowed to leave namespaces set 
+	 * to NULL. This implementation will then skip actually storing the message.
+	 */
+	if ( senv->namespaces != NULL ) {
+		box = act_store_mailbox_open(aenv, &ctx->mailbox, &ns, &folder);
+
+		/* Check whether we are trying to store the message in the folder it
+		 * originates from. In that case we skip actually storing it.
+	   */
+		if ( box != NULL && mailbox_backends_equal(box, msgdata->mail->box) ) {
+			mailbox_close(&box);
+			box = NULL;
+			ns = NULL;
+			redundant = TRUE;		
+		}
+	} else {
+		disabled = TRUE;
+	}
+				
+	/* Create transaction context */
+	trans = p_new(pool, struct act_store_transaction, 1);
+
+	trans->context = ctx;
+	trans->namespace = ns;
+	trans->folder = folder;
+	trans->box = box;
+	trans->flags = 0;
+
+	trans->disabled = disabled;
+	trans->redundant = redundant;
+		
+	if ( ns != NULL && box == NULL ) 
+		sieve_act_store_get_storage_error(aenv, trans);	
+	
+	*tr_context = (void *)trans;
+
+	return ( (box != NULL) 
+		|| (trans->error_code == MAIL_ERROR_NOTFOUND) 
+		|| disabled || redundant );
+}
+
+static struct mail_keywords *act_store_keywords_create
+(const struct sieve_action_exec_env *aenv, ARRAY_TYPE(const_string) *keywords, 
+	struct mailbox *box)
+{
+	struct mail_keywords *box_keywords = NULL;
+	
+	if ( array_is_created(keywords) && array_count(keywords) > 0 ) 
+	{
+		const char *const *kwds;
+		
+		(void)array_append_space(keywords);
+		kwds = array_idx(keywords, 0);
+				
+		/* FIXME: Do we need to clear duplicates? */
+		if ( mailbox_keywords_create(box, kwds, &box_keywords) < 0) {
+			sieve_result_error(aenv, "invalid keywords set for stored message");
+			return NULL;
+		}
+	}
+
+	return box_keywords;	
+}
+
+static bool act_store_execute
+(const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_action_exec_env *aenv, void *tr_context)
+{   
+	struct act_store_transaction *trans = 
+		(struct act_store_transaction *) tr_context;
+	const struct sieve_message_data *msgdata = aenv->msgdata;
+	struct mail_save_context *save_ctx;
+	struct mail_keywords *keywords = NULL;
+	bool result = TRUE;
+	
+	/* Verify transaction */
+	if ( trans == NULL ) return FALSE;
+
+	/* Check whether we need to do anything */
+	if ( trans->disabled ) return TRUE;
+
+	/* If the message originates from the target mailbox, only update the flags 
+	 * and keywords 
+	 */
+	if ( trans->redundant ) {
+		if ( trans->flags_altered ) {
+			keywords = act_store_keywords_create
+				(aenv, &trans->keywords, msgdata->mail->box);
+
+			if ( keywords != NULL ) {
+				mail_update_keywords(msgdata->mail, MODIFY_REPLACE, keywords);
+				mailbox_keywords_free(trans->box, &keywords);
+			}
+
+			mail_update_flags(msgdata->mail, MODIFY_REPLACE, trans->flags);
+		}
+
+		return TRUE;
+	}
+
+	/* Exit early if namespace or mailbox are not available */
+	if ( trans->namespace == NULL )
+		return FALSE;
+	else if ( trans->box == NULL ) 
+		return FALSE;
+
+	/* Mark attempt to store in default mailbox */
+	if ( strcmp(trans->context->mailbox, 
+		SIEVE_SCRIPT_DEFAULT_MAILBOX(aenv->scriptenv)) == 0 ) 
+		aenv->exec_status->tried_default_save = TRUE;
+
+	/* Mark attempt to use storage. Can only get here when all previous actions
+	 * succeeded. 
+	 */
+	aenv->exec_status->last_storage = trans->namespace->storage;
+	
+	/* Start mail transaction */
+	trans->mail_trans = mailbox_transaction_begin
+		(trans->box, MAILBOX_TRANSACTION_FLAG_EXTERNAL);
+
+	/* Create mail object for stored message */
+	trans->dest_mail = mail_alloc(trans->mail_trans, 0, NULL);
+ 
+	/* Store the message */
+	save_ctx = mailbox_save_alloc(trans->mail_trans);
+	mailbox_save_set_dest_mail(save_ctx, trans->dest_mail);
+
+	/* Apply keywords and flags that side-effects may have added */
+	if ( trans->flags_altered ) {
+		keywords = act_store_keywords_create(aenv, &trans->keywords, trans->box);
+		
+		mailbox_save_set_flags(save_ctx, trans->flags, keywords);
+	}
+
+	if ( mailbox_copy(&save_ctx, aenv->msgdata->mail) < 0 ) {
+		sieve_act_store_get_storage_error(aenv, trans);
+ 		result = FALSE;
+ 	}
+ 	
+	/* Deallocate keywords */
+ 	if ( keywords != NULL ) {
+ 		mailbox_keywords_free(trans->box, &keywords);
+ 	}
+ 		 	
+	return result;
+}
+
+static void act_store_log_status
+(struct act_store_transaction *trans, 
+	const struct sieve_action_exec_env *aenv, bool rolled_back, bool status )
+{
+	const char *mailbox_name;
+	
+	mailbox_name = str_sanitize(trans->context->mailbox, 128);
+
+	/* Store disabled? */
+	if ( trans->disabled ) {
+		sieve_result_log(aenv, "store into mailbox '%s' skipped", mailbox_name);
+	
+	/* Store redundant? */
+	} else if ( trans->redundant ) {
+		sieve_result_log(aenv, "left message in mailbox '%s'", mailbox_name);
+
+	/* Namespace not set? */
+	} else if ( trans->namespace == NULL ) {
+		sieve_result_error
+			(aenv, "failed to find namespace for mailbox '%s'", mailbox_name);
+
+	/* Store failed? */
+	} else if ( !status ) {
+		const char *errstr;
+		enum mail_error error;
+
+		if ( trans->error != NULL )
+			errstr = trans->error;
+		else
+			errstr = mail_storage_get_last_error(trans->namespace->storage, &error);
+	
+		sieve_result_error(aenv, "failed to store into mailbox '%s': %s", 
+			mailbox_name, errstr);
+
+	/* Store aborted? */
+	} else if ( rolled_back ) {
+		sieve_result_log(aenv, "store into mailbox '%s' aborted", mailbox_name);
+
+	/* Succeeded */
+	} else {
+		sieve_result_log(aenv, "stored mail into mailbox '%s'", mailbox_name);
+
+	}
+}
+
+static bool act_store_commit
+(const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_action_exec_env *aenv, void *tr_context, bool *keep)
+{  
+	struct act_store_transaction *trans = 
+		(struct act_store_transaction *) tr_context;
+	bool status = TRUE;
+
+	/* Verify transaction */
+	if ( trans == NULL ) return FALSE;
+
+	/* Check whether we need to do anything */
+	if ( trans->disabled ) {
+		act_store_log_status(trans, aenv, FALSE, status);
+		*keep = FALSE;
+		return TRUE;
+	} else if ( trans->redundant ) {
+		act_store_log_status(trans, aenv, FALSE, status);
+		aenv->exec_status->keep_original = TRUE;
+		aenv->exec_status->message_saved = TRUE;
+		return TRUE;	
+	}
+
+	/* Exit early if namespace is not available */
+	if ( trans->namespace == NULL )
+		return FALSE;
+	else if ( trans->box == NULL ) 
+		return FALSE;
+
+	/* Mark attempt to use storage. Can only get here when all previous actions
+	 * succeeded. 
+	 */
+	aenv->exec_status->last_storage = trans->namespace->storage;
+
+	/* Free mail object for stored message */
+	if ( trans->dest_mail != NULL ) 
+		mail_free(&trans->dest_mail);	
+
+	/* Commit mailbox transaction */	
+	status = ( mailbox_transaction_commit(&trans->mail_trans) == 0 );
+
+	/* Note the fact that the message was stored at least once */
+	if ( status )
+		aenv->exec_status->message_saved = TRUE;
+	
+	/* Log our status */
+	act_store_log_status(trans, aenv, FALSE, status);
+	
+	/* Cancel implicit keep if all went well */
+	*keep = !status;
+	
+	/* Close mailbox */	
+	if ( trans->box != NULL )
+		mailbox_close(&trans->box);
+
+	return status;
+}
+
+static void act_store_rollback
+(const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_action_exec_env *aenv, void *tr_context, bool success)
+{
+	struct act_store_transaction *trans = 
+		(struct act_store_transaction *) tr_context;
+
+	/* Log status */
+	act_store_log_status(trans, aenv, TRUE, success);
+
+	/* Free mailobject for stored message */
+	if ( trans->dest_mail != NULL ) 
+		mail_free(&trans->dest_mail);	
+
+	/* Rollback mailbox transaction */
+	if ( trans->mail_trans != NULL )
+		mailbox_transaction_rollback(&trans->mail_trans);
+  
+	/* Close the mailbox */
+	if ( trans->box != NULL )  
+		mailbox_close(&trans->box);
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-actions.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-actions.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-actions.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-actions.h	2009-08-05 12:43:18.000000000 +0200
@@ -0,0 +1,226 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+
+#ifndef __SIEVE_ACTIONS_H
+#define __SIEVE_ACTIONS_H
+
+#include "lib.h"
+#include "mail-storage.h"
+
+#include "sieve-common.h"
+#include "sieve-objects.h"
+#include "sieve-extensions.h"
+
+/*
+ * Action execution environment
+ */
+
+struct sieve_action_exec_env { 
+	struct sieve_result *result;
+	const struct sieve_message_data *msgdata;
+	struct sieve_message_context *msgctx;
+	const struct sieve_script_env *scriptenv;
+	struct sieve_exec_status *exec_status;
+};
+
+const char *sieve_action_get_location(const struct sieve_action_exec_env *aenv);
+
+/*
+ * Action flags
+ */
+
+enum sieve_action_flags {
+	SIEVE_ACTFLAG_TRIES_DELIVER = (1 << 0),
+	SIEVE_ACTFLAG_SENDS_RESPONSE = (1 << 1)
+};
+
+/*
+ *
+ */
+ 
+struct sieve_action_data {
+	const struct sieve_action *action;
+	const char *location;
+	void *context;
+	bool executed;
+};
+
+/* 
+ * Action object
+ */
+
+struct sieve_action {
+	const char *name;
+	unsigned int flags;
+	
+	bool (*equals)
+		(const struct sieve_script_env *senv, const void *ctx1, const void *ctx2);
+
+	/* Result verification */
+	
+	int (*check_duplicate)	
+		(const struct sieve_runtime_env *renv,
+			const struct sieve_action_data *act, 
+			const struct sieve_action_data *act_other);	
+	int (*check_conflict)
+		(const struct sieve_runtime_env *renv, 
+			const struct sieve_action_data *act, 
+			const struct sieve_action_data *act_other);	
+
+	/* Result printing */
+	
+	void (*print)
+		(const struct sieve_action *action, 
+			const struct sieve_result_print_env *penv, void *context, bool *keep);	
+		
+	/* Result execution */	
+		
+	bool (*start)
+		(const struct sieve_action *action, 
+			const struct sieve_action_exec_env *aenv, void *context, 
+			void **tr_context);		
+	bool (*execute)
+		(const struct sieve_action *action, 
+			const struct sieve_action_exec_env *aenv, void *tr_context);
+	bool (*commit)
+		(const struct sieve_action *action, 
+			const struct sieve_action_exec_env *aenv, void *tr_context, bool *keep);
+	void (*rollback)
+		(const struct sieve_action *action, 
+			const struct sieve_action_exec_env *aenv, void *tr_context, bool success);
+};
+
+/* 
+ * Action side effects 
+ */
+
+/* Side effect object */
+
+struct sieve_side_effect {
+	struct sieve_object object;
+	
+	/* The action it is supposed to link to */
+	
+	const struct sieve_action *to_action;
+		
+	/* Context coding */
+	
+	bool (*dump_context)
+		(const struct sieve_side_effect *seffect, 
+			const struct sieve_dumptime_env *renv, sieve_size_t *address);
+	bool (*read_context)
+		(const struct sieve_side_effect *seffect, 
+			const struct sieve_runtime_env *renv, sieve_size_t *address,
+			void **se_context);
+		
+	/* Result verification */
+	
+	int (*merge)
+		(const struct sieve_runtime_env *renv, const struct sieve_action *action, 
+			const struct sieve_side_effect *seffect, 
+			void **old_context, void *new_context);
+
+	/* Result printing */	
+			
+	void (*print)
+		(const struct sieve_side_effect *seffect, const struct sieve_action *action, 
+			const struct sieve_result_print_env *penv, void *se_context, bool *keep);
+
+	/* Result execution */
+
+	bool (*pre_execute)
+		(const struct sieve_side_effect *seffect, const struct sieve_action *action, 
+			const struct sieve_action_exec_env *aenv, void **se_context, 
+			void *tr_context);
+	bool (*post_execute)
+		(const struct sieve_side_effect *seffect, const struct sieve_action *action, 
+			const struct sieve_action_exec_env *aenv, void *se_context, 
+			void *tr_context);
+	void (*post_commit)
+		(const struct sieve_side_effect *seffect, const struct sieve_action *action, 
+			const struct sieve_action_exec_env *aenv, void *se_context,
+			void *tr_context, bool *keep);
+	void (*rollback)
+		(const struct sieve_side_effect *seffect, const struct sieve_action *action, 
+			const struct sieve_action_exec_env *aenv, void *se_context,
+			void *tr_context, bool success);
+};
+
+/*
+ * Side effect operand
+ */
+ 
+#define SIEVE_EXT_DEFINE_SIDE_EFFECT(SEF) SIEVE_EXT_DEFINE_OBJECT(SEF)
+#define SIEVE_EXT_DEFINE_SIDE_EFFECTS(SEFS) SIEVE_EXT_DEFINE_OBJECTS(SEFS)
+
+#define SIEVE_OPT_SIDE_EFFECT (-1)
+
+extern const struct sieve_operand_class sieve_side_effect_operand_class;
+
+static inline void sieve_opr_side_effect_emit
+(struct sieve_binary *sbin, const struct sieve_side_effect *seff)
+{ 
+	sieve_opr_object_emit(sbin, &seff->object);
+}
+
+static inline const struct sieve_side_effect *sieve_opr_side_effect_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	return (const struct sieve_side_effect *) sieve_opr_object_read
+		(renv, &sieve_side_effect_operand_class, address);
+}
+
+bool sieve_opr_side_effect_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+
+/* 
+ * Core actions 
+ */
+
+extern const struct sieve_action act_redirect;
+extern const struct sieve_action act_store;
+extern const struct sieve_action act_discard;
+
+/* 
+ * Store action
+ */
+
+struct act_store_context {
+	/* Folder name represented in modified utf-7 */
+	const char *mailbox; 
+};
+
+struct act_store_transaction {
+	struct act_store_context *context;
+	struct mail_namespace *namespace;
+	struct mailbox *box;
+	struct mailbox_transaction_context *mail_trans;
+	struct mail *dest_mail;
+
+	const char *folder;
+
+	const char *error;
+	enum mail_error error_code;
+	
+	enum mail_flags flags;
+	ARRAY_TYPE(const_string) keywords;
+
+	unsigned int flags_altered:1;
+	unsigned int disabled:1;
+	unsigned int redundant:1;
+};
+
+int sieve_act_store_add_to_result
+	(const struct sieve_runtime_env *renv, 
+		struct sieve_side_effects_list *seffects, const char *mailbox,
+		unsigned int source_line);
+
+void sieve_act_store_add_flags
+	(const struct sieve_action_exec_env *aenv, void *tr_context,
+		const char *const *keywords, enum mail_flags flags);
+
+void sieve_act_store_get_storage_error
+	(const struct sieve_action_exec_env *aenv, 
+		struct act_store_transaction *trans);
+		
+#endif /* __SIEVE_ACTIONS_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-address.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-address.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-address.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-address.c	2009-07-21 00:34:04.000000000 +0200
@@ -0,0 +1,785 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+ 
+#include "lib.h"
+#include "str.h"
+#include "str-sanitize.h"
+#include "rfc822-parser.h"
+
+#include "sieve-common.h"
+#include "sieve-address.h"
+
+#include <ctype.h>
+
+/*
+ * RFC 2822 addresses
+ */
+
+/* Mail message address according to RFC 2822 and implemented in the Dovecot 
+ * message address parser:
+ *
+ *   address         =       mailbox / group
+ *   mailbox         =       name-addr / addr-spec
+ *   name-addr       =       [display-name] angle-addr
+ *   angle-addr      =       [CFWS] "<" addr-spec ">" [CFWS] / obs-angle-addr
+ *   group           =       display-name ":" [mailbox-list / CFWS] ";" [CFWS]
+ *   display-name    =       phrase
+ *
+ *   addr-spec       =       local-part "@" domain
+ *   local-part      =       dot-atom / quoted-string / obs-local-part
+ *   domain          =       dot-atom / domain-literal / obs-domain
+ *   domain-literal  =       [CFWS] "[" *([FWS] dcontent) [FWS] "]" [CFWS]
+ *   dcontent        =       dtext / quoted-pair
+ *   dtext           =       NO-WS-CTL /     ; Non white space controls
+ *                           %d33-90 /       ; The rest of the US-ASCII
+ *                           %d94-126        ;  characters not including "[",
+ *                                           ;  "]", or "\"
+ *
+ *   atext           =       ALPHA / DIGIT / ; Any character except controls,
+ *                           "!" / "#" /     ;  SP, and specials.
+ *                           "$" / "%" /     ;  Used for atoms
+ *                           "&" / "'" /
+ *                           "*" / "+" /
+ *                           "-" / "/" /
+ *                           "=" / "?" /
+ *                           "^" / "_" /
+ *                           "`" / "{" /
+ *                           "|" / "}" /
+ *                           "~"
+ *   atom            =       [CFWS] 1*atext [CFWS]
+ *   dot-atom        =       [CFWS] dot-atom-text [CFWS]
+ *   dot-atom-text   =       1*atext *("." 1*atext)
+ *   word            =       atom / quoted-string
+ *   phrase          =       1*word / obs-phrase
+ *
+ * Message address specification as allowed bij the RFC 5228 SIEVE 
+ * specification:
+ *   sieve-address   =       addr-spec                  ; simple address
+ *                           / phrase "<" addr-spec ">" ; name & addr-spec\
+ *
+ * Which concisely is about equal to:
+ *   sieve-address   =       mailbox
+ */ 
+
+/*
+ * Address parse context
+ */
+ 
+struct sieve_message_address_parser {
+	struct rfc822_parser_context parser;
+
+	string_t *str;
+	string_t *local_part;
+	string_t *domain;
+	
+	string_t *error;
+};
+
+/*
+ * Error handling
+ */
+
+static inline void sieve_address_error
+	(struct sieve_message_address_parser *ctx, const char *fmt, ...) 
+		ATTR_FORMAT(2, 3);
+
+static inline void sieve_address_error
+	(struct sieve_message_address_parser *ctx, const char *fmt, ...)
+{
+	va_list args;
+	
+	if ( str_len(ctx->error) == 0 ) {
+		va_start(args, fmt);
+		str_vprintfa(ctx->error, fmt, args);
+		va_end(args);
+	}
+}
+
+/*
+ * Partial RFC 2822 address parser
+ *
+ *   FIXME: lots of overlap with dovecot/src/lib-mail/message-parser.c
+ *          --> this implementation adds textual error reporting
+ *          MERGE!
+ */
+	
+static int parse_local_part(struct sieve_message_address_parser *ctx)
+{
+	int ret;
+
+	/*
+	   local-part      = dot-atom / quoted-string / obs-local-part
+	   obs-local-part  = word *("." word)
+	*/
+	if (ctx->parser.data == ctx->parser.end) {
+		sieve_address_error(ctx, "empty local part");
+		return -1;
+	}
+
+	str_truncate(ctx->local_part, 0);
+	if (*ctx->parser.data == '"')
+		ret = rfc822_parse_quoted_string(&ctx->parser, ctx->local_part);
+	else
+		ret = rfc822_parse_dot_atom(&ctx->parser, ctx->local_part);
+		
+	if (ret < 0) {
+		sieve_address_error(ctx, "invalid local part");
+		return -1;
+	}
+
+	return ret;
+}
+
+static int parse_domain(struct sieve_message_address_parser *ctx)
+{
+	int ret;
+
+	str_truncate(ctx->domain, 0);
+	if ((ret = rfc822_parse_domain(&ctx->parser, ctx->domain)) < 0) {
+		sieve_address_error(ctx, "invalid or missing domain");
+		return -1;
+	}
+
+	return ret;
+}
+
+static int parse_addr_spec(struct sieve_message_address_parser *ctx)
+{
+	/* addr-spec       = local-part "@" domain */
+	int ret;
+
+	if ((ret = parse_local_part(ctx)) < 0)
+		return ret;
+	
+	if ( ret > 0 && *ctx->parser.data == '@') {
+		return parse_domain(ctx);
+	} 
+
+	sieve_address_error(ctx, "invalid or lonely local part '%s' (expecting '@')", 
+		str_sanitize(str_c(ctx->local_part), 80));
+	return -1;
+}
+
+static int parse_mailbox(struct sieve_message_address_parser *ctx)
+{
+	int ret;
+	const unsigned char *start;
+	
+	/* sieve-address   =       addr-spec                  ; simple address
+	 *                         / phrase "<" addr-spec ">" ; name & addr-spec
+	 */
+ 
+	/* Record parser state in case we fail at our first attempt */
+	start = ctx->parser.data;   
+ 
+	/* First try: phrase "<" addr-spec ">" ; name & addr-spec */	
+	str_truncate(ctx->str, 0);
+	if (rfc822_parse_phrase(&ctx->parser, ctx->str) <= 0 ||
+	    *ctx->parser.data != '<') {
+	  /* Failed; try just bare addr-spec */
+	  ctx->parser.data = start;
+	  return parse_addr_spec(ctx);
+	} 
+
+	/* "<" addr-spec ">" */
+	ctx->parser.data++;
+
+	if ((ret = rfc822_skip_lwsp(&ctx->parser)) <= 0 ) {
+		if ( ret < 0 )	
+			sieve_address_error(ctx, "invalid characters after <");		
+		return ret;
+	} 
+
+	if ((ret = parse_addr_spec(ctx)) < 0)
+		return -1;
+
+	if (*ctx->parser.data != '>') {
+		sieve_address_error(ctx, "missing '>'");
+		return -1;
+	}
+	ctx->parser.data++;
+
+	if ( (ret=rfc822_skip_lwsp(&ctx->parser)) < 0 )
+		sieve_address_error(ctx, "address ends with invalid characters");
+		
+	return ret;
+}
+
+static bool parse_mailbox_address
+(struct sieve_message_address_parser *ctx, const unsigned char *address, 
+	unsigned int addr_size)
+{
+	int ret;
+	
+	/* Initialize parser */
+	
+	rfc822_parser_init(&ctx->parser, address, addr_size, NULL);
+
+	/* Parse */
+	
+	rfc822_skip_lwsp(&ctx->parser);
+
+	if (ctx->parser.data == ctx->parser.end) {
+		sieve_address_error(ctx, "empty address");
+		return FALSE;
+	}
+	
+	if ((ret = parse_mailbox(ctx)) < 0) {
+		return FALSE;
+	}
+
+	if (ctx->parser.data != ctx->parser.end) {
+		if ( *ctx->parser.data == ',' ) 
+			sieve_address_error(ctx, "not a single addres (found ',')");
+		else
+			sieve_address_error(ctx, "address ends in invalid characters");
+		return FALSE;
+	}
+			
+	if ( str_len(ctx->domain) == 0 ) {
+		/* Not gonna happen */
+		sieve_address_error(ctx, "missing domain");
+		return FALSE;
+	}
+
+	if ( str_len(ctx->local_part) == 0 ) {
+		sieve_address_error(ctx, "missing local part");
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+/* FIXME: change the names of these functions */
+bool sieve_rfc2822_mailbox_validate(const char *address, const char **error_r)
+{
+	struct sieve_message_address_parser ctx;
+
+	if ( address == NULL ) {
+		*error_r = "null address";
+		return FALSE;
+	}
+
+	memset(&ctx, 0, sizeof(ctx));
+	
+	ctx.local_part = t_str_new(128);
+	ctx.domain = t_str_new(128);
+	ctx.str = t_str_new(128);
+	ctx.error = t_str_new(128);
+
+	if ( !parse_mailbox_address(&ctx, (const unsigned char *) address, 
+		strlen(address)) ) {
+		if ( error_r != NULL )	
+			*error_r = str_c(ctx.error);
+		return FALSE;
+	}
+
+	if ( error_r != NULL )
+		*error_r = NULL;
+
+	return TRUE;
+}
+
+const char *sieve_rfc2822_mailbox_normalize
+(const char *address, const char **error_r)
+{
+	struct sieve_message_address_parser ctx;
+
+	if ( error_r != NULL )
+		*error_r = NULL;
+
+	if ( address == NULL ) return NULL;
+
+	memset(&ctx, 0, sizeof(ctx));
+	
+	ctx.local_part = t_str_new(128);
+	ctx.domain = t_str_new(128);
+	ctx.str = t_str_new(128);
+	ctx.error = t_str_new(128);
+
+	if ( !parse_mailbox_address(&ctx, (const unsigned char *) address, 
+		strlen(address)) ) {
+		if ( error_r != NULL )	
+			*error_r = str_c(ctx.error);
+		return NULL;
+	}
+		
+	(void)str_lcase(str_c_modifiable(ctx.domain));
+
+	return t_strconcat(str_c(ctx.local_part), "@", str_c(ctx.domain), NULL);
+}
+
+/*
+ * Sieve address
+ */
+
+const char *sieve_address_normalize
+(string_t *address, const char **error_r)
+{
+	struct sieve_message_address_parser ctx;
+
+	memset(&ctx, 0, sizeof(ctx));
+	
+	ctx.local_part = t_str_new(128);
+	ctx.domain = t_str_new(128);
+	ctx.str = t_str_new(128);
+	ctx.error = t_str_new(128);
+
+	if ( !parse_mailbox_address(&ctx, str_data(address), str_len(address)) )
+	{
+		*error_r = str_c(ctx.error);
+		return NULL;
+	}
+	
+	*error_r = NULL;
+	(void)str_lcase(str_c_modifiable(ctx.domain));
+
+	return t_strconcat(str_c(ctx.local_part), "@", str_c(ctx.domain), NULL);
+}
+
+bool sieve_address_validate
+(string_t *address, const char **error_r)
+{
+	struct sieve_message_address_parser ctx;
+
+	memset(&ctx, 0, sizeof(ctx));
+
+	ctx.local_part = ctx.domain = ctx.str = t_str_new(128);
+	ctx.error = t_str_new(128);
+
+	if ( !parse_mailbox_address(&ctx, str_data(address), str_len(address)) )
+	{
+		*error_r = str_c(ctx.error);
+		return FALSE;
+	}
+	
+	*error_r = NULL;
+	return TRUE;
+}
+
+int sieve_address_compare
+(const char *address1, const char *address2, bool normalized ATTR_UNUSED)
+{
+	/* NOTE: this deviates from RFC specification in that it compares the local 
+	 * part of the address case-insensitively. This however conforms to the 
+	 * consensus in mail software.
+	 */
+	 
+	/* FIXME: provided addresses are currently assumed to be normalized to 
+	 * local_part@domain
+	 */
+
+	i_assert(address1 != NULL);
+	i_assert(address2 != NULL);
+	 
+	return strcasecmp(address1, address2);
+}
+
+/*
+ * RFC 2821 addresses (envelope paths)
+ */
+ 
+/* FIXME: Quite a bit of this will overlap with the rfc822 parser
+ * dovecot already has and the rfc2821 parser that it probably will
+ * have once it implements LMTP. For now we implement things separately. 
+ */
+
+#define AB (1<<0)
+#define DB (1<<1)
+#define QB (1<<2)
+
+/* atext = ALPHA / DIGIT / "!" / "#" / "$" / "%"
+ *         / "&" / "'" / "*" / "+" / "-" / "/" / "="
+ *         / "?" / "^" / "_" / "`" / "{" / "|" / "}" / "~" 
+ */
+//#define IS_ATEXT(C) ((rfc2821_chars[C] & AB) != 0) 
+
+/* dtext = NO-WS-CTL / %d33-90 / %d94-126 
+ * NO-WS-CTL = %d1-8 / %d11 / %d12 / %d14-31 / %d127 
+ */
+#define IS_DTEXT(C) ((rfc2821_chars[C] & DB) != 0) 
+
+/* qtext= NO-WS-CTL  / %d33 / %d35-91 / %d93-126 */
+#define IS_QTEXT(C) ((rfc2821_chars[C] & QB) == 0) 
+
+/* text	= %d1-9 / %d11 / %d12 / %d14-127 / obs-text*/
+#define IS_TEXT(C) ((C) != '\r' && (C) != '\n' && (C) < 128)
+
+static unsigned char rfc2821_chars[256] = {
+	   DB,    DB,    DB,    DB,    DB,    DB,    DB,    DB, // 0
+	   DB,    QB,    QB,    DB,    DB,    QB,    DB,    DB, // 8
+	   DB,    DB,    DB,    DB,    DB,    DB,    DB,    DB, // 16
+	   DB,    DB,    DB,    DB,    DB,    DB,    DB,    DB, // 24
+	   QB, DB|AB, QB|DB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, // 32
+	   DB,    DB, DB|AB, DB|AB,    DB, DB|AB,    DB, DB|AB, // 40
+	   DB,    DB,    DB,    DB,    DB,    DB,    DB,    DB, // 48
+	   DB,    DB,    DB,    DB,    DB, DB|AB,    DB, DB|AB, // 56
+	   DB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, // 64
+	DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, // 72
+	DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, // 80
+	DB|AB, DB|AB, DB|AB,     0,    QB,     0, DB|AB, DB|AB, // 88
+	DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, // 96
+	DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, // 104
+	DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, // 112
+	DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|QB, // 120
+
+	0, 0, 0, 0, 0, 0, 0, 0, // 128
+	0, 0, 0, 0, 0, 0, 0, 0, // 136
+	0, 0, 0, 0, 0, 0, 0, 0, // 144
+	0, 0, 0, 0, 0, 0, 0, 0, // 152
+	0, 0, 0, 0, 0, 0, 0, 0, // 160
+	0, 0, 0, 0, 0, 0, 0, 0, // 168
+	0, 0, 0, 0, 0, 0, 0, 0, // 176
+	0, 0, 0, 0, 0, 0, 0, 0, // 184
+	0, 0, 0, 0, 0, 0, 0, 0, // 192
+	0, 0, 0, 0, 0, 0, 0, 0, // 200
+	0, 0, 0, 0, 0, 0, 0, 0, // 208
+	0, 0, 0, 0, 0, 0, 0, 0, // 216
+	0, 0, 0, 0, 0, 0, 0, 0, // 224
+	0, 0, 0, 0, 0, 0, 0, 0, // 232
+	0, 0, 0, 0, 0, 0, 0, 0, // 240
+	0, 0, 0, 0, 0, 0, 0, 0, // 248
+
+};
+
+struct sieve_envelope_address_parser {
+	pool_t pool;
+
+	const unsigned char *data;
+	const unsigned char *end;
+
+	string_t *str;
+
+	struct sieve_address *address;
+};
+
+static int path_skip_white_space(struct sieve_envelope_address_parser *parser)
+{
+	/* Not mentioned anywhere in the specification, but we do it any way
+	 * (e.g. Exim does so too)
+	 */
+	while ( parser->data < parser->end && 
+		(*parser->data == ' ' || *parser->data == '\t') )
+		parser->data++;
+
+	return parser->data < parser->end;
+}
+
+static int path_skip_address_literal
+(struct sieve_envelope_address_parser *parser)
+{
+	int count = 0;
+
+	/* Currently we are oblivious to address syntax:
+	 * address-literal = "[" 1*dcontent "]"
+	 * dcontent	= dtext / quoted-pair
+	 */
+
+	i_assert ( *parser->data == '[' );
+
+	str_append_c(parser->str, *parser->data);
+	parser->data++;
+
+	while ( parser->data < parser->end ) {
+		if ( *parser->data == '\\' ) {
+			str_append_c(parser->str, *parser->data);
+			parser->data++;
+				
+			if ( parser->data < parser->end ) {
+				if ( !IS_TEXT(*parser->data) ) 
+					return -1;
+
+				str_append_c(parser->str, *parser->data);
+				parser->data++;
+			} else return -1;
+		} else {
+			if ( !IS_DTEXT(*parser->data) )
+				break;
+
+			str_append_c(parser->str, *parser->data);
+			parser->data++;
+		}
+
+		count++;
+	}
+
+		
+	if ( count == 0 || parser->data >= parser->end || *parser->data != ']' )
+		return -1;
+
+	str_append_c(parser->str, *parser->data);
+	parser->data++;
+
+	return parser->data < parser->end;
+}
+
+static int path_parse_domain
+(struct sieve_envelope_address_parser *parser, bool skip)
+{
+	int ret;
+
+	/* Domain = (sub-domain 1*("." sub-domain)) / address-literal
+	 * sub-domain = Let-dig [Ldh-str]
+	 * Let-dig = ALPHA / DIGIT
+	 * Ldh-str = *( ALPHA / DIGIT / "-" ) Let-dig
+	 */
+	
+	str_truncate(parser->str, 0);
+	if ( *parser->data == '[' ) {
+		ret = path_skip_address_literal(parser);
+
+		if ( ret < 0 ) return ret;
+	} else {
+		for (;;) {
+			if ( !i_isalnum(*parser->data) )
+				return -1;
+
+			str_append_c(parser->str, *parser->data);
+			parser->data++;
+
+			while ( parser->data < parser->end ) {
+				if ( !i_isalnum(*parser->data) && *parser->data != '-' )
+					break;
+
+				str_append_c(parser->str, *parser->data);
+				parser->data++;
+			}
+
+			if ( !i_isalnum(*(parser->data-1)) )
+				return -1;
+			
+			if ( (ret=path_skip_white_space(parser)) < 0 )
+				return ret;
+
+			if ( *parser->data != '.' )
+				break;
+
+			str_append_c(parser->str, *parser->data);
+			parser->data++;
+
+			if ( (ret=path_skip_white_space(parser)) <= 0 )
+				return -1;
+		}
+	}
+
+	if ( !skip )
+		parser->address->domain = p_strdup(parser->pool, str_c(parser->str));
+
+	return path_skip_white_space(parser);
+}
+
+static int path_skip_source_route(struct sieve_envelope_address_parser *parser)
+{
+	int ret;
+
+	/* Source-route = [ A-d-l ":" ] 
+	 * A-d-l = At-domain *( "," A-d-l )
+	 * At-domain = "@" domain
+	 */
+
+	if ( *parser->data == '@' ) {
+		parser->data++;
+	
+		for (;;) {
+			if ( (ret=path_skip_white_space(parser)) <= 0 )
+				return -1;	
+
+			if ( (ret=path_parse_domain(parser, TRUE)) <= 0 )
+				return -1;	
+
+			if ( (ret=path_skip_white_space(parser)) <= 0 )
+				return ret;
+
+			/* Next? */
+			if ( *parser->data != ',' )
+				break;
+			parser->data++;
+
+			if ( (ret=path_skip_white_space(parser)) <= 0 )
+				return -1;
+
+			if ( *parser->data != '@' )
+				return -1;
+			parser->data++;
+		}
+
+		if ( *parser->data != ':' )
+			return -1;
+		parser->data++;
+	}
+
+	return path_skip_white_space(parser);
+}
+
+static int path_parse_local_part(struct sieve_envelope_address_parser *parser)
+{
+	int ret;
+	/* Local-part = Dot-string / Quoted-string
+	 * Dot-string = Atom *("." Atom)
+	 * Atom = 1*atext
+	 * Quoted-string = DQUOTE *qcontent DQUOTE
+	 * qcontent = qtext / quoted-pair
+	 * quoted-pair  =   ("\" text)
+	 */
+
+	str_truncate(parser->str, 0);
+	if ( *parser->data == '"' ) {
+		str_append_c(parser->str, *parser->data);
+		parser->data++;
+
+		while ( parser->data < parser->end ) {
+			if ( *parser->data == '\\' ) {
+				str_append_c(parser->str, *parser->data);
+				parser->data++;
+
+				if ( parser->data < parser->end ) {
+					if ( !IS_TEXT(*parser->data) )
+						return -1;
+
+					str_append_c(parser->str, *parser->data);
+					parser->data++;
+				} else return -1;
+			} else {
+				if ( !IS_QTEXT(*parser->data) )
+					break;
+
+				str_append_c(parser->str, *parser->data);
+				parser->data++;
+			}
+		}
+		
+		if ( *parser->data != '"' )
+			return -1;
+
+		str_append_c(parser->str, *parser->data);
+		parser->data++;
+		
+		if ( (ret=path_skip_white_space(parser)) < 0 )
+			return ret;
+	} else {
+		for (;;) {
+			if ( !IS_ATEXT(*parser->data) ) 
+				return -1;
+			str_append_c(parser->str, *parser->data);
+			parser->data++;
+
+			while ( parser->data < parser->end && IS_ATEXT(*parser->data)) {
+				str_append_c(parser->str, *parser->data);
+				parser->data++;
+			}
+			
+			if ( (ret=path_skip_white_space(parser)) < 0 )
+				return ret;
+
+			if ( *parser->data != '.' )
+				break;
+
+			str_append_c(parser->str, *parser->data);
+				parser->data++;
+	
+			if ( (ret=path_skip_white_space(parser)) <= 0 )
+				return -1;
+		}
+	}
+
+	parser->address->local_part = p_strdup(parser->pool, str_c(parser->str));
+	return parser->data < parser->end;
+}
+
+static int path_parse_mailbox(struct sieve_envelope_address_parser *parser)
+{
+	int ret;
+
+	/* Mailbox = Local-part "@" Domain */
+	
+	if ( (ret=path_parse_local_part(parser)) <= 0 )
+		return -1;
+
+	if ( (ret=path_skip_white_space(parser)) <= 0 )
+		return -1;
+
+	if ( *parser->data != '@' )
+		return -1;
+	parser->data++;
+
+	if ( (ret=path_skip_white_space(parser)) <= 0 )
+		return -1;
+
+	return path_parse_domain(parser, FALSE);
+}
+
+static int path_parse(struct sieve_envelope_address_parser *parser)
+{
+	int ret;
+	bool brackets = FALSE;
+
+	/* Path = "<" [ A-d-l ":" ] Mailbox ">" */
+
+	if ( (ret=path_skip_white_space(parser)) <= 0 ) 
+		return ret;
+	
+	/* We allow angle brackets to be missing */
+	if ( *parser->data == '<' ) {
+		parser->data++;
+		brackets = TRUE;
+
+		if ( (ret=path_skip_white_space(parser)) <= 0 ) 
+			return -1;
+
+		/* Null path? */
+		if ( *parser->data == '>' ) {
+			parser->data++;
+			return path_skip_white_space(parser);
+		}
+	}
+
+	/*  [ A-d-l ":" ] Mailbox */
+	if ( (ret=path_skip_source_route(parser)) <= 0 )
+		return -1;
+
+	if ( (ret=path_parse_mailbox(parser)) < 0 )
+		return -1;
+
+	if ( ret > 0 && (ret=path_skip_white_space(parser)) < 0 ) 
+		return -1;
+
+	if ( brackets ) {
+		if ( ret <= 0 ) return -1;
+
+		if ( *parser->data != '>' )
+			return -1;
+		parser->data++;
+	}
+
+	return parser->data < parser->end;
+}
+
+const struct sieve_address *sieve_address_parse_envelope_path
+(pool_t pool, const char *field_value)
+{
+	struct sieve_envelope_address_parser parser;
+	int ret;
+
+	if ( field_value == NULL ) {
+		return p_new(pool, struct sieve_address, 1);
+	}
+
+	parser.pool = pool;
+	parser.data = (const unsigned char *) field_value;
+	parser.end = (const unsigned char *) field_value + strlen(field_value);
+	parser.address = p_new(pool, struct sieve_address, 1);
+	parser.str = t_str_new(256); /* IMPORTAINT: maintain datastack level */
+
+	if ( (ret=path_parse(&parser)) < 0 )
+		return NULL;
+	
+	if ( ret > 0 && path_skip_white_space(&parser) < 0 )
+		return NULL;
+
+	if ( parser.data != parser.end )
+		return NULL;
+
+	return parser.address;
+}
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-address.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-address.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-address.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-address.h	2009-07-21 00:26:19.000000000 +0200
@@ -0,0 +1,52 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+ 
+#ifndef __SIEVE_ADDRESS_H
+#define __SIEVE_ADDRESS_H
+ 
+#include "lib.h"
+#include "strfuncs.h"
+
+/*
+ * Generic address representation
+ */ 
+ 
+struct sieve_address {
+	const char *local_part;
+	const char *domain;
+};
+
+static inline const char *sieve_address_to_string(const struct sieve_address *address) 
+{
+    if ( address == NULL || address->local_part == NULL || address->domain == NULL )
+        return NULL;
+
+    return t_strconcat(address->local_part, "@", address->domain, NULL);
+}
+
+/* 
+ * RFC 2822 addresses
+ */ 
+
+bool sieve_rfc2822_mailbox_validate
+	(const char *address, const char **error_r);
+const char *sieve_rfc2822_mailbox_normalize
+	(const char *address, const char **error_r);
+
+
+const char *sieve_address_normalize
+	(string_t *address, const char **error_r);
+bool sieve_address_validate
+	(string_t *address, const char **error_r);
+	
+int sieve_address_compare
+	(const char *address1, const char *address2, bool normalized);
+
+/*
+ * RFC 2821 addresses (paths)
+ */
+
+const struct sieve_address *sieve_address_parse_envelope_path
+	(pool_t pool, const char *field_value);
+
+#endif
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-address-parts.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-address-parts.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-address-parts.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-address-parts.c	2009-04-10 14:10:55.000000000 +0200
@@ -0,0 +1,376 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+
+#include "lib.h"
+#include "compat.h"
+#include "mempool.h"
+#include "hash.h"
+#include "array.h"
+#include "message-address.h"
+
+#include "sieve-extensions.h"
+#include "sieve-code.h"
+#include "sieve-address.h"
+#include "sieve-commands.h"
+#include "sieve-binary.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+#include "sieve-address-parts.h"
+
+#include <string.h>
+
+/* 
+ * Default address parts
+ */
+
+const struct sieve_address_part *sieve_core_address_parts[] = {
+	&all_address_part, &local_address_part, &domain_address_part
+};
+
+const unsigned int sieve_core_address_parts_count = 
+	N_ELEMENTS(sieve_core_address_parts);
+
+/* 
+ * Address-part 'extension' 
+ */
+
+static int ext_my_id = -1;
+
+static bool addrp_validator_load(struct sieve_validator *validator);
+
+const struct sieve_extension address_part_extension = {
+	"@address-parts",
+	&ext_my_id,
+	NULL, NULL,
+	addrp_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_NO_OPERATIONS,
+	SIEVE_EXT_DEFINE_NO_OPERANDS /* Defined as core operand */
+};
+
+static const struct sieve_extension *ext_this = &address_part_extension;
+	
+/* 
+ * Validator context:
+ *   name-based address-part registry. 
+ */
+ 
+void sieve_address_part_register
+(struct sieve_validator *validator, const struct sieve_address_part *addrp) 
+{
+	struct sieve_validator_object_registry *regs = 
+		sieve_validator_object_registry_get(validator, ext_this);
+	
+	sieve_validator_object_registry_add(regs, &addrp->object);
+}
+
+const struct sieve_address_part *sieve_address_part_find
+(struct sieve_validator *validator, const char *identifier) 
+{
+	struct sieve_validator_object_registry *regs = 
+		sieve_validator_object_registry_get(validator, ext_this);
+	const struct sieve_object *object = 
+		sieve_validator_object_registry_find(regs, identifier);
+
+  return (const struct sieve_address_part *) object;
+}
+
+bool addrp_validator_load(struct sieve_validator *validator)
+{
+	struct sieve_validator_object_registry *regs = 
+		sieve_validator_object_registry_init(validator, ext_this);
+	unsigned int i;
+
+	/* Register core address-parts */
+	for ( i = 0; i < sieve_core_address_parts_count; i++ ) {
+		sieve_validator_object_registry_add
+			(regs, &(sieve_core_address_parts[i]->object));
+	}
+
+	return TRUE;
+}
+
+void sieve_address_parts_link_tags
+	(struct sieve_validator *validator, 
+		struct sieve_command_registration *cmd_reg, int id_code) 
+{	
+	sieve_validator_register_tag
+		(validator, cmd_reg, &address_part_tag, id_code); 	
+}
+
+/* 
+ * Address-part tagged argument 
+ */
+ 
+/* Forward declarations */
+
+static bool tag_address_part_is_instance_of
+	(struct sieve_validator *validator, struct sieve_command_context *cmd,
+		struct sieve_ast_argument *arg);
+static bool tag_address_part_validate
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+static bool tag_address_part_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+		struct sieve_command_context *cmd);
+
+/* Argument object */
+
+const struct sieve_argument address_part_tag = { 
+	"ADDRESS-PART",
+	tag_address_part_is_instance_of, 
+	NULL,
+	tag_address_part_validate,
+	NULL, 
+	tag_address_part_generate 
+};
+
+/* Argument implementation */
+  
+static bool tag_address_part_is_instance_of
+(struct sieve_validator *validator, struct sieve_command_context *cmd,
+	struct sieve_ast_argument *arg)
+{
+	struct sieve_address_part_context *adpctx;
+	const struct sieve_address_part *addrp = sieve_address_part_find
+		(validator, sieve_ast_argument_tag(arg));
+
+	if ( addrp == NULL ) return FALSE;
+
+	adpctx = p_new(sieve_command_pool(cmd), struct sieve_address_part_context, 1);
+	adpctx->command_ctx = cmd;
+	adpctx->address_part = addrp;
+
+	/* Store address-part in context */
+	arg->context = (void *) adpctx;
+
+	return TRUE;
+}
+ 
+static bool tag_address_part_validate
+(struct sieve_validator *validator ATTR_UNUSED, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd ATTR_UNUSED)
+{
+	/* FIXME: Currenly trivial, but might need to allow for further validation for
+	 * future extensions.
+	 */
+	 
+	/* Syntax:   
+	 *   ":localpart" / ":domain" / ":all" (subject to extension)
+   */
+	
+	/* Skip tag */
+	*arg = sieve_ast_argument_next(*arg);
+
+	return TRUE;
+}
+
+static bool tag_address_part_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+	struct sieve_command_context *cmd ATTR_UNUSED)
+{
+	struct sieve_address_part_context *adpctx =
+		(struct sieve_address_part_context *) arg->context;
+		
+	sieve_opr_address_part_emit(cgenv->sbin, adpctx->address_part); 
+		
+	return TRUE;
+}
+
+/*
+ * Address-part operand
+ */
+ 
+const struct sieve_operand_class sieve_address_part_operand_class = 
+	{ "address part" };
+
+static const struct sieve_extension_objects core_address_parts =
+	SIEVE_EXT_DEFINE_MATCH_TYPES(sieve_core_address_parts);
+
+const struct sieve_operand address_part_operand = { 
+	"address-part", 
+	NULL, SIEVE_OPERAND_ADDRESS_PART,
+	&sieve_address_part_operand_class,
+	&core_address_parts
+};
+
+/*
+ * Address Matching
+ */
+ 
+int sieve_address_match
+(const struct sieve_address_part *addrp, struct sieve_match_context *mctx, 		
+	const char *data)
+{
+	int result = FALSE;
+	const struct message_address *addr;
+
+	T_BEGIN {
+		bool valid = TRUE;
+		const struct message_address *aitem;
+
+		addr = message_address_parse
+			(pool_datastack_create(), (const unsigned char *) data, 
+				strlen(data), 256, FALSE);
+
+		/* Check validity of all addresses simultaneously. Unfortunately,
+		 * errorneous addresses cannot be extracted from the address list
+		 * and therefore :all will match against the whole header value
+		 * which is not entirely standard.
+		 */
+		aitem = addr;
+		while ( aitem != NULL) {
+			if ( aitem->invalid_syntax )
+				valid = FALSE;
+			aitem = aitem->next;
+		}
+
+		if ( !valid || addr == NULL ) {
+			if ( addrp == &all_address_part )
+				result = sieve_match_value(mctx, data, strlen(data));
+			else 
+				result = FALSE;
+		} else {
+			while ( result == 0 && addr != NULL) {
+				/* mailbox@domain */
+				struct sieve_address address;
+				const char *part;
+			
+				if ( addr->domain != NULL ) {
+					address.local_part = addr->mailbox;
+					address.domain = addr->domain;
+	
+					part = addrp->extract_from(&address);
+
+					if ( part != NULL )
+						result = sieve_match_value(mctx, part, strlen(part));
+				}
+				addr = addr->next;
+			}
+		}
+	} T_END;
+	
+	return result;
+}
+
+/* 
+ * Default ADDRESS-PART, MATCH-TYPE, COMPARATOR access
+ */
+ 
+bool sieve_addrmatch_default_dump_optionals
+(const struct sieve_dumptime_env *denv, sieve_size_t *address) 
+{
+	int opt_code = 1;
+	
+	if ( sieve_operand_optional_present(denv->sbin, address) ) {
+		while ( opt_code != 0 ) {
+			if ( !sieve_operand_optional_read(denv->sbin, address, &opt_code) ) 
+				return FALSE;
+
+			switch ( opt_code ) {
+			case 0:
+				break;
+			case SIEVE_AM_OPT_COMPARATOR:
+				if ( !sieve_opr_comparator_dump(denv, address) )
+					return FALSE;
+				break;
+			case SIEVE_AM_OPT_MATCH_TYPE:
+				if ( !sieve_opr_match_type_dump(denv, address) )
+					return FALSE;
+				break;
+			case SIEVE_AM_OPT_ADDRESS_PART:
+				if ( !sieve_opr_address_part_dump(denv, address) )
+					return FALSE;
+				break;
+			default:
+				return FALSE;
+			}
+		}
+	}
+	
+	return TRUE;
+}
+
+bool sieve_addrmatch_default_get_optionals
+(const struct sieve_runtime_env *renv, sieve_size_t *address, 
+	const struct sieve_address_part **addrp, const struct sieve_match_type **mtch, 
+	const struct sieve_comparator **cmp) 
+{
+	int opt_code = 1;
+	
+	
+	if ( sieve_operand_optional_present(renv->sbin, address) ) {
+		while ( opt_code != 0 ) {
+			if ( !sieve_operand_optional_read(renv->sbin, address, &opt_code) )
+				return FALSE;
+				  
+			switch ( opt_code ) {
+			case 0:
+				break;
+			case SIEVE_AM_OPT_COMPARATOR:
+				if ( (*cmp = sieve_opr_comparator_read(renv, address)) == NULL )
+					return FALSE;
+				break;
+			case SIEVE_AM_OPT_MATCH_TYPE:
+				if ( (*mtch = sieve_opr_match_type_read(renv, address)) == NULL )
+					return FALSE;
+				break;
+			case SIEVE_AM_OPT_ADDRESS_PART:
+				if ( (*addrp = sieve_opr_address_part_read(renv, address)) == NULL )
+					return FALSE;
+				break;
+			default:
+				return FALSE;
+			}
+		}
+	}
+	
+	return TRUE;
+}
+
+/* 
+ * Core address-part modifiers
+ */
+ 
+static const char *addrp_all_extract_from
+	(const struct sieve_address *address)
+{
+	const char *local_part = address->local_part;
+	const char *domain = address->domain;
+
+	return t_strconcat(local_part, "@", domain, NULL);
+}
+
+static const char *addrp_domain_extract_from
+	(const struct sieve_address *address)
+{
+	return address->domain;
+}
+
+static const char *addrp_localpart_extract_from
+	(const struct sieve_address *address)
+{
+	return address->local_part;
+}
+
+const struct sieve_address_part all_address_part = {
+	SIEVE_OBJECT("all", &address_part_operand, SIEVE_ADDRESS_PART_ALL),
+	addrp_all_extract_from
+};
+
+const struct sieve_address_part local_address_part = {
+	SIEVE_OBJECT("localpart", &address_part_operand, SIEVE_ADDRESS_PART_LOCAL),
+	addrp_localpart_extract_from
+};
+
+const struct sieve_address_part domain_address_part = {
+	SIEVE_OBJECT("domain", &address_part_operand,	SIEVE_ADDRESS_PART_DOMAIN),
+	addrp_domain_extract_from
+};
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-address-parts.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-address-parts.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-address-parts.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-address-parts.h	2009-02-24 13:39:14.000000000 +0100
@@ -0,0 +1,116 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+ 
+#ifndef __SIEVE_ADDRESS_PARTS_H
+#define __SIEVE_ADDRESS_PARTS_H
+
+#include "message-address.h"
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-objects.h"
+
+/*
+ * Address part object 
+ */
+
+struct sieve_address_part {
+	struct sieve_object object;		
+
+	const char *(*extract_from)(const struct sieve_address *address);
+};
+
+/*
+ * Core address parts
+ */
+ 
+enum sieve_address_part_code {
+	SIEVE_ADDRESS_PART_ALL,
+	SIEVE_ADDRESS_PART_LOCAL,
+	SIEVE_ADDRESS_PART_DOMAIN,
+	SIEVE_ADDRESS_PART_CUSTOM
+};
+
+extern const struct sieve_address_part all_address_part;
+extern const struct sieve_address_part local_address_part;
+extern const struct sieve_address_part domain_address_part;
+
+/*
+ * Address part tagged argument
+ */
+ 
+extern const struct sieve_argument address_part_tag;
+
+struct sieve_address_part_context {
+	struct sieve_command_context *command_ctx;
+	const struct sieve_address_part *address_part;
+};
+
+void sieve_address_parts_link_tags
+	(struct sieve_validator *validator, 
+		struct sieve_command_registration *cmd_reg, int id_code);
+
+/*
+ * Address part registry
+ */
+		
+void sieve_address_part_register
+	(struct sieve_validator *validator, 
+		const struct sieve_address_part *addrp);
+const struct sieve_address_part *sieve_address_part_find
+	(struct sieve_validator *validator, const char *identifier);
+		
+/*
+ * Address part operand
+ */
+
+extern const struct sieve_operand address_part_operand;
+extern const struct sieve_operand_class sieve_address_part_operand_class;
+
+#define SIEVE_EXT_DEFINE_ADDRESS_PART(OP) SIEVE_EXT_DEFINE_OBJECT(OP)
+#define SIEVE_EXT_DEFINE_ADDRESS_PARTS(OPS) SIEVE_EXT_DEFINE_OBJECTS(OPS)
+
+static inline void sieve_opr_address_part_emit
+(struct sieve_binary *sbin, const struct sieve_address_part *addrp)
+{ 
+	sieve_opr_object_emit(sbin, &addrp->object);
+}
+
+static inline const struct sieve_address_part *sieve_opr_address_part_read
+  (const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	return (const struct sieve_address_part *) sieve_opr_object_read
+		(renv, &sieve_address_part_operand_class, address);
+}
+
+static inline bool sieve_opr_address_part_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	return sieve_opr_object_dump
+		(denv, &sieve_address_part_operand_class, address, NULL);
+}
+
+/* 
+ * Match utility 
+ */
+
+int sieve_address_match
+(const struct sieve_address_part *addrp, struct sieve_match_context *mctx,
+    const char *data);
+
+enum sieve_addrmatch_opt_operand {
+	SIEVE_AM_OPT_END,
+	SIEVE_AM_OPT_COMPARATOR,
+	SIEVE_AM_OPT_ADDRESS_PART,
+	SIEVE_AM_OPT_MATCH_TYPE
+};
+
+bool sieve_addrmatch_default_dump_optionals
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+
+bool sieve_addrmatch_default_get_optionals
+	(const struct sieve_runtime_env *renv, sieve_size_t *address, 
+		const struct sieve_address_part **addp, 
+		const struct sieve_match_type **mtch, const struct sieve_comparator **cmp);
+
+#endif /* __SIEVE_ADDRESS_PARTS_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-ast.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-ast.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-ast.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-ast.c	2009-07-08 19:23:13.000000000 +0200
@@ -0,0 +1,1061 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#include "lib.h"
+#include "str.h"
+#include "mempool.h"
+#include "array.h"
+
+#include "sieve-common.h"
+#include "sieve-script.h"
+#include "sieve-extensions.h"
+
+#include "sieve-ast.h"
+
+#include <stdio.h>
+
+/* 
+ * Forward declarations 
+ */
+
+static struct sieve_ast_node *sieve_ast_node_create
+	(struct sieve_ast *ast, struct sieve_ast_node *parent, 
+		enum sieve_ast_type type, unsigned int source_line);
+
+/*
+ * Types
+ */
+
+/* Extensions to the AST */
+
+struct sieve_ast_extension_reg {
+	const struct sieve_ast_extension *ast_ext;
+	void *context;
+};
+
+/* 
+ * AST object 
+ */
+
+struct sieve_ast {
+	pool_t pool;
+	int refcount;
+		
+	struct sieve_script *script;
+		
+	struct sieve_ast_node *root;
+	
+	ARRAY_DEFINE(linked_extensions, const struct sieve_extension *);
+	ARRAY_DEFINE(extensions, struct sieve_ast_extension_reg);
+};
+
+struct sieve_ast *sieve_ast_create(struct sieve_script *script) 
+{
+	pool_t pool;
+	struct sieve_ast *ast;
+	
+	pool = pool_alloconly_create("sieve_ast", 16384);	
+	ast = p_new(pool, struct sieve_ast, 1);
+	ast->pool = pool;
+	ast->refcount = 1;
+	
+	ast->script = script;
+	sieve_script_ref(script);
+		
+	ast->root = sieve_ast_node_create(ast, NULL, SAT_ROOT, 0);
+	ast->root->identifier = "ROOT";
+	
+	p_array_init(&ast->linked_extensions, pool, sieve_extensions_get_count());
+	p_array_init(&ast->extensions, pool, sieve_extensions_get_count());
+	
+	return ast;
+}
+
+void sieve_ast_ref(struct sieve_ast *ast) 
+{
+	ast->refcount++;
+}
+
+void sieve_ast_unref(struct sieve_ast **ast) 
+{
+	unsigned int i, ext_count;
+	const struct sieve_ast_extension_reg *extrs;
+	
+	i_assert((*ast)->refcount > 0);
+
+	if (--(*ast)->refcount != 0)
+		return;
+	
+	/* Release script reference */
+	sieve_script_unref(&(*ast)->script);
+	
+	/* Signal registered extensions that the AST is being destroyed */
+	extrs = array_get(&(*ast)->extensions, &ext_count);
+	for ( i = 0; i < ext_count; i++ ) {
+		if ( extrs[i].ast_ext != NULL && 
+			extrs[i].ast_ext->free != NULL )
+			extrs[i].ast_ext->free(*ast, extrs[i].context);
+	}
+
+	/* Destroy AST */
+	pool_unref(&(*ast)->pool);
+	
+	*ast = NULL;
+}
+
+struct sieve_ast_node *sieve_ast_root(struct sieve_ast *ast)
+{
+	return ast->root;
+}
+
+pool_t sieve_ast_pool(struct sieve_ast *ast)
+{
+	return ast->pool;
+}
+
+struct sieve_script *sieve_ast_script(struct sieve_ast *ast)
+{
+	return ast->script;
+}
+
+/* 
+ * Extension support 
+ */
+
+void sieve_ast_extension_link
+(struct sieve_ast *ast, const struct sieve_extension *ext)
+{
+	int ext_id = SIEVE_EXT_ID(ext);
+	unsigned int i, ext_count;
+	const struct sieve_extension *const *extensions;
+	
+	if ( ext_id < 0 ) return;
+	 
+	/* Prevent duplicates */
+	extensions = array_get(&ast->linked_extensions, &ext_count);
+	for ( i = 0; i < ext_count; i++ ) {
+		if ( extensions[i] == ext )
+			return;
+	}
+
+	/* Add extension */
+	array_append(&ast->linked_extensions, &ext, 1);	
+}
+
+const struct sieve_extension * const *sieve_ast_extensions_get
+(struct sieve_ast *ast, unsigned int *count_r)
+{
+	return array_get(&ast->linked_extensions, count_r);
+}
+
+void sieve_ast_extension_register
+(struct sieve_ast *ast, const struct sieve_ast_extension *ast_ext, 
+	void *context)
+{
+	int ext_id = SIEVE_EXT_ID(ast_ext->ext);
+	struct sieve_ast_extension_reg reg;
+
+	if ( ext_id < 0 ) return;
+
+	/* Initialize registration */
+	reg.ast_ext = ast_ext;
+	reg.context = context;	
+	array_idx_set(&ast->extensions, (unsigned int) ext_id, &reg);
+}
+
+void *sieve_ast_extension_get_context
+(struct sieve_ast *ast, const struct sieve_extension *ext) 
+{
+	int ext_id = SIEVE_EXT_ID(ext);
+	const struct sieve_ast_extension_reg *reg;
+
+	if  ( ext_id < 0 || ext_id >= (int) array_count(&ast->extensions) )
+		return NULL;
+	
+	reg = array_idx(&ast->extensions, (unsigned int) ext_id);		
+
+	return reg->context;
+}
+
+/*
+ * AST list implementations
+ */
+ 
+/* Very simplistic linked list implementation
+ * FIXME: Move to separate file
+ */
+#define __LIST_CREATE(pool, type) { \
+		type *list = p_new(pool, type, 1); \
+		list->head = NULL; \
+		list->tail = NULL; \
+		list->len = 0;		\
+		return list; \
+	}
+
+#define __LIST_ADD(list, node) { \
+		if ( list->len + 1 < list->len ) \
+			return FALSE; \
+		\
+		node->next = NULL; \
+		if ( list->head == NULL ) { \
+			node->prev = NULL; \
+			list->head = node; \
+			list->tail = node; \
+		} else { \
+			list->tail->next = node; \
+			node->prev = list->tail; \
+			list->tail = node; \
+		} \
+		list->len++; \
+		node->list = list; \
+		return TRUE; \
+	}	 
+	
+#define __LIST_INSERT(list, before, node) { \
+		if ( list->len + 1 < list->len ) \
+			return FALSE; \
+		\
+		node->next = before; \
+		if ( list->head == before ) { \
+			node->prev = NULL; \
+			list->head = node; \
+		} else { \
+			before->prev->next = node; \
+		} \
+		node->prev = before->prev; \
+		before->prev = node; \
+		list->len++; \
+		node->list = list; \
+		\
+		return TRUE; \
+	}
+
+#define __LIST_JOIN(list, node_type, items) { \
+		node_type *node; \
+		\
+		if ( list->len + items->len < list->len ) \
+			return FALSE; \
+		\
+		if ( items->len == 0 ) return TRUE; \
+		\
+		if ( list->head == NULL ) { \
+			list->head = items->head; \
+			list->tail = items->tail; \
+		} else { \
+			list->tail->next = items->head; \
+			items->head->prev = list->tail; \
+			list->tail = items->tail; \
+		} \
+		list->len += items->len; \
+		\
+		node = items->head; \
+		while ( node != NULL ) { \
+			node->list = list; \
+			node = node->next; \
+		} \
+		return TRUE; \
+	}	 
+
+#define __LIST_DETACH(first, node_type, count) { \
+		node_type *last, *result; \
+		unsigned int left; \
+		\
+		i_assert(first->list != NULL); \
+		\
+		left = count - 1; \
+		last = first; \
+		while ( left > 0 && last->next != NULL ) { \
+			left--; \
+			last = last->next; \
+		} \
+		\
+		if ( first->list->head == first ) \
+			first->list->head = last->next; \
+		if ( first->list->tail == last ) \
+			first->list->tail = first->prev; \
+		\
+		if ( first->prev != NULL ) \
+			first->prev->next = last->next;	\
+		if ( last->next != NULL ) \
+			last->next->prev = first->prev; \
+		\
+		first->list->len -= count - left; \
+		\
+		result = last->next; \
+		first->prev = NULL; \
+		last->next = NULL; \
+		\
+		return result; \
+	}
+
+/* List of AST nodes */
+
+static struct sieve_ast_list *sieve_ast_list_create(pool_t pool) 
+	__LIST_CREATE(pool, struct sieve_ast_list)
+
+static bool sieve_ast_list_add
+(struct sieve_ast_list *list, struct sieve_ast_node *node) 
+	__LIST_ADD(list, node)
+
+static struct sieve_ast_node *sieve_ast_list_detach
+(struct sieve_ast_node *first, unsigned int count) 
+	__LIST_DETACH(first, struct sieve_ast_node, count)
+
+/* List of argument AST nodes */
+
+struct sieve_ast_arg_list *sieve_ast_arg_list_create(pool_t pool) 
+	__LIST_CREATE(pool, struct sieve_ast_arg_list)
+	
+bool sieve_ast_arg_list_add
+(struct sieve_ast_arg_list *list, struct sieve_ast_argument *argument)
+	__LIST_ADD(list, argument)
+
+bool sieve_ast_arg_list_insert
+(struct sieve_ast_arg_list *list, struct sieve_ast_argument *before,
+	struct sieve_ast_argument *argument)
+	__LIST_INSERT(list, before, argument)
+
+static bool sieve_ast_arg_list_join
+(struct sieve_ast_arg_list *list, struct sieve_ast_arg_list *items)
+	__LIST_JOIN(list, struct sieve_ast_argument, items)
+
+static struct sieve_ast_argument *sieve_ast_arg_list_detach
+(struct sieve_ast_argument *first, const unsigned int count)
+	__LIST_DETACH(first, struct sieve_ast_argument, count)
+
+void sieve_ast_arg_list_substitute
+(struct sieve_ast_arg_list *list, struct sieve_ast_argument *argument, 
+	struct sieve_ast_argument *replacement)
+{
+	if ( list->head == argument )
+		list->head = replacement;
+	if ( list->tail == argument )
+		list->tail = replacement;
+		
+	if ( argument->prev != NULL )
+		argument->prev->next = replacement;
+	if ( argument->next != NULL )
+		argument->next->prev = replacement;
+	
+	replacement->prev = argument->prev;
+	replacement->next = argument->next;
+	replacement->list = argument->list;
+	
+	argument->next = NULL;
+	argument->prev = NULL;
+}
+	
+/* 
+ * AST node 
+ */
+
+static struct sieve_ast_node *sieve_ast_node_create
+(struct sieve_ast *ast, struct sieve_ast_node *parent, enum sieve_ast_type type, 
+	unsigned int source_line) 
+{
+	struct sieve_ast_node *node = p_new(ast->pool, struct sieve_ast_node, 1);
+	
+	node->ast = ast;
+	node->parent = parent;
+	node->type = type;
+	
+	node->prev = NULL;
+	node->next = NULL;
+	
+	node->arguments = NULL;
+	node->tests = NULL;
+	node->commands = NULL;		
+	
+	node->test_list = FALSE;
+	node->block = FALSE;
+	
+	node->source_line = source_line;
+	
+	return node;
+}
+
+static bool sieve_ast_node_add_command
+(struct sieve_ast_node *node, struct sieve_ast_node *command) 
+{
+	i_assert( command->type == SAT_COMMAND && 
+		(node->type == SAT_ROOT || node->type == SAT_COMMAND) );
+	
+	if (node->commands == NULL) 
+		node->commands = sieve_ast_list_create(node->ast->pool);
+	
+	return sieve_ast_list_add(node->commands, command);
+}
+
+static bool sieve_ast_node_add_test
+(struct sieve_ast_node *node, struct sieve_ast_node *test) 
+{
+	i_assert( test->type == SAT_TEST && 
+		(node->type == SAT_TEST || node->type == SAT_COMMAND) );
+	
+	if (node->tests == NULL) 
+		node->tests = sieve_ast_list_create(node->ast->pool);
+	
+	return sieve_ast_list_add(node->tests, test);
+}
+
+static bool sieve_ast_node_add_argument
+(struct sieve_ast_node *node, struct sieve_ast_argument *argument) 
+{
+	i_assert( node->type == SAT_TEST || node->type == SAT_COMMAND );
+	
+	if (node->arguments == NULL) 
+		node->arguments = sieve_ast_arg_list_create(node->ast->pool);
+	
+	return sieve_ast_arg_list_add(node->arguments, argument);
+}
+
+struct sieve_ast_node *sieve_ast_node_detach
+(struct sieve_ast_node *first) 
+{	
+	return sieve_ast_list_detach(first, 1);
+}
+
+const char *sieve_ast_type_name
+(enum sieve_ast_type ast_type) 
+{
+	switch ( ast_type ) {
+	
+	case SAT_NONE: return "none";
+	case SAT_ROOT: return "ast root node";
+	case SAT_COMMAND: return "command";
+	case SAT_TEST: return "test";
+	
+	default: return "??AST NODE??";
+	}
+}
+
+/* 
+ * Argument AST node 
+ */
+
+struct sieve_ast_argument *sieve_ast_argument_create
+(struct sieve_ast *ast, unsigned int source_line) 
+{	
+	struct sieve_ast_argument *arg = 
+		p_new(ast->pool, struct sieve_ast_argument, 1);
+	
+	arg->ast = ast;
+	
+	arg->prev = NULL;
+	arg->next = NULL;
+	
+	arg->source_line = source_line;
+	arg->context = NULL;
+	
+	arg->argument = NULL;
+	arg->arg_id_code = 0;
+			
+	return arg;
+}
+
+static void sieve_ast_argument_substitute
+(struct sieve_ast_argument *argument, struct sieve_ast_argument *replacement) 
+{
+	sieve_ast_arg_list_substitute(argument->list, argument, replacement);
+}
+
+struct sieve_ast_argument *sieve_ast_argument_string_create_raw
+(struct sieve_ast *ast, string_t *str, unsigned int source_line) 
+{
+	struct sieve_ast_argument *argument = sieve_ast_argument_create
+		(ast, source_line);
+		
+	argument->type = SAAT_STRING;
+	argument->_value.str = str;
+
+	return argument;
+}
+
+struct sieve_ast_argument *sieve_ast_argument_string_create
+(struct sieve_ast_node *node, const string_t *str, unsigned int source_line) 
+{	
+	struct sieve_ast_argument *argument;
+	string_t *newstr;
+	
+	/* Allocate new internal string buffer */
+	newstr = str_new(node->ast->pool, str_len(str));
+	
+	/* Clone string */
+	str_append_str(newstr, str);
+	 
+	/* Create string argument */
+	argument = sieve_ast_argument_string_create_raw
+		(node->ast, newstr, source_line);
+
+	/* Add argument to command/test node */
+	sieve_ast_node_add_argument(node, argument);
+
+	return argument;
+}
+
+struct sieve_ast_argument *sieve_ast_argument_cstring_create
+(struct sieve_ast_node *node, const char *str, unsigned int source_line) 
+{	
+	struct sieve_ast_argument *argument;
+	string_t *newstr;
+	
+	/* Allocate new internal string buffer */
+	newstr = str_new(node->ast->pool, strlen(str));
+	
+	/* Clone string */
+	str_append(newstr, str);
+	 
+	/* Create string argument */
+	argument = sieve_ast_argument_string_create_raw
+		(node->ast, newstr, source_line);
+
+	/* Add argument to command/test node */
+	sieve_ast_node_add_argument(node, argument);
+
+	return argument;
+}
+
+void sieve_ast_argument_string_set
+(struct sieve_ast_argument *argument, string_t *newstr)
+{
+	i_assert( argument->type == SAAT_STRING);
+	argument->_value.str = newstr;
+}
+
+void sieve_ast_argument_string_setc
+(struct sieve_ast_argument *argument, const char *newstr)
+{
+	i_assert( argument->type == SAAT_STRING);
+	
+	str_truncate(argument->_value.str, 0);
+	str_append(argument->_value.str, newstr);
+}
+
+void sieve_ast_argument_number_substitute
+(struct sieve_ast_argument *argument, unsigned int number)
+{
+	argument->type = SAAT_NUMBER;
+	argument->_value.number = number;
+}
+
+struct sieve_ast_argument *sieve_ast_argument_stringlist_create
+(struct sieve_ast_node *node, unsigned int source_line) 
+{
+	struct sieve_ast_argument *argument = 
+		sieve_ast_argument_create(node->ast, source_line);
+	
+	argument->type = SAAT_STRING_LIST;
+	argument->_value.strlist = NULL;
+	
+	sieve_ast_node_add_argument(node, argument);
+
+	return argument;
+}
+
+struct sieve_ast_argument *sieve_ast_argument_stringlist_substitute
+(struct sieve_ast_node *node, struct sieve_ast_argument *arg) 
+{
+	struct sieve_ast_argument *argument = 
+		sieve_ast_argument_create(node->ast, arg->source_line);
+	
+	argument->type = SAAT_STRING_LIST;
+	argument->_value.strlist = NULL;
+	
+	sieve_ast_argument_substitute(arg, argument);
+
+	return argument;
+}
+
+static inline bool _sieve_ast_stringlist_add_item
+(struct sieve_ast_argument *list, struct sieve_ast_argument *item) 
+{
+	i_assert( list->type == SAAT_STRING_LIST );
+	
+	if ( list->_value.strlist == NULL ) 
+		list->_value.strlist = sieve_ast_arg_list_create(list->ast->pool);
+	
+	return sieve_ast_arg_list_add(list->_value.strlist, item);
+}
+
+static bool sieve_ast_stringlist_add_stringlist
+(struct sieve_ast_argument *list, struct sieve_ast_argument *items) 
+{
+	i_assert( list->type == SAAT_STRING_LIST );
+	i_assert( items->type == SAAT_STRING_LIST );
+
+	if ( list->_value.strlist == NULL ) 
+		list->_value.strlist = sieve_ast_arg_list_create(list->ast->pool);
+	
+	return sieve_ast_arg_list_join(list->_value.strlist, items->_value.strlist);
+}
+
+static bool _sieve_ast_stringlist_add_str
+(struct sieve_ast_argument *list, string_t *str, unsigned int source_line) 
+{
+	struct sieve_ast_argument *stritem;
+	
+	stritem = sieve_ast_argument_create(list->ast, source_line);		
+	stritem->type = SAAT_STRING;
+	stritem->_value.str = str;
+
+	return _sieve_ast_stringlist_add_item(list, stritem);
+}
+
+bool sieve_ast_stringlist_add
+(struct sieve_ast_argument *list, const string_t *str, unsigned int source_line) 
+{
+	string_t *copied_str = str_new(list->ast->pool, str_len(str));
+	str_append_str(copied_str, str);
+
+	return _sieve_ast_stringlist_add_str(list, copied_str, source_line);
+}
+
+bool sieve_ast_stringlist_add_strc
+(struct sieve_ast_argument *list, const char *str, unsigned int source_line) 
+{
+	string_t *copied_str = str_new(list->ast->pool, strlen(str));
+	str_append(copied_str, str);
+	
+	return _sieve_ast_stringlist_add_str(list, copied_str, source_line);
+}
+
+struct sieve_ast_argument *sieve_ast_argument_tag_create
+(struct sieve_ast_node *node, const char *tag, unsigned int source_line) 
+{	
+	struct sieve_ast_argument *argument = 
+		sieve_ast_argument_create(node->ast, source_line);
+	
+	argument->type = SAAT_TAG;
+	argument->_value.tag = p_strdup(node->ast->pool, tag);
+
+	if ( !sieve_ast_node_add_argument(node, argument) )
+		return NULL;
+
+	return argument;
+}
+
+struct sieve_ast_argument *sieve_ast_argument_tag_insert
+(struct sieve_ast_argument *before, const char *tag, unsigned int source_line) 
+{	
+	struct sieve_ast_argument *argument = 
+		sieve_ast_argument_create(before->ast, source_line);
+	
+	argument->type = SAAT_TAG;
+	argument->_value.tag = p_strdup(before->ast->pool, tag);
+
+	if ( !sieve_ast_arg_list_insert(before->list, before, argument) )
+		return NULL;
+	
+	return argument;
+}
+
+struct sieve_ast_argument *sieve_ast_argument_number_create
+(struct sieve_ast_node *node, unsigned int number, unsigned int source_line) 
+{
+	
+	struct sieve_ast_argument *argument = 
+		sieve_ast_argument_create(node->ast, source_line);
+		
+	argument->type = SAAT_NUMBER;
+	argument->_value.number = number;
+	
+	if ( !sieve_ast_node_add_argument(node, argument) )
+		return NULL;
+	
+	return argument;
+}
+
+void sieve_ast_argument_number_set
+(struct sieve_ast_argument *argument, unsigned int newnum)
+{
+	i_assert( argument->type == SAAT_NUMBER );
+	argument->_value.number = newnum;
+}
+
+
+struct sieve_ast_argument *sieve_ast_arguments_detach
+(struct sieve_ast_argument *first, unsigned int count) 
+{	
+	return sieve_ast_arg_list_detach(first, count);
+}
+
+bool sieve_ast_argument_attach
+(struct sieve_ast_node *node, struct sieve_ast_argument *argument)
+{
+	return sieve_ast_node_add_argument(node, argument);
+}
+
+const char *sieve_ast_argument_type_name
+(enum sieve_ast_argument_type arg_type) 
+{
+	switch ( arg_type ) {
+	
+	case SAAT_NONE: return "none";
+	case SAAT_STRING_LIST: return "a string list";
+	case SAAT_STRING: return "a string";
+	case SAAT_NUMBER: return "a number";
+	case SAAT_TAG: return "a tag";
+	
+	default: return "??ARGUMENT??";
+	}
+}
+
+/* Test AST node */
+
+struct sieve_ast_node *sieve_ast_test_create
+(struct sieve_ast_node *parent, const char *identifier, 
+	unsigned int source_line) 
+{	
+	struct sieve_ast_node *test = sieve_ast_node_create
+		(parent->ast, parent, SAT_TEST, source_line);
+		
+	test->identifier = p_strdup(parent->ast->pool, identifier);
+	
+	if ( !sieve_ast_node_add_test(parent, test) )
+		return NULL;
+	
+	return test;
+}
+
+/* Command AST node */
+
+struct sieve_ast_node *sieve_ast_command_create
+(struct sieve_ast_node *parent, const char *identifier, 
+	unsigned int source_line) 
+{
+
+	struct sieve_ast_node *command = sieve_ast_node_create
+		(parent->ast, parent, SAT_COMMAND, source_line);
+	
+	command->identifier = p_strdup(parent->ast->pool, identifier);
+	
+	if ( !sieve_ast_node_add_command(parent, command) )
+		return NULL;
+	
+	return command;
+}
+
+/*
+ * Utility
+ */
+
+int sieve_ast_stringlist_map
+(struct sieve_ast_argument **listitem, void *context,
+	int (*map_function)(void *context, struct sieve_ast_argument *arg))
+{
+	if ( sieve_ast_argument_type(*listitem) == SAAT_STRING ) {
+		/* Single string */
+		return map_function(context, *listitem);
+	} else if ( sieve_ast_argument_type(*listitem) == SAAT_STRING_LIST ) {
+		int ret = 0; 
+		
+		/* String list */
+		*listitem = sieve_ast_strlist_first(*listitem);
+		
+		while ( *listitem != NULL ) {
+			
+			if ( (ret=map_function(context, *listitem)) <= 0 )
+				return ret;
+			
+			*listitem = sieve_ast_strlist_next(*listitem);
+		}
+		
+		return ret;
+	} 
+	
+	i_unreached();
+	return -1;
+}
+
+struct sieve_ast_argument *sieve_ast_stringlist_join
+(struct sieve_ast_argument *list, struct sieve_ast_argument *items)
+{
+	enum sieve_ast_argument_type list_type, items_type;
+	struct sieve_ast_argument *newlist;
+	
+	list_type = sieve_ast_argument_type(list);
+	items_type = sieve_ast_argument_type(items);
+	
+	switch ( list_type ) {
+	
+	case SAAT_STRING:
+		switch ( items_type ) {
+		
+		case SAAT_STRING:
+			newlist = 
+				sieve_ast_argument_create(list->ast, list->source_line);
+			newlist->type = SAAT_STRING_LIST;
+			newlist->_value.strlist = NULL;
+			
+			sieve_ast_argument_substitute(list, newlist);
+			sieve_ast_arguments_detach(items, 1);
+			
+			if ( !_sieve_ast_stringlist_add_item(newlist, list) ||
+				!_sieve_ast_stringlist_add_item(newlist, items) ) {
+				return NULL;
+			}
+			
+			return newlist;
+			
+		case SAAT_STRING_LIST:
+			/* Adding stringlist to string; make them swith places and add one to the
+			 * other.
+			 */
+			sieve_ast_arguments_detach(items, 1);
+			sieve_ast_argument_substitute(list, items);
+			if ( !_sieve_ast_stringlist_add_item(items, list) ) 
+				return NULL;
+			
+			return list;
+			
+		default:
+			i_unreached();
+		}
+		break;
+		
+	case SAAT_STRING_LIST:
+		switch ( items_type ) {
+		
+		case SAAT_STRING:
+			/* Adding string to stringlist; straightforward add */
+			sieve_ast_arguments_detach(items, 1);
+			if ( !_sieve_ast_stringlist_add_item(list, items) )
+				return NULL;
+			
+			return list;
+			
+		case SAAT_STRING_LIST:
+			/* Adding stringlist to stringlist; perform actual join */
+			sieve_ast_arguments_detach(items, 1);
+			if ( !sieve_ast_stringlist_add_stringlist(list, items) )
+				return NULL;
+			
+			return list;
+			
+		default:
+			i_unreached();
+		}
+		
+		break;
+	default:
+		i_unreached();
+	}
+	
+	return NULL;
+}
+
+
+/* Debug */
+
+/* Unparsing, currently implemented using plain printf()s */
+
+static void sieve_ast_unparse_string(const string_t *strval) 
+{
+	char *str = t_strdup_noconst(str_c((string_t *) strval));
+
+	if ( strchr(str, '\n') != NULL && str[strlen(str)-1] == '\n' ) {
+		/* Print it as a multi-line string and do required dotstuffing */
+		char *spos = str;
+		char *epos = strchr(str, '\n');
+		printf("text:\n");
+		
+		while ( epos != NULL ) {
+			*epos = '\0';
+			if ( *spos == '.' ) 
+				printf(".");
+			
+			printf("%s\n", spos);
+			
+			spos = epos+1;
+			epos = strchr(spos, '\n');
+		}
+		if ( *spos == '.' ) 
+				printf(".");
+		
+		printf("%s\n.\n", spos);	
+	} else {
+		/* Print it as a quoted string and escape " */
+		char *spos = str;
+		char *epos = strchr(str, '"');
+		printf("\"");
+		
+		while ( epos != NULL ) {
+			*epos = '\0';
+			printf("%s\\\"", spos);
+			
+			spos = epos+1;
+			epos = strchr(spos, '"');
+		}
+		
+		printf("%s\"", spos);
+	}
+}
+
+static void sieve_ast_unparse_argument
+	(struct sieve_ast_argument *argument, int level);
+
+static void sieve_ast_unparse_stringlist
+(struct sieve_ast_argument *strlist, int level) 
+{
+	struct sieve_ast_argument *stritem;
+	
+	if ( sieve_ast_strlist_count(strlist) > 1 ) { 
+		int i;
+		
+		printf("[\n");
+	
+		/* Create indent */
+		for ( i = 0; i < level+2; i++ ) 
+			printf("  ");	
+
+		stritem = sieve_ast_strlist_first(strlist);
+		sieve_ast_unparse_string(sieve_ast_strlist_str(stritem));
+		
+		stritem = sieve_ast_strlist_next(stritem);
+		while ( stritem != NULL ) {
+			printf(",\n");
+			for ( i = 0; i < level+2; i++ ) 
+				printf("  ");
+			sieve_ast_unparse_string(sieve_ast_strlist_str(stritem));
+		  stritem = sieve_ast_strlist_next(stritem);
+	  }
+ 
+		printf(" ]");
+	} else {
+		stritem = sieve_ast_strlist_first(strlist);
+		if ( stritem != NULL ) 
+			sieve_ast_unparse_string(sieve_ast_strlist_str(stritem));
+	}
+}
+
+static void sieve_ast_unparse_argument
+(struct sieve_ast_argument *argument, int level) 
+{
+	switch ( argument->type ) {
+	case SAAT_STRING:
+		sieve_ast_unparse_string(sieve_ast_argument_str(argument));
+		break;
+	case SAAT_STRING_LIST:
+		sieve_ast_unparse_stringlist(argument, level+1);
+		break;
+	case SAAT_NUMBER:
+		printf("%d", sieve_ast_argument_number(argument));
+		break;
+	case SAAT_TAG:
+		printf(":%s", sieve_ast_argument_tag(argument));
+		break;
+	default:
+		printf("??ARGUMENT??");
+		break;
+	}
+}
+
+static void sieve_ast_unparse_test
+	(struct sieve_ast_node *node, int level);
+
+static void sieve_ast_unparse_tests
+(struct sieve_ast_node *node, int level) 
+{
+	struct sieve_ast_node *test;
+	
+	if ( sieve_ast_test_count(node) > 1 ) { 
+		int i;
+		
+		printf(" (\n");
+	
+		/* Create indent */
+		for ( i = 0; i < level+2; i++ ) 
+			printf("  ");	
+
+		test = sieve_ast_test_first(node);
+		sieve_ast_unparse_test(test, level+1);
+		
+		test = sieve_ast_test_next(test);
+		while ( test != NULL ) {
+			printf(", \n");
+			for ( i = 0; i < level+2; i++ ) 
+				printf("  ");
+			sieve_ast_unparse_test(test, level+1);
+		  test = sieve_ast_test_next(test);
+	  }
+ 
+		printf(" )");
+	} else {
+		test = sieve_ast_test_first(node);
+		if ( test != NULL ) 
+			sieve_ast_unparse_test(test, level);
+	}
+}
+
+static void sieve_ast_unparse_test
+(struct sieve_ast_node *node, int level) 
+{
+	struct sieve_ast_argument *argument;
+		
+	printf(" %s", node->identifier);
+	
+	argument = sieve_ast_argument_first(node);
+	while ( argument != NULL ) {
+		printf(" ");
+		sieve_ast_unparse_argument(argument, level);
+		argument = sieve_ast_argument_next(argument);
+	}
+	
+	sieve_ast_unparse_tests(node, level);
+}
+
+static void sieve_ast_unparse_command
+(struct sieve_ast_node *node, int level) 
+{
+	struct sieve_ast_node *command;
+	struct sieve_ast_argument *argument;
+	
+	int i;
+	
+	/* Create indent */
+	for ( i = 0; i < level; i++ ) 
+		printf("  ");
+		
+	printf("%s", node->identifier);
+	
+	argument = sieve_ast_argument_first(node);
+	while ( argument != NULL ) {
+		printf(" ");
+		sieve_ast_unparse_argument(argument, level);
+		argument = sieve_ast_argument_next(argument);
+	}
+	
+	sieve_ast_unparse_tests(node, level);
+	
+	command = sieve_ast_command_first(node);
+	if ( command != NULL ) {
+		printf(" {\n");
+		
+		while ( command != NULL) {	
+			sieve_ast_unparse_command(command, level+1);
+			command = sieve_ast_command_next(command);
+		}
+		
+		for ( i = 0; i < level; i++ ) 
+			printf("  ");
+		printf("}\n");
+	} else 
+		printf(";\n");
+}
+
+void sieve_ast_unparse(struct sieve_ast *ast) 
+{
+	struct sieve_ast_node *command;
+
+	printf("Unparsing Abstract Syntax Tree:\n");
+
+	T_BEGIN {	
+		command = sieve_ast_command_first(sieve_ast_root(ast));
+		while ( command != NULL ) {	
+			sieve_ast_unparse_command(command, 0);
+			command = sieve_ast_command_next(command);
+		}		
+	} T_END;
+}
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-ast.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-ast.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-ast.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-ast.h	2009-07-08 19:23:24.000000000 +0200
@@ -0,0 +1,372 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_AST_H
+#define __SIEVE_AST_H
+
+#include "lib.h"
+#include "str.h"
+
+#include "sieve-common.h"
+#include "sieve-error.h"
+
+/*
+	Abstract Syntax Tree (AST) structure:
+	
+	sieve_ast (root)
+	[*command]
+	 |
+	 +-- command:
+	 |   ....
+	 +-- command:
+	 |	 [identifier *argument                      *test *command]
+	 |                +-- argument:                 |     \--> as from root
+	 |                |   ....                      |
+ 	 |                +-- argument:                 V (continued below)
+	 |                |   [number | tag | *string]
+	 |                .
+	 .
+	
+	 *test
+	 +-- test:
+	 |   ....
+	 +-- test:
+	 |   [identifier *argument                     *test]
+	 |               +-- argument:                 \-->  as from the top 
+	 .               |   ....                              of this tree
+	                 +-- argument:
+	                 |   [number | tag | *string]
+	                 .
+	                 
+	 Tests and commands are defined using the same structure: sieve_ast_node. 
+	 However, arguments and string-lists are described using sieve_ast_argument.  
+*/
+
+/* IMPORTANT NOTICE: Do not decorate the AST with objects other than those 
+ * allocated on the ast's pool or static const objects. Otherwise it is possible 
+ * that pointers in the tree become dangling which is highly undesirable.
+ */
+
+/*
+ * Forward declarations
+ */ 
+
+struct sieve_ast_list;
+struct sieve_ast_arg_list;
+
+/*
+ * Types
+ */
+ 
+enum sieve_ast_argument_type {
+	SAAT_NONE,
+	SAAT_NUMBER,
+	SAAT_STRING,
+	SAAT_STRING_LIST,
+	SAAT_TAG,
+};
+
+enum sieve_ast_type {
+	SAT_NONE,
+	SAT_ROOT,
+	SAT_COMMAND,
+	SAT_TEST,
+};
+
+/*
+ * AST Nodes
+ */
+ 
+/* Argument node */
+
+struct sieve_ast_argument {
+	enum sieve_ast_argument_type type;
+
+	/* Back reference to the AST object */
+	struct sieve_ast *ast;
+
+	/* List related */
+	struct sieve_ast_arg_list *list;
+	struct sieve_ast_argument *next;
+	struct sieve_ast_argument *prev;
+  
+	/* Parser-assigned data */
+  
+	union {	
+		string_t *str;
+		struct sieve_ast_arg_list *strlist;
+		const char *tag;
+		unsigned int number;
+	} _value;
+  
+	unsigned int source_line;
+  
+	/* Assigned during validation */
+
+	/* Argument associated with this ast element  */
+	const struct sieve_argument *argument;
+	int arg_id_code;
+
+	/* Parameters to this (tag) argument */
+	struct sieve_ast_argument *parameters;
+	
+	/* Context data associated with this ast element */
+	void *context;
+};
+
+struct sieve_ast_node {
+	enum sieve_ast_type type;
+
+	/* Back reference to the AST object */
+	struct sieve_ast *ast;
+	
+	/* Back reference to this node's parent */
+	struct sieve_ast_node *parent;
+	
+	/* Linked list references */
+	struct sieve_ast_list *list;
+	struct sieve_ast_node *next;
+	struct sieve_ast_node *prev;
+	
+	/* Commands (NULL if not allocated) */
+	bool block;
+	struct sieve_ast_list *commands;
+	
+	/* Tests (NULL if not allocated)*/
+	bool test_list;
+	struct sieve_ast_list *tests;
+
+	/* Arguments (NULL if not allocated) */
+	struct sieve_ast_arg_list *arguments;	
+
+	/* Identifier of command or test */
+	const char *identifier;		
+
+	/* The location in the file where this command was started */
+	unsigned int source_line;
+		
+	/* Assigned during validation */
+		
+	/* Context */
+	struct sieve_command_context *context;	
+};
+
+/*
+ * AST node lists
+ */
+ 
+struct sieve_ast_list {
+	struct sieve_ast_node *head;		
+	struct sieve_ast_node *tail;
+	unsigned int len; 	
+};
+
+struct sieve_ast_arg_list {
+	struct sieve_ast_argument *head;		
+	struct sieve_ast_argument *tail;
+	unsigned int len; 	
+};
+
+/*
+ * AST object 
+ */
+ 
+struct sieve_ast; 
+ 
+struct sieve_ast *sieve_ast_create(struct sieve_script *script);
+void sieve_ast_ref(struct sieve_ast *ast);
+void sieve_ast_unref(struct sieve_ast **ast);
+
+struct sieve_ast_node *sieve_ast_root(struct sieve_ast *ast);
+pool_t sieve_ast_pool(struct sieve_ast *ast);
+struct sieve_script *sieve_ast_script(struct sieve_ast *ast);
+
+/* Extension support */
+
+struct sieve_ast_extension {
+	const struct sieve_extension *ext;	
+
+	void (*free)(struct sieve_ast *ast, void *context);
+};
+
+void sieve_ast_extension_link
+	(struct sieve_ast *ast, const struct sieve_extension *ext);
+const struct sieve_extension * const *sieve_ast_extensions_get
+	(struct sieve_ast *ast, unsigned int *count_r);
+
+void sieve_ast_extension_register
+	(struct sieve_ast *ast, const struct sieve_ast_extension *ast_ext, 
+		void *context);
+void *sieve_ast_extension_get_context
+	(struct sieve_ast *ast, const struct sieve_extension *ext);
+
+/* 
+ * AST node manipulation
+ */
+ 
+/* Command nodes */
+
+struct sieve_ast_node *sieve_ast_test_create
+	(struct sieve_ast_node *parent, const char *identifier, 
+		unsigned int source_line);
+struct sieve_ast_node *sieve_ast_command_create
+	(struct sieve_ast_node *parent, const char *identifier, 
+		unsigned int source_line);
+
+struct sieve_ast_node *sieve_ast_node_detach
+	(struct sieve_ast_node *first);
+
+const char *sieve_ast_type_name(enum sieve_ast_type ast_type);
+	
+/* Argument nodes */
+
+struct sieve_ast_argument *sieve_ast_argument_create
+	(struct sieve_ast *ast, unsigned int source_line);
+
+struct sieve_ast_arg_list *sieve_ast_arg_list_create(pool_t pool);	
+bool sieve_ast_arg_list_add
+	(struct sieve_ast_arg_list *list, struct sieve_ast_argument *argument);
+bool sieve_ast_arg_list_insert
+	(struct sieve_ast_arg_list *list, struct sieve_ast_argument *before,
+		struct sieve_ast_argument *argument);
+void sieve_ast_arg_list_substitute
+	(struct sieve_ast_arg_list *list, struct sieve_ast_argument *argument, 
+		struct sieve_ast_argument *replacement);
+
+struct sieve_ast_argument *sieve_ast_argument_string_create_raw
+	(struct sieve_ast *ast, string_t *str, unsigned int source_line);
+struct sieve_ast_argument *sieve_ast_argument_string_create
+	(struct sieve_ast_node *node, const string_t *str, unsigned int source_line);
+struct sieve_ast_argument *sieve_ast_argument_cstring_create
+	(struct sieve_ast_node *node, const char *str, unsigned int source_line);
+	
+struct sieve_ast_argument *sieve_ast_argument_tag_create
+	(struct sieve_ast_node *node, const char *tag, unsigned int source_line);
+
+struct sieve_ast_argument *sieve_ast_argument_number_create
+	(struct sieve_ast_node *node, unsigned int number, unsigned int source_line);
+
+void sieve_ast_argument_string_set
+	(struct sieve_ast_argument *argument, string_t *newstr);
+void sieve_ast_argument_string_setc
+	(struct sieve_ast_argument *argument, const char *newstr);
+
+void sieve_ast_argument_number_set
+	(struct sieve_ast_argument *argument, unsigned int newnum);
+void sieve_ast_argument_number_substitute
+	(struct sieve_ast_argument *argument, unsigned int number);
+
+struct sieve_ast_argument *sieve_ast_argument_tag_insert
+(struct sieve_ast_argument *before, const char *tag, unsigned int source_line); 
+
+struct sieve_ast_argument *sieve_ast_argument_stringlist_create
+	(struct sieve_ast_node *node, unsigned int source_line);
+struct sieve_ast_argument *sieve_ast_argument_stringlist_substitute
+	(struct sieve_ast_node *node, struct sieve_ast_argument *arg);
+
+struct sieve_ast_argument *sieve_ast_arguments_detach
+	(struct sieve_ast_argument *first, unsigned int count);
+bool sieve_ast_argument_attach
+	(struct sieve_ast_node *node, struct sieve_ast_argument *argument);
+	
+const char *sieve_ast_argument_type_name(enum sieve_ast_argument_type arg_type);
+#define sieve_ast_argument_name(argument) \
+	sieve_ast_argument_type_name((argument)->type)
+
+bool sieve_ast_stringlist_add
+	(struct sieve_ast_argument *list, const string_t *str, 
+		unsigned int source_line);
+bool sieve_ast_stringlist_add_strc
+	(struct sieve_ast_argument *list, const char *str, 
+		unsigned int source_line);
+		
+/* 
+ * Utility
+ */
+
+int sieve_ast_stringlist_map
+	(struct sieve_ast_argument **listitem, void *context,
+		int (*map_function)(void *context, struct sieve_ast_argument *arg));
+struct sieve_ast_argument *sieve_ast_stringlist_join
+	(struct sieve_ast_argument *list, struct sieve_ast_argument *items);
+	
+/* 
+ * AST access macros 
+ */
+
+/* Generic list access macros */
+#define __AST_LIST_FIRST(list) \
+	((list) == NULL ? NULL : (list)->head)
+#define __AST_LIST_LAST(list) \
+	((list) == NULL ? NULL : (list)->tail)
+#define __AST_LIST_COUNT(list) \
+	((list) == NULL || (list)->head == NULL ? 0 : (list)->len)
+#define __AST_LIST_NEXT(item) ((item)->next)
+#define __AST_LIST_PREV(item) ((item)->prev)
+
+#define __AST_NODE_LIST_FIRST(node, list) __AST_LIST_FIRST((node)->list)
+#define __AST_NODE_LIST_LAST(node, list) __AST_LIST_LAST((node)->list)
+#define __AST_NODE_LIST_COUNT(node, list) __AST_LIST_COUNT((node)->list)
+
+/* AST macros */
+
+/* AST node macros */
+#define sieve_ast_node_pool(node) (sieve_ast_pool((node)->ast))
+#define sieve_ast_node_parent(node) ((node)->parent)
+#define sieve_ast_node_prev(node) __AST_LIST_PREV(node)
+#define sieve_ast_node_next(node) __AST_LIST_NEXT(node)
+#define sieve_ast_node_type(node) ((node) == NULL ? SAT_NONE : (node)->type)
+#define sieve_ast_node_line(node) ((node) == NULL ? 0 : (node)->source_line)
+
+/* AST command node macros */
+#define sieve_ast_command_first(node) __AST_NODE_LIST_FIRST(node, commands)
+#define sieve_ast_command_count(node) __AST_NODE_LIST_COUNT(node, commands)
+#define sieve_ast_command_prev(command) __AST_LIST_PREV(command)
+#define sieve_ast_command_next(command) __AST_LIST_NEXT(command)
+
+/* Compare the identifier of the previous command */
+#define sieve_ast_prev_cmd_is(cmd, id) \
+	( (cmd)->prev == NULL ? FALSE : \
+		strncasecmp((cmd)->prev->identifier, id, sizeof(id)-1) == 0 )
+	
+/* AST test macros */
+#define sieve_ast_test_count(node) __AST_NODE_LIST_COUNT(node, tests)
+#define sieve_ast_test_first(node) __AST_NODE_LIST_FIRST(node, tests)
+#define sieve_ast_test_next(test) __AST_LIST_NEXT(test)
+
+/* AST argument macros */
+#define sieve_ast_argument_first(node) __AST_NODE_LIST_FIRST(node, arguments)
+#define sieve_ast_argument_last(node) __AST_NODE_LIST_LAST(node, arguments)
+#define sieve_ast_argument_count(node) __AST_NODE_LIST_COUNT(node, arguments)
+#define sieve_ast_argument_prev(argument) __AST_LIST_PREV(argument)
+#define sieve_ast_argument_next(argument) __AST_LIST_NEXT(argument)
+#define sieve_ast_argument_type(argument) \
+	((argument) == NULL ? SAAT_NONE : (argument)->type)
+#define sieve_ast_argument_line(argument) \
+	((argument) == NULL ? 0 : (argument)->source_line)
+
+#define sieve_ast_argument_str(argument) ((argument)->_value.str)
+#define sieve_ast_argument_strc(argument) (str_c((argument)->_value.str))
+#define sieve_ast_argument_tag(argument) ((argument)->_value.tag)
+#define sieve_ast_argument_number(argument) ((argument)->_value.number)
+
+/* AST string list macros */
+// @UNSAFE: should check whether we are actually accessing a string list
+#define sieve_ast_strlist_first(list) \
+	__AST_NODE_LIST_FIRST(list, _value.strlist)
+#define sieve_ast_strlist_last(list) \
+	__AST_NODE_LIST_LAST(list, _value.strlist)
+#define sieve_ast_strlist_count(list) \
+	__AST_NODE_LIST_COUNT(list, _value.strlist)
+#define sieve_ast_strlist_next(str) __AST_LIST_NEXT(str)
+#define sieve_ast_strlist_prev(str) __AST_LIST_PREV(str)
+#define sieve_ast_strlist_str(str) sieve_ast_argument_str(str)
+#define sieve_ast_strlist_strc(str) sieve_ast_argument_strc(str)
+
+/* 
+ * Debug 
+ */
+
+void sieve_ast_unparse(struct sieve_ast *ast);
+
+#endif /* __SIEVE_AST_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-binary.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-binary.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-binary.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-binary.c	2009-08-05 13:07:17.000000000 +0200
@@ -0,0 +1,1776 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "str-sanitize.h"
+#include "mempool.h"
+#include "buffer.h"
+#include "hash.h"
+#include "array.h"
+#include "ostream.h"
+#include "eacces-error.h"	
+
+#include "sieve-error.h"
+#include "sieve-extensions.h"
+#include "sieve-code.h"
+#include "sieve-script.h"
+
+#include "sieve-binary.h"
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+/*
+ * Config
+ */
+ 
+#define SIEVE_BINARY_VERSION_MAJOR     0
+#define SIEVE_BINARY_VERSION_MINOR     1
+
+/*
+ * Macros
+ */
+
+#define SIEVE_BINARY_MAGIC              0xcafebabe
+#define SIEVE_BINARY_MAGIC_OTHER_ENDIAN 0xbebafeca 
+
+#define SIEVE_BINARY_ALIGN(offset) \
+	(((offset) + 3) & ~3)
+#define SIEVE_BINARY_ALIGN_PTR(ptr) \
+	((void *) SIEVE_BINARY_ALIGN(((size_t) ptr)))
+
+/* 
+ * Forward declarations 
+ */
+
+struct sieve_binary_file;
+
+static bool sieve_binary_file_open
+	(struct sieve_binary_file *file, const char *path);
+static void sieve_binary_file_close(struct sieve_binary_file **file);
+
+static struct sieve_binary_block *sieve_binary_load_block
+	(struct sieve_binary *sbin, unsigned int id);
+
+static inline struct sieve_binary_extension_reg *sieve_binary_extension_get_reg
+	(struct sieve_binary *sbin, const struct sieve_extension *ext, 
+		bool create);
+static inline int sieve_binary_extension_register
+	(struct sieve_binary *sbin, const struct sieve_extension *ext, 
+		struct sieve_binary_extension_reg **reg);
+
+static inline sieve_size_t sieve_binary_emit_dynamic_data
+	(struct sieve_binary *binary, const void *data, size_t size);
+
+/* 
+ * Internal structures
+ */
+
+/* Extension registration */
+
+struct sieve_binary_extension_reg {
+	/* The identifier of the extension within this binary */
+	int index;
+	
+	/* Global extension object */
+	const struct sieve_extension *extension; 
+	
+	/* Extension to the binary; typically used to manage extension-specific blocks 
+	 * in the binary and as a means to get a binary_free notification to release
+	 * references held by extensions. 
+	 */
+	const struct sieve_binary_extension *binext;	
+	
+	/* Context data associated to the binary by this extension */
+	void *context;
+	
+	/* Main block for this extension */
+	unsigned int block_id;
+};
+
+/* Block */
+
+struct sieve_binary_block {
+	buffer_t *buffer;
+	int ext_index;
+	
+	uoff_t offset;
+};
+
+/* File */
+
+/* FIXME: In essence this is an unbuffered stream implementation. Maybe this 
+ * can be merged with the generic dovecot istream interface.
+ */
+struct sieve_binary_file {
+	pool_t pool;
+	const char *path;
+	
+	struct stat st;
+	int fd;
+	off_t offset;
+
+	bool (*load)(struct sieve_binary_file *file);	
+	const void *(*load_data)
+		(struct sieve_binary_file *file, off_t *offset, size_t size);
+	buffer_t *(*load_buffer)
+		(struct sieve_binary_file *file, off_t *offset, size_t size);
+};
+
+/*
+ * Binary object
+ */
+
+struct sieve_binary {
+	pool_t pool;
+	int refcount;
+	
+	struct sieve_script *script;
+	
+	struct sieve_binary_file *file;
+	
+	/* When the binary is loaded into memory or when it is being constructed by
+	 * the generator, extensions can be associated to the binary. The extensions
+	 * array is a sequential list of all linked extensions. The extension_index 
+	 * array is a mapping ext_id -> binary_extension. This is used to obtain the 
+	 * index code associated with an extension for this particular binary. The 
+	 * linked_extensions list all extensions linked to this binary object other
+	 * than the preloaded language features implemented as 'extensions'. 
+	 * 
+	 * All arrays refer to the same extension registration objects. Upon loading 
+	 * a binary, the 'require'd extensions will sometimes need to associate 
+	 * context data to the binary object in memory. This is stored in these 
+	 * registration objects as well.
+	 */
+	ARRAY_DEFINE(extensions, struct sieve_binary_extension_reg *); 
+	ARRAY_DEFINE(extension_index, struct sieve_binary_extension_reg *); 
+	ARRAY_DEFINE(linked_extensions, struct sieve_binary_extension_reg *); 
+		
+	/* Attributes of a loaded binary */
+	const char *path;
+		
+	/* Blocks */
+	ARRAY_DEFINE(blocks, struct sieve_binary_block *); 
+	unsigned int active_block;
+	
+	/* Current block buffer: all emit and read functions act upon this buffer */
+	buffer_t *data;
+	const signed char *code;
+	size_t code_size;
+};
+
+static struct sieve_binary *sieve_binary_create(struct sieve_script *script) 
+{
+	pool_t pool;
+	struct sieve_binary *sbin;
+	unsigned int i;
+	
+	pool = pool_alloconly_create("sieve_binary", 8192);	
+	sbin = p_new(pool, struct sieve_binary, 1);
+	sbin->pool = pool;
+	sbin->refcount = 1;
+	sbin->script = script;
+	if ( script != NULL ) 
+		sieve_script_ref(script);
+	
+	p_array_init(&sbin->linked_extensions, pool, 5);
+	p_array_init(&sbin->extensions, pool, 5);
+	p_array_init(&sbin->extension_index, pool, sieve_extensions_get_count());
+	
+	p_array_init(&sbin->blocks, pool, 3);
+
+	/* Pre-load core language features implemented as 'extensions' */
+	for ( i = 0; i < sieve_preloaded_extensions_count; i++ ) {
+		const struct sieve_extension *ext = sieve_preloaded_extensions[i];
+		if ( ext->binary_load != NULL )
+			(void)ext->binary_load(sbin);		
+	}
+			
+	return sbin;
+}
+
+struct sieve_binary *sieve_binary_create_new(struct sieve_script *script) 
+{
+	struct sieve_binary *sbin = sieve_binary_create(script); 
+	
+	/* Extensions block */
+	(void) sieve_binary_block_create(sbin);
+	
+	/* Main program block */
+	(void) sieve_binary_block_set_active
+		(sbin, sieve_binary_block_create(sbin), NULL);
+	
+	return sbin;
+}
+
+void sieve_binary_ref(struct sieve_binary *sbin) 
+{
+	sbin->refcount++;
+}
+
+static inline void sieve_binary_extensions_free(struct sieve_binary *sbin) 
+{
+	unsigned int ext_count, i;
+	
+	/* Cleanup binary extensions */
+	ext_count = array_count(&sbin->extensions);	
+	for ( i = 0; i < ext_count; i++ ) {
+		struct sieve_binary_extension_reg * const *ereg
+			= array_idx(&sbin->extensions, i);
+		const struct sieve_binary_extension *binext = (*ereg)->binext;
+		
+		if ( binext != NULL && binext->binary_free != NULL )
+			binext->binary_free(sbin);
+	}
+}
+
+void sieve_binary_unref(struct sieve_binary **sbin) 
+{
+	i_assert((*sbin)->refcount > 0);
+
+	if (--(*sbin)->refcount != 0)
+		return;
+
+	sieve_binary_extensions_free(*sbin);
+	
+	if ( (*sbin)->file != NULL )
+		sieve_binary_file_close(&(*sbin)->file);
+
+	if ( (*sbin)->script != NULL )
+		sieve_script_unref(&(*sbin)->script);
+	
+	pool_unref(&((*sbin)->pool));
+	
+	*sbin = NULL;
+}
+
+static inline sieve_size_t _sieve_binary_get_code_size
+(struct sieve_binary *sbin)
+{
+	return buffer_get_used_size(sbin->data);
+}
+
+sieve_size_t sieve_binary_get_code_size(struct sieve_binary *sbin)
+{
+	return _sieve_binary_get_code_size(sbin);
+}
+
+pool_t sieve_binary_pool(struct sieve_binary *sbin)
+{
+	return sbin->pool;
+}
+
+struct sieve_script *sieve_binary_script(struct sieve_binary *sbin)
+{
+	return sbin->script;
+}
+
+const char *sieve_binary_path(struct sieve_binary *sbin)
+{
+	return sbin->path;
+}
+
+bool sieve_binary_script_older
+(struct sieve_binary *sbin, struct sieve_script *script)
+{
+	i_assert(sbin->file != NULL);
+	return ( sieve_script_older(script, sbin->file->st.st_mtime) );
+}
+
+const char *sieve_binary_script_name(struct sieve_binary *sbin)
+{
+	struct sieve_script *script = sieve_binary_script(sbin);
+
+	return ( script == NULL ? NULL : sieve_script_name(script) );
+}
+
+const char *sieve_binary_script_path(struct sieve_binary *sbin)
+{
+	struct sieve_script *script = sieve_binary_script(sbin);
+
+	return ( script == NULL ? NULL : sieve_script_path(script) );
+}
+
+
+/* 
+ * Block management 
+ */
+
+static inline struct sieve_binary_block *sieve_binary_block_get
+(struct sieve_binary *sbin, unsigned int id) 
+{
+	struct sieve_binary_block * const *block;
+
+	if  ( id >= array_count(&sbin->blocks) )
+		return NULL;
+	
+	block = array_idx(&sbin->blocks, id);		
+
+	return *block;
+}
+
+static inline unsigned int sieve_binary_block_add
+(struct sieve_binary *sbin, struct sieve_binary_block *block)
+{
+	unsigned int id = array_count(&sbin->blocks);
+	
+	array_append(&sbin->blocks, &block, 1);	
+	return id;
+}
+
+static inline unsigned int sieve_binary_block_count
+(struct sieve_binary *sbin)
+{
+	return array_count(&sbin->blocks);
+}
+
+void sieve_binary_block_clear
+(struct sieve_binary *sbin, unsigned int id)
+{
+	struct sieve_binary_block *block = sieve_binary_block_get(sbin, id);
+	
+	buffer_reset(block->buffer);
+}
+
+bool sieve_binary_block_set_active
+(struct sieve_binary *sbin, unsigned int id, unsigned *old_id_r)
+{
+	struct sieve_binary_block *block = sieve_binary_block_get(sbin, id);
+			
+	if ( block == NULL ) return FALSE;
+	
+	if ( block->buffer == NULL ) {
+		if ( sbin->file ) {
+			/* Try to acces the block in the binary on disk (apperently we were lazy)
+			 */
+			if ( sieve_binary_load_block(sbin, id) == NULL || block->buffer == NULL )
+				return FALSE;
+		} else {
+			/* Block buffer is missing during code generation. This is what we would 
+			 * call a bug. FAIL. 
+			 */
+			return FALSE;
+		}
+	}
+	
+	if ( old_id_r != NULL ) 
+		*old_id_r = sbin->active_block;
+
+	sbin->data = block->buffer;
+	sbin->code = buffer_get_data(block->buffer, &sbin->code_size);
+	sbin->active_block = id;
+	
+	return TRUE;
+}
+
+unsigned int sieve_binary_block_create(struct sieve_binary *sbin)
+{
+	struct sieve_binary_block *block;
+	
+	block = p_new(sbin->pool, struct sieve_binary_block, 1);
+	block->buffer = buffer_create_dynamic(sbin->pool, 64);
+
+	return sieve_binary_block_add(sbin, block);
+}
+
+static struct sieve_binary_block *sieve_binary_block_create_id
+(struct sieve_binary *sbin, unsigned int id)
+{
+	struct sieve_binary_block *block;
+	
+	block = p_new(sbin->pool, struct sieve_binary_block, 1);
+
+	if ( id >= SBIN_SYSBLOCK_LAST )
+		array_idx_set(&sbin->blocks, id, &block);		
+	else
+		(void)sieve_binary_block_add(sbin, block);
+	
+	return block;
+}
+
+/*
+ * Header and record structures of the binary on disk 
+ */
+ 
+struct sieve_binary_header {
+	uint32_t magic;
+	uint16_t version_major;
+	uint16_t version_minor;
+	uint32_t blocks;
+};
+
+struct sieve_binary_block_index {
+	uint32_t id;
+	uint32_t size;
+	uint32_t offset;
+	uint32_t ext_id;
+};
+
+struct sieve_binary_block_header {
+	uint32_t id; 
+	uint32_t size;
+};
+
+/* 
+ * Saving the binary to a file. 
+ */
+
+static inline bool _save_skip(struct ostream *stream, size_t size)
+{	
+	if ( (o_stream_seek(stream, stream->offset + size)) <= 0 ) 
+		return FALSE;
+		
+	return TRUE;
+}
+
+static inline bool _save_skip_aligned
+(struct ostream *stream, size_t size, uoff_t *offset)
+{
+	uoff_t aligned_offset = SIEVE_BINARY_ALIGN(stream->offset);
+	
+	if ( (o_stream_seek(stream, aligned_offset + size)) <= 0 ) 
+		return FALSE;
+		
+	if ( offset != NULL )
+		*offset = aligned_offset;
+		
+	return TRUE;
+}
+
+/* FIXME: Is this even necessary for a file? */
+static bool _save_full(struct ostream *stream, const void *data, size_t size)
+{
+	size_t bytes_left = size;
+	const void *pdata = data;
+	
+	while ( bytes_left > 0 ) {
+		ssize_t ret;
+		
+		if ( (ret=o_stream_send(stream, pdata, bytes_left)) <= 0 ) 
+			return FALSE;
+			
+		pdata = PTR_OFFSET(pdata, ret);
+		bytes_left -= ret;
+	}	
+	
+	return TRUE;
+}
+
+static bool _save_aligned
+(struct ostream *stream, const void *data, size_t size, uoff_t *offset)
+{	
+	uoff_t aligned_offset = SIEVE_BINARY_ALIGN(stream->offset);
+
+	o_stream_cork(stream);
+	
+	/* Align the data by adding zeroes to the output stream */
+	if ( stream->offset < aligned_offset ) {
+		if ( !_save_skip(stream, aligned_offset - stream->offset) ) 
+			return FALSE;
+	}
+	
+	if ( !_save_full(stream, data, size) )
+		return FALSE;
+	
+	o_stream_uncork(stream); 
+
+	if ( offset != NULL )
+		*offset = aligned_offset;
+
+	return TRUE;
+} 
+
+static bool _save_block
+(struct sieve_binary *sbin, struct ostream *stream, unsigned int id)
+{
+	struct sieve_binary_block_header block_header;
+	struct sieve_binary_block *block;
+	const void *data;
+	size_t size;
+		
+	block = sieve_binary_block_get(sbin, id);
+	if ( block == NULL )
+		return FALSE;
+		
+	data = buffer_get_data(block->buffer, &size);
+	
+	block_header.id = id;
+	block_header.size = size;
+	
+	if ( !_save_aligned(stream, &block_header,
+		sizeof(block_header), &block->offset) )
+		return FALSE;
+	
+	return _save_aligned(stream, data, size, NULL);
+}
+
+static bool _save_block_index_record
+(struct sieve_binary *sbin, struct ostream *stream, unsigned int id)
+{
+	struct sieve_binary_block *block;
+	struct sieve_binary_block_index header;
+	
+	block = sieve_binary_block_get(sbin, id);
+	if ( block == NULL )
+		return FALSE;
+	
+	header.id = id;
+	header.size = buffer_get_used_size(block->buffer);
+	header.ext_id = block->ext_index;
+	header.offset = block->offset;
+	
+	if ( !_save_full(stream, &header, sizeof(header)) ) {
+		sieve_sys_error("failed to save block index header %d: %m", id);
+		
+		return FALSE;
+	}
+	
+	return TRUE;
+}
+
+static bool _sieve_binary_save
+(struct sieve_binary *sbin, struct ostream *stream)
+{
+	struct sieve_binary_header header;
+	unsigned int ext_count, blk_count, i;
+	uoff_t block_index;
+	
+	blk_count = sieve_binary_block_count(sbin);
+	
+	/* Signal all extensions to finish generating their blocks */
+	
+	ext_count = array_count(&sbin->extensions);	
+	for ( i = 0; i < ext_count; i++ ) {
+		struct sieve_binary_extension_reg * const *ereg
+			= array_idx(&sbin->extensions, i);
+		const struct sieve_binary_extension *binext = (*ereg)->binext;
+		
+		if ( binext != NULL && binext->binary_save != NULL )
+			binext->binary_save(sbin);
+	}
+		
+	/* Create header */
+	
+	header.magic = SIEVE_BINARY_MAGIC;
+	header.version_major = SIEVE_BINARY_VERSION_MAJOR;
+	header.version_minor = SIEVE_BINARY_VERSION_MINOR;
+	header.blocks = blk_count;
+
+	if ( !_save_aligned(stream, &header, sizeof(header), NULL) ) {
+		sieve_sys_error("failed to save binary header: %m");
+		return FALSE;
+	} 
+	
+	/* Skip block index for now */
+	
+	if ( !_save_skip_aligned(stream, 
+		sizeof(struct sieve_binary_block_index) * blk_count, &block_index) )
+		return FALSE;
+	
+	/* Create block containing all used extensions 
+	 *   FIXME: Per-extension this should also store binary version numbers.
+	 */
+	if ( !sieve_binary_block_set_active(sbin, SBIN_SYSBLOCK_EXTENSIONS, NULL) )
+		return FALSE;
+		
+	ext_count = array_count(&sbin->linked_extensions);
+	sieve_binary_emit_unsigned(sbin, ext_count);
+	
+	for ( i = 0; i < ext_count; i++ ) {
+		struct sieve_binary_extension_reg * const *ext
+			= array_idx(&sbin->linked_extensions, i);
+		
+		sieve_binary_emit_cstring(sbin, (*ext)->extension->name);
+		sieve_binary_emit_unsigned(sbin, (*ext)->block_id);
+	}
+	
+	if ( !sieve_binary_block_set_active(sbin, SBIN_SYSBLOCK_MAIN_PROGRAM, NULL) )
+		return FALSE;
+	
+	/* Save all blocks into the binary */
+	
+	for ( i = 0; i < blk_count; i++ ) {
+		if ( !_save_block(sbin, stream, i) ) 
+			return FALSE;
+	}
+	
+	/* Create the block index */
+	o_stream_seek(stream, block_index);
+	for ( i = 0; i < blk_count; i++ ) {
+		if ( !_save_block_index_record(sbin, stream, i) ) 
+			return FALSE;
+	}
+
+	return TRUE;
+} 
+
+bool sieve_binary_save
+(struct sieve_binary *sbin, const char *path)
+{
+	bool result = TRUE;
+	const char *temp_path;
+	struct ostream *stream;
+	int fd;
+	mode_t save_mode = sbin->script == NULL ? 0600 : sieve_script_permissions(sbin->script);
+	
+	/* Use default path if none is specified */
+	if ( path == NULL ) {
+		if ( sbin->script == NULL ) {
+			sieve_sys_error("cannot determine default binary save path "
+				"with missing script object");
+        	return FALSE;
+		}
+		path = sieve_script_binpath(sbin->script);
+	}
+
+	/* Open it as temp file first, as not to overwrite an existing just yet */
+	temp_path = t_strconcat(path, ".tmp", NULL);
+	fd = open(temp_path, O_CREAT | O_TRUNC | O_WRONLY, save_mode);
+	if ( fd < 0 ) {
+		if ( errno == EACCES ) {
+			sieve_sys_error("failed to save binary: %s",
+				eacces_error_get_creating("open", temp_path));
+		} else {
+			sieve_sys_error("failed to save binary: open(%s) failed: %m", 
+				temp_path);
+		}
+		return FALSE;
+	}
+
+	stream = o_stream_create_fd(fd, 0, FALSE);
+	result = _sieve_binary_save(sbin, stream);
+	o_stream_destroy(&stream);
+ 
+	if (close(fd) < 0)
+		sieve_sys_error("failed to close saved binary temporary file: "
+			"close(fd=%s) failed: %m", temp_path);
+
+	/* Replace any original binary atomically */
+	if (result && (rename(temp_path, path) < 0)) {
+		if ( errno == EACCES ) {
+			sieve_sys_error("failed to replace existing binary: %s", 
+				eacces_error_get_creating("rename", path));			
+		} else { 		
+			sieve_sys_error("failed to replace existing binary: "
+				"rename(%s, %s) failed: %m", temp_path, path);
+		}
+		result = FALSE;
+	}
+
+	if ( !result ) {
+		/* Get rid of temp output (if any) */
+		(void) unlink(temp_path);
+	} else {
+		if ( sbin->path == NULL || strcmp(sbin->path, path) != 0 ) {
+			sbin->path = p_strdup(sbin->pool, path);
+		}
+	}
+	
+	return result;
+}
+
+/* 
+ * Binary file management 
+ */
+
+static bool sieve_binary_file_open
+	(struct sieve_binary_file *file, const char *path)
+{
+	int fd;
+	struct stat st;
+	
+	if ( (fd=open(path, O_RDONLY)) < 0 ) {
+		if ( errno != ENOENT ) {
+			if ( errno == EACCES ) {
+				sieve_sys_error("failed to open binary: %s", 
+					eacces_error_get("open", path));			
+			} else {
+				sieve_sys_error("failed to open binary: "
+					"open(%s) failed: %m", path);
+			}
+		}
+		return FALSE;
+	}
+
+	if ( fstat(fd, &st) < 0 ) {
+		if ( errno != ENOENT ) {
+			sieve_sys_error("failed to open binary: "
+				"fstat(fd=%s) failed: %m", path);
+		}
+		return FALSE;
+	}
+
+	if ( !S_ISREG(st.st_mode) ) {
+		sieve_sys_error("binary %s is not a regular file", path);
+		return FALSE;		
+	}
+	
+	file->fd = fd;
+	file->st = st;
+
+	return TRUE;
+}
+	
+static void sieve_binary_file_close(struct sieve_binary_file **file)
+{
+	if ( (*file)->fd != -1 ) {
+		if ( close((*file)->fd) < 0 ) {
+			sieve_sys_error("failed to close opened binary: "
+				"close(fd=%s) failed: %m", (*file)->path);
+		}
+	}
+
+	pool_unref(&(*file)->pool);
+	
+	*file = NULL;
+}
+
+#if 0 /* file_memory is currently unused */
+
+/* File loaded/mapped to memory */
+
+struct _file_memory {
+	struct sieve_binary_file binfile;
+
+	/* Pointer to the binary in memory */
+	const void *memory;
+	off_t memory_size;
+};
+
+static const void *_file_memory_load_data
+	(struct sieve_binary_file *file, off_t *offset, size_t size)
+{	
+	struct _file_memory *fmem = (struct _file_memory *) file;
+
+	*offset = SIEVE_BINARY_ALIGN(*offset);
+
+	if ( (*offset) + size <= fmem->memory_size ) {
+		const void *data = PTR_OFFSET(fmem->memory, *offset);
+		*offset += size;
+		file->offset = *offset;
+		
+		return data;
+	}
+		
+	return NULL;
+}
+
+static buffer_t *_file_memory_load_buffer
+	(struct sieve_binary_file *file, off_t *offset, size_t size)
+{	
+	struct _file_memory *fmem = (struct _file_memory *) file;
+
+	*offset = SIEVE_BINARY_ALIGN(*offset);
+
+	if ( (*offset) + size <= fmem->memory_size ) {
+		const void *data = PTR_OFFSET(fmem->memory, *offset);
+		*offset += size;
+		file->offset = *offset;
+		
+		return buffer_create_const_data(file->pool, data, size);
+	}
+	
+	return NULL;
+}
+
+static bool _file_memory_load(struct sieve_binary_file *file)
+{
+	struct _file_memory *fmem = (struct _file_memory *) file;
+	int ret;
+	size_t size;
+	void *indata;
+		
+	i_assert(file->fd > 0);
+		
+	/* Allocate memory buffer
+	 */
+	indata = p_malloc(file->pool, file->st.st_size);
+	size = file->st.st_size; 
+	
+	file->offset = 0; 
+	fmem->memory = indata;
+	fmem->memory_size = file->st.st_size;
+
+	/* Return to beginning of the file */
+	if ( lseek(file->fd, 0, SEEK_SET) == (off_t) -1 ) {
+		sieve_sys_error("failed to seek() in binary %s: %m", file->path);
+		return FALSE;
+	}	
+
+	/* Read the whole file into memory */
+	while (size > 0) {
+		if ( (ret=read(file->fd, indata, size)) <= 0 ) {
+			sieve_sys_error("failed to read from binary %s: %m", file->path);
+			break;
+		}
+		
+		indata = PTR_OFFSET(indata, ret);
+		size -= ret;
+	}	
+
+	if ( size != 0 ) {
+		/* Failed to read the whole file */
+		return FALSE;
+	}
+	
+	return TRUE;
+}
+
+static struct sieve_binary_file *_file_memory_open(const char *path)
+{
+	pool_t pool;
+	struct _file_memory *file;
+	
+	pool = pool_alloconly_create("sieve_binary_file_memory", 1024);
+	file = p_new(pool, struct _file_memory, 1);
+	file->binfile.pool = pool;
+	file->binfile.path = p_strdup(pool, path);
+	file->binfile.load = _file_memory_load;
+	file->binfile.load_data = _file_memory_load_data;
+	file->binfile.load_buffer = _file_memory_load_buffer;
+	
+	if ( !sieve_binary_file_open(&file->binfile, path) ) {
+		pool_unref(&pool);
+		return NULL;
+	}
+
+	return &file->binfile;
+}
+
+#endif /* file_memory is currently unused */
+
+/* File open in lazy mode (only read what is needed into memory) */
+
+static bool _file_lazy_read
+(struct sieve_binary_file *file, off_t *offset, void *buffer, size_t size)
+{
+	int ret;
+	void *indata = buffer;
+	size_t insize = size;
+	
+	*offset = SIEVE_BINARY_ALIGN(*offset);
+	
+	/* Seek to the correct position */ 
+	if ( *offset != file->offset && 
+		lseek(file->fd, *offset, SEEK_SET) == (off_t) -1 ) {
+		sieve_sys_error("failed to seek(fd, %lld, SEEK_SET) in binary %s: %m", 
+			(long long) *offset, file->path);
+		return FALSE;
+	}	
+
+	/* Read record into memory */
+	while (insize > 0) {
+		if ( (ret=read(file->fd, indata, insize)) <= 0 ) {
+			if ( ret == 0 ) 
+				sieve_sys_error("binary %s is truncated (more data expected)", 
+					file->path);
+			else
+				sieve_sys_error("failed to read from binary %s: %m", file->path);
+			break;
+		}
+		
+		indata = PTR_OFFSET(indata, ret);
+		insize -= ret;
+	}	
+
+	if ( insize != 0 ) {
+		/* Failed to read the whole requested record */
+		return FALSE;
+	}
+	
+	*offset += size;
+	file->offset = *offset;
+
+	return TRUE;
+}
+
+static const void *_file_lazy_load_data
+(struct sieve_binary_file *file, off_t *offset, size_t size)
+{	
+	void *data = t_malloc(size);
+
+	if ( _file_lazy_read(file, offset, data, size) ) {
+		return data;
+	}
+	
+	return NULL;
+}
+
+static buffer_t *_file_lazy_load_buffer
+(struct sieve_binary_file *file, off_t *offset, size_t size)
+{			
+	buffer_t *buffer = buffer_create_static_hard(file->pool, size);
+	
+	if ( _file_lazy_read
+		(file, offset, buffer_get_space_unsafe(buffer, 0, size), size) ) {
+		return buffer;
+	}
+	
+	return NULL;
+}
+
+static struct sieve_binary_file *_file_lazy_open(const char *path)
+{
+	pool_t pool;
+	struct sieve_binary_file *file;
+	
+	pool = pool_alloconly_create("sieve_binary_file_lazy", 4096);
+	file = p_new(pool, struct sieve_binary_file, 1);
+	file->pool = pool;
+	file->path = p_strdup(pool, path);
+	file->load_data = _file_lazy_load_data;
+	file->load_buffer = _file_lazy_load_buffer;
+	
+	if ( !sieve_binary_file_open(file, path) ) {
+		pool_unref(&pool);
+		return NULL;
+	}
+
+	return file;
+}
+
+/* 
+ * Load binary from a file
+ */
+
+#define LOAD_HEADER(sbin, offset, header) \
+	(header *) sbin->file->load_data(sbin->file, offset, sizeof(header))
+
+static struct sieve_binary_block *_load_block
+(struct sieve_binary *sbin, off_t *offset, unsigned int id)
+{
+	const struct sieve_binary_block_header *header = 
+		LOAD_HEADER(sbin, offset, const struct sieve_binary_block_header);
+	struct sieve_binary_block *block;
+		
+	if ( header == NULL ) {
+		sieve_sys_error("block %d of loaded binary %s is truncated", id, sbin->path);
+		return NULL;
+	}
+	
+	if ( header->id != id ) {
+		sieve_sys_error("block %d of loaded binary %s has unexpected id %d", id, 
+			sbin->path, header->id);
+		return NULL;
+	}
+	
+	block = sieve_binary_block_get(sbin, id);
+	
+	if ( block == NULL ) {
+		sieve_sys_error("!!BUG!!: block %d missing in index (impossible) "
+			"of binary %s",	id, sbin->path);
+		return NULL;
+	}
+	
+	block->buffer = sbin->file->load_buffer(sbin->file, offset, header->size);
+	if ( block->buffer == NULL ) {
+		sieve_sys_error("block %d of loaded binary %s has invalid size %d",
+			id, sbin->path, header->size);
+		return NULL;
+	}
+		
+	return block;
+}
+
+static struct sieve_binary_block *sieve_binary_load_block
+(struct sieve_binary *sbin, unsigned int id)
+{
+	struct sieve_binary_block *block;
+	off_t offset;
+	
+	block = sieve_binary_block_get(sbin, id);
+	
+	if ( block == NULL ) return NULL;
+	
+	offset = block->offset;
+	
+	return _load_block(sbin, &offset, id);
+}
+
+static bool _load_block_index_record
+(struct sieve_binary *sbin, off_t *offset, unsigned int id)
+{
+	const struct sieve_binary_block_index *record = 
+		LOAD_HEADER(sbin, offset, const struct sieve_binary_block_index);
+	struct sieve_binary_block *block;
+	
+	if ( record == NULL ) {
+		sieve_sys_error("failed to read index record for block %d in binary %s", 
+			id, sbin->path);
+		return FALSE;
+	}
+	
+	if ( record->id != id ) {
+		sieve_sys_error("block index record %d of loaded binary %s "
+			"has unexpected id %d", id, sbin->path, record->id);
+		return FALSE;
+	}
+	
+	block = sieve_binary_block_create_id(sbin, id);
+	block->ext_index = record->ext_id;
+	block->offset = record->offset;
+	
+	return TRUE;
+}
+
+static bool _sieve_binary_load_extensions(struct sieve_binary *sbin)
+{
+	sieve_size_t offset = 0;
+	unsigned int i, count;
+	bool result = TRUE;
+	
+	if ( !sieve_binary_block_set_active(sbin, SBIN_SYSBLOCK_EXTENSIONS, NULL) ) 
+		return FALSE;
+
+	if ( !sieve_binary_read_unsigned(sbin, &offset, &count) )
+		return FALSE;
+	
+	for ( i = 0; result && i < count; i++ ) {
+		T_BEGIN {
+			string_t *extension;
+			const struct sieve_extension *ext;
+			
+			if ( sieve_binary_read_string(sbin, &offset, &extension) ) { 
+				ext = sieve_extension_get_by_name(str_c(extension));	
+			
+				if ( ext == NULL ) { 
+					sieve_sys_error("loaded binary %s requires unknown extension '%s'", 
+						sbin->path, str_sanitize(str_c(extension), 128));
+					result = FALSE;					
+				} else {
+					struct sieve_binary_extension_reg *ereg = NULL;
+					
+					(void) sieve_binary_extension_register(sbin, ext, &ereg);
+					if ( !sieve_binary_read_unsigned(sbin, &offset, &ereg->block_id) )
+						result = FALSE;
+				}
+			}	else
+				result = FALSE;
+		} T_END;
+	}		
+		
+	return result;
+}
+
+static bool _sieve_binary_open(struct sieve_binary *sbin)
+{
+	bool result = TRUE;
+	off_t offset = 0;
+	const struct sieve_binary_header *header;
+	struct sieve_binary_block *extensions;
+	unsigned int i, blk_count;
+	
+	/* Verify header */
+	
+	T_BEGIN {
+		header = LOAD_HEADER(sbin, &offset, const struct sieve_binary_header);
+		if ( header == NULL ) {
+			sieve_sys_error("opened binary %s is not even large enough "
+				"to contain a header.", sbin->path);
+			result = FALSE;
+
+		} else if ( header->magic != SIEVE_BINARY_MAGIC ) {
+			if ( header->magic != SIEVE_BINARY_MAGIC_OTHER_ENDIAN ) 
+				sieve_sys_error("opened binary %s has corrupted header (0x%08x)", 
+					sbin->path, header->magic);
+			result = FALSE;
+
+		} else if ( result && (
+		  header->version_major != SIEVE_BINARY_VERSION_MAJOR || 
+			header->version_minor != SIEVE_BINARY_VERSION_MINOR ) ) {
+
+			/* Binary is of different version. Caller will have to recompile */
+			result = FALSE;
+
+		} else if ( result && header->blocks == 0 ) {
+			sieve_sys_error("opened binary %s contains no blocks", sbin->path);
+			result = FALSE; 
+
+		} else {
+			blk_count = header->blocks;
+		}
+	} T_END;
+	
+	if ( !result ) return FALSE;
+	
+	/* Load block index */
+	
+	for ( i = 0; i < blk_count && result; i++ ) {	
+		T_BEGIN {
+			if ( !_load_block_index_record(sbin, &offset, i) ) {
+				sieve_sys_error(
+					"block index record %d of opened binary %s is corrupt", 
+					i, sbin->path);
+				result = FALSE;
+			}
+		} T_END;
+	}
+	
+	if ( !result ) return FALSE;
+	
+	/* Load extensions used by this binary */
+	
+	T_BEGIN {
+		extensions =_load_block(sbin, &offset, 0);
+		if ( extensions == NULL ) {
+			result = FALSE;
+		} else if ( !_sieve_binary_load_extensions(sbin) ) {
+			sieve_sys_error("extension block of opened binary %s is corrupt", 
+				sbin->path);
+			result = FALSE;
+		}
+	} T_END;
+		
+	return result;
+}
+
+static bool _sieve_binary_load(struct sieve_binary *sbin) 
+{	
+	bool result = TRUE;
+	unsigned int i, blk_count;
+	struct sieve_binary_block *block;
+	off_t offset;
+	
+	blk_count = array_count(&sbin->blocks);
+	if ( blk_count == 1 ) {
+		/* Binary is empty */
+		return TRUE;
+	}	
+
+	block = sieve_binary_block_get(sbin, SBIN_SYSBLOCK_MAIN_PROGRAM);
+	offset = block->offset;
+	
+	/* Load the other blocks */
+	
+	for ( i = 1; result && i < blk_count; i++ ) {	
+		T_BEGIN {
+			if ( _load_block(sbin, &offset, i) == NULL ) {
+				sieve_sys_error("block %d of loaded binary %s is corrupt", 
+					i, sbin->path);
+				result = FALSE;
+			}
+		} T_END;
+	}
+				
+	return result;
+}
+
+struct sieve_binary *sieve_binary_open
+	(const char *path, struct sieve_script *script)
+{
+	unsigned int ext_count, i;
+	struct sieve_binary *sbin;
+	struct sieve_binary_file *file;
+		
+	//file = _file_memory_open(path);	
+	file = _file_lazy_open(path);
+	if ( file == NULL )
+		return NULL;
+		
+	/* Create binary object */
+	sbin = sieve_binary_create(script);
+	sbin->path = p_strdup(sbin->pool, path);
+	sbin->file = file;
+	
+	if ( !_sieve_binary_open(sbin) ) {
+		sieve_binary_unref(&sbin);
+		return NULL;
+	}
+	
+	sieve_binary_activate(sbin);
+	
+	/* Signal open event to extensions */
+	ext_count = array_count(&sbin->extensions);	
+	for ( i = 0; i < ext_count; i++ ) {
+		struct sieve_binary_extension_reg * const *ereg
+			= array_idx(&sbin->extensions, i);
+		const struct sieve_binary_extension *binext = (*ereg)->binext;
+		
+		if ( binext != NULL && binext->binary_open != NULL && 
+			!binext->binary_open(sbin) ) {
+			/* Extension thinks its corrupt */
+			sieve_binary_unref(&sbin);
+			return NULL;
+		}
+	}	
+
+	return sbin;
+}
+
+bool sieve_binary_load(struct sieve_binary *sbin)
+{
+	i_assert(sbin->file != NULL);
+
+	/*
+	if ( sbin->file->load != NULL && !sbin->file->load(sbin->file) )
+		return FALSE;	*/		
+	
+	if ( !_sieve_binary_load(sbin) ) {
+		/* Failed to interpret binary header and/or block structure */
+		return FALSE;
+	}
+	
+	return TRUE;
+}
+
+/*
+ * Up-to-date checking
+ */
+
+bool sieve_binary_up_to_date(struct sieve_binary *sbin)
+{
+	unsigned int ext_count, i;
+	
+	i_assert(sbin->file != NULL);
+
+	if ( sbin->script == NULL || !sieve_script_older
+		(sbin->script, sbin->file->st.st_mtime) )
+		return FALSE;
+	
+	ext_count = array_count(&sbin->extensions);	
+	for ( i = 0; i < ext_count; i++ ) {
+		struct sieve_binary_extension_reg * const *ereg
+			= array_idx(&sbin->extensions, i);
+		const struct sieve_binary_extension *binext = (*ereg)->binext;
+		
+		if ( binext != NULL && binext->binary_up_to_date != NULL && 
+			!binext->binary_up_to_date(sbin) )
+			return FALSE;
+	}
+	
+	return TRUE;
+}
+
+/*
+ * Activate the binary (after code generation)
+ */
+ 
+void sieve_binary_activate(struct sieve_binary *sbin)
+{
+	unsigned int i;
+	
+	(void)sieve_binary_block_set_active(sbin, SBIN_SYSBLOCK_MAIN_PROGRAM, NULL);
+	
+	/* Load other extensions into binary */
+	for ( i = 0; i < array_count(&sbin->linked_extensions); i++ ) {
+		struct sieve_binary_extension_reg * const *ereg = 
+			array_idx(&sbin->linked_extensions, i);
+		const struct sieve_extension *ext = (*ereg)->extension;
+		
+		if ( ext != NULL && ext->binary_load != NULL )
+			ext->binary_load(sbin);
+	}
+}
+
+/* 
+ * Extension handling 
+ */
+
+static inline struct sieve_binary_extension_reg *
+	sieve_binary_extension_create_reg
+(struct sieve_binary *sbin, const struct sieve_extension *ext)
+{
+	int ext_id = SIEVE_EXT_ID(ext);
+	int index = array_count(&sbin->extensions);
+	struct sieve_binary_extension_reg *ereg;
+
+	if ( ext_id < 0 ) return NULL;
+
+	ereg = p_new(sbin->pool, struct sieve_binary_extension_reg, 1);
+	ereg->index = index;
+	ereg->extension = ext;
+	
+	array_idx_set(&sbin->extensions, (unsigned int) index, &ereg);
+	array_idx_set(&sbin->extension_index, (unsigned int) ext_id, &ereg);
+	
+	return ereg;
+}
+
+static inline struct sieve_binary_extension_reg *sieve_binary_extension_get_reg 
+(struct sieve_binary *sbin, const struct sieve_extension *ext, bool create) 
+{
+	int ext_id = SIEVE_EXT_ID(ext);
+	struct sieve_binary_extension_reg *reg = NULL;
+
+	if ( ext_id >= 0 && ext_id < (int) array_count(&sbin->extension_index) ) {
+		struct sieve_binary_extension_reg * const *ereg = 
+			array_idx(&sbin->extension_index, (unsigned int) ext_id);
+		
+		reg = *ereg;
+	}
+
+	/* Register if not known */
+	if ( reg == NULL && create )
+		return sieve_binary_extension_create_reg(sbin, ext);
+
+	return reg;
+}
+
+void sieve_binary_extension_set_context
+(struct sieve_binary *sbin, const struct sieve_extension *ext, void *context)
+{
+	struct sieve_binary_extension_reg *ereg = 
+		sieve_binary_extension_get_reg(sbin, ext, TRUE);
+	
+	if ( ereg != NULL )
+		ereg->context = context;
+}
+
+const void *sieve_binary_extension_get_context
+	(struct sieve_binary *sbin, const struct sieve_extension *ext) 
+{
+	struct sieve_binary_extension_reg *ereg = 
+		sieve_binary_extension_get_reg(sbin, ext, TRUE);
+
+	if ( ereg != NULL ) {
+		return ereg->context;
+	}
+		
+	return NULL;
+}
+
+void sieve_binary_extension_set
+(struct sieve_binary *sbin, const struct sieve_binary_extension *bext,
+	void *context)
+{
+	struct sieve_binary_extension_reg *ereg = 
+		sieve_binary_extension_get_reg(sbin, bext->extension, TRUE);
+	
+	if ( ereg != NULL ) {
+		ereg->binext = bext;
+
+		if ( context != NULL )
+			ereg->context = context;
+	}
+}
+
+unsigned int sieve_binary_extension_create_block
+(struct sieve_binary *sbin, const struct sieve_extension *ext)
+{
+	struct sieve_binary_block *block;	
+	unsigned int block_id;
+	struct sieve_binary_extension_reg *ereg = 
+		sieve_binary_extension_get_reg(sbin, ext, TRUE);
+	
+	i_assert(ereg != NULL);
+
+	block = p_new(sbin->pool, struct sieve_binary_block, 1);
+	block->buffer = buffer_create_dynamic(sbin->pool, 64);
+
+	block_id = sieve_binary_block_add(sbin, block);
+	
+	if ( ereg->block_id < SBIN_SYSBLOCK_LAST )
+		ereg->block_id = block_id;
+	block->ext_index = ereg->index;
+	
+	return block_id;
+}
+
+unsigned int sieve_binary_extension_get_block
+(struct sieve_binary *sbin, const struct sieve_extension *ext)
+{
+	struct sieve_binary_extension_reg *ereg = 
+		sieve_binary_extension_get_reg(sbin, ext, TRUE);
+		
+	i_assert(ereg != NULL);
+
+	return ereg->block_id;
+}
+
+static inline int sieve_binary_extension_register
+(struct sieve_binary *sbin, const struct sieve_extension *ext, 
+	struct sieve_binary_extension_reg **reg_r) 
+{
+	struct sieve_binary_extension_reg *ereg;
+
+	if ( (ereg=sieve_binary_extension_get_reg(sbin, ext, FALSE)) == NULL ) {
+		ereg = sieve_binary_extension_create_reg(sbin, ext);
+		
+		if ( ereg == NULL ) return -1;
+
+		array_append(&sbin->linked_extensions, &ereg, 1);
+	}
+
+	if ( reg_r != NULL ) *reg_r = ereg;
+	return ereg->index;
+}
+
+int sieve_binary_extension_link
+(struct sieve_binary *sbin, const struct sieve_extension *ext) 
+{	
+	return sieve_binary_extension_register(sbin, ext, NULL);
+}
+
+static inline const struct sieve_extension *_sieve_binary_extension_get_by_index
+(struct sieve_binary *sbin, int index) 
+{
+	struct sieve_binary_extension_reg * const *ext;
+	
+	if ( index < (int) array_count(&sbin->extensions) ) {
+		ext = array_idx(&sbin->extensions, (unsigned int) index);
+		
+		return (*ext)->extension;
+	}
+	
+	return NULL;
+}
+
+const struct sieve_extension *sieve_binary_extension_get_by_index
+(struct sieve_binary *sbin, int index)
+{
+	return _sieve_binary_extension_get_by_index(sbin, index);
+}
+
+int sieve_binary_extension_get_index
+	(struct sieve_binary *sbin, const struct sieve_extension *ext) 
+{
+	struct sieve_binary_extension_reg *ereg =
+		sieve_binary_extension_get_reg(sbin, ext, FALSE);
+	
+	return ( ereg == NULL ? -1 : ereg->index );
+}
+
+int sieve_binary_extensions_count(struct sieve_binary *sbin) 
+{
+	return (int) array_count(&sbin->extensions);
+}
+
+/*
+ * Emission functions
+ */
+
+/* Low-level emission functions */
+
+static inline void _sieve_binary_emit_data
+(struct sieve_binary *sbin, const void *data, sieve_size_t size) 
+{	  
+	buffer_append(sbin->data, data, size);
+}
+
+static inline void _sieve_binary_emit_byte
+(struct sieve_binary *sbin, unsigned char byte)
+{
+    _sieve_binary_emit_data(sbin, &byte, 1);
+}
+
+static inline void _sieve_binary_update_data
+(struct sieve_binary *sbin, sieve_size_t address, const void *data, 
+	sieve_size_t size) 
+{
+	buffer_write(sbin->data, address, data, size);
+}
+
+sieve_size_t sieve_binary_emit_data
+(struct sieve_binary *sbin, const void *data, sieve_size_t size)
+{
+	sieve_size_t address = _sieve_binary_get_code_size(sbin);
+
+	_sieve_binary_emit_data(sbin, data, size);
+
+	return address;
+}
+
+sieve_size_t sieve_binary_emit_byte
+(struct sieve_binary *sbin, unsigned char byte) 
+{
+	sieve_size_t address = _sieve_binary_get_code_size(sbin);
+
+	_sieve_binary_emit_data(sbin, &byte, 1);
+	
+	return address;
+}
+
+void sieve_binary_update_data
+(struct sieve_binary *sbin, sieve_size_t address, const void *data, 
+	sieve_size_t size) 
+{
+	_sieve_binary_update_data(sbin, address, data, size);
+}
+
+/* Offset emission functions */
+
+sieve_size_t sieve_binary_emit_offset(struct sieve_binary *binary, int offset) 
+{
+	int i;
+	sieve_size_t address = _sieve_binary_get_code_size(binary);
+
+	for ( i = 3; i >= 0; i-- ) {
+		char c = (char) (offset >> (i * 8));
+		_sieve_binary_emit_data(binary, &c, 1);
+	}
+	
+	return address;
+}
+
+void sieve_binary_resolve_offset
+	(struct sieve_binary *binary, sieve_size_t address) 
+{
+	int i;
+	int offset = _sieve_binary_get_code_size(binary) - address; 
+	
+	for ( i = 3; i >= 0; i-- ) {
+		char c = (char) (offset >> (i * 8));	
+		_sieve_binary_update_data(binary, address + 3 - i, &c, 1);
+	}
+}
+
+/* Literal emission */
+
+/* FIXME: this integer format is compact, but it might be too slow. 
+ */
+
+sieve_size_t sieve_binary_emit_integer
+(struct sieve_binary *binary, sieve_number_t integer)
+{
+	sieve_size_t address = _sieve_binary_get_code_size(binary);
+	int i;
+	char buffer[sizeof(sieve_number_t) + 1];
+	int bufpos = sizeof(buffer) - 1;
+  
+	buffer[bufpos] = integer & 0x7F;
+	bufpos--;
+	integer >>= 7;
+	while ( integer > 0 ) {
+		buffer[bufpos] = integer & 0x7F;
+		bufpos--;
+		integer >>= 7;  
+	}
+  
+	bufpos++;
+	if ( (sizeof(buffer) - bufpos) > 1 ) { 
+		for ( i = bufpos; i < ((int) sizeof(buffer) - 1); i++) {
+			buffer[i] |= 0x80;
+		}
+	} 
+  
+	_sieve_binary_emit_data(binary, buffer + bufpos, sizeof(buffer) - bufpos);
+
+	return address;
+}
+
+static inline sieve_size_t sieve_binary_emit_dynamic_data
+	(struct sieve_binary *binary, const void *data, sieve_size_t size)
+{
+	sieve_size_t address = sieve_binary_emit_integer(binary, (sieve_number_t) size);
+
+	_sieve_binary_emit_data(binary, data, size);
+  
+	return address;
+}
+
+sieve_size_t sieve_binary_emit_cstring
+	(struct sieve_binary *binary, const char *str)
+{
+	sieve_size_t address = sieve_binary_emit_dynamic_data
+		(binary, (void *) str, (sieve_size_t) strlen(str));
+	_sieve_binary_emit_byte(binary, 0);
+  
+	return address;
+}
+
+sieve_size_t sieve_binary_emit_string
+	(struct sieve_binary *binary, const string_t *str)
+{
+	sieve_size_t address = sieve_binary_emit_dynamic_data
+		(binary, (void *) str_data(str), (sieve_size_t) str_len(str));
+	_sieve_binary_emit_byte(binary, 0);
+	
+	return address;
+}
+
+/*
+ * Extension emission
+ */
+
+sieve_size_t sieve_binary_emit_extension
+(struct sieve_binary *sbin, const struct sieve_extension *ext,
+	unsigned int offset)
+{
+	sieve_size_t address = _sieve_binary_get_code_size(sbin);
+	struct sieve_binary_extension_reg *ereg = NULL;
+
+	(void)sieve_binary_extension_register(sbin, ext, &ereg);
+
+	i_assert(ereg != NULL);
+
+   	_sieve_binary_emit_byte(sbin, offset + ereg->index);
+	return address;
+}
+
+void sieve_binary_emit_extension_object
+(struct sieve_binary *sbin, const struct sieve_extension_objects *objs,
+	unsigned int code)
+{
+	if ( objs->count > 1 )
+		_sieve_binary_emit_byte(sbin, code);
+}
+
+/*
+ * Code retrieval
+ */
+ 
+#define ADDR_CODE_AT(binary, address) ((signed char) ((binary)->code[*address]))
+#define ADDR_DATA_AT(binary, address) ((unsigned char) ((binary)->code[*address]))
+#define ADDR_POINTER(binary, address) ((const char *) (&(binary)->code[*address]))
+#define ADDR_BYTES_LEFT(binary, address) ((binary)->code_size - (*address))
+#define ADDR_JUMP(address, offset) (*address) += offset
+
+/* Literals */
+
+bool sieve_binary_read_byte
+	(struct sieve_binary *binary, sieve_size_t *address, unsigned int *byte_r) 
+{	
+	if ( ADDR_BYTES_LEFT(binary, address) >= 1 ) {
+		if ( byte_r != NULL )
+			*byte_r = ADDR_DATA_AT(binary, address);
+		ADDR_JUMP(address, 1);
+			
+		return TRUE;
+	}
+	
+	*byte_r = 0;
+	return FALSE;
+}
+
+bool sieve_binary_read_code
+	(struct sieve_binary *binary, sieve_size_t *address, signed int *code_r) 
+{	
+	if ( ADDR_BYTES_LEFT(binary, address) >= 1 ) {
+		if ( code_r != NULL )
+			*code_r = ADDR_CODE_AT(binary, address);
+		ADDR_JUMP(address, 1);
+			
+		return TRUE;
+	}
+	
+	*code_r = 0;
+	return FALSE;
+}
+
+
+bool sieve_binary_read_offset
+	(struct sieve_binary *binary, sieve_size_t *address, int *offset_r) 
+{
+	uint32_t offs = 0;
+	
+	if ( ADDR_BYTES_LEFT(binary, address) >= 4 ) {
+		int i; 
+	  
+		for ( i = 0; i < 4; i++ ) {
+			offs = (offs << 8) + ADDR_DATA_AT(binary, address);
+			ADDR_JUMP(address, 1);
+		}
+	  
+		if ( offset_r != NULL )
+			*offset_r = (int) offs;
+			
+		return TRUE;
+	}
+	
+	return FALSE;
+}
+
+/* FIXME: might need negative numbers in the future */
+bool sieve_binary_read_integer
+  (struct sieve_binary *binary, sieve_size_t *address, sieve_number_t *int_r) 
+{
+	int bits = sizeof(sieve_number_t) * 8;
+	*int_r = 0;
+  
+	if ( ADDR_BYTES_LEFT(binary, address) == 0 )
+		return FALSE;
+  
+	while ( (ADDR_DATA_AT(binary, address) & 0x80) > 0 ) {
+		if ( ADDR_BYTES_LEFT(binary, address) > 0 && bits > 0) {
+			*int_r |= ADDR_DATA_AT(binary, address) & 0x7F;
+			ADDR_JUMP(address, 1);
+    
+			*int_r <<= 7;
+			bits -= 7;
+		} else {
+			/* This is an error */
+			return FALSE;
+		}
+	}
+  
+	*int_r |= ADDR_DATA_AT(binary, address) & 0x7F;
+	ADDR_JUMP(address, 1);
+  
+	return TRUE;
+}
+
+bool sieve_binary_read_string
+(struct sieve_binary *binary, sieve_size_t *address, string_t **str_r) 
+{
+	unsigned int strlen = 0;
+  
+	if ( !sieve_binary_read_unsigned(binary, address, &strlen) ) 
+		return FALSE;
+    	  
+	if ( strlen > ADDR_BYTES_LEFT(binary, address) ) 
+		return FALSE;
+ 
+ 	if ( str_r != NULL )  
+		*str_r = t_str_new_const(ADDR_POINTER(binary, address), strlen);
+	ADDR_JUMP(address, strlen);
+	
+	if ( ADDR_CODE_AT(binary, address) != 0 )
+		return FALSE;
+	
+	ADDR_JUMP(address, 1);
+  
+	return TRUE;
+}
+
+bool sieve_binary_read_extension
+(struct sieve_binary *sbin, sieve_size_t *address, unsigned int *offset_r,
+	const struct sieve_extension **ext_r)
+{
+	unsigned int code;
+	unsigned int offset = *offset_r;
+	const struct sieve_extension *ext = NULL;
+
+	if ( ADDR_BYTES_LEFT(sbin, address) <= 0 )
+		return FALSE;
+
+	(*offset_r) = code = ADDR_DATA_AT(sbin, address);
+	ADDR_JUMP(address, 1);
+
+	if ( code >= offset ) {
+		ext = _sieve_binary_extension_get_by_index(sbin, code - offset);
+		
+		if ( ext == NULL ) 
+			return FALSE;
+	}
+
+	(*ext_r) = ext;
+
+	return TRUE;
+}
+
+const void *sieve_binary_read_extension_object
+(struct sieve_binary *sbin, sieve_size_t *address, 
+	const struct sieve_extension_objects *objs)
+{
+	unsigned int code;
+
+	if ( objs->count == 0 ) 
+		return NULL;
+
+	if ( objs->count == 1 )
+		return objs->objects;
+
+	if ( ADDR_BYTES_LEFT(sbin, address) <= 0 )
+		return NULL;
+
+	code = ADDR_DATA_AT(sbin, address);
+	ADDR_JUMP(address, 1);	
+
+	if ( code >= objs->count )
+		return NULL;
+
+	return ((const void *const *) objs->objects)[code];
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-binary-dumper.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-binary-dumper.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-binary-dumper.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-binary-dumper.c	2009-04-10 17:48:29.000000000 +0200
@@ -0,0 +1,153 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "ostream.h"
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-binary.h"
+
+#include "sieve-dump.h"
+
+/*
+ * Binary dumper object
+ */ 
+ 
+struct sieve_binary_dumper {
+	pool_t pool;
+	
+	/* Dumptime environment */
+	struct sieve_dumptime_env dumpenv; 
+};
+
+struct sieve_binary_dumper *sieve_binary_dumper_create
+	(struct sieve_binary *sbin) 
+{
+	pool_t pool;
+	struct sieve_binary_dumper *dumper;
+	
+	pool = pool_alloconly_create("sieve_binary_dumper", 4096);	
+	dumper = p_new(pool, struct sieve_binary_dumper, 1);
+	dumper->pool = pool;
+	dumper->dumpenv.dumper = dumper;
+	
+	dumper->dumpenv.sbin = sbin;
+	sieve_binary_ref(sbin);
+	
+	return dumper;
+}
+
+void sieve_binary_dumper_free(struct sieve_binary_dumper **dumper) 
+{
+	sieve_binary_unref(&(*dumper)->dumpenv.sbin);
+	pool_unref(&((*dumper)->pool));
+	
+	*dumper = NULL;
+}
+
+pool_t sieve_binary_dumper_pool(struct sieve_binary_dumper *dumper)
+{
+	return dumper->pool;
+}
+
+/* 
+ * Formatted output 
+ */
+
+void sieve_binary_dumpf
+(const struct sieve_dumptime_env *denv, const char *fmt, ...)
+{ 
+	string_t *outbuf = t_str_new(128);
+	va_list args;
+	
+	va_start(args, fmt);			
+	str_vprintfa(outbuf, fmt, args);
+	va_end(args);
+	
+	o_stream_send(denv->stream, str_data(outbuf), str_len(outbuf));
+}
+
+void sieve_binary_dump_sectionf
+(const struct sieve_dumptime_env *denv, const char *fmt, ...)
+{
+	string_t *outbuf = t_str_new(128);
+	va_list args;
+	
+	va_start(args, fmt);			
+	str_printfa(outbuf, "\n* ");
+	str_vprintfa(outbuf, fmt, args);
+	str_printfa(outbuf, ":\n\n");
+	va_end(args);
+	
+	o_stream_send(denv->stream, str_data(outbuf), str_len(outbuf));
+}
+
+/* 
+ * Dumping the binary
+ */
+
+bool sieve_binary_dumper_run
+(struct sieve_binary_dumper *dumper, struct ostream *stream) 
+{	
+	struct sieve_binary *sbin = dumper->dumpenv.sbin;
+	struct sieve_dumptime_env *denv = &(dumper->dumpenv);
+	int count, i;
+	
+	dumper->dumpenv.stream = stream;
+	
+	/* Dump list of used extensions */
+	
+	count = sieve_binary_extensions_count(sbin);
+	if ( count > 0 ) {
+		sieve_binary_dump_sectionf(denv, "Required extensions");
+	
+		for ( i = 0; i < count; i++ ) {
+			const struct sieve_extension *ext = sieve_binary_extension_get_by_index
+				(sbin, i);
+			sieve_binary_dumpf(denv, "%3d: %s (%d)\n", i, ext->name, SIEVE_EXT_ID(ext));
+		}
+	}
+
+	/* Dump extension-specific elements of the binary */
+	
+	count = sieve_binary_extensions_count(sbin);
+	if ( count > 0 ) {	
+		for ( i = 0; i < count; i++ ) {
+			bool success = TRUE;
+
+			T_BEGIN { 
+				const struct sieve_extension *ext = sieve_binary_extension_get_by_index
+					(sbin, i);
+	
+				if ( ext->binary_dump != NULL ) {	
+					success = ext->binary_dump(denv);
+				}
+			} T_END;
+
+			if ( !success ) return FALSE;
+		}
+	}
+	
+	/* Dump main program */
+	
+	sieve_binary_dump_sectionf(denv, "Main program (block: %d)", SBIN_SYSBLOCK_MAIN_PROGRAM);
+
+	if ( !sieve_binary_block_set_active(sbin, SBIN_SYSBLOCK_MAIN_PROGRAM, NULL) ) {
+        return FALSE;
+	}
+
+	dumper->dumpenv.cdumper = sieve_code_dumper_create(&(dumper->dumpenv));
+
+	if ( dumper->dumpenv.cdumper != NULL ) {
+		sieve_code_dumper_run(dumper->dumpenv.cdumper);
+		
+		sieve_code_dumper_free(&dumper->dumpenv.cdumper);
+	}
+	
+	/* Finish with empty line */
+	sieve_binary_dumpf(denv, "\n");
+
+	return TRUE;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-binary-dumper.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-binary-dumper.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-binary-dumper.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-binary-dumper.h	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,40 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_BINARY_DUMPER_H
+#define __SIEVE_BINARY_DUMPER_H
+
+#include "sieve-common.h"
+
+/*
+ * Binary dumper object
+ */
+
+struct sieve_binary_dumper;
+
+struct sieve_binary_dumper *sieve_binary_dumper_create
+	(struct sieve_binary *sbin);
+void sieve_binary_dumper_free
+	(struct sieve_binary_dumper **dumper);
+
+pool_t sieve_binary_dumper_pool
+	(struct sieve_binary_dumper *dumper);
+
+/* 
+ * Formatted output 
+ */
+
+void sieve_binary_dumpf
+	(const struct sieve_dumptime_env *denv, const char *fmt, ...);
+void sieve_binary_dump_sectionf
+	(const struct sieve_dumptime_env *denv, const char *fmt, ...);
+
+/*
+ * Dumping the binary
+ */
+
+bool sieve_binary_dumper_run
+	(struct sieve_binary_dumper *dumper, struct ostream *stream);
+
+
+#endif /* __SIEVE_BINARY_DUMPER_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-binary.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-binary.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-binary.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-binary.h	2009-08-05 13:07:32.000000000 +0200
@@ -0,0 +1,194 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_BINARY_H
+#define __SIEVE_BINARY_H
+
+#include "lib.h"
+
+#include "sieve-common.h"
+
+/*
+ * Binary object
+ */
+ 
+struct sieve_binary;
+
+struct sieve_binary *sieve_binary_create_new(struct sieve_script *script);
+void sieve_binary_ref(struct sieve_binary *sbin);
+void sieve_binary_unref(struct sieve_binary **sbin);
+
+/*
+ * Accessors
+ */
+
+pool_t sieve_binary_pool(struct sieve_binary *sbin);
+struct sieve_script *sieve_binary_script(struct sieve_binary *sbin);
+const char *sieve_binary_path(struct sieve_binary *sbin);
+bool sieve_binary_script_older
+	(struct sieve_binary *sbin, struct sieve_script *script);
+
+const char *sieve_binary_script_name(struct sieve_binary *sbin);
+const char *sieve_binary_script_path(struct sieve_binary *sbin);
+
+/*
+ * Activation after code generation
+ */ 
+ 
+void sieve_binary_activate(struct sieve_binary *sbin);
+
+/* 
+ * Saving the binary
+ */
+ 
+bool sieve_binary_save
+	(struct sieve_binary *sbin, const char *path);
+	
+/* 
+ * Loading the binary
+ */ 
+	
+struct sieve_binary *sieve_binary_open
+	(const char *path, struct sieve_script *script);
+bool sieve_binary_up_to_date(struct sieve_binary *sbin);
+bool sieve_binary_load(struct sieve_binary *sbin);
+	
+/* 
+ * Block management 
+ */
+ 
+enum sieve_binary_system_block {
+	SBIN_SYSBLOCK_EXTENSIONS,
+	SBIN_SYSBLOCK_MAIN_PROGRAM,
+	SBIN_SYSBLOCK_LAST
+};
+
+bool sieve_binary_block_set_active
+	(struct sieve_binary *sbin, unsigned int id, unsigned *old_id_r);
+unsigned int sieve_binary_block_create(struct sieve_binary *sbin);
+void sieve_binary_block_clear
+	(struct sieve_binary *sbin, unsigned int id);
+	
+/* 
+ * Extension support 
+ */
+ 
+struct sieve_binary_extension {
+	const struct sieve_extension *extension;
+
+	bool (*binary_save)(struct sieve_binary *sbin);
+	bool (*binary_open)(struct sieve_binary *sbin);
+	
+	void (*binary_free)(struct sieve_binary *sbin);
+	
+	bool (*binary_up_to_date)(struct sieve_binary *sbin);
+};
+ 
+void sieve_binary_extension_set_context
+	(struct sieve_binary *sbin, const struct sieve_extension *ext, void *context);
+const void *sieve_binary_extension_get_context
+	(struct sieve_binary *sbin, const struct sieve_extension *ext);
+	
+void sieve_binary_extension_set
+	(struct sieve_binary *sbin, const struct sieve_binary_extension *bext,
+		void *context);
+
+unsigned int sieve_binary_extension_create_block
+	(struct sieve_binary *sbin, const struct sieve_extension *ext);
+unsigned int sieve_binary_extension_get_block
+(struct sieve_binary *sbin, const struct sieve_extension *ext);
+
+int sieve_binary_extension_link
+	(struct sieve_binary *sbin, const struct sieve_extension *ext);
+const struct sieve_extension *sieve_binary_extension_get_by_index
+	(struct sieve_binary *sbin, int index);
+int sieve_binary_extension_get_index
+	(struct sieve_binary *sbin, const struct sieve_extension *ext);
+int sieve_binary_extensions_count(struct sieve_binary *sbin);
+
+	
+/* 
+ * Code emission 
+ */
+ 
+/* Low-level emission functions */
+
+sieve_size_t sieve_binary_emit_data
+	(struct sieve_binary *binary, const void *data, sieve_size_t size);
+sieve_size_t sieve_binary_emit_byte
+	(struct sieve_binary *binary, unsigned char byte);
+void sieve_binary_update_data
+	(struct sieve_binary *binary, sieve_size_t address, const void *data, 
+		sieve_size_t size);
+sieve_size_t sieve_binary_get_code_size(struct sieve_binary *binary);
+
+/* Offset emission functions */
+
+sieve_size_t sieve_binary_emit_offset
+	(struct sieve_binary *binary, int offset);
+void sieve_binary_resolve_offset
+	(struct sieve_binary *binary, sieve_size_t address);
+
+/* Literal emission functions */
+
+sieve_size_t sieve_binary_emit_integer
+	(struct sieve_binary *binary, sieve_number_t integer);
+sieve_size_t sieve_binary_emit_string
+	(struct sieve_binary *binary, const string_t *str);
+sieve_size_t sieve_binary_emit_cstring
+	(struct sieve_binary *binary, const char *str);
+
+static inline sieve_size_t sieve_binary_emit_unsigned
+	(struct sieve_binary *binary, unsigned int count)
+{
+	return sieve_binary_emit_integer(binary, count);
+}
+
+
+/* Extension emission functions */
+
+sieve_size_t sieve_binary_emit_extension
+	(struct sieve_binary *sbin, const struct sieve_extension *ext,
+		unsigned int offset);
+void sieve_binary_emit_extension_object
+	(struct sieve_binary *sbin, const struct sieve_extension_objects *objs,
+    	unsigned int code);
+
+/* 
+ * Code retrieval 
+ */
+
+/* Literals */
+bool sieve_binary_read_byte
+	(struct sieve_binary *binary, sieve_size_t *address, unsigned int *byte_r);
+bool sieve_binary_read_code
+	(struct sieve_binary *binary, sieve_size_t *address, signed int *code_r);
+bool sieve_binary_read_offset
+	(struct sieve_binary *binary, sieve_size_t *address, int *offset_r);
+bool sieve_binary_read_integer
+  (struct sieve_binary *binary, sieve_size_t *address, sieve_number_t *int_r); 
+bool sieve_binary_read_string
+  (struct sieve_binary *binary, sieve_size_t *address, string_t **str_r);
+
+static inline bool sieve_binary_read_unsigned
+  (struct sieve_binary *binary, sieve_size_t *address, unsigned int *count_r)
+{
+	sieve_number_t integer;
+
+	if ( !sieve_binary_read_integer(binary, address, &integer) )
+		return FALSE;
+
+	*count_r = integer;
+
+	return TRUE;
+}
+
+/* Extension */
+bool sieve_binary_read_extension
+	(struct sieve_binary *sbin, sieve_size_t *address, unsigned int *offset_r,
+		const struct sieve_extension **ext_r);
+const void *sieve_binary_read_extension_object
+	(struct sieve_binary *binary, sieve_size_t *address,
+    	const struct sieve_extension_objects *objs);
+
+#endif
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve.c	2009-08-04 19:31:14.000000000 +0200
@@ -0,0 +1,609 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "istream.h"
+#include "buffer.h"
+
+#include "sieve-extensions.h"
+
+#include "sieve-script.h"
+#include "sieve-ast.h"
+#include "sieve-binary.h"
+#include "sieve-actions.h"
+#include "sieve-result.h"
+
+#include "sieve-parser.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-binary-dumper.h"
+
+#include "sieve.h"
+#include "sieve-common.h"
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <dirent.h>
+
+/* 
+ * Main Sieve library interface
+ */
+
+bool sieve_init(void)
+{
+	return sieve_extensions_init();
+}
+
+void sieve_deinit(void)
+{
+	sieve_extensions_deinit();
+}
+
+void sieve_set_extensions(const char *extensions)
+{
+	sieve_extensions_set_string(extensions);
+}
+
+const char *sieve_get_capabilities(const char *name) 
+{
+	if ( name == NULL || *name == '\0' )
+		return sieve_extensions_get_string();
+	
+	return sieve_extension_capabilities_get_string(name);
+}
+
+/*
+ * Low-level compiler functions 
+ */
+
+struct sieve_ast *sieve_parse
+	(struct sieve_script *script, struct sieve_error_handler *ehandler)
+{
+	struct sieve_parser *parser;
+	struct sieve_ast *ast = NULL;
+	
+	/* Parse */
+	if ( (parser = sieve_parser_create(script, ehandler)) == NULL )
+		return NULL;
+
+ 	if ( !sieve_parser_run(parser, &ast) || sieve_get_errors(ehandler) > 0 ) {
+ 		ast = NULL;
+ 	} else 
+		sieve_ast_ref(ast);
+	
+	sieve_parser_free(&parser); 	
+	
+	return ast;
+}
+
+bool sieve_validate(struct sieve_ast *ast, struct sieve_error_handler *ehandler)
+{
+	bool result = TRUE;
+	struct sieve_validator *validator = sieve_validator_create(ast, ehandler);
+		
+	if ( !sieve_validator_run(validator) || sieve_get_errors(ehandler) > 0 ) 
+		result = FALSE;
+	
+	sieve_validator_free(&validator);	
+		
+	return result;
+}
+
+static struct sieve_binary *sieve_generate
+	(struct sieve_ast *ast, struct sieve_error_handler *ehandler)
+{
+	struct sieve_generator *generator = sieve_generator_create(ast, ehandler);
+	struct sieve_binary *sbin = NULL;
+		
+	(void) sieve_generator_run(generator, &sbin);
+	
+	sieve_generator_free(&generator);
+	
+	return sbin;
+}
+
+/*
+ * Sieve compilation
+ */
+
+struct sieve_binary *sieve_compile_script
+(struct sieve_script *script, struct sieve_error_handler *ehandler) 
+{
+	struct sieve_ast *ast;
+	struct sieve_binary *sbin;		
+  	
+	/* Parse */
+	if ( (ast = sieve_parse(script, ehandler)) == NULL ) {
+ 		sieve_error(ehandler, sieve_script_name(script), "parse failed");
+		return NULL;
+	}
+
+	/* Validate */
+	if ( !sieve_validate(ast, ehandler) ) {
+		sieve_error(ehandler, sieve_script_name(script), "validation failed");
+		
+ 		sieve_ast_unref(&ast);
+ 		return NULL;
+ 	}
+ 	
+	/* Generate */
+	if ( (sbin=sieve_generate(ast, ehandler)) == NULL ) {
+		sieve_error(ehandler, sieve_script_name(script), "code generation failed");
+		
+		sieve_ast_unref(&ast);
+		return NULL;
+	}
+	
+	/* Cleanup */
+	sieve_ast_unref(&ast);
+
+	return sbin;
+}
+
+struct sieve_binary *sieve_compile
+(const char *script_path, const char *script_name, 
+	struct sieve_error_handler *ehandler)
+{
+	struct sieve_script *script;
+	struct sieve_binary *sbin;
+
+	if ( (script = sieve_script_create
+		(script_path, script_name, ehandler, NULL)) == NULL )
+		return NULL;
+	
+	sbin = sieve_compile_script(script, ehandler);
+	
+	sieve_script_unref(&script);
+	
+	return sbin;
+}
+
+/*
+ * Sieve runtime
+ */
+
+static int sieve_run
+(struct sieve_binary *sbin, struct sieve_result **result, 
+	const struct sieve_message_data *msgdata, const struct sieve_script_env *senv, 
+	struct sieve_error_handler *ehandler)
+{
+	struct sieve_interpreter *interp;
+	int ret = 0;
+
+	/* Create the interpreter */
+	if ( (interp=sieve_interpreter_create(sbin, ehandler)) == NULL )
+		return SIEVE_EXEC_BIN_CORRUPT;
+
+	/* Reset execution status */
+	if ( senv->exec_status != NULL )
+		memset(senv->exec_status, 0, sizeof(*senv->exec_status));
+	
+	/* Create result object */
+	if ( *result == NULL )
+		*result = sieve_result_create(msgdata, senv, ehandler);
+	else {
+		sieve_result_ref(*result);
+		sieve_result_set_error_handler(*result, ehandler);
+	}
+							
+	/* Run the interpreter */
+	ret = sieve_interpreter_run(interp, msgdata, senv, *result);
+	
+	/* Free the interpreter */
+	sieve_interpreter_free(&interp);
+
+	return ret;
+}
+
+/*
+ * Reading/writing sieve binaries
+ */
+
+struct sieve_binary *sieve_open
+(const char *script_path, const char *script_name,
+	struct sieve_error_handler *ehandler, bool *exists_r)
+{
+	struct sieve_script *script;
+	struct sieve_binary *sbin;
+	const char *binpath;
+	
+	/* First open the scriptfile itself */
+	script = sieve_script_create(script_path, script_name, ehandler, exists_r);
+
+	if ( script == NULL ) {
+		/* Failed */
+		return NULL;
+	}
+
+	T_BEGIN {
+		/* Then try to open the matching binary */
+		binpath = sieve_script_binpath(script);	
+		sbin = sieve_binary_open(binpath, script);
+	
+		if (sbin != NULL) {
+			/* Ok, it exists; now let's see if it is up to date */
+			if ( !sieve_binary_up_to_date(sbin) ) {
+				/* Not up to date */
+				sieve_binary_unref(&sbin);
+				sbin = NULL;
+			} else if ( !sieve_binary_load(sbin) ) {
+				/* Failed to load */
+				sieve_binary_unref(&sbin);
+				sbin = NULL;
+			}
+		}
+		
+		/* If the binary does not exist, is not up-to-date or fails to load, we need
+		 * to (re-)compile.
+		 */
+		if ( sbin == NULL ) {	
+			sbin = sieve_compile_script(script, ehandler);
+
+			/* Save the binary if compile was successful */
+			if ( sbin != NULL ) 
+				(void) sieve_binary_save(sbin, binpath);	
+		}
+	} T_END;
+	
+	/* Drop script reference, if sbin != NULL it holds a reference of its own. 
+	 * Otherwise the script object is freed here.
+	 */
+	sieve_script_unref(&script);
+
+	return sbin;
+} 
+
+bool sieve_save
+(struct sieve_binary *sbin, const char *bin_path)
+{
+	return sieve_binary_save(sbin, bin_path);
+}
+
+struct sieve_binary *sieve_load
+(const char *bin_path)
+{
+	struct sieve_binary *sbin = sieve_binary_open(bin_path, NULL);
+
+    if ( sbin != NULL && !sieve_binary_load(sbin) ) {
+        sieve_binary_unref(&sbin);
+        sbin = NULL;
+    }
+
+	return sbin;
+}
+
+void sieve_close(struct sieve_binary **sbin)
+{
+	sieve_binary_unref(sbin);
+}
+
+/*
+ * Debugging
+ */
+
+void sieve_dump(struct sieve_binary *sbin, struct ostream *stream) 
+{
+	struct sieve_binary_dumper *dumpr = sieve_binary_dumper_create(sbin);			
+
+	sieve_binary_dumper_run(dumpr, stream);	
+	
+	sieve_binary_dumper_free(&dumpr);
+}
+
+int sieve_test
+(struct sieve_binary *sbin, const struct sieve_message_data *msgdata,
+	const struct sieve_script_env *senv, struct sieve_error_handler *ehandler,
+	struct ostream *stream, bool *keep) 	
+{
+	struct sieve_result *result = NULL;
+	int ret;
+
+	if ( keep != NULL ) *keep = FALSE;
+	
+	/* Run the script */
+	ret = sieve_run(sbin, &result, msgdata, senv, ehandler);
+				
+	/* Print result if successful */
+	if ( ret > 0 ) {
+		ret = sieve_result_print(result, senv, stream, keep);
+	} else if ( ret == 0 ) {
+		if ( keep != NULL ) *keep = TRUE;
+	}
+	
+	/* Cleanup */
+	sieve_result_unref(&result);
+	
+	return ret;
+}
+
+/*
+ * Script execution
+ */
+
+int sieve_execute
+(struct sieve_binary *sbin, const struct sieve_message_data *msgdata,
+	const struct sieve_script_env *senv, struct sieve_error_handler *ehandler,
+	bool *keep)
+{
+	struct sieve_result *result = NULL;
+	int ret;
+
+	if ( keep != NULL ) *keep = FALSE;
+	
+	/* Run the script */
+	ret = sieve_run(sbin, &result, msgdata, senv, ehandler);
+		
+	/* Evaluate status and execute the result:
+	 *   Strange situations, e.g. currupt binaries, must be handled by the caller. 
+	 *   In that case no implicit keep is attempted, because the situation may be 
+	 *   resolved.
+	 */
+	if ( ret > 0 ) {
+		/* Execute result */
+		ret = sieve_result_execute(result, keep);
+	} else if ( ret == 0 ) {
+		/* Perform implicit keep if script failed with a normal runtime error */
+		if ( !sieve_result_implicit_keep(result) ) {
+			ret = SIEVE_EXEC_KEEP_FAILED;
+		} else {
+			if ( keep != NULL ) *keep = TRUE;
+		}
+	}
+	
+	/* Cleanup */
+	sieve_result_unref(&result);
+
+	return ret;
+}
+
+/*
+ * Multiscript support
+ */
+ 
+struct sieve_multiscript {
+	struct sieve_result *result;
+	const struct sieve_message_data *msgdata;
+	const struct sieve_script_env *scriptenv;
+
+	int status;
+	bool active;
+	bool ended;
+	bool keep;
+
+	struct ostream *teststream;
+};
+ 
+struct sieve_multiscript *sieve_multiscript_start_execute
+(const struct sieve_message_data *msgdata, const struct sieve_script_env *senv)
+{
+	pool_t pool;
+	struct sieve_result *result;
+	struct sieve_multiscript *mscript;
+	
+	result = sieve_result_create(msgdata, senv, NULL);
+	pool = sieve_result_pool(result);
+	
+	sieve_result_set_keep_action(result, NULL);
+	
+	mscript = p_new(pool, struct sieve_multiscript, 1);
+	mscript->result = result;
+	mscript->msgdata = msgdata;
+	mscript->scriptenv = senv;
+	mscript->status = SIEVE_EXEC_OK;
+	mscript->active = TRUE;
+	mscript->keep = TRUE;
+	
+	return mscript;
+}
+
+struct sieve_multiscript *sieve_multiscript_start_test
+(const struct sieve_message_data *msgdata, const struct sieve_script_env *senv,
+	struct ostream *stream)
+{
+	struct sieve_multiscript *mscript = 
+		sieve_multiscript_start_execute(msgdata, senv);
+	
+	mscript->teststream = stream;
+
+	return mscript;
+}
+
+static void sieve_multiscript_test
+(struct sieve_multiscript *mscript, struct sieve_error_handler *ehandler,
+	bool *keep)
+{						
+	sieve_result_set_error_handler(mscript->result, ehandler);
+
+	if ( mscript->status > 0 ) {
+		mscript->status = sieve_result_print
+			(mscript->result, mscript->scriptenv, mscript->teststream, keep);
+	} else {
+		if ( keep != NULL ) *keep = TRUE;
+	}
+		
+	mscript->active = ( mscript->active && *keep );
+
+	sieve_result_mark_executed(mscript->result);
+}
+
+static void sieve_multiscript_execute
+(struct sieve_multiscript *mscript, struct sieve_error_handler *ehandler,
+	bool *keep)
+{
+	sieve_result_set_error_handler(mscript->result, ehandler);
+
+	if ( mscript->status > 0 ) {
+		mscript->status = sieve_result_execute(mscript->result, keep);
+	} else {
+		if ( !sieve_result_implicit_keep(mscript->result) )
+			mscript->status = SIEVE_EXEC_KEEP_FAILED;
+		else
+			if ( keep != NULL ) *keep = TRUE;			
+	}
+	
+	mscript->active = ( mscript->active && *keep );
+}
+
+bool sieve_multiscript_run
+(struct sieve_multiscript *mscript, struct sieve_binary *sbin,
+	struct sieve_error_handler *ehandler, bool final)
+{
+	if ( !mscript->active ) return FALSE;
+	
+	if ( final )
+		sieve_result_set_keep_action(mscript->result, &act_store);
+	
+	/* Run the script */
+	mscript->status = sieve_run(sbin, &mscript->result, mscript->msgdata, 
+		mscript->scriptenv, ehandler);
+
+	if ( mscript->status >= 0 ) {
+		mscript->keep = FALSE;
+
+		if ( mscript->teststream != NULL ) 
+			sieve_multiscript_test(mscript, ehandler, &mscript->keep);
+		else
+			sieve_multiscript_execute(mscript, ehandler, &mscript->keep);
+
+		if ( final ) mscript->active = FALSE;
+	}	
+
+	if ( mscript->status <= 0 )
+		return FALSE;
+
+	return mscript->active;
+}
+
+int sieve_multiscript_status(struct sieve_multiscript *mscript)
+{
+	return mscript->status;
+}
+
+int sieve_multiscript_finish(struct sieve_multiscript **mscript, 
+	struct sieve_error_handler *ehandler, bool *keep)
+{
+	struct sieve_result *result = (*mscript)->result;
+	int ret = (*mscript)->status;
+
+	if ( ehandler != NULL )
+		sieve_result_set_error_handler((*mscript)->result, ehandler);	
+
+	if ( (*mscript)->active ) {
+		ret = SIEVE_EXEC_FAILURE;
+
+		if ( (*mscript)->teststream ) {
+			(*mscript)->keep = TRUE;
+		} else {
+			if ( !sieve_result_implicit_keep((*mscript)->result) )
+				ret = SIEVE_EXEC_KEEP_FAILED;
+			else
+				(*mscript)->keep = TRUE;
+		}
+	}
+
+	if ( keep != NULL ) *keep = (*mscript)->keep;
+	
+	/* Cleanup */
+	sieve_result_unref(&result);
+	*mscript = NULL;
+	
+	return ret;
+}
+
+/*
+ * Script directory
+ */
+
+struct sieve_directory {
+		DIR *dirp;
+
+		const char *path;
+};
+
+struct sieve_directory *sieve_directory_open(const char *path)
+{ 
+	struct sieve_directory *sdir = NULL;
+	DIR *dirp;
+	struct stat st;
+
+	/* Specified path can either be a regular file or a directory */
+	if ( stat(path, &st) != 0 )
+		return NULL;
+
+	if ( S_ISDIR(st.st_mode) ) {
+	 	
+		/* Open the directory */
+		if ( (dirp = opendir(path)) == NULL ) {
+			sieve_sys_error("opendir(%s) failed: %m", path);
+			return NULL;		
+		}
+	
+		/* Create object */
+		sdir = t_new(struct sieve_directory, 1);
+		sdir->path = path;
+		sdir->dirp = dirp;
+	} else {
+		sdir = t_new(struct sieve_directory, 1);
+		sdir->path = path;
+		sdir->dirp = NULL;
+	}
+
+	return sdir;
+}
+
+const char *sieve_directory_get_scriptfile(struct sieve_directory *sdir)
+{
+	const char *script = NULL;
+	struct dirent *dp;
+	
+	if ( sdir->dirp != NULL ) {
+		while ( script == NULL ) {
+			const char *file;
+			struct stat st;
+
+			errno = 0;
+			if ( (dp = readdir(sdir->dirp)) == NULL ) {
+				if ( errno != 0 ) { 
+					sieve_sys_error("readdir(%s) failed: %m", sdir->path);
+					continue;
+				} else 
+					return NULL;
+			}
+
+			if ( !sieve_script_file_has_extension(dp->d_name) )
+				continue;
+
+			if ( sdir->path[strlen(sdir->path)-1] == '/' )
+				file = t_strconcat(sdir->path, dp->d_name, NULL);
+			else
+				file = t_strconcat(sdir->path, "/", dp->d_name, NULL);
+
+			if ( stat(file, &st) != 0 || !S_ISREG(st.st_mode) )
+				continue;
+
+			script = file;
+		}
+	} else {
+		script = sdir->path;
+		sdir->path = NULL;		
+	}
+							
+	return script;
+}
+
+void sieve_directory_close(struct sieve_directory **sdir)
+{
+	/* Close the directory */
+	if ( (*sdir)->dirp != NULL && closedir((*sdir)->dirp) < 0 ) 
+		sieve_sys_error("closedir(%s) failed: %m", (*sdir)->path);
+		
+	*sdir = NULL;
+}
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-code.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-code.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-code.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-code.c	2009-08-05 13:08:32.000000000 +0200
@@ -0,0 +1,1026 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#include "lib.h"
+#include "str.h"
+#include "str-sanitize.h"
+
+#include "sieve-common.h"
+#include "sieve-limits.h"
+#include "sieve-extensions.h"
+#include "sieve-actions.h"
+#include "sieve-binary.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "sieve-code.h"
+
+#include <stdio.h>
+
+/* 
+ * Coded stringlist
+ */
+
+struct sieve_coded_stringlist {
+	const struct sieve_runtime_env *runenv;
+	sieve_size_t start_address;
+	sieve_size_t end_address;
+	sieve_size_t current_offset;
+	unsigned int length;
+	unsigned int index;
+};
+
+static struct sieve_coded_stringlist *sieve_coded_stringlist_create
+(const struct sieve_runtime_env *renv, 
+	 sieve_size_t start_address, unsigned int length, sieve_size_t end)
+{
+	struct sieve_coded_stringlist *strlist;
+	
+	if ( end > sieve_binary_get_code_size(renv->sbin) ) 
+  		return NULL;
+    
+	strlist = t_new(struct sieve_coded_stringlist, 1);
+	strlist->runenv = renv;
+	strlist->start_address = start_address;
+	strlist->current_offset = start_address;
+	strlist->end_address = end;
+	strlist->length = length;
+	strlist->index = 0;
+  
+	return strlist;
+}
+
+bool sieve_coded_stringlist_next_item
+(struct sieve_coded_stringlist *strlist, string_t **str_r) 
+{
+	sieve_size_t address;
+	*str_r = NULL;
+  
+	if ( strlist->index >= strlist->length ) 
+		return TRUE;
+	else {
+		address = strlist->current_offset;
+  	
+		if ( sieve_opr_string_read(strlist->runenv, &address, str_r) ) {
+			strlist->index++;
+			strlist->current_offset = address;
+			return TRUE;
+		}
+	}  
+  
+	return FALSE;
+}
+
+void sieve_coded_stringlist_reset(struct sieve_coded_stringlist *strlist) 
+{  
+	strlist->current_offset = strlist->start_address;
+	strlist->index = 0;
+}
+
+unsigned int sieve_coded_stringlist_get_length
+(struct sieve_coded_stringlist *strlist)
+{
+	return strlist->length;
+}
+
+sieve_size_t sieve_coded_stringlist_get_end_address
+(struct sieve_coded_stringlist *strlist)
+{
+	return strlist->end_address;
+}
+
+sieve_size_t sieve_coded_stringlist_get_current_offset
+(struct sieve_coded_stringlist *strlist)
+{
+	return strlist->current_offset;
+}
+
+bool sieve_coded_stringlist_read_all
+(struct sieve_coded_stringlist *strlist, pool_t pool,
+	const char * const **list_r)
+{
+	bool result = FALSE;
+	ARRAY_DEFINE(items, const char *);
+	string_t *item;
+	
+	sieve_coded_stringlist_reset(strlist);
+	
+	p_array_init(&items, pool, 4);
+	
+	item = NULL;
+	while ( (result=sieve_coded_stringlist_next_item(strlist, &item)) && 
+		item != NULL ) {
+		const char *stritem = p_strdup(pool, str_c(item));
+		
+		array_append(&items, &stritem, 1);
+	}
+	
+	(void)array_append_space(&items);
+	*list_r = array_idx(&items, 0);
+
+	return result;
+}
+
+static bool sieve_coded_stringlist_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address, 
+	unsigned int length, sieve_size_t end, const char *field_name)
+{
+	unsigned int i;
+	
+	if ( end > sieve_binary_get_code_size(denv->sbin) ) 
+  		return FALSE;
+    
+	if ( field_name != NULL )
+		sieve_code_dumpf(denv, "%s: STRLIST [%u] (end: %08llx)", 
+			field_name, length, (unsigned long long) end);
+	else
+		sieve_code_dumpf(denv, "STRLIST [%u] (end: %08llx)", 
+			length, (unsigned long long) end);
+	
+	sieve_code_descend(denv);
+	
+	for ( i = 0; i < length; i++ ) {
+		bool success = TRUE;
+
+		T_BEGIN { 		
+			success = sieve_opr_string_dump(denv, address, NULL);
+		} T_END;
+
+		if ( !success || *address > end ) 
+			return FALSE;
+	}
+
+	if ( *address != end ) return FALSE;
+	
+	sieve_code_ascend(denv);
+		
+	return TRUE;
+}
+	
+/*
+ * Source line coding
+ */
+
+void sieve_code_source_line_emit
+(struct sieve_binary *sbin, unsigned int source_line)
+{
+    (void)sieve_binary_emit_unsigned(sbin, source_line);
+}
+
+bool sieve_code_source_line_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+    unsigned int number = 0;
+
+	sieve_code_mark(denv);
+    if (sieve_binary_read_unsigned(denv->sbin, address, &number) ) {
+        sieve_code_dumpf(denv, "(source line: %lu)", (unsigned long) number);
+
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+bool sieve_code_source_line_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address,
+	unsigned int *source_line_r)
+{
+	return sieve_binary_read_unsigned(renv->sbin, address, source_line_r);
+}
+
+/*
+ * Core operands
+ */
+ 
+extern const struct sieve_operand comparator_operand;
+extern const struct sieve_operand match_type_operand;
+extern const struct sieve_operand address_part_operand;
+
+const struct sieve_operand *sieve_operands[] = {
+	&omitted_operand, /* SIEVE_OPERAND_OPTIONAL */
+	&number_operand,
+	&string_operand,
+	&stringlist_operand,
+	&comparator_operand,
+	&match_type_operand,
+	&address_part_operand,
+	&catenated_string_operand
+}; 
+
+const unsigned int sieve_operand_count =
+	N_ELEMENTS(sieve_operands);
+
+/* 
+ * Operand functions 
+ */
+
+sieve_size_t sieve_operand_emit_code
+(struct sieve_binary *sbin, const struct sieve_operand *opr)
+{
+	sieve_size_t address;
+
+	if ( opr->extension != NULL ) {
+		address = sieve_binary_emit_extension
+			(sbin, opr->extension, sieve_operand_count);
+	
+		sieve_binary_emit_extension_object
+			(sbin, &opr->extension->operands, opr->code);
+
+		return address;
+	}
+
+	return  sieve_binary_emit_byte(sbin, opr->code);
+}
+
+const struct sieve_operand *sieve_operand_read
+(struct sieve_binary *sbin, sieve_size_t *address) 
+{
+	const struct sieve_extension *ext;
+	unsigned int code = sieve_operand_count;
+
+	if ( !sieve_binary_read_extension(sbin, address, &code, &ext) )
+		return NULL;
+
+	if ( !ext )
+		return code < sieve_operand_count ? sieve_operands[code] : NULL;
+
+	return (const struct sieve_operand *) sieve_binary_read_extension_object
+		(sbin, address, &ext->operands);
+}
+
+bool sieve_operand_optional_present
+(struct sieve_binary *sbin, sieve_size_t *address)
+{	
+	sieve_size_t tmp_addr = *address;
+	unsigned int op = -1;
+	
+	if ( sieve_binary_read_byte(sbin, &tmp_addr, &op) && 
+		(op == SIEVE_OPERAND_OPTIONAL) ) {
+		*address = tmp_addr;
+		return TRUE;
+	}
+	
+	return FALSE;
+}
+
+bool sieve_operand_optional_read
+(struct sieve_binary *sbin, sieve_size_t *address, signed int *id_code)
+{
+	if ( sieve_binary_read_code(sbin, address, id_code) ) 
+		return TRUE;
+	
+	*id_code = 0;
+
+	return FALSE;
+}
+
+/* 
+ * Operand definitions
+ */
+
+/* Omitted */
+
+const struct sieve_operand_class omitted_class =
+	{ "OMITTED" };
+
+const struct sieve_operand omitted_operand = {
+	"@OMITTED",
+	NULL, SIEVE_OPERAND_OPTIONAL,	
+	&omitted_class, NULL
+};
+ 
+/* Number */
+
+static bool opr_number_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+		const char *field_name);
+static bool opr_number_read
+	(const struct sieve_runtime_env *renv, sieve_size_t *address, 
+		sieve_number_t *number_r);
+
+const struct sieve_opr_number_interface number_interface = { 
+	opr_number_dump, 
+	opr_number_read
+};
+
+const struct sieve_operand_class number_class = 
+	{ "number" };
+	
+const struct sieve_operand number_operand = { 
+	"@number", 
+	NULL, SIEVE_OPERAND_NUMBER,
+	&number_class,
+	&number_interface 
+};
+
+/* String */
+
+static bool opr_string_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+		const char *field_name);
+static bool opr_string_read
+	(const struct sieve_runtime_env *renv, sieve_size_t *address, string_t **str_r);
+
+const struct sieve_opr_string_interface string_interface ={ 
+	opr_string_dump,
+	opr_string_read
+};
+	
+const struct sieve_operand_class string_class = 
+	{ "string" };
+	
+const struct sieve_operand string_operand = { 
+	"@string", 
+	NULL, SIEVE_OPERAND_STRING,
+	&string_class,
+	&string_interface
+};	
+
+/* String List */
+
+static bool opr_stringlist_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+		const char *field_name);
+static struct sieve_coded_stringlist *opr_stringlist_read
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_opr_stringlist_interface stringlist_interface = { 
+	opr_stringlist_dump, 
+	opr_stringlist_read
+};
+
+const struct sieve_operand_class stringlist_class = 
+	{ "string-list" };
+
+const struct sieve_operand stringlist_operand =	{ 
+	"@string-list", 
+	NULL, SIEVE_OPERAND_STRING_LIST,
+	&stringlist_class, 
+	&stringlist_interface
+};
+
+/* Catenated String */
+
+static bool opr_catenated_string_read
+	(const struct sieve_runtime_env *renv, sieve_size_t *address, string_t **str);
+static bool opr_catenated_string_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+		const char *field_name);
+
+const struct sieve_opr_string_interface catenated_string_interface = { 
+	opr_catenated_string_dump,
+	opr_catenated_string_read
+};
+		
+const struct sieve_operand catenated_string_operand = { 
+	"@catenated-string", 
+	NULL, SIEVE_OPERAND_CATENATED_STRING,
+	&string_class,
+	&catenated_string_interface
+};	
+	
+/* 
+ * Operand implementations 
+ */
+
+/* Omitted */
+
+void sieve_opr_omitted_emit(struct sieve_binary *sbin)
+{
+    (void) sieve_operand_emit_code(sbin, &omitted_operand);
+}
+ 
+/* Number */
+
+void sieve_opr_number_emit(struct sieve_binary *sbin, sieve_number_t number) 
+{
+	(void) sieve_operand_emit_code(sbin, &number_operand);
+	(void) sieve_binary_emit_integer(sbin, number);
+}
+
+bool sieve_opr_number_dump_data
+(const struct sieve_dumptime_env *denv, const struct sieve_operand *operand,
+	sieve_size_t *address, const char *field_name) 
+{
+	const struct sieve_opr_number_interface *intf;
+
+	if ( !sieve_operand_is_number(operand) ) 
+		return FALSE;
+		
+	intf = (const struct sieve_opr_number_interface *) operand->interface; 
+	
+	if ( intf->dump == NULL )
+		return FALSE;
+
+	return intf->dump(denv, address, field_name);  
+}
+
+bool sieve_opr_number_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+	const char *field_name) 
+{
+	const struct sieve_operand *operand;
+	
+	sieve_code_mark(denv);
+	
+	operand = sieve_operand_read(denv->sbin, address);
+
+	return sieve_opr_number_dump_data(denv, operand, address, field_name);
+}
+
+bool sieve_opr_number_read_data
+(const struct sieve_runtime_env *renv, const struct sieve_operand *operand,
+	sieve_size_t *address, sieve_number_t *number_r)
+{
+	const struct sieve_opr_number_interface *intf;
+		
+	if ( !sieve_operand_is_number(operand) ) 
+		return FALSE;	
+		
+	intf = (const struct sieve_opr_number_interface *) operand->interface; 
+	
+	if ( intf->read == NULL )
+		return FALSE;
+
+	return intf->read(renv, address, number_r);  
+}
+
+bool sieve_opr_number_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address, 
+	sieve_number_t *number_r)
+{
+	const struct sieve_operand *operand = sieve_operand_read(renv->sbin, address);
+		
+	return sieve_opr_number_read_data(renv, operand, address, number_r);
+}
+
+static bool opr_number_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+	const char *field_name) 
+{
+	sieve_number_t number = 0;
+	
+	if (sieve_binary_read_integer(denv->sbin, address, &number) ) {
+		if ( field_name != NULL ) 
+			sieve_code_dumpf(denv, "%s: NUM %llu", field_name, (unsigned long long) number);
+		else
+			sieve_code_dumpf(denv, "NUM %llu", (unsigned long long) number);
+
+		return TRUE;
+	}
+	
+	return FALSE;
+}
+
+static bool opr_number_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address, 
+	sieve_number_t *number_r)
+{ 
+	return sieve_binary_read_integer(renv->sbin, address, number_r);
+}
+
+/* String */
+
+void sieve_opr_string_emit(struct sieve_binary *sbin, string_t *str)
+{
+	(void) sieve_operand_emit_code(sbin, &string_operand);
+	(void) sieve_binary_emit_string(sbin, str);
+}
+
+bool sieve_opr_string_dump_data
+(const struct sieve_dumptime_env *denv, const struct sieve_operand *operand,
+	sieve_size_t *address, const char *field_name) 
+{
+	const struct sieve_opr_string_interface *intf;
+	
+	if ( !sieve_operand_is_string(operand) ) {
+		sieve_code_dumpf(denv, "ERROR: INVALID STRING OPERAND %s", operand->name);
+		return FALSE;
+	}
+		
+	intf = (const struct sieve_opr_string_interface *) operand->interface; 
+	
+	if ( intf->dump == NULL ) {
+		sieve_code_dumpf(denv, "ERROR: DUMP STRING OPERAND");
+		return FALSE;
+	}
+
+	return intf->dump(denv, address, field_name);  
+}
+
+bool sieve_opr_string_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+	const char *field_name) 
+{
+	const struct sieve_operand *operand;
+	
+	sieve_code_mark(denv);
+	operand = sieve_operand_read(denv->sbin, address);
+	
+	if ( operand == NULL ) {
+		sieve_code_dumpf(denv, "ERROR: INVALID OPERAND");
+		return FALSE;
+	}
+
+	return sieve_opr_string_dump_data(denv, operand, address, field_name);
+}
+
+bool sieve_opr_string_dump_ex
+(const struct sieve_dumptime_env *denv, sieve_size_t *address, 
+	const char *field_name, bool *literal_r)
+{
+	const struct sieve_operand *operand;
+	
+	sieve_code_mark(denv);
+	operand = sieve_operand_read(denv->sbin, address);
+
+	*literal_r = ( operand == &string_operand );	
+
+	return sieve_opr_string_dump_data(denv, operand, address, field_name);
+} 
+
+bool sieve_opr_string_read_data
+(const struct sieve_runtime_env *renv, const struct sieve_operand *operand,
+	sieve_size_t *address, string_t **str_r)
+{
+	const struct sieve_opr_string_interface *intf;
+	
+	if ( operand == NULL || operand->class != &string_class ) 
+		return FALSE;
+		
+	intf = (const struct sieve_opr_string_interface *) operand->interface; 
+	
+	if ( intf->read == NULL )
+		return FALSE;
+
+	return intf->read(renv, address, str_r);  
+}
+
+bool sieve_opr_string_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address, string_t **str_r)
+{
+	const struct sieve_operand *operand = sieve_operand_read(renv->sbin, address);
+
+	return sieve_opr_string_read_data(renv, operand, address, str_r);
+}
+
+bool sieve_opr_string_read_ex
+(const struct sieve_runtime_env *renv, sieve_size_t *address, string_t **str_r,
+	bool *literal_r)
+{
+	const struct sieve_operand *operand = sieve_operand_read(renv->sbin, address);
+
+	*literal_r = ( operand == &string_operand );
+
+	return sieve_opr_string_read_data(renv, operand, address, str_r);
+}
+
+static void _dump_string
+(const struct sieve_dumptime_env *denv, string_t *str, 
+	const char *field_name) 
+{
+	if ( str_len(str) > 80 ) {
+		if ( field_name != NULL ) 
+			sieve_code_dumpf(denv, "%s: STR[%ld] \"%s", 
+				field_name, (long) str_len(str), str_sanitize(str_c(str), 80));
+		else
+			sieve_code_dumpf(denv, "STR[%ld] \"%s", 
+				(long) str_len(str), str_sanitize(str_c(str), 80));
+	} else {
+		if ( field_name != NULL )
+			sieve_code_dumpf(denv, "%s: STR[%ld] \"%s\"", 
+				field_name, (long) str_len(str), str_sanitize(str_c(str), 80));		
+		else
+			sieve_code_dumpf(denv, "STR[%ld] \"%s\"", 
+				(long) str_len(str), str_sanitize(str_c(str), 80));		
+	}
+}
+
+bool opr_string_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+	const char *field_name) 
+{
+	string_t *str; 
+	
+	if ( sieve_binary_read_string(denv->sbin, address, &str) ) {
+		_dump_string(denv, str, field_name);   		
+		
+		return TRUE;
+	}
+  
+	return FALSE;
+}
+
+static bool opr_string_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address, string_t **str_r)
+{ 	
+	return sieve_binary_read_string(renv->sbin, address, str_r);
+}
+
+/* String list */
+
+void sieve_opr_stringlist_emit_start
+	(struct sieve_binary *sbin, unsigned int listlen, void **context)
+{
+	sieve_size_t *end_offset = t_new(sieve_size_t, 1);
+
+	/* Emit byte identifying the type of operand */	  
+	(void) sieve_operand_emit_code(sbin, &stringlist_operand);
+  
+	/* Give the interpreter an easy way to skip over this string list */
+	*end_offset = sieve_binary_emit_offset(sbin, 0);
+	*context = (void *) end_offset;
+
+	/* Emit the length of the list */
+	(void) sieve_binary_emit_unsigned(sbin, listlen);
+}
+
+void sieve_opr_stringlist_emit_item
+(struct sieve_binary *sbin, void *context ATTR_UNUSED, string_t *item)
+{
+	(void) sieve_opr_string_emit(sbin, item);
+}
+
+void sieve_opr_stringlist_emit_end
+(struct sieve_binary *sbin, void *context)
+{
+	sieve_size_t *end_offset = (sieve_size_t *) context;
+
+	(void) sieve_binary_resolve_offset(sbin, *end_offset);
+}
+
+bool sieve_opr_stringlist_dump_data
+(const struct sieve_dumptime_env *denv, const struct sieve_operand *operand,
+	sieve_size_t *address, const char *field_name) 
+{
+	if ( operand == NULL )
+		return FALSE;
+	
+	if ( operand->class == &stringlist_class ) {
+		const struct sieve_opr_stringlist_interface *intf =
+			(const struct sieve_opr_stringlist_interface *) operand->interface; 
+		
+		if ( intf->dump == NULL )
+			return FALSE;
+
+		return intf->dump(denv, address, field_name); 
+	} else if ( operand->class == &string_class ) {
+		const struct sieve_opr_string_interface *intf =
+			(const struct sieve_opr_string_interface *) operand->interface; 
+	
+		if ( intf->dump == NULL ) 
+			return FALSE;
+
+		return intf->dump(denv, address, field_name);  
+	}
+	
+	return FALSE;
+}
+
+bool sieve_opr_stringlist_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+	const char *field_name) 
+{
+	const struct sieve_operand *operand;
+
+	sieve_code_mark(denv);
+	operand = sieve_operand_read(denv->sbin, address);
+
+	return sieve_opr_stringlist_dump_data(denv, operand, address, field_name);
+}
+
+struct sieve_coded_stringlist *sieve_opr_stringlist_read_data
+(const struct sieve_runtime_env *renv, const struct sieve_operand *operand,
+	sieve_size_t op_address, sieve_size_t *address)
+{
+	if ( operand == NULL )
+		return NULL;
+		
+	if ( operand->class == &stringlist_class ) {
+		const struct sieve_opr_stringlist_interface *intf = 
+			(const struct sieve_opr_stringlist_interface *) operand->interface;
+			
+		if ( intf->read == NULL ) 
+			return NULL;
+
+		return intf->read(renv, address);  
+	} else if ( operand->class == &string_class ) {
+		/* Special case, accept single string as string list as well. */
+		const struct sieve_opr_string_interface *intf = 
+			(const struct sieve_opr_string_interface *) operand->interface;
+				
+		if ( intf->read == NULL || !intf->read(renv, address, NULL) ) {
+			return NULL;
+		}
+		
+		return sieve_coded_stringlist_create(renv, op_address, 1, *address); 
+	}	
+	
+	return NULL;
+}
+
+struct sieve_coded_stringlist *sieve_opr_stringlist_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	sieve_size_t op_address = *address;
+	const struct sieve_operand *operand = sieve_operand_read(renv->sbin, address);
+	
+	return sieve_opr_stringlist_read_data(renv, operand, op_address, address);
+}
+
+static bool opr_stringlist_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address, 
+	const char *field_name) 
+{
+	sieve_size_t pc = *address;
+	sieve_size_t end; 
+	unsigned int length = 0; 
+ 	int end_offset;
+
+	if ( !sieve_binary_read_offset(denv->sbin, address, &end_offset) )
+		return FALSE;
+
+	end = pc + end_offset;
+
+	if ( !sieve_binary_read_unsigned(denv->sbin, address, &length) ) 
+		return FALSE;	
+  	
+	return sieve_coded_stringlist_dump(denv, address, length, end, field_name); 
+}
+
+static struct sieve_coded_stringlist *opr_stringlist_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address )
+{
+	struct sieve_coded_stringlist *strlist;
+	sieve_size_t pc = *address;
+	sieve_size_t end; 
+	unsigned int length = 0;  
+	int end_offset;
+	
+	if ( !sieve_binary_read_offset(renv->sbin, address, &end_offset) )
+		return NULL;
+
+	end = pc + end_offset;
+
+	if ( !sieve_binary_read_unsigned(renv->sbin, address, &length) ) 
+	  	return NULL;	
+  	
+	strlist = sieve_coded_stringlist_create(renv, *address, (unsigned int) length, end); 
+
+	/* Skip over the string list for now */
+	*address = end;
+  
+	return strlist;
+}  
+
+/* Catenated String */
+
+void sieve_opr_catenated_string_emit
+(struct sieve_binary *sbin, unsigned int elements) 
+{
+	(void) sieve_operand_emit_code(sbin, &catenated_string_operand);
+	(void) sieve_binary_emit_unsigned(sbin, elements);
+}
+
+static bool opr_catenated_string_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+	const char *field_name) 
+{
+	unsigned int elements = 0;
+	unsigned int i;
+	
+	if (!sieve_binary_read_unsigned(denv->sbin, address, &elements) )
+		return FALSE;
+	
+	if ( field_name != NULL ) 
+		sieve_code_dumpf(denv, "%s: CAT-STR [%ld]:", 
+			field_name, (long) elements);
+	else
+		sieve_code_dumpf(denv, "CAT-STR [%ld]:", (long) elements);
+
+	sieve_code_descend(denv);
+	for ( i = 0; i < (unsigned int) elements; i++ ) {
+		if ( !sieve_opr_string_dump(denv, address, NULL) )
+			return FALSE;
+	}
+	sieve_code_ascend(denv);
+	
+	return TRUE;
+}
+
+static bool opr_catenated_string_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address, string_t **str)
+{ 
+	unsigned int elements = 0;
+	unsigned int i;
+		
+	if ( !sieve_binary_read_unsigned(renv->sbin, address, &elements) )
+		return FALSE;
+
+	/* Parameter str can be NULL if we are requested to only skip and not 
+	 * actually read the argument.
+	 */
+	if ( str == NULL ) {
+		for ( i = 0; i < (unsigned int) elements; i++ ) {		
+			if ( !sieve_opr_string_read(renv, address, NULL) ) 
+				return FALSE;
+		}
+	} else {
+		string_t *strelm;
+		string_t **elm = &strelm;
+
+		*str = t_str_new(128);
+		for ( i = 0; i < (unsigned int) elements; i++ ) {
+		
+			if ( !sieve_opr_string_read(renv, address, elm) ) 
+				return FALSE;
+		
+			if ( elm != NULL ) {
+				str_append_str(*str, strelm);
+
+				if ( str_len(*str) > SIEVE_MAX_STRING_LEN ) {
+					str_truncate(*str, SIEVE_MAX_STRING_LEN);
+					elm = NULL;
+				}
+			}
+		}
+	}
+
+	return TRUE;
+}
+
+/* 
+ * Core operations
+ */
+ 
+/* Forward declarations */
+
+static bool opc_jmp_dump
+	(const struct sieve_operation *op, 
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+
+static int opc_jmp_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+static int opc_jmptrue_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+static int opc_jmpfalse_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+/* Operation objects defined in this file */
+
+const struct sieve_operation sieve_jmp_operation = { 
+	"JMP",
+	NULL,
+	SIEVE_OPERATION_JMP,
+	opc_jmp_dump, 
+	opc_jmp_execute 
+};
+
+const struct sieve_operation sieve_jmptrue_operation = { 
+	"JMPTRUE",
+	NULL,
+	SIEVE_OPERATION_JMPTRUE,
+	opc_jmp_dump, 
+	opc_jmptrue_execute 
+};
+
+const struct sieve_operation sieve_jmpfalse_operation = { 
+	"JMPFALSE",
+	NULL,
+	SIEVE_OPERATION_JMPFALSE,
+	opc_jmp_dump, 
+	opc_jmpfalse_execute 
+};
+
+/* Operation objects defined in other files */
+	
+extern const struct sieve_operation cmd_stop_operation;
+extern const struct sieve_operation cmd_keep_operation;
+extern const struct sieve_operation cmd_discard_operation;
+extern const struct sieve_operation cmd_redirect_operation;
+
+extern const struct sieve_operation tst_address_operation;
+extern const struct sieve_operation tst_header_operation;
+extern const struct sieve_operation tst_exists_operation;
+extern const struct sieve_operation tst_size_over_operation;
+extern const struct sieve_operation tst_size_under_operation;
+
+const struct sieve_operation *sieve_operations[] = {
+	NULL, 
+	
+	&sieve_jmp_operation,
+	&sieve_jmptrue_operation, 
+	&sieve_jmpfalse_operation,
+	
+	&cmd_stop_operation,
+	&cmd_keep_operation,
+	&cmd_discard_operation,
+	&cmd_redirect_operation,
+
+	&tst_address_operation,
+	&tst_header_operation,
+	&tst_exists_operation,
+	&tst_size_over_operation,
+	&tst_size_under_operation
+}; 
+
+const unsigned int sieve_operation_count =
+	N_ELEMENTS(sieve_operations);
+
+/* 
+ * Operation functions 
+ */
+
+sieve_size_t sieve_operation_emit_code
+(struct sieve_binary *sbin, const struct sieve_operation *op)
+{
+	sieve_size_t address;
+
+    if ( op->extension != NULL ) {
+        address = sieve_binary_emit_extension
+            (sbin, op->extension, sieve_operation_count);
+
+        sieve_binary_emit_extension_object
+            (sbin, &op->extension->operations, op->code);
+
+        return address;
+    }
+
+    return  sieve_binary_emit_byte(sbin, op->code);
+}
+
+const struct sieve_operation *sieve_operation_read
+(struct sieve_binary *sbin, sieve_size_t *address) 
+{
+	const struct sieve_extension *ext;
+	unsigned int code = sieve_operation_count;
+
+	if ( !sieve_binary_read_extension(sbin, address, &code, &ext) )
+		return NULL;
+
+	if ( !ext )
+		return code < sieve_operation_count ? sieve_operations[code] : NULL;
+
+    return (const struct sieve_operation *) sieve_binary_read_extension_object
+        (sbin, address, &ext->operations);
+}
+
+/*
+ * Jump operations
+ */
+	
+/* Code dump */
+
+static bool opc_jmp_dump
+(const struct sieve_operation *op,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	unsigned int pc = *address;
+	int offset;
+	
+	if ( sieve_binary_read_offset(denv->sbin, address, &offset) ) 
+		sieve_code_dumpf(denv, "%s %d [%08x]", 
+			op->mnemonic, offset, pc + offset);
+	else
+		return FALSE;
+	
+	return TRUE;
+}	
+			
+/* Code execution */
+
+static int opc_jmp_execute
+(const struct sieve_operation *op ATTR_UNUSED, 
+	const struct sieve_runtime_env *renv, sieve_size_t *address ATTR_UNUSED) 
+{
+	sieve_runtime_trace(renv, "JMP");
+	
+	return sieve_interpreter_program_jump(renv->interp, TRUE);
+}	
+		
+static int opc_jmptrue_execute
+(const struct sieve_operation *op ATTR_UNUSED, 
+	const struct sieve_runtime_env *renv, sieve_size_t *address ATTR_UNUSED)
+{	
+	bool result = sieve_interpreter_get_test_result(renv->interp);
+	
+	sieve_runtime_trace(renv, "JMPTRUE (%s)", result ? "true" : "false");
+	
+	return sieve_interpreter_program_jump(renv->interp, result);
+}
+
+static int opc_jmpfalse_execute
+(const struct sieve_operation *op ATTR_UNUSED, 
+	const struct sieve_runtime_env *renv, sieve_size_t *address ATTR_UNUSED)
+{	
+	bool result = sieve_interpreter_get_test_result(renv->interp);
+	
+	sieve_runtime_trace(renv, "JMPFALSE (%s)", result ? "true" : "false" );
+	
+	return sieve_interpreter_program_jump(renv->interp, !result);
+}	
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-code-dumper.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-code-dumper.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-code-dumper.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-code-dumper.c	2009-02-02 10:17:30.000000000 +0100
@@ -0,0 +1,292 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include <stdio.h>
+#include <string.h>
+
+#include "lib.h"
+#include "str.h"
+#include "mempool.h"
+#include "ostream.h"
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-actions.h"
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+#include "sieve-result.h"
+#include "sieve-comparators.h"
+
+#include "sieve-dump.h"
+
+/* 
+ * Code dumper extension
+ */
+
+struct sieve_code_dumper_extension_reg {
+	const struct sieve_code_dumper_extension *val_ext;
+	void *context;
+};
+
+struct sieve_code_dumper {
+	pool_t pool;
+					
+	/* Dump status */
+	sieve_size_t pc;          /* Program counter */
+	
+	const struct sieve_operation *operation;
+	sieve_size_t mark_address;
+	unsigned int indent;
+	
+	/* Dump environment */
+	struct sieve_dumptime_env *dumpenv; 
+	
+	ARRAY_DEFINE(extensions, struct sieve_code_dumper_extension_reg);
+};
+
+struct sieve_code_dumper *sieve_code_dumper_create
+	(struct sieve_dumptime_env *denv) 
+{
+	pool_t pool;
+	struct sieve_code_dumper *dumper;
+	
+	pool = pool_alloconly_create("sieve_code_dumper", 4096);	
+	dumper = p_new(pool, struct sieve_code_dumper, 1);
+	dumper->pool = pool;
+	dumper->dumpenv = denv;
+	dumper->pc = 0;
+	
+	/* Setup storage for extension contexts */		
+	p_array_init(&dumper->extensions, pool, sieve_extensions_get_count());
+
+	return dumper;
+}
+
+void sieve_code_dumper_free(struct sieve_code_dumper **dumper) 
+{
+	pool_unref(&((*dumper)->pool));
+	
+	*dumper = NULL;
+}
+
+pool_t sieve_code_dumper_pool(struct sieve_code_dumper *dumper)
+{
+	return dumper->pool;
+}
+
+/* EXtension support */
+
+void sieve_dump_extension_register
+(struct sieve_code_dumper *dumper, 
+	const struct sieve_code_dumper_extension *dump_ext, void *context)
+{
+	struct sieve_code_dumper_extension_reg reg = { dump_ext, context };
+	int ext_id = SIEVE_EXT_ID(dump_ext->ext);
+
+	if ( ext_id < 0 ) return;
+	
+	array_idx_set(&dumper->extensions, (unsigned int) ext_id, &reg);	
+}
+
+void sieve_dump_extension_set_context
+(struct sieve_code_dumper *dumper, const struct sieve_extension *ext, 
+	void *context)
+{
+	struct sieve_code_dumper_extension_reg reg = { NULL, context };
+	int ext_id = SIEVE_EXT_ID(ext);
+
+	if ( ext_id < 0 ) return;
+	
+	array_idx_set(&dumper->extensions, (unsigned int) ext_id, &reg);	
+}
+
+void *sieve_dump_extension_get_context
+(struct sieve_code_dumper *dumper, const struct sieve_extension *ext) 
+{
+	int ext_id = SIEVE_EXT_ID(ext);
+	const struct sieve_code_dumper_extension_reg *reg;
+
+	if  ( ext_id < 0 || ext_id >= (int) array_count(&dumper->extensions) )
+		return NULL;
+	
+	reg = array_idx(&dumper->extensions, (unsigned int) ext_id);		
+
+	return reg->context;
+}
+
+/* Dump functions */
+
+void sieve_code_dumpf
+(const struct sieve_dumptime_env *denv, const char *fmt, ...)
+{
+	struct sieve_code_dumper *cdumper = denv->cdumper;	
+	unsigned tab = cdumper->indent;
+	 
+	string_t *outbuf = t_str_new(128);
+	va_list args;
+	
+	va_start(args, fmt);	
+	str_printfa(outbuf, "%08llx: ", (unsigned long long) cdumper->mark_address);
+	
+	while ( tab > 0 )	{
+		str_append(outbuf, "  ");
+		tab--;
+	}
+	
+	str_vprintfa(outbuf, fmt, args);
+	str_append_c(outbuf, '\n');
+	va_end(args);
+	
+	o_stream_send(denv->stream, str_data(outbuf), str_len(outbuf));
+}
+
+void sieve_code_mark(const struct sieve_dumptime_env *denv)
+{
+	denv->cdumper->mark_address = denv->cdumper->pc;
+}
+
+void sieve_code_mark_specific
+(const struct sieve_dumptime_env *denv, sieve_size_t location)
+{
+	denv->cdumper->mark_address = location;
+}
+
+void sieve_code_descend(const struct sieve_dumptime_env *denv)
+{
+	denv->cdumper->indent++;
+}
+
+void sieve_code_ascend(const struct sieve_dumptime_env *denv)
+{
+	if ( denv->cdumper->indent > 0 )
+		denv->cdumper->indent--;
+}
+
+/* Operations and operands */
+
+bool sieve_code_dumper_print_optional_operands
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	int opt_code = -1;
+	
+	if ( sieve_operand_optional_present(denv->sbin, address) ) {
+		
+		while ( opt_code != 0 ) {			
+			if ( !sieve_operand_optional_read(denv->sbin, address, &opt_code) ) {
+				return FALSE;
+			}
+
+			if ( opt_code == SIEVE_OPT_SIDE_EFFECT ) {
+				if ( !sieve_opr_side_effect_dump(denv, address) )
+					return FALSE;
+			}
+		}
+	} 
+	return TRUE;
+}
+ 
+/* Code Dump */
+
+static bool sieve_code_dumper_print_operation
+	(struct sieve_code_dumper *dumper) 
+{	
+	const struct sieve_operation *op;
+	struct sieve_dumptime_env *denv = dumper->dumpenv;
+	sieve_size_t address;
+	
+	/* Mark start address of operation */
+	dumper->indent = 0;
+	address = dumper->mark_address = dumper->pc;
+
+	/* Read operation */
+	dumper->operation = op = 
+		sieve_operation_read(denv->sbin, &(dumper->pc));
+
+	/* Try to dump it */
+	if ( op != NULL ) {
+		if ( op->dump != NULL )
+			return op->dump(op, denv, &(dumper->pc));
+		else if ( op->mnemonic != NULL )
+			sieve_code_dumpf(denv, "%s", op->mnemonic);
+		else
+			return FALSE;
+			
+		return TRUE;
+	}		
+	
+	sieve_code_dumpf(denv, "Failed to read opcode.");
+	return FALSE;
+}
+
+void sieve_code_dumper_run(struct sieve_code_dumper *dumper) 
+{
+	const struct sieve_dumptime_env *denv = dumper->dumpenv;
+	struct sieve_binary *sbin = denv->sbin;
+	unsigned int ext_count;
+	bool success = TRUE;
+
+	dumper->pc = 0;
+	
+	/* Load and dump extensions listed in code */
+	sieve_code_mark(denv);
+	
+	if ( sieve_binary_read_unsigned(sbin, &dumper->pc, &ext_count) ) {
+		unsigned int i;
+		
+		sieve_code_dumpf(denv, "EXTENSIONS [%d]:", ext_count);
+		sieve_code_descend(denv);
+		
+		for ( i = 0; i < ext_count; i++ ) {
+			unsigned int code = 0;
+			const struct sieve_extension *ext;
+			
+			T_BEGIN {
+				sieve_code_mark(denv);
+			
+				if ( !sieve_binary_read_extension(sbin, &dumper->pc, &code, &ext) ) {
+					success = FALSE;
+					break;
+				}
+      	
+				sieve_code_dumpf(denv, "%s", ext->name);
+      
+				if ( ext->code_dump != NULL ) {
+					sieve_code_descend(denv);
+					if ( !ext->code_dump(denv, &dumper->pc) ) {
+						success = FALSE;
+						break;
+					}
+					sieve_code_ascend(denv);
+				}
+			} T_END;
+		}
+		
+		sieve_code_ascend(denv);
+	}	else
+		success = FALSE;
+		
+	if ( !success ) {
+		sieve_code_dumpf(denv, "Binary code header is corrupt.");
+		return;
+	}
+	
+	while ( dumper->pc < 
+		sieve_binary_get_code_size(sbin) ) {
+
+		T_BEGIN {
+			success = sieve_code_dumper_print_operation(dumper);
+		} T_END;
+
+		if ( !success ) {
+			sieve_code_dumpf(dumper->dumpenv, "Binary is corrupt.");
+			return;
+		}
+	}
+	
+	/* Mark end of the binary */
+	dumper->indent = 0;
+	dumper->mark_address = sieve_binary_get_code_size(sbin);
+	sieve_code_dumpf(dumper->dumpenv, "[End of code]");	
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-code-dumper.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-code-dumper.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-code-dumper.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-code-dumper.h	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,58 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_CODE_DUMPER_H
+#define __SIEVE_CODE_DUMPER_H
+
+#include "sieve-common.h"
+
+struct sieve_code_dumper;
+
+struct sieve_code_dumper *sieve_code_dumper_create
+	(struct sieve_dumptime_env *denv);
+void sieve_code_dumper_free
+	(struct sieve_code_dumper **dumper);
+pool_t sieve_code_dumper_pool
+	(struct sieve_code_dumper *dumper);
+	
+/* 
+ * Extension support
+ */
+
+struct sieve_code_dumper_extension {
+	const struct sieve_extension *ext;	
+
+	void (*free)(struct sieve_code_dumper *dumper, void *context);
+};
+
+void sieve_dump_extension_register
+(struct sieve_code_dumper *dumper, 
+	const struct sieve_code_dumper_extension *dump_ext, void *context);
+void sieve_dump_extension_set_context
+	(struct sieve_code_dumper *dumper, const struct sieve_extension *ext, 
+		void *context);
+void *sieve_dump_extension_get_context
+	(struct sieve_code_dumper *dumper, const struct sieve_extension *ext); 
+	
+/* Dump functions */	
+	
+void sieve_code_dumpf
+	(const struct sieve_dumptime_env *denv, const char *fmt, ...)
+		ATTR_FORMAT(2, 3);
+
+void sieve_code_mark(const struct sieve_dumptime_env *denv);
+void sieve_code_mark_specific
+	(const struct sieve_dumptime_env *denv, sieve_size_t location);
+void sieve_code_descend(const struct sieve_dumptime_env *denv);
+void sieve_code_ascend(const struct sieve_dumptime_env *denv);
+
+/* Operations and operands */
+	
+bool sieve_code_dumper_print_optional_operands
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+
+/* Code dump (debugging purposes) */
+
+void sieve_code_dumper_run(struct sieve_code_dumper *dumper);
+
+#endif /* __SIEVE_CODE_DUMPER_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-code.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-code.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-code.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-code.h	2009-08-05 13:09:10.000000000 +0200
@@ -0,0 +1,295 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#ifndef __SIEVE_CODE_H
+#define __SIEVE_CODE_H
+
+#include "lib.h"
+#include "buffer.h"
+#include "mempool.h"
+#include "array.h"
+
+#include "sieve-common.h"
+
+/* 
+ * Coded string list 
+ */
+
+struct sieve_coded_stringlist;
+
+bool sieve_coded_stringlist_next_item
+	(struct sieve_coded_stringlist *strlist, string_t **str_r);
+void sieve_coded_stringlist_reset
+	(struct sieve_coded_stringlist *strlist);
+bool sieve_coded_stringlist_read_all
+	(struct sieve_coded_stringlist *strlist, pool_t pool,
+		const char * const **list_r);
+
+unsigned int sieve_coded_stringlist_get_length
+	(struct sieve_coded_stringlist *strlist);
+sieve_size_t sieve_coded_stringlist_get_end_address
+	(struct sieve_coded_stringlist *strlist);
+sieve_size_t sieve_coded_stringlist_get_current_offset
+	(struct sieve_coded_stringlist *strlist);
+
+/* 
+ * Source line coding
+ */
+
+void sieve_code_source_line_emit
+	(struct sieve_binary *sbin, unsigned int source_line);
+bool sieve_code_source_line_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+bool sieve_code_source_line_read
+	(const struct sieve_runtime_env *renv, sieve_size_t *address, 
+    	unsigned int *source_line_r);
+
+/* 
+ * Operand object
+ */
+
+struct sieve_operand_class {
+	const char *name;
+};
+
+struct sieve_operand {
+	const char *name;
+	
+	const struct sieve_extension *extension;
+	unsigned int code;
+	
+	const struct sieve_operand_class *class;
+	const void *interface;
+};
+
+sieve_size_t sieve_operand_emit_code
+	(struct sieve_binary *sbin, const struct sieve_operand *opr);
+const struct sieve_operand *sieve_operand_read
+	(struct sieve_binary *sbin, sieve_size_t *address);
+
+bool sieve_operand_optional_present
+	(struct sieve_binary *sbin, sieve_size_t *address);
+bool sieve_operand_optional_read	
+	(struct sieve_binary *sbin, sieve_size_t *address, 
+		signed int *id_code);
+
+/*
+ * Core operands
+ */
+ 
+/* Operand codes */
+
+enum sieve_core_operand {
+	SIEVE_OPERAND_OPTIONAL = 0x00,
+	SIEVE_OPERAND_NUMBER,
+	SIEVE_OPERAND_STRING,
+	SIEVE_OPERAND_STRING_LIST,
+	SIEVE_OPERAND_COMPARATOR,
+	SIEVE_OPERAND_MATCH_TYPE,
+	SIEVE_OPERAND_ADDRESS_PART,
+	SIEVE_OPERAND_CATENATED_STRING,
+
+	SIEVE_OPERAND_CUSTOM
+};
+
+/* Operand classes */
+
+extern const struct sieve_operand_class number_class;
+extern const struct sieve_operand_class string_class;
+extern const struct sieve_operand_class stringlist_class;
+
+/* Operand objects */
+
+extern const struct sieve_operand omitted_operand;
+extern const struct sieve_operand number_operand;
+extern const struct sieve_operand string_operand;
+extern const struct sieve_operand stringlist_operand;
+extern const struct sieve_operand catenated_string_operand;
+
+extern const struct sieve_operand *sieve_operands[];
+extern const unsigned int sieve_operand_count;
+
+/* Operand object interfaces */
+
+struct sieve_opr_number_interface {
+	bool (*dump)	
+		(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+			const char *field_name);
+	bool (*read)
+	  (const struct sieve_runtime_env *renv, sieve_size_t *address, 
+	  	sieve_number_t *number_r);
+};
+
+struct sieve_opr_string_interface {
+	bool (*dump)
+		(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+			const char *field_name);
+	bool (*read)
+		(const struct sieve_runtime_env *renv, sieve_size_t *address, 
+			string_t **str_r);
+};
+
+struct sieve_opr_stringlist_interface {
+	bool (*dump)
+		(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+			const char *field_name);
+	struct sieve_coded_stringlist *(*read)
+		(const struct sieve_runtime_env *renv, sieve_size_t *address);
+};
+
+/* 
+ * Core operand functions 
+ */
+
+/* Omitted */
+
+void sieve_opr_omitted_emit(struct sieve_binary *sbin);
+
+static inline bool sieve_operand_is_omitted
+(const struct sieve_operand *operand)
+{
+	return ( operand != NULL && operand == &omitted_operand );
+}
+
+/* Number */
+
+void sieve_opr_number_emit(struct sieve_binary *sbin, sieve_number_t number);
+bool sieve_opr_number_dump_data	
+	(const struct sieve_dumptime_env *denv, const struct sieve_operand *operand,
+		sieve_size_t *address, const char *field_name); 
+bool sieve_opr_number_dump	
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+		const char *field_name); 
+bool sieve_opr_number_read_data
+	(const struct sieve_runtime_env *renv, const struct sieve_operand *operand,
+		sieve_size_t *address, sieve_number_t *number_r);
+bool sieve_opr_number_read
+	(const struct sieve_runtime_env *renv, sieve_size_t *address, 
+		sieve_number_t *number_r);
+
+static inline bool sieve_operand_is_number
+(const struct sieve_operand *operand)
+{
+	return ( operand != NULL && operand->class == &number_class );
+}
+
+/* String */
+
+void sieve_opr_string_emit(struct sieve_binary *sbin, string_t *str);
+bool sieve_opr_string_dump_data
+	(const struct sieve_dumptime_env *denv, const struct sieve_operand *operand,
+		sieve_size_t *address, const char *field_name); 
+bool sieve_opr_string_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+		const char *field_name); 
+bool sieve_opr_string_dump_ex
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address, 
+		const char *field_name, bool *literal_r); 
+bool sieve_opr_string_read_data
+	(const struct sieve_runtime_env *renv, const struct sieve_operand *operand,
+		sieve_size_t *address, string_t **str_r);
+bool sieve_opr_string_read
+	(const struct sieve_runtime_env *renv, sieve_size_t *address, string_t **str_r);
+bool sieve_opr_string_read_ex
+	(const struct sieve_runtime_env *renv, sieve_size_t *address, string_t **str_r,
+		bool *literal_r);
+
+static inline bool sieve_operand_is_string
+(const struct sieve_operand *operand)
+{
+	return ( operand != NULL && operand->class == &string_class );
+}
+
+/* String list */
+
+void sieve_opr_stringlist_emit_start
+	(struct sieve_binary *sbin, unsigned int listlen, void **context);
+void sieve_opr_stringlist_emit_item
+	(struct sieve_binary *sbin, void *context ATTR_UNUSED, string_t *item);
+void sieve_opr_stringlist_emit_end
+	(struct sieve_binary *sbin, void *context);
+bool sieve_opr_stringlist_dump_data
+	(const struct sieve_dumptime_env *denv, const struct sieve_operand *operand, 
+		sieve_size_t *address, const char *field_name);
+bool sieve_opr_stringlist_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+		const char *field_name);
+struct sieve_coded_stringlist *sieve_opr_stringlist_read_data
+	(const struct sieve_runtime_env *renv, const struct sieve_operand *operand, 
+		sieve_size_t op_address, sieve_size_t *address);
+struct sieve_coded_stringlist *sieve_opr_stringlist_read
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+static inline bool sieve_operand_is_stringlist
+(const struct sieve_operand *operand)
+{
+	return ( operand != NULL && 
+		(operand->class == &stringlist_class || operand->class == &string_class) );
+}
+
+/* Catenated string */
+
+void sieve_opr_catenated_string_emit
+	(struct sieve_binary *sbin, unsigned int elements);
+	
+/*
+ * Operation object
+ */
+ 
+struct sieve_operation {
+	const char *mnemonic;
+	
+	const struct sieve_extension *extension;
+	unsigned int code;
+	
+	bool (*dump)
+		(const struct sieve_operation *op, 
+			const struct sieve_dumptime_env *denv, sieve_size_t *address);
+	int (*execute)
+		(const struct sieve_operation *op, 
+			const struct sieve_runtime_env *renv, sieve_size_t *address);
+};
+
+sieve_size_t sieve_operation_emit_code
+	(struct sieve_binary *sbin, const struct sieve_operation *op);	
+const struct sieve_operation *sieve_operation_read
+	(struct sieve_binary *sbin, sieve_size_t *address);
+const char *sieve_operation_read_string
+    (struct sieve_binary *sbin, sieve_size_t *address);
+
+/* 
+ * Core operations 
+ */
+
+/* Opcodes */
+
+enum sieve_operation_code {
+	SIEVE_OPERATION_INVALID,
+	SIEVE_OPERATION_JMP,
+	SIEVE_OPERATION_JMPTRUE,
+	SIEVE_OPERATION_JMPFALSE,
+	
+	SIEVE_OPERATION_STOP,
+	SIEVE_OPERATION_KEEP,
+	SIEVE_OPERATION_DISCARD,
+	SIEVE_OPERATION_REDIRECT,
+	
+	SIEVE_OPERATION_ADDRESS,
+	SIEVE_OPERATION_HEADER, 
+	SIEVE_OPERATION_EXISTS, 
+	SIEVE_OPERATION_SIZE_OVER,
+	SIEVE_OPERATION_SIZE_UNDER,
+	
+	SIEVE_OPERATION_CUSTOM
+};
+
+/* Operation objects */
+
+extern const struct sieve_operation sieve_jmp_operation;
+extern const struct sieve_operation sieve_jmptrue_operation;
+extern const struct sieve_operation sieve_jmpfalse_operation; 
+
+extern const struct sieve_operation *sieve_operations[];
+extern const unsigned int sieve_operations_count;
+
+#endif
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-commands.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-commands.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-commands.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-commands.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,371 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "str-sanitize.h"
+
+#include "rfc2822.h"
+
+#include "sieve-common.h"
+#include "sieve-ast.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-interpreter.h"
+
+/* 
+ * Literal arguments
+ */
+
+/* Forward declarations */
+
+static bool arg_number_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+		struct sieve_command_context *context);
+static bool arg_string_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+		struct sieve_command_context *context);
+static bool arg_string_list_validate
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *context);
+static bool arg_string_list_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+		struct sieve_command_context *context);
+
+/* Argument objects */
+
+const struct sieve_argument number_argument = { 
+	"@number", 
+	NULL, NULL, NULL, NULL,
+	arg_number_generate 
+};
+
+const struct sieve_argument string_argument = { 
+	"@string", 
+	NULL, NULL, NULL, NULL,
+	arg_string_generate 
+};
+
+const struct sieve_argument string_list_argument = { 
+	"@string-list", 
+	NULL, NULL,
+	arg_string_list_validate, 
+	NULL, 
+	arg_string_list_generate 
+};	
+
+/* Argument implementations */
+
+static bool arg_number_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+	struct sieve_command_context *context ATTR_UNUSED)
+{
+	sieve_opr_number_emit(cgenv->sbin, sieve_ast_argument_number(arg));
+
+	return TRUE;
+}
+
+static bool arg_string_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+	struct sieve_command_context *context ATTR_UNUSED)
+{
+	sieve_opr_string_emit(cgenv->sbin, sieve_ast_argument_str(arg));
+  
+	return TRUE;
+}
+
+static bool arg_string_list_validate
+(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *context)
+{
+	struct sieve_ast_argument *stritem;
+
+	stritem = sieve_ast_strlist_first(*arg);	
+	while ( stritem != NULL ) {
+		if ( !sieve_validator_argument_activate(validator, context, stritem, FALSE) )
+			return FALSE;
+			
+		stritem = sieve_ast_strlist_next(stritem);
+	}
+
+	return TRUE;	
+}
+
+static bool emit_string_list_operand
+(const struct sieve_codegen_env *cgenv, const struct sieve_ast_argument *strlist,
+	struct sieve_command_context *context)
+{	
+	void *list_context;
+	struct sieve_ast_argument *stritem;
+   	
+	sieve_opr_stringlist_emit_start
+		(cgenv->sbin, sieve_ast_strlist_count(strlist), &list_context);
+
+	stritem = sieve_ast_strlist_first(strlist);
+	while ( stritem != NULL ) {
+		if ( !sieve_generate_argument(cgenv, stritem, context) )
+			return FALSE;
+			
+		stritem = sieve_ast_strlist_next(stritem);
+	}
+
+	sieve_opr_stringlist_emit_end(cgenv->sbin, list_context);
+	
+	return TRUE;
+}
+
+static bool arg_string_list_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+	struct sieve_command_context *context)
+{
+	if ( sieve_ast_argument_type(arg) == SAAT_STRING ) {
+		return ( sieve_generate_argument(cgenv, arg, context) );
+
+	} else if ( sieve_ast_argument_type(arg) == SAAT_STRING_LIST ) {
+		bool result = TRUE;
+		
+		if ( sieve_ast_strlist_count(arg) == 1 ) 
+			return ( sieve_generate_argument
+				(cgenv, sieve_ast_strlist_first(arg), context) );
+		else {
+			T_BEGIN { 
+				result=emit_string_list_operand(cgenv, arg, context);
+			} T_END;
+		}
+
+		return result;
+	}
+	
+	return FALSE;
+}
+
+/*
+ * Abstract arguments 
+ *
+ *   (Generated by processing and not by parsing the grammar)
+ */
+ 
+/* Catenated string */
+
+struct sieve_arg_catenated_string {
+	struct sieve_ast_arg_list *str_parts;
+};
+ 
+struct sieve_arg_catenated_string *sieve_arg_catenated_string_create
+(struct sieve_ast_argument *orig_arg)
+{
+	pool_t pool = sieve_ast_pool(orig_arg->ast);
+	struct sieve_ast_arg_list *arglist;
+	struct sieve_arg_catenated_string *catstr;
+
+	arglist = sieve_ast_arg_list_create(pool);
+					
+	catstr = p_new(pool, struct sieve_arg_catenated_string, 1);
+	catstr->str_parts = arglist;
+	(orig_arg)->context = (void *) catstr;
+	
+	return catstr;
+}
+
+void sieve_arg_catenated_string_add_element
+(struct sieve_arg_catenated_string *catstr, 
+	struct sieve_ast_argument *element)
+{
+	sieve_ast_arg_list_add(catstr->str_parts, element);
+}
+
+#define _cat_string_first(catstr) __AST_LIST_FIRST((catstr)->str_parts)
+#define _cat_string_count(catstr) __AST_LIST_COUNT((catstr)->str_parts)
+#define _cat_string_next(item) __AST_LIST_NEXT(item)
+
+bool sieve_arg_catenated_string_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+	struct sieve_command_context *cmd) 
+{
+	struct sieve_binary *sbin = cgenv->sbin;
+	struct sieve_arg_catenated_string *catstr = 
+		(struct sieve_arg_catenated_string *) arg->context;
+	struct sieve_ast_argument *strpart;
+	
+	if ( _cat_string_count(catstr) == 1 )
+		sieve_generate_argument(cgenv, _cat_string_first(catstr), cmd);
+	else {
+		sieve_opr_catenated_string_emit(sbin, _cat_string_count(catstr));
+
+		strpart = _cat_string_first(catstr);
+		while ( strpart != NULL ) {
+			if ( !sieve_generate_argument(cgenv, strpart, cmd) )
+				return FALSE;
+			
+			strpart = _cat_string_next(strpart);
+		}
+	}
+	
+	return TRUE;
+}
+
+/* 
+ * Core tests and commands 
+ */
+
+const struct sieve_command *sieve_core_tests[] = {
+	&tst_false, &tst_true,
+	&tst_not, &tst_anyof, &tst_allof,
+	&tst_address, &tst_header, &tst_exists, &tst_size
+};
+
+const unsigned int sieve_core_tests_count = N_ELEMENTS(sieve_core_tests);
+
+const struct sieve_command *sieve_core_commands[] = {
+	&cmd_require, 
+	&cmd_stop, &cmd_if, &cmd_elsif, &cmd_else, 
+	&cmd_keep, &cmd_discard, &cmd_redirect
+};
+
+const unsigned int sieve_core_commands_count = N_ELEMENTS(sieve_core_commands);
+	
+/* 
+ * Command context 
+ */
+
+struct sieve_command_context *sieve_command_prev_context	
+	(struct sieve_command_context *context) 
+{
+	struct sieve_ast_node *node = sieve_ast_node_prev(context->ast_node);
+	
+	if ( node != NULL ) {
+		return node->context;
+	}
+	
+	return NULL;
+}
+
+struct sieve_command_context *sieve_command_parent_context	
+	(struct sieve_command_context *context) 
+{
+	struct sieve_ast_node *node = sieve_ast_node_parent(context->ast_node);
+	
+	if ( node != NULL ) {
+		return node->context;
+	}
+	
+	return NULL;
+}
+
+struct sieve_command_context *sieve_command_context_create
+	(struct sieve_ast_node *cmd_node, const struct sieve_command *command,
+		struct sieve_command_registration *reg)
+{
+	struct sieve_command_context *cmd;
+	
+	cmd = p_new(sieve_ast_node_pool(cmd_node), struct sieve_command_context, 1);
+	
+	cmd->ast_node = cmd_node;	
+	cmd->command = command;
+	cmd->cmd_reg = reg;
+	
+	cmd->block_exit_command = NULL;
+	
+	return cmd;
+}
+
+const char *sieve_command_type_name(const struct sieve_command *command) {
+	switch ( command->type ) {
+	case SCT_NONE: return "command of unspecified type (bug)";
+	case SCT_TEST: return "test";
+	case SCT_COMMAND: return "command";
+	default:
+		break;
+	}
+	return "??COMMAND-TYPE??";
+}
+
+struct sieve_ast_argument *sieve_command_add_dynamic_tag
+(struct sieve_command_context *cmd, const struct sieve_argument *tag, 
+	int id_code)
+{
+	struct sieve_ast_argument *arg;
+	
+	if ( cmd->first_positional != NULL )
+		arg = sieve_ast_argument_tag_insert
+			(cmd->first_positional, tag->identifier, cmd->ast_node->source_line);
+	else
+		arg = sieve_ast_argument_tag_create
+			(cmd->ast_node, tag->identifier, cmd->ast_node->source_line);
+	
+	arg->argument = tag;
+	arg->arg_id_code = id_code;
+	
+	return arg;
+}
+
+struct sieve_ast_argument *sieve_command_find_argument
+(struct sieve_command_context *cmd, const struct sieve_argument *argument)
+{
+	struct sieve_ast_argument *arg = sieve_ast_argument_first(cmd->ast_node);
+		
+	/* Visit tagged and optional arguments */
+	while ( arg != NULL ) {
+		if ( arg->argument == argument ) 
+			return arg;
+			
+		arg = sieve_ast_argument_next(arg);
+	}
+	
+	return arg;
+}
+
+/* Use this function with caution. The command commits to exiting the block.
+ * When it for some reason does not, the interpretation will break later on, 
+ * because exiting jumps are not generated when they would otherwise be 
+ * necessary.
+ */
+void sieve_command_exit_block_unconditionally
+	(struct sieve_command_context *cmd)
+{
+	struct sieve_command_context *parent = sieve_command_parent_context(cmd);
+
+	/* Only the first unconditional exit is of importance */
+	if ( parent != NULL && parent->block_exit_command == NULL ) 
+		parent->block_exit_command = cmd;
+}
+
+bool sieve_command_block_exits_unconditionally
+	(struct sieve_command_context *cmd)
+{
+	return ( cmd->block_exit_command != NULL );
+}
+
+/*
+ * Command utility functions
+ */
+
+/* NOTE: this may be moved */
+
+static int _verify_header_name_item
+(void *context, struct sieve_ast_argument *header)
+{
+	struct sieve_validator *valdtr = (struct sieve_validator *) context;
+	string_t *name = sieve_ast_argument_str(header);
+
+	if ( sieve_argument_is_string_literal(header) &&
+		!rfc2822_header_field_name_verify(str_c(name), str_len(name)) ) {
+		sieve_argument_validate_warning
+			(valdtr, header, "specified header field name '%s' is invalid",
+				str_sanitize(str_c(name), 80));
+
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+bool sieve_command_verify_headers_argument
+(struct sieve_validator *valdtr, struct sieve_ast_argument *headers)
+{	
+	return ( sieve_ast_stringlist_map
+		(&headers, (void *) valdtr, _verify_header_name_item) >= 0 );
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-commands.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-commands.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-commands.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-commands.h	2009-02-14 09:32:55.000000000 +0100
@@ -0,0 +1,221 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_COMMANDS_H
+#define __SIEVE_COMMANDS_H
+
+#include "lib.h"
+
+#include "sieve-common.h"
+#include "sieve-ast.h"
+
+/* 
+ * Argument object
+ */
+
+struct sieve_argument {
+	const char *identifier;
+	
+	bool (*is_instance_of)
+		(struct sieve_validator *validator, struct sieve_command_context *cmdctx,
+			struct sieve_ast_argument *arg);
+	
+	bool (*validate_persistent) // FIXME: this method must be moved down
+		(struct sieve_validator *validator, struct sieve_command_context *cmdctx);
+	bool (*validate)
+		(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+			struct sieve_command_context *context);
+	bool (*validate_context)
+		(struct sieve_validator *validator, struct sieve_ast_argument *arg, 
+			struct sieve_command_context *context);
+		
+	bool (*generate)
+		(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+			struct sieve_command_context *context);
+};
+
+/* Utility macros */
+
+#define sieve_argument_is_string_literal(arg) \
+	( (arg)->argument == &string_argument )
+
+/* Error handling */
+
+#define sieve_argument_validate_error(validator, arg_node, ...) \
+	sieve_validator_error(validator, (arg_node)->source_line, __VA_ARGS__)
+#define sieve_argument_validate_warning(validator, arg_node, ...) \
+	sieve_validator_warning(validator, (arg_node)->source_line, __VA_ARGS__)
+
+/* Literal arguments */
+
+extern const struct sieve_argument number_argument;
+extern const struct sieve_argument string_argument;
+extern const struct sieve_argument string_list_argument;
+
+/* Catenated string argument */
+
+bool sieve_arg_catenated_string_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+		struct sieve_command_context *context);
+
+struct sieve_arg_catenated_string;		
+
+struct sieve_arg_catenated_string *sieve_arg_catenated_string_create
+	(struct sieve_ast_argument *orig_arg);
+void sieve_arg_catenated_string_add_element
+	(struct sieve_arg_catenated_string *strdata, 
+		struct sieve_ast_argument *element);
+
+/* 
+ * Command object
+ */
+
+enum sieve_command_type {
+	SCT_NONE,
+	SCT_COMMAND,
+	SCT_TEST,
+	SCT_HYBRID
+};
+
+struct sieve_command {
+	const char *identifier;
+	enum sieve_command_type type;
+	
+	/* High-level command syntax */
+	int positional_arguments;
+	int subtests;
+	bool block_allowed;
+	bool block_required;
+	
+	bool (*registered)
+		(struct sieve_validator *validator, 
+			struct sieve_command_registration *cmd_reg); 
+	bool (*pre_validate)
+		(struct sieve_validator *validator, struct sieve_command_context *context); 
+	bool (*validate)
+		(struct sieve_validator *validator, struct sieve_command_context *context); 
+	bool (*generate) 
+		(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+	bool (*control_generate) 
+		(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx,
+		struct sieve_jumplist *jumps, bool jump_true);
+};
+
+/*
+ * Command context
+ */
+
+struct sieve_command_context {
+	const struct sieve_command *command;
+	
+	/* The registration of this command in the validator (sieve-validator.h) */
+	struct sieve_command_registration *cmd_reg;
+
+	/* The ast node of this command */
+	struct sieve_ast_node *ast_node;
+			
+	/* First positional argument, found during argument validation */
+	struct sieve_ast_argument *first_positional;
+
+	/* The child ast node that unconditionally exits this command's block */
+	struct sieve_command_context *block_exit_command;
+
+	/* Command-specific context data*/
+	void *data;
+};
+
+/* Context API */
+
+struct sieve_command_context *sieve_command_context_create
+	(struct sieve_ast_node *cmd_node, const struct sieve_command *command,
+		struct sieve_command_registration *reg);
+		
+const char *sieve_command_type_name(const struct sieve_command *command);		
+
+struct sieve_command_context *sieve_command_prev_context	
+	(struct sieve_command_context *context); 
+struct sieve_command_context *sieve_command_parent_context	
+	(struct sieve_command_context *context);
+	
+struct sieve_ast_argument *sieve_command_add_dynamic_tag
+	(struct sieve_command_context *cmd, const struct sieve_argument *tag,
+		int id_code);
+struct sieve_ast_argument *sieve_command_find_argument
+	(struct sieve_command_context *cmd, const struct sieve_argument *argument);	
+	
+void sieve_command_exit_block_unconditionally
+	(struct sieve_command_context *cmd);
+bool sieve_command_block_exits_unconditionally
+	(struct sieve_command_context *cmd);
+	
+/* Error handling */
+		
+#define sieve_command_validate_error(validator, context, ...) \
+	sieve_validator_error(validator, (context)->ast_node->source_line, __VA_ARGS__)
+#define sieve_command_validate_warning(validator, context, ...) \
+	sieve_validator_warning(validator, (context)->ast_node->source_line, __VA_ARGS__)
+#define sieve_command_validate_critical(validator, context, ...) \
+	sieve_validator_critical(validator, (context)->ast_node->source_line, __VA_ARGS__)
+
+#define sieve_command_generate_error(gentr, context, ...) \
+	sieve_generator_error(gentr, (context)->ast_node->source_line, __VA_ARGS__)
+#define sieve_command_generate_critical(gentr, context, ...) \
+	sieve_generator_critical(gentr, (context)->ast_node->source_line, __VA_ARGS__)
+
+/* Utility macros */
+
+#define sieve_command_pool(context) \
+	sieve_ast_node_pool((context)->ast_node)
+
+#define sieve_command_source_line(context) \
+	(context)->ast_node->source_line
+
+#define sieve_command_first_argument(context) \
+	sieve_ast_argument_first((context)->ast_node)
+	
+#define sieve_command_is_toplevel(context) \
+	( sieve_ast_node_type(sieve_ast_node_parent((context)->ast_node)) == SAT_ROOT )
+#define sieve_command_is_first(context) \
+	( sieve_ast_node_prev((context)->ast_node) == NULL )	
+
+/*
+ * Core commands
+ */
+ 
+extern const struct sieve_command cmd_require;
+extern const struct sieve_command cmd_stop;
+extern const struct sieve_command cmd_if;
+extern const struct sieve_command cmd_elsif;
+extern const struct sieve_command cmd_else;
+extern const struct sieve_command cmd_redirect;
+extern const struct sieve_command cmd_keep;
+extern const struct sieve_command cmd_discard;
+
+extern const struct sieve_command *sieve_core_commands[];
+extern const unsigned int sieve_core_commands_count;
+
+/* 
+ * Core tests 
+ */
+
+extern const struct sieve_command tst_true;
+extern const struct sieve_command tst_false;
+extern const struct sieve_command tst_not;
+extern const struct sieve_command tst_anyof;
+extern const struct sieve_command tst_allof;
+extern const struct sieve_command tst_address;
+extern const struct sieve_command tst_header;
+extern const struct sieve_command tst_exists;
+extern const struct sieve_command tst_size;
+
+extern const struct sieve_command *sieve_core_tests[];
+extern const unsigned int sieve_core_tests_count;
+
+/*
+ * Command utility functions
+ */
+
+bool sieve_command_verify_headers_argument
+(struct sieve_validator *valdtr, struct sieve_ast_argument *headers);
+
+#endif /* __SIEVE_COMMANDS_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-common.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-common.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-common.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-common.h	2009-08-05 08:59:18.000000000 +0200
@@ -0,0 +1,123 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_COMMON_H
+#define __SIEVE_COMMON_H
+
+#include "sieve-config.h"
+#include "sieve-types.h"
+
+#include <sys/types.h>
+
+/* 
+ * Types
+ */
+
+typedef size_t        sieve_size_t; 
+typedef uint32_t      sieve_offset_t;
+typedef uint32_t      sieve_number_t;
+
+#define SIEVE_MAX_NUMBER ((sieve_number_t) -1)
+
+/*
+ * Forward declarations
+ */
+
+/* sieve-error.h */
+struct sieve_error_handler;
+
+/* sieve-ast.h */
+enum sieve_ast_argument_type;
+
+struct sieve_ast;
+struct sieve_ast_node;
+struct sieve_ast_argument;
+
+/* sieve-commands.h */
+struct sieve_argument;
+struct sieve_command;
+struct sieve_command_context;
+struct sieve_command_registration;
+
+/* sieve-code.h */
+struct sieve_operation_extension;
+
+/* sieve-lexer.h */
+struct sieve_lexer;
+
+/* sieve-parser.h */
+struct sieve_parser;
+
+/* sieve-validator.h */
+struct sieve_validator;
+
+/* sieve-generator.h */
+struct sieve_jumplist;
+struct sieve_generator;
+struct sieve_codegen_env;
+
+/* sieve-interpreter.h */
+struct sieve_runtime_env;
+struct sieve_interpreter;
+
+/* sieve-binary-dumper.h */
+struct sieve_dumptime_env;
+struct sieve_binary_dumper;
+
+/* sieve-code-dumper.h */
+struct sieve_code_dumper;
+
+/* sieve-extension.h */
+struct sieve_extension;
+struct sieve_extension_objects;
+
+/* sieve-code.h */
+struct sieve_operand;
+struct sieve_operand_class;
+struct sieve_operation;
+struct sieve_coded_stringlist;
+
+/* sieve-binary.h */
+struct sieve_binary;
+
+/* sieve-objects.h */
+struct sieve_object;
+
+/* sieve-comparator.h */
+struct sieve_comparator;
+
+/* sieve-match-types.h */
+struct sieve_match_type;
+
+/* sieve-match.h */
+struct sieve_match_context;
+
+/* sieve-address.h */
+struct sieve_address;
+
+/* sieve-address-parts.h */
+struct sieve_address_part;
+
+/* sieve-result.h */
+struct sieve_result;
+struct sieve_side_effects_list;
+struct sieve_result_print_env;
+
+/* sieve-actions.h */
+struct sieve_action_exec_env;
+struct sieve_action;
+struct sieve_side_effect;
+
+/* sieve-script.h */
+struct sieve_script;
+
+/* sieve-message.h */
+struct sieve_message_context;
+
+/* sieve.c */
+struct sieve_ast *sieve_parse
+	(struct sieve_script *script, struct sieve_error_handler *ehandler);
+bool sieve_validate
+	(struct sieve_ast *ast, struct sieve_error_handler *ehandler);	
+
+#endif /* __SIEVE_COMMON_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-comparators.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-comparators.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-comparators.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-comparators.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,272 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+
+#include "lib.h"
+#include "str-sanitize.h"
+#include "hash.h"
+#include "array.h"
+
+#include "sieve-extensions.h"
+#include "sieve-code.h"
+#include "sieve-commands.h"
+#include "sieve-binary.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "sieve-comparators.h"
+
+#include <string.h>
+#include <stdio.h>
+
+/* 
+ * Core comparators
+ */
+ 
+const struct sieve_comparator *sieve_core_comparators[] = {
+	&i_octet_comparator, &i_ascii_casemap_comparator
+};
+
+const unsigned int sieve_core_comparators_count =
+	N_ELEMENTS(sieve_core_comparators);
+
+/*
+ * Forward declarations
+ */
+ 
+static void sieve_opr_comparator_emit
+	(struct sieve_binary *sbin, const struct sieve_comparator *cmp);
+
+/* 
+ * Comparator 'extension' 
+ */
+
+static int ext_my_id = -1;
+
+static bool cmp_validator_load(struct sieve_validator *validator);
+
+const struct sieve_extension comparator_extension = {
+	"@comparators",
+	&ext_my_id,
+	NULL, NULL,
+	cmp_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_NO_OPERATIONS,
+	SIEVE_EXT_DEFINE_NO_OPERANDS    /* Defined as core operand */
+};
+
+static const struct sieve_extension *ext_this = &comparator_extension;
+	
+/* 
+ * Validator context:
+ *   name-based comparator registry. 
+ */
+ 
+void sieve_comparator_register
+(struct sieve_validator *validator, const struct sieve_comparator *cmp) 
+{
+	struct sieve_validator_object_registry *regs = 
+		sieve_validator_object_registry_get(validator, ext_this);
+	
+	sieve_validator_object_registry_add(regs, &cmp->object);
+}
+
+const struct sieve_comparator *sieve_comparator_find
+(struct sieve_validator *validator, const char *identifier) 
+{
+	struct sieve_validator_object_registry *regs = 
+		sieve_validator_object_registry_get(validator, ext_this);
+	const struct sieve_object *object = 
+		sieve_validator_object_registry_find(regs, identifier);
+
+  return (const struct sieve_comparator *) object;
+}
+
+bool cmp_validator_load(struct sieve_validator *validator)
+{
+	struct sieve_validator_object_registry *regs = 
+		sieve_validator_object_registry_init(validator, ext_this);
+	unsigned int i;
+		
+	/* Register core comparators */
+	for ( i = 0; i < sieve_core_comparators_count; i++ ) {
+		sieve_validator_object_registry_add
+			(regs, &(sieve_core_comparators[i]->object));
+	}
+
+	return TRUE;
+}
+
+/* 
+ * Comparator tagged argument 
+ */
+ 
+/* Context data */
+
+struct sieve_comparator_context {
+	struct sieve_command_context *command_ctx;
+	const struct sieve_comparator *comparator;
+};
+ 
+/* Forward declarations */
+
+static bool tag_comparator_validate
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd);
+static bool tag_comparator_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+	struct sieve_command_context *cmd);
+
+/* Argument object */
+
+const struct sieve_argument comparator_tag = { 
+	"comparator", 
+	NULL, NULL,
+	tag_comparator_validate, 
+	NULL,
+	tag_comparator_generate 
+};
+
+/* Argument implementation */
+
+static bool tag_comparator_validate
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd)
+{
+	struct sieve_comparator_context *cmpctx;
+	struct sieve_ast_argument *tag = *arg;
+	const struct sieve_comparator *cmp;
+	
+	/* Skip tag */
+	*arg = sieve_ast_argument_next(*arg);
+	
+	/* Check syntax:
+	 *   ":comparator" <comparator-name: string>
+	 */
+	if ( (*arg)->type != SAAT_STRING ) {
+		sieve_argument_validate_error(validator, *arg, 
+			":comparator tag requires one string argument, but %s was found", 
+			sieve_ast_argument_name(*arg) );
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(validator, cmd, *arg, FALSE) )
+		return FALSE;
+
+	/* FIXME: We can currently only handle string literal argument, so
+	 * variables are not allowed.
+	 */
+	if ( !sieve_argument_is_string_literal(*arg) ) {
+		sieve_argument_validate_error(validator, *arg, 
+			"this Sieve implementation currently only supports "
+			"a literal string argument for the :comparator tag");
+		return FALSE;
+	}
+	
+	/* Get comparator from registry */
+	cmp = sieve_comparator_find(validator, sieve_ast_argument_strc(*arg));
+	
+	if ( cmp == NULL ) {
+		sieve_argument_validate_error(validator, *arg, 
+			"unknown comparator '%s'", 
+			str_sanitize(sieve_ast_argument_strc(*arg),80));
+
+		return FALSE;
+	}
+	
+	/* String argument not needed during code generation, so detach it from 
+	 * argument list 
+	 */
+	*arg = sieve_ast_arguments_detach(*arg, 1);
+
+	/* Create context */
+	cmpctx = p_new(sieve_command_pool(cmd), struct sieve_comparator_context, 1);
+	cmpctx->command_ctx = cmd;
+	cmpctx->comparator = cmp;
+
+	/* Store comparator in context */
+	tag->context = (void *) cmpctx;
+	
+	return TRUE;
+}
+
+static bool tag_comparator_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+	struct sieve_command_context *cmd ATTR_UNUSED)
+{
+	struct sieve_comparator_context *cmpctx = 
+		(struct sieve_comparator_context *) arg->context;
+	const struct sieve_comparator *cmp = cmpctx->comparator;
+	
+	sieve_opr_comparator_emit(cgenv->sbin, cmp);
+		
+	return TRUE;
+}
+
+/* Functions to enable and evaluate comparator tag for commands */
+
+void sieve_comparators_link_tag
+(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg,	
+	int id_code) 
+{
+	sieve_validator_register_tag(validator, cmd_reg, &comparator_tag, id_code); 	
+}
+
+bool sieve_comparator_tag_is
+(struct sieve_ast_argument *tag, const struct sieve_comparator *cmp)
+{
+	const struct sieve_comparator_context *cmpctx = 
+		(const struct sieve_comparator_context *) tag->context;
+
+	if ( cmpctx == NULL ) return FALSE;
+	
+	return ( tag->argument == &comparator_tag && cmpctx->comparator == cmp );
+}
+
+const struct sieve_comparator *sieve_comparator_tag_get
+(struct sieve_ast_argument *tag)
+{
+	const struct sieve_comparator_context *cmpctx;
+	
+	if ( tag->argument != &comparator_tag ) 
+		return NULL;
+		
+	cmpctx = (const struct sieve_comparator_context *) tag->context;
+		 
+	return cmpctx->comparator;
+}
+
+/*
+ * Comparator coding
+ */
+ 
+const struct sieve_operand_class sieve_comparator_operand_class = 
+	{ "comparator" };
+	
+static const struct sieve_extension_objects core_comparators =
+	SIEVE_EXT_DEFINE_COMPARATORS(sieve_core_comparators);
+
+const struct sieve_operand comparator_operand = { 
+	"comparator", 
+	NULL,
+	SIEVE_OPERAND_COMPARATOR, 
+	&sieve_comparator_operand_class,
+	&core_comparators
+};
+
+/*
+ * Trivial/Common comparator method implementations
+ */
+
+bool sieve_comparator_octet_skip
+	(const struct sieve_comparator *cmp ATTR_UNUSED, 
+		const char **val, const char *val_end)
+{
+	if ( *val < val_end ) {
+		(*val)++;
+		return TRUE;
+	}
+	
+	return FALSE;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-comparators.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-comparators.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-comparators.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-comparators.h	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,124 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+ 
+#ifndef __SIEVE_COMPARATORS_H
+#define __SIEVE_COMPARATORS_H
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-objects.h"
+#include "sieve-code.h"
+
+/* 
+ * Core comparators 
+ */
+ 
+enum sieve_comparator_code {
+	SIEVE_COMPARATOR_I_OCTET,
+	SIEVE_COMPARATOR_I_ASCII_CASEMAP,
+	SIEVE_COMPARATOR_CUSTOM
+};
+
+extern const struct sieve_comparator i_octet_comparator;
+extern const struct sieve_comparator i_ascii_casemap_comparator;
+
+/*
+ * Comparator flags
+ */
+
+enum sieve_comparator_flags {
+	SIEVE_COMPARATOR_FLAG_ORDERING = (1 << 0),
+	SIEVE_COMPARATOR_FLAG_EQUALITY = (1 << 1),
+	SIEVE_COMPARATOR_FLAG_PREFIX_MATCH = (1 << 2),
+	SIEVE_COMPARATOR_FLAG_SUBSTRING_MATCH = (1 << 3),	
+};
+
+/*
+ * Comparator object
+ */
+
+struct sieve_comparator {
+	struct sieve_object object;	
+		
+	unsigned int flags;
+	
+	/* Equality and ordering */
+
+	int (*compare)(const struct sieve_comparator *cmp, 
+		const char *val1, size_t val1_size, 
+		const char *val2, size_t val2_size);
+	
+	/* Prefix and substring match */
+	
+	bool (*char_match)(const struct sieve_comparator *cmp, 
+		const char **val, const char *val_end,
+		const char **key, const char *key_end);
+	bool (*char_skip)(const struct sieve_comparator *cmp, 
+		const char **val, const char *val_end);
+};
+
+/*
+ * Comparator tagged argument
+ */
+ 
+extern const struct sieve_argument comparator_tag;
+
+static inline bool sieve_argument_is_comparator
+	(struct sieve_ast_argument *arg) 
+{
+	return arg->argument == &comparator_tag;
+}
+
+void sieve_comparators_link_tag
+	(struct sieve_validator *validator, 
+		struct sieve_command_registration *cmd_reg,	int id_code);
+bool sieve_comparator_tag_is
+	(struct sieve_ast_argument *tag, const struct sieve_comparator *cmp);
+const struct sieve_comparator *sieve_comparator_tag_get
+	(struct sieve_ast_argument *tag);
+
+void sieve_comparator_register
+	(struct sieve_validator *validator, const struct sieve_comparator *cmp); 
+const struct sieve_comparator *sieve_comparator_find
+	(struct sieve_validator *validator, const char *identifier);
+		
+/*
+ * Comparator operand
+ */
+
+#define SIEVE_EXT_DEFINE_COMPARATOR(OP) SIEVE_EXT_DEFINE_OBJECT(OP)
+#define SIEVE_EXT_DEFINE_COMPARATORS(OPS) SIEVE_EXT_DEFINE_OBJECTS(OPS)
+
+extern const struct sieve_operand_class sieve_comparator_operand_class;
+extern const struct sieve_operand comparator_operand;
+
+static inline void sieve_opr_comparator_emit
+(struct sieve_binary *sbin, const struct sieve_comparator *cmp)
+{ 
+	sieve_opr_object_emit(sbin, &cmp->object);
+}
+
+static inline const struct sieve_comparator *sieve_opr_comparator_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	return (const struct sieve_comparator *) sieve_opr_object_read
+		(renv, &sieve_comparator_operand_class, address);
+}
+
+static inline bool sieve_opr_comparator_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	return sieve_opr_object_dump
+		(denv, &sieve_comparator_operand_class, address, NULL);
+}
+	
+/*
+ * Trivial/Common comparator method implementations
+ */
+
+bool sieve_comparator_octet_skip
+	(const struct sieve_comparator *cmp ATTR_UNUSED, 
+		const char **val, const char *val_end);
+
+#endif /* __SIEVE_COMPARATORS_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-config.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-config.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-config.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-config.h	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,11 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+
+#ifndef __SIEVE_CONFIG_H
+#define __SIEVE_CONFIG_H
+
+#include "dsieve-config.h"
+
+#define SIEVE_IMPLEMENTATION SIEVE_NAME " " SIEVE_VERSION
+
+#endif
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-dump.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-dump.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-dump.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-dump.h	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,24 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_DUMP_H
+#define __SIEVE_DUMP_H
+
+#include "sieve-common.h"
+
+#include "sieve-binary-dumper.h"
+#include "sieve-code-dumper.h"
+
+/*
+ * Dumptime environment
+ */
+
+struct sieve_dumptime_env {
+	struct sieve_binary_dumper *dumper;
+	struct sieve_code_dumper *cdumper;
+	struct sieve_binary *sbin;
+	
+	struct ostream *stream;
+};
+
+#endif /* __SIEVE_DUMP_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-error.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-error.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-error.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-error.c	2009-08-21 00:52:15.000000000 +0200
@@ -0,0 +1,699 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#include "lib.h"
+#include "str.h"
+#include "ostream.h"
+#include "eacces-error.h"
+
+#include "sieve-common.h"
+#include "sieve-script.h"
+#include "sieve-error-private.h"
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <stdio.h>
+
+/*
+ * Definitions
+ */
+
+#define CRITICAL_MSG \
+	"internal error occurred: refer to server log for more information."
+#define CRITICAL_MSG_STAMP CRITICAL_MSG " [%Y-%m-%d %H:%M:%S]"
+
+/* Logfile error handler will rotate log when it exceeds 10k bytes */
+#define LOGFILE_MAX_SIZE (10 * 1024)
+
+/*
+ * Utility
+ */
+
+const char *sieve_error_script_location
+(const struct sieve_script *script, unsigned int source_line)
+{
+    const char *sname;
+
+	sname = ( script == NULL ? NULL : sieve_script_name(script) );
+
+    if ( sname == NULL || *sname == '\0' )
+        return t_strdup_printf("line %d", source_line);
+
+    return t_strdup_printf("%s: line %d", sname, source_line);
+}
+
+/*
+ * Main error functions
+ */
+
+void sieve_verror
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args)
+{
+	if ( ehandler == NULL ) return;
+	
+	if ( ehandler->log_master ) {
+		va_list args_copy;
+
+		VA_COPY(args_copy, args);
+
+		if ( location == NULL || *location == '\0' )
+			sieve_sys_error("%s", t_strdup_vprintf(fmt, args_copy));
+		else
+			sieve_sys_error("%s: %s", location, t_strdup_vprintf(fmt, args_copy));
+	}
+
+	if ( sieve_errors_more_allowed(ehandler) ) {
+		if ( ehandler->verror != NULL )
+			ehandler->verror(ehandler, location, fmt, args);
+		
+		if ( ehandler->pool != NULL )
+			ehandler->errors++;
+	}
+}
+
+void sieve_vwarning
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args)
+{
+	if ( ehandler == NULL ) return;
+
+	if ( ehandler->log_master ) {
+		va_list args_copy;
+
+		VA_COPY(args_copy, args);
+
+		if ( location == NULL || *location == '\0' )
+			sieve_sys_warning("%s", t_strdup_vprintf(fmt, args_copy));
+		else
+			sieve_sys_warning("%s: %s", location, t_strdup_vprintf(fmt, args_copy));
+	}
+	
+	if ( ehandler->vwarning != NULL )	
+		ehandler->vwarning(ehandler, location, fmt, args);
+
+	if ( ehandler->pool != NULL )
+		ehandler->warnings++;
+}
+
+void sieve_vinfo
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args)
+{
+	if ( ehandler == NULL ) return;
+
+	if ( ehandler->log_master ) {
+		va_list args_copy;
+
+		VA_COPY(args_copy, args);
+
+
+		if ( location == NULL || *location == '\0' )
+			sieve_sys_info("%s", t_strdup_vprintf(fmt, args_copy));
+		else	
+			sieve_sys_info("%s: %s", location, t_strdup_vprintf(fmt, args_copy));
+	}
+	
+	if ( ehandler->log_info && ehandler->vinfo != NULL )	
+		ehandler->vinfo(ehandler, location, fmt, args);
+}
+
+void sieve_vcritical
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args)
+{
+	char str[256];
+	struct tm *tm; 
+	
+	tm = localtime(&ioloop_time);
+	
+	if ( location == NULL || *location == '\0' )
+		sieve_sys_error("%s", t_strdup_vprintf(fmt, args));
+	else
+		sieve_sys_error("%s: %s", location, t_strdup_vprintf(fmt, args));
+		
+	if ( ehandler == NULL ) return;
+	
+	sieve_error(ehandler, location, "%s", 
+		strftime(str, sizeof(str), CRITICAL_MSG_STAMP, tm) > 0 ? 
+			str : CRITICAL_MSG );	
+}
+
+/*
+ * Error statistics
+ */
+
+unsigned int sieve_get_errors(struct sieve_error_handler *ehandler) 
+{
+	if ( ehandler == NULL || ehandler->pool == NULL ) return 0;
+	
+	return ehandler->errors;
+}
+
+unsigned int sieve_get_warnings(struct sieve_error_handler *ehandler) 
+{
+	if ( ehandler == NULL || ehandler->pool == NULL ) return 0;
+
+	return ehandler->errors;
+}
+
+bool sieve_errors_more_allowed(struct sieve_error_handler *ehandler) 
+{
+	if ( ehandler == NULL || ehandler->pool == NULL ) 
+		return TRUE;
+
+	return ehandler->max_errors == 0 || ehandler->errors < ehandler->max_errors;
+}
+
+/*
+ * Error handler configuration
+ */
+
+void sieve_error_handler_accept_infolog
+	(struct sieve_error_handler *ehandler, bool enable)
+{
+	ehandler->log_info = enable;	
+}
+
+void sieve_error_handler_copy_masterlog
+	(struct sieve_error_handler *ehandler, bool enable)
+{
+	ehandler->log_master = enable;
+}
+
+/*
+ * Error handler init
+ */
+
+void sieve_error_handler_init
+	(struct sieve_error_handler *ehandler, pool_t pool, unsigned int max_errors)
+{
+	ehandler->pool = pool;
+	ehandler->refcount = 1;
+	ehandler->max_errors = max_errors;
+	
+	ehandler->errors = 0;
+	ehandler->warnings = 0;
+}
+
+void sieve_error_handler_ref(struct sieve_error_handler *ehandler)
+{
+	if ( ehandler == NULL || ehandler->pool == NULL ) return;
+
+	ehandler->refcount++;
+}
+
+void sieve_error_handler_unref(struct sieve_error_handler **ehandler)
+{
+	if ( *ehandler == NULL || (*ehandler)->pool == NULL ) return;
+
+	i_assert((*ehandler)->refcount > 0);
+
+	if (--(*ehandler)->refcount != 0)
+        	return;
+
+	if ( (*ehandler)->free != NULL )
+		(*ehandler)->free(*ehandler);
+
+	pool_unref(&((*ehandler)->pool));
+
+	*ehandler = NULL;
+}
+
+void sieve_error_handler_reset(struct sieve_error_handler *ehandler)
+{
+	if ( ehandler == NULL || ehandler->pool == NULL ) return;
+
+	ehandler->errors = 0;
+	ehandler->warnings = 0;
+}
+
+/* 
+ * Master/System error handler
+ *
+ * - Output errors directly to Dovecot master log
+ */
+
+static void sieve_master_verror
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, va_list args) 
+{
+	if ( ehandler->log_master ) return;
+
+	if ( location == NULL || *location == '\0' )
+		i_error("sieve: %s", t_strdup_vprintf(fmt, args));
+	else
+		i_error("sieve: %s: %s", location, t_strdup_vprintf(fmt, args));
+}
+
+static void sieve_master_vwarning
+(struct sieve_error_handler *ehandler ATTR_UNUSED, const char *location, 
+	const char *fmt, va_list args) 
+{
+	if ( ehandler->log_master ) return;
+
+	if ( location == NULL || *location == '\0' )
+		i_warning("sieve: %s", t_strdup_vprintf(fmt, args));
+	else
+		i_warning("sieve: %s: %s", location, t_strdup_vprintf(fmt, args));
+}
+
+static void sieve_master_vinfo
+(struct sieve_error_handler *ehandler ATTR_UNUSED, const char *location, 
+	const char *fmt, va_list args) 
+{
+	if ( ehandler->log_master ) return;
+
+	if ( location == NULL || *location == '\0' )
+		i_info("sieve: %s", t_strdup_vprintf(fmt, args));
+	else
+		i_info("sieve: %s: %s", location, t_strdup_vprintf(fmt, args));
+}
+
+struct sieve_error_handler *sieve_master_ehandler_create
+(unsigned int max_errors) 
+{
+	pool_t pool;
+	struct sieve_error_handler *ehandler;
+	
+	/* Pool is not strictly necessary, but other handler types will need a pool,
+	 * so this one will have one too.
+	 */
+	pool = pool_alloconly_create
+		("master_error_handler", sizeof(struct sieve_error_handler));
+	ehandler = p_new(pool, struct sieve_error_handler, 1);
+	sieve_error_handler_init(ehandler, pool, max_errors);
+
+	ehandler->verror = sieve_master_verror;
+	ehandler->vwarning = sieve_master_vwarning;
+	ehandler->vinfo = sieve_master_vinfo;
+	
+	return ehandler;	
+}
+
+struct sieve_error_handler _sieve_system_ehandler_object = {
+	NULL, 0, 0, 0, 0,
+	FALSE,
+	TRUE,
+	sieve_master_verror,
+	sieve_master_vwarning,
+	sieve_master_vinfo,
+	NULL
+};
+
+struct sieve_error_handler *_sieve_system_ehandler = &_sieve_system_ehandler_object;
+
+void sieve_system_ehandler_set(struct sieve_error_handler *ehandler)
+{
+	sieve_error_handler_unref(&_sieve_system_ehandler);
+	_sieve_system_ehandler = ehandler;
+	sieve_error_handler_ref(_sieve_system_ehandler);
+}
+
+void sieve_system_ehandler_reset(void)
+{
+	sieve_error_handler_unref(&_sieve_system_ehandler);
+	_sieve_system_ehandler = &_sieve_system_ehandler_object;	
+}
+
+/* 
+ * STDERR error handler
+ *
+ * - Output errors directly to stderror 
+ */
+
+static void sieve_stderr_verror
+(struct sieve_error_handler *ehandler ATTR_UNUSED, const char *location, 
+	const char *fmt, va_list args) 
+{
+	if ( location == NULL || *location == '\0' )
+		fprintf(stderr, "error: %s.\n", t_strdup_vprintf(fmt, args));
+	else
+		fprintf(stderr, "%s: error: %s.\n", location, t_strdup_vprintf(fmt, args));
+}
+
+static void sieve_stderr_vwarning
+(struct sieve_error_handler *ehandler ATTR_UNUSED, const char *location, 
+	const char *fmt, va_list args) 
+{
+	if ( location == NULL || *location == '\0' )
+		fprintf(stderr, "warning: %s.\n", t_strdup_vprintf(fmt, args));
+	else
+		fprintf(stderr, "%s: warning: %s.\n", location, t_strdup_vprintf(fmt, args));
+}
+
+static void sieve_stderr_vinfo
+(struct sieve_error_handler *ehandler ATTR_UNUSED, const char *location, 
+	const char *fmt, va_list args) 
+{
+	if ( location == NULL || *location == '\0' )
+		fprintf(stderr, "info: %s.\n", t_strdup_vprintf(fmt, args));
+	else
+		fprintf(stderr, "%s: info: %s.\n", location, t_strdup_vprintf(fmt, args));
+}
+
+struct sieve_error_handler *sieve_stderr_ehandler_create
+(unsigned int max_errors) 
+{
+	pool_t pool;
+	struct sieve_error_handler *ehandler;
+	
+	/* Pool is not strictly necessary, but other handler types will need a pool,
+	 * so this one will have one too.
+	 */
+	pool = pool_alloconly_create
+		("stderr_error_handler", sizeof(struct sieve_error_handler));
+	ehandler = p_new(pool, struct sieve_error_handler, 1);
+	sieve_error_handler_init(ehandler, pool, max_errors);
+
+	ehandler->verror = sieve_stderr_verror;
+	ehandler->vwarning = sieve_stderr_vwarning;
+	ehandler->vinfo = sieve_stderr_vinfo;
+	
+	return ehandler;	
+}
+
+/* String buffer error handler
+ *
+ * - Output errors to a string buffer 
+ */
+
+struct sieve_strbuf_ehandler {
+	struct sieve_error_handler handler;
+
+	string_t *errors;
+	bool crlf;
+};
+
+static void sieve_strbuf_verror
+(struct sieve_error_handler *ehandler, const char *location,
+    const char *fmt, va_list args)
+{
+	struct sieve_strbuf_ehandler *handler =
+		(struct sieve_strbuf_ehandler *) ehandler;
+
+	if ( location != NULL && *location != '\0' )
+		str_printfa(handler->errors, "%s: ", location);
+	str_append(handler->errors, "error: ");
+	str_vprintfa(handler->errors, fmt, args);
+
+	if ( !handler->crlf )
+		str_append(handler->errors, ".\n");
+	else
+		str_append(handler->errors, ".\r\n");
+}
+
+static void sieve_strbuf_vwarning
+(struct sieve_error_handler *ehandler, const char *location,
+    const char *fmt, va_list args)
+{
+	struct sieve_strbuf_ehandler *handler =
+		(struct sieve_strbuf_ehandler *) ehandler;
+
+	if ( location != NULL && *location != '\0' )
+		str_printfa(handler->errors, "%s: ", location);
+	str_printfa(handler->errors, "warning: ");
+	str_vprintfa(handler->errors, fmt, args);
+
+	if ( !handler->crlf )
+		str_append(handler->errors, ".\n");
+	else
+		str_append(handler->errors, ".\r\n");
+}
+
+static void sieve_strbuf_vinfo
+(struct sieve_error_handler *ehandler, const char *location,
+    const char *fmt, va_list args)
+{
+	struct sieve_strbuf_ehandler *handler =
+		(struct sieve_strbuf_ehandler *) ehandler;
+
+	if ( location != NULL && *location != '\0' )
+		str_printfa(handler->errors, "%s: ", location);	
+	str_printfa(handler->errors, "info: ");
+	str_vprintfa(handler->errors, fmt, args);
+
+	if ( !handler->crlf )
+		str_append(handler->errors, ".\n");
+	else
+		str_append(handler->errors, ".\r\n");
+}
+
+struct sieve_error_handler *sieve_strbuf_ehandler_create
+(string_t *strbuf, bool crlf, unsigned int max_errors)
+{
+	pool_t pool;
+	struct sieve_strbuf_ehandler *ehandler;
+
+	pool = pool_alloconly_create("strbuf_error_handler", 256);
+	ehandler = p_new(pool, struct sieve_strbuf_ehandler, 1);
+	ehandler->errors = strbuf;
+    
+	sieve_error_handler_init(&ehandler->handler, pool, max_errors);
+
+	ehandler->handler.verror = sieve_strbuf_verror;
+	ehandler->handler.vwarning = sieve_strbuf_vwarning;
+	ehandler->handler.vinfo = sieve_strbuf_vinfo;
+
+	ehandler->crlf = crlf;
+
+	return &(ehandler->handler);
+}
+
+/* 
+ * Logfile error handler
+ * 
+ * - Output errors to a log file 
+ */
+
+struct sieve_logfile_ehandler {
+	struct sieve_error_handler handler;
+	
+	const char *logfile;
+	bool started;
+	int fd;
+	struct ostream *stream;
+};
+
+static void sieve_logfile_vprintf
+(struct sieve_logfile_ehandler *ehandler, const char *location, 
+	const char *prefix, const char *fmt, va_list args) 
+{
+	string_t *outbuf;
+	ssize_t ret = 0, remain;
+	const char *data;
+	
+	if ( ehandler->stream == NULL ) return;
+	
+	T_BEGIN {
+		outbuf = t_str_new(256);
+		if ( location != NULL && *location != '\0' )
+			str_printfa(outbuf, "%s: ", location);
+		str_printfa(outbuf, "%s: ", prefix);	
+		str_vprintfa(outbuf, fmt, args);
+		str_append(outbuf, ".\n");
+	
+		remain = str_len(outbuf);
+		data = (const char *) str_data(outbuf);
+
+		while ( remain > 0 ) { 
+			if ( (ret=o_stream_send(ehandler->stream, data, remain)) < 0 )
+				break;
+
+			remain -= ret;
+			data += ret;
+		}
+	} T_END;
+
+	if ( ret < 0 ) {
+		sieve_sys_error(
+			"o_stream_send() failed on logfile %s: %m", ehandler->logfile);		
+	}
+}
+
+inline static void sieve_logfile_printf
+(struct sieve_logfile_ehandler *ehandler, const char *location, const char *prefix,
+	const char *fmt, ...) 
+{
+	va_list args;
+	va_start(args, fmt);
+	
+	sieve_logfile_vprintf(ehandler, location, prefix, fmt, args);
+	
+	va_end(args);
+}
+
+static void sieve_logfile_start(struct sieve_logfile_ehandler *ehandler)
+{
+	int fd;
+	struct ostream *ostream = NULL;
+	struct stat st;
+	struct tm *tm;
+	char buf[256];
+	time_t now;
+
+	/* Open the logfile */
+
+	fd = open(ehandler->logfile, O_CREAT | O_APPEND | O_WRONLY, 0600);
+	if (fd == -1) {
+		if ( errno == EACCES ) {
+			sieve_sys_error("failed to open logfile (LOGGING TO STDERR): %s",
+				eacces_error_get_creating("open", ehandler->logfile));
+		} else {
+			sieve_sys_error("failed to open logfile (LOGGING TO STDERR): "
+				"open(%s) failed: %m", ehandler->logfile);
+		}
+		fd = STDERR_FILENO;
+	} else {
+		/* fd_close_on_exec(fd, TRUE); Necessary? */
+
+		/* Stat the log file to obtain size information */
+		if ( fstat(fd, &st) != 0 ) {
+			sieve_sys_error("failed to stat logfile (logging to STDERR): "
+				"fstat(fd=%s) failed: %m", ehandler->logfile);
+			
+			if ( close(fd) < 0 ) {
+				sieve_sys_error("failed to close logfile after error: "
+					"close(fd=%s) failed: %m", ehandler->logfile);
+			}
+
+			fd = STDERR_FILENO;
+		}
+		
+		/* Rotate log when it has grown too large */
+		if ( st.st_size >= LOGFILE_MAX_SIZE ) {
+			const char *rotated;
+			
+			/* Close open file */
+			if ( close(fd) < 0 ) {
+				sieve_sys_error("failed to close logfile: close(fd=%s) failed: %m",
+					ehandler->logfile);
+			}
+			
+			/* Rotate logfile */
+			rotated = t_strconcat(ehandler->logfile, ".0", NULL);
+			if ( rename(ehandler->logfile, rotated) < 0 ) {
+				sieve_sys_error("failed to rotate logfile: rename(%s, %s) failed: %m", 
+					ehandler->logfile, rotated);
+			}
+			
+			/* Open clean logfile (overwrites existing if rename() failed earlier) */
+			fd = open(ehandler->logfile, O_CREAT | O_WRONLY | O_TRUNC, 0600);
+			if (fd == -1) {
+				if ( errno == EACCES ) {
+					sieve_sys_error("failed to open logfile (LOGGING TO STDERR): %s",
+						eacces_error_get_creating("open", ehandler->logfile));
+				} else {
+					sieve_sys_error("failed to open logfile (LOGGING TO STDERR): "
+						"open(%s) failed: %m", ehandler->logfile);
+				}
+				fd = STDERR_FILENO;
+			}
+		}
+	}
+
+	ostream = o_stream_create_fd(fd, 0, FALSE);
+	if ( ostream == NULL ) {
+		/* Can't we do anything else in this most awkward situation? */
+		sieve_sys_error("failed to open log stream on open file: "
+			"o_stream_create_fd(fd=%s) failed "
+			"(non-critical messages are not logged!)", ehandler->logfile);
+	} 
+
+	ehandler->fd = fd;
+	ehandler->stream = ostream;
+	ehandler->started = TRUE;
+	
+	if ( ostream != NULL ) {
+		now = time(NULL);	
+		tm = localtime(&now);
+
+		if (strftime(buf, sizeof(buf), "%b %d %H:%M:%S", tm) > 0) {
+			sieve_logfile_printf(ehandler, "sieve", "info",
+				"started log at %s", buf);
+		}
+	}
+}
+
+static void sieve_logfile_verror
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, va_list args) 
+{
+	struct sieve_logfile_ehandler *handler = 
+		(struct sieve_logfile_ehandler *) ehandler;
+
+	if ( !handler->started ) sieve_logfile_start(handler);	
+
+	sieve_logfile_vprintf(handler, location, "error", fmt, args);
+}
+
+static void sieve_logfile_vwarning
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, va_list args) 
+{
+	struct sieve_logfile_ehandler *handler = 
+		(struct sieve_logfile_ehandler *) ehandler;
+
+	if ( !handler->started ) sieve_logfile_start(handler);	
+
+	sieve_logfile_vprintf(handler, location, "warning", fmt, args);
+}
+
+static void sieve_logfile_vinfo
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, va_list args) 
+{
+	struct sieve_logfile_ehandler *handler = 
+		(struct sieve_logfile_ehandler *) ehandler;
+
+	if ( !handler->started ) sieve_logfile_start(handler);	
+
+	sieve_logfile_vprintf(handler, location, "info", fmt, args);
+}
+
+static void sieve_logfile_free
+(struct sieve_error_handler *ehandler)
+{
+	struct sieve_logfile_ehandler *handler = 
+		(struct sieve_logfile_ehandler *) ehandler;
+		
+	if ( handler->stream != NULL ) {
+		o_stream_destroy(&(handler->stream));
+		if ( handler->fd != STDERR_FILENO ){
+			if ( close(handler->fd) < 0 ) {
+				sieve_sys_error("failed to close logfile: "
+					"close(fd=%s) failed: %m", handler->logfile);
+			}
+		}
+	}
+}
+
+struct sieve_error_handler *sieve_logfile_ehandler_create
+(const char *logfile, unsigned int max_errors) 
+{
+	pool_t pool;
+	struct sieve_logfile_ehandler *ehandler;
+	
+	pool = pool_alloconly_create("logfile_error_handler", 256);	
+	ehandler = p_new(pool, struct sieve_logfile_ehandler, 1);
+	sieve_error_handler_init(&ehandler->handler, pool, max_errors);
+
+	ehandler->handler.verror = sieve_logfile_verror;
+	ehandler->handler.vwarning = sieve_logfile_vwarning;
+	ehandler->handler.vinfo = sieve_logfile_vinfo;
+	ehandler->handler.free = sieve_logfile_free;
+	
+	/* Don't open logfile until something is actually logged. 
+	 * Let's not pullute the sieve directory with useless logfiles.
+	 */
+	ehandler->logfile = p_strdup(pool, logfile);
+	ehandler->started = FALSE;
+	ehandler->stream = NULL;
+	ehandler->fd = -1;
+	
+	return &(ehandler->handler);	
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-error.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-error.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-error.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-error.h	2009-07-21 01:19:26.000000000 +0200
@@ -0,0 +1,172 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_ERROR_H
+#define __SIEVE_ERROR_H
+
+#include "lib.h"
+#include "compat.h"
+
+#include <stdarg.h>
+
+/*
+ * Forward declarations
+ */
+
+struct sieve_script;
+struct sieve_error_handler;
+
+/*
+ * Types
+ */
+
+typedef void (*sieve_error_vfunc_t)
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args);
+
+/*
+ * System errors
+ */
+
+extern struct sieve_error_handler *_sieve_system_ehandler;
+
+#define sieve_sys_error(...) sieve_error(_sieve_system_ehandler, NULL, __VA_ARGS__ )
+#define sieve_sys_warning(...) sieve_warning(_sieve_system_ehandler, NULL, __VA_ARGS__ )
+#define sieve_sys_info(...) sieve_info(_sieve_system_ehandler, NULL, __VA_ARGS__ )
+
+void sieve_system_ehandler_set(struct sieve_error_handler *ehandler);
+void sieve_system_ehandler_reset(void);
+
+/*
+ * Main error functions
+ */
+
+/* For these functions it is the responsibility of the caller to
+ * manage the datastack.
+ */
+
+const char *sieve_error_script_location
+	(const struct sieve_script *script, unsigned int source_line);
+
+void sieve_verror
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args);
+void sieve_vwarning
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args); 
+void sieve_vinfo
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args); 
+void sieve_vcritical
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args); 
+
+inline static void sieve_error
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, ...) ATTR_FORMAT(3, 4);
+inline static void sieve_warning
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, ...) ATTR_FORMAT(3, 4);
+inline static void sieve_info
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, ...) ATTR_FORMAT(3, 4);
+inline static void sieve_critical
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, ...) ATTR_FORMAT(3, 4);
+
+inline static void sieve_error
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+	
+	T_BEGIN { sieve_verror(ehandler, location, fmt, args); } T_END;
+	
+	va_end(args);
+}
+
+inline static void sieve_warning
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+	
+	T_BEGIN { sieve_vwarning(ehandler, location, fmt, args); } T_END;
+
+	va_end(args);
+}
+
+inline static void sieve_info
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+	
+	T_BEGIN { sieve_vinfo(ehandler, location, fmt, args); } T_END;
+	
+	va_end(args);
+}
+
+inline static void sieve_critical
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+	
+	T_BEGIN { sieve_vcritical(ehandler, location, fmt, args); } T_END;
+	
+	va_end(args);
+}
+
+/*
+ * Error handler configuration
+ */
+
+void sieve_error_handler_accept_infolog
+	(struct sieve_error_handler *ehandler, bool enable);
+void sieve_error_handler_copy_masterlog
+	(struct sieve_error_handler *ehandler, bool enable);
+
+/*
+ * Error handler statistics
+ */
+
+unsigned int sieve_get_errors(struct sieve_error_handler *ehandler);
+unsigned int sieve_get_warnings(struct sieve_error_handler *ehandler);
+
+bool sieve_errors_more_allowed(struct sieve_error_handler *ehandler);
+
+/*
+ * Error handler object
+ */
+
+void sieve_error_handler_ref(struct sieve_error_handler *ehandler);
+void sieve_error_handler_unref(struct sieve_error_handler **ehandler);
+
+void sieve_error_handler_reset(struct sieve_error_handler *ehandler);
+
+/* 
+ * Error handlers 
+ */
+
+/* Write errors to dovecot master log */
+struct sieve_error_handler *sieve_master_ehandler_create
+	(unsigned int max_errors);
+
+/* Write errors to stderr */
+struct sieve_error_handler *sieve_stderr_ehandler_create
+	(unsigned int max_errors);
+
+/* Write errors into a string buffer */
+struct sieve_error_handler *sieve_strbuf_ehandler_create
+	(string_t *strbuf, bool crlf, unsigned int max_errors);
+
+/* Write errors to a logfile */
+struct sieve_error_handler *sieve_logfile_ehandler_create
+	(const char *logfile, unsigned int max_errors);  
+
+#endif /* __SIEVE_ERROR_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-error-private.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-error-private.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-error-private.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-error-private.h	2009-04-09 21:45:29.000000000 +0200
@@ -0,0 +1,47 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_ERROR_PRIVATE_H
+#define __SIEVE_ERROR_PRIVATE_H
+
+#include "sieve-error.h"
+
+/*
+ * Error handler object
+ */
+
+struct sieve_error_handler {
+	pool_t pool;
+	int refcount;
+
+	unsigned int max_errors;
+
+	unsigned int errors;
+	unsigned int warnings;
+
+	/* Should we copy log to i_error, i_warning and i_info? */
+	bool log_master;
+
+	/* Should the errorhandler handle or discard info log?
+	 * (This does not influence the previous setting)
+	 */
+	bool log_info;
+
+	void (*verror)
+		(struct sieve_error_handler *ehandler, const char *location,
+			const char *fmt, va_list args);
+	void (*vwarning)
+		(struct sieve_error_handler *ehandler, const char *location,
+			const char *fmt, va_list args);
+	void (*vinfo)
+		(struct sieve_error_handler *ehandler, const char *location,
+			const char *fmt, va_list args);
+
+	void (*free)
+		(struct sieve_error_handler *ehandler);
+};
+
+void sieve_error_handler_init
+	(struct sieve_error_handler *ehandler, pool_t pool, unsigned int max_errors);
+
+#endif /* __SIEVE_ERROR_PRIVATE_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-extensions.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-extensions.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-extensions.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-extensions.c	2009-08-21 00:52:15.000000000 +0200
@@ -0,0 +1,555 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "mempool.h"
+#include "hash.h"
+#include "array.h"
+
+#include "sieve-error.h"
+#include "sieve-extensions.h"
+
+/*
+ * Forward declarations 
+ */
+
+static void sieve_extensions_init_registry(void);
+static void sieve_extensions_deinit_registry(void);
+
+static void sieve_extensions_init_capabilities(void);
+static void sieve_extensions_deinit_capabilities(void);
+
+/* 
+ * Pre-loaded 'extensions' 
+ */
+
+extern const struct sieve_extension comparator_extension;
+extern const struct sieve_extension match_type_extension;
+extern const struct sieve_extension address_part_extension;
+
+const struct sieve_extension *sieve_preloaded_extensions[] = {
+	&comparator_extension, &match_type_extension, &address_part_extension
+};
+
+const unsigned int sieve_preloaded_extensions_count = 
+	N_ELEMENTS(sieve_preloaded_extensions);
+
+/* 
+ * Dummy extensions 
+ */
+ 
+/* FIXME: This is stupid. Define a comparator-* extension and be done with it */
+
+static const struct sieve_extension comparator_i_octet_extension = {
+	"comparator-i;octet", 
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_NO_OPERATIONS, 
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+static const struct sieve_extension comparator_i_ascii_casemap_extension = {
+	"comparator-i;ascii-casemap", 
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
+	SIEVE_EXT_DEFINE_NO_OPERATIONS, 
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+/* 
+ * Core extensions 
+ */
+
+extern const struct sieve_extension fileinto_extension;
+extern const struct sieve_extension reject_extension;
+extern const struct sieve_extension envelope_extension;
+extern const struct sieve_extension encoded_character_extension;
+
+/* 
+ * Native 'plugin' extensions 
+ */
+
+extern const struct sieve_extension vacation_extension;
+extern const struct sieve_extension subaddress_extension;
+extern const struct sieve_extension comparator_i_ascii_numeric_extension;
+extern const struct sieve_extension relational_extension;
+extern const struct sieve_extension regex_extension;
+extern const struct sieve_extension imap4flags_extension;
+extern const struct sieve_extension copy_extension;
+extern const struct sieve_extension include_extension;
+extern const struct sieve_extension body_extension;
+extern const struct sieve_extension variables_extension;
+extern const struct sieve_extension enotify_extension;
+extern const struct sieve_extension environment_extension;
+extern const struct sieve_extension mailbox_extension;
+extern const struct sieve_extension date_extension;
+
+/*
+ * List of native extensions
+ */
+
+const struct sieve_extension *sieve_core_extensions[] = {
+	/* Preloaded 'extensions' */
+	&comparator_extension, &match_type_extension, &address_part_extension,
+	
+	/* Dummy extensions */ 
+	&comparator_i_octet_extension, &comparator_i_ascii_casemap_extension, 
+	
+	/* Core extensions */
+	&fileinto_extension, &reject_extension, &envelope_extension, 
+	&encoded_character_extension,
+	
+	/* 'Plugins' */
+	&vacation_extension, &subaddress_extension, 
+	&comparator_i_ascii_numeric_extension, 
+	&relational_extension, &regex_extension, &imap4flags_extension,
+	&copy_extension, &include_extension, &body_extension,
+	&variables_extension, &enotify_extension, &environment_extension,
+	&mailbox_extension, &date_extension
+};
+
+const unsigned int sieve_core_extensions_count =
+	N_ELEMENTS(sieve_core_extensions);
+
+/*
+ * Deprecated extensions
+ */
+
+extern const struct sieve_extension imapflags_extension;
+extern const struct sieve_extension notify_extension;
+
+const struct sieve_extension *sieve_deprecated_extensions[] = {
+	&imapflags_extension,
+	&notify_extension
+};
+
+const unsigned int sieve_deprecated_extensions_count =
+	N_ELEMENTS(sieve_deprecated_extensions);
+
+/*
+ * Unfinished extensions
+ */
+
+#ifdef HAVE_SIEVE_UNFINISHED
+
+extern const struct sieve_extension ereject_extension;
+
+const struct sieve_extension *sieve_unfinished_extensions[] = {
+	&ereject_extension,
+};
+
+const unsigned int sieve_unfinished_extensions_count =
+	N_ELEMENTS(sieve_unfinished_extensions);
+
+#endif /* HAVE_SIEVE_UNFINISHED */
+
+/* 
+ * Extensions init/deinit
+ */
+
+bool sieve_extensions_init(void) 
+{
+	unsigned int i;
+	
+	sieve_extensions_init_registry();
+	sieve_extensions_init_capabilities();
+	
+	/* Pre-load core extensions */
+	for ( i = 0; i < sieve_core_extensions_count; i++ ) {
+		(void)sieve_extension_register(sieve_core_extensions[i], TRUE);
+	}
+
+	/* Register deprecated extensions */
+	for ( i = 0; i < sieve_deprecated_extensions_count; i++ ) {
+		(void)sieve_extension_register(sieve_deprecated_extensions[i], FALSE);
+	}
+
+#ifdef HAVE_SIEVE_UNFINISHED
+	/* Register unfinished extensions */
+	for ( i = 0; i < sieve_unfinished_extensions_count; i++ ) {
+		(void)sieve_extension_register(sieve_unfinished_extensions[i], FALSE);
+	}
+#endif
+
+	/* More extensions can be added through plugins */
+	
+	return TRUE;
+}
+
+void sieve_extensions_deinit(void)
+{	
+	sieve_extensions_deinit_capabilities();
+	sieve_extensions_deinit_registry();
+}
+
+/* 
+ * Extension registry
+ */
+ 
+struct sieve_extension_registration {
+	const struct sieve_extension *extension;
+	int id;
+	bool required;
+	bool loaded;
+};
+
+static ARRAY_DEFINE(extensions, struct sieve_extension_registration); 
+static struct hash_table *extension_index; 
+
+static void sieve_extensions_init_registry(void)
+{	
+	i_array_init(&extensions, 30);
+	extension_index = hash_table_create
+		(default_pool, default_pool, 0, str_hash, (hash_cmp_callback_t *)strcmp);
+}
+
+static bool _sieve_extension_load
+(const struct sieve_extension *extension)
+{
+	/* Call load handler */
+	if ( extension->load != NULL && !extension->load() ) {
+		sieve_sys_error("failed to load '%s' extension support.", 
+			extension->name);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+static struct sieve_extension_registration *_sieve_extension_register
+(const struct sieve_extension *extension, bool load)
+{
+	struct sieve_extension_registration *ereg = 
+		(struct sieve_extension_registration *)	
+		hash_table_lookup(extension_index, extension->name);
+
+	/* Register extension if it is not registered already */
+	if ( ereg == NULL ) {
+		int ext_id = array_count(&extensions);
+
+		/* Add extension to the registry */
+
+		ereg = array_append_space(&extensions);
+		ereg->id = ext_id;
+
+		hash_table_insert(extension_index, (void *) extension->name, (void *) ereg);
+	}
+
+	/* Enable extension */
+	if ( extension->_id != NULL && load ) {
+		/* Make sure extension is enabled */
+		*(extension->_id) = ereg->id;
+
+		/* Call load handler if extension was not loaded already */
+		if ( !ereg->loaded ) {
+			if ( !_sieve_extension_load(extension) )
+				return NULL;
+		}
+
+		ereg->loaded = TRUE;
+	}
+
+	ereg->extension = extension;
+
+	return ereg;
+}
+
+int sieve_extension_register
+(const struct sieve_extension *extension, bool load) 
+{
+	struct sieve_extension_registration *ereg;
+
+	/* Register the extension */
+	if ( (ereg=_sieve_extension_register(extension, load)) == NULL ) {
+		return -1;
+	}
+
+	return ereg->id;
+}
+
+int sieve_extension_require(const struct sieve_extension *extension)
+{
+	struct sieve_extension_registration *ereg;
+
+	/* Register (possibly unknown) extension */
+    if ( (ereg=_sieve_extension_register(extension, TRUE)) == NULL ) {
+        return -1;
+    }
+
+	ereg->required = TRUE;
+	return ereg->id;
+}
+
+int sieve_extensions_get_count(void)
+{
+	return array_count(&extensions);
+}
+
+const struct sieve_extension *sieve_extension_get_by_id(unsigned int ext_id) 
+{
+	const struct sieve_extension_registration *ereg;
+	
+	if ( ext_id < array_count(&extensions) ) {
+		ereg = array_idx(&extensions, ext_id);
+
+		if ( SIEVE_EXT_ENABLED(ereg->extension) )
+			return ereg->extension;
+	}
+	
+	return NULL;
+}
+
+const struct sieve_extension *sieve_extension_get_by_name(const char *name) 
+{
+	struct sieve_extension_registration *ereg;
+	
+	if ( *name == '@' )
+		return NULL;	
+		
+	ereg = (struct sieve_extension_registration *) 
+		hash_table_lookup(extension_index, name);
+
+	if ( ereg == NULL || !SIEVE_EXT_ENABLED(ereg->extension) )
+		return NULL;
+		
+	return ereg->extension;
+}
+
+static inline bool _list_extension
+	(const struct sieve_extension_registration *ereg)
+{
+	return 
+		( SIEVE_EXT_ENABLED(ereg->extension) && 
+			*(ereg->extension->name) != '@' );
+}
+
+const char *sieve_extensions_get_string(void)
+{
+	unsigned int i, ext_count;
+	const struct sieve_extension_registration *eregs;
+	string_t *extstr = t_str_new(256);
+
+	eregs = array_get(&extensions, &ext_count);
+
+	if ( ext_count > 0 ) {
+		i = 0;
+		
+		/* Find first listable extension */
+		while ( i < ext_count && !_list_extension(&eregs[i]) )
+			i++;
+
+		if ( i < ext_count ) {
+			/* Add first to string */
+			str_append(extstr, eregs[i].extension->name);
+			i++;	 
+
+	 		/* Add others */
+			for ( ; i < ext_count; i++ ) {
+				if ( _list_extension(&eregs[i]) ) {
+					str_append_c(extstr, ' ');
+					str_append(extstr, eregs[i].extension->name);
+				}
+			}
+		}
+	}
+
+	return str_c(extstr);
+}
+
+static void sieve_extension_enable(struct sieve_extension_registration *ereg)
+{
+	if ( ereg->extension->_id != NULL ) {
+		*(ereg->extension->_id) = ereg->id;
+	
+		if ( !ereg->loaded ) {
+			(void)_sieve_extension_load(ereg->extension);
+		}
+	}
+
+	ereg->loaded = TRUE;
+}
+
+static void sieve_extension_disable(struct sieve_extension_registration *ereg)
+{
+	if ( ereg->extension->_id != NULL )
+		*(ereg->extension->_id) = -1;	
+}
+
+void sieve_extensions_set_string(const char *ext_string)
+{
+	ARRAY_DEFINE(enabled_extensions, const struct sieve_extension *);
+	ARRAY_DEFINE(disabled_extensions, const struct sieve_extension *);
+	const struct sieve_extension *const *ext_enabled;
+	const struct sieve_extension *const *ext_disabled;
+	struct sieve_extension_registration *eregs;
+	const char **ext_names;
+	unsigned int i, ext_count, ena_count, dis_count;
+	bool relative = FALSE;
+
+	if ( ext_string == NULL ) {
+		/* Enable all */
+		eregs = array_get_modifiable(&extensions, &ext_count);
+		
+		for ( i = 0; i < ext_count; i++ )
+			sieve_extension_enable(&eregs[i]);
+
+		return;	
+	}
+
+	T_BEGIN {
+		t_array_init(&enabled_extensions, array_count(&extensions));
+		t_array_init(&disabled_extensions, array_count(&extensions));
+
+		ext_names = t_strsplit_spaces(ext_string, " \t");
+
+		while ( *ext_names != NULL ) {
+			const char *name = *ext_names;
+
+			ext_names++;
+
+			if ( *name != '\0' ) {
+				const struct sieve_extension_registration *ereg;
+				char op = '\0'; /* No add/remove operation */
+	
+				if ( *name == '+' 		/* Add to existing config */
+					|| *name == '-' ) {	/* Remove from existing config */
+				 	op = *name++;
+				 	relative = TRUE;
+				}
+
+				if ( *name == '@' )
+					ereg = NULL;
+				else
+					ereg = (const struct sieve_extension_registration *) 
+						hash_table_lookup(extension_index, name);
+	
+				if ( ereg == NULL ) {
+					sieve_sys_warning(
+						"ignored unknown extension '%s' while configuring "
+						"available extensions", name);
+					continue;
+				}
+
+				if ( op == '-' )
+					array_append(&disabled_extensions, &ereg->extension, 1);
+				else
+					array_append(&enabled_extensions, &ereg->extension, 1);
+			}
+		}
+
+		eregs = array_get_modifiable(&extensions, &ext_count);
+		ext_enabled = array_get(&enabled_extensions, &ena_count);
+		ext_disabled = array_get(&disabled_extensions, &dis_count);
+
+		/* Set new extension status */
+
+		for ( i = 0; i < ext_count; i++ ) {
+			unsigned int j;
+			bool disabled = TRUE;
+
+			/* If extensions are specified relative to the default set,
+			 * we first need to check which ones are disabled 
+			 */
+
+			if ( relative ) {
+				/* Enable if core extension */
+				for ( j = 0; j < sieve_core_extensions_count; j++ ) {
+					if ( sieve_core_extensions[j] == eregs[i].extension ) {
+						disabled = FALSE;
+						break;
+					}
+    			}
+
+				/* Disable if explicitly disabled */
+				for ( j = 0; j < dis_count; j++ ) {
+					if ( ext_disabled[j] == eregs[i].extension ) {
+						disabled = TRUE;
+						break;
+					}
+				}
+			} 
+
+			/* Enable if listed with '+' or no prefix */
+	
+			for ( j = 0; j < ena_count; j++ ) {
+				if ( ext_enabled[j] == eregs[i].extension ) {
+					disabled = FALSE;
+					break;
+				}		
+			}
+
+			/* Perform actual activation/deactivation */
+
+			if ( eregs[i].extension->_id != NULL && 
+				*(eregs[i].extension->name) != '@' ) {
+				if ( disabled && !eregs[i].required )
+					sieve_extension_disable(&eregs[i]);
+				else
+					sieve_extension_enable(&eregs[i]);
+			}
+		}
+	} T_END;
+}
+
+static void sieve_extensions_deinit_registry(void) 
+{
+	struct hash_iterate_context *itx = 
+		hash_table_iterate_init(extension_index);
+	void *key; 
+	void *value;
+	
+	while ( hash_table_iterate(itx, &key, &value) ) {
+		struct sieve_extension_registration *ereg =
+			(struct sieve_extension_registration *) value;
+		const struct sieve_extension *ext = ereg->extension;
+		
+		if ( ext->unload != NULL )
+			ext->unload();
+	}
+
+	hash_table_iterate_deinit(&itx); 	
+
+	array_free(&extensions);
+	hash_table_destroy(&extension_index);
+}
+
+/*
+ * Extension capabilities
+ */
+
+static struct hash_table *capabilities_index; 
+
+static void sieve_extensions_init_capabilities(void)
+{	
+	capabilities_index = hash_table_create
+		(default_pool, default_pool, 0, str_hash, (hash_cmp_callback_t *)strcmp);
+}
+
+static void sieve_extensions_deinit_capabilities(void) 
+{
+	hash_table_destroy(&capabilities_index);
+}
+
+void sieve_extension_capabilities_register
+	(const struct sieve_extension_capabilities *cap) 
+{	
+	hash_table_insert
+		(capabilities_index, (void *) cap->name, (void *) cap);
+}
+
+const char *sieve_extension_capabilities_get_string
+	(const char *cap_name) 
+{
+  const struct sieve_extension_capabilities *cap = 
+		(const struct sieve_extension_capabilities *) 
+			hash_table_lookup(capabilities_index, cap_name);
+
+	if ( cap == NULL || cap->get_string == NULL || 
+		!SIEVE_EXT_ENABLED(cap->extension) )
+		return NULL;
+		
+	return cap->get_string();
+}
+
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-extensions.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-extensions.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-extensions.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-extensions.h	2009-02-04 23:05:38.000000000 +0100
@@ -0,0 +1,118 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_EXTENSIONS_H
+#define __SIEVE_EXTENSIONS_H
+
+#include "lib.h"
+#include "sieve-common.h"
+
+/* 
+ * Per-extension object registry 
+ */
+
+struct sieve_extension_objects {
+	const void *objects;
+	unsigned int count;
+};
+
+/* 
+ * Extension object 
+ */
+
+struct sieve_extension {
+	const char *name;
+
+	int *const _id;
+		
+	bool (*load)(void);
+	void (*unload)(void);
+
+	bool (*validator_load)
+		(struct sieve_validator *validator);	
+	bool (*generator_load)
+		(const struct sieve_codegen_env *cgenv);
+	bool (*interpreter_load)
+		(const struct sieve_runtime_env *renv, sieve_size_t *address);
+	bool (*binary_load)
+		(struct sieve_binary *binary);
+	
+	bool (*binary_dump)
+		(struct sieve_dumptime_env *denv);
+	bool (*code_dump)
+		(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+
+	struct sieve_extension_objects operations;
+	struct sieve_extension_objects operands;
+};
+
+#define SIEVE_EXT_ID(EXT) (*((EXT)->_id))
+#define SIEVE_EXT_ENABLED(EXT) (((EXT)->_id != NULL) && (*((EXT)->_id) >= 0))
+
+#define SIEVE_EXT_DEFINE_NO_OBJECTS \
+	{ NULL, 0 }
+#define SIEVE_EXT_DEFINE_OBJECT(OBJ) \
+	{ &OBJ, 1 }
+#define SIEVE_EXT_DEFINE_OBJECTS(OBJS) \
+	{ OBJS, N_ELEMENTS(OBJS) }
+
+#define SIEVE_EXT_GET_OBJECTS_COUNT(ext, field) \
+	ext->field->count;
+
+/* 
+ * Defining opcodes and operands 
+ */
+
+#define SIEVE_EXT_DEFINE_NO_OPERATIONS SIEVE_EXT_DEFINE_NO_OBJECTS
+#define SIEVE_EXT_DEFINE_OPERATION(OP) SIEVE_EXT_DEFINE_OBJECT(OP)
+#define SIEVE_EXT_DEFINE_OPERATIONS(OPS) SIEVE_EXT_DEFINE_OBJECTS(OPS)
+
+#define SIEVE_EXT_DEFINE_NO_OPERANDS SIEVE_EXT_DEFINE_NO_OBJECTS
+#define SIEVE_EXT_DEFINE_OPERAND(OP) SIEVE_EXT_DEFINE_OBJECT(OP)
+#define SIEVE_EXT_DEFINE_OPERANDS(OPS) SIEVE_EXT_DEFINE_OBJECTS(OPS)
+
+/* 
+ * Pre-loaded extensions 
+ */
+
+extern const struct sieve_extension *sieve_preloaded_extensions[];
+extern const unsigned int sieve_preloaded_extensions_count;
+
+/*  
+ * Extensions init/deinit 
+ */
+
+bool sieve_extensions_init(void);
+void sieve_extensions_deinit(void);
+
+/* 
+ * Extension registry 
+ */
+
+int sieve_extension_register(const struct sieve_extension *extension, bool load);
+int sieve_extension_require(const struct sieve_extension *extension);
+int sieve_extensions_get_count(void);
+const struct sieve_extension *sieve_extension_get_by_id(unsigned int ext_id);
+const struct sieve_extension *sieve_extension_get_by_name(const char *name);
+
+const char *sieve_extensions_get_string(void);
+void sieve_extensions_set_string(const char *ext_string);
+
+/*
+ * Capability registries
+ */
+
+struct sieve_extension_capabilities {
+	const char *name;
+
+	const struct sieve_extension *extension;
+
+	const char *(*get_string)(void);	
+};
+
+void sieve_extension_capabilities_register
+	(const struct sieve_extension_capabilities *cap);
+const char *sieve_extension_capabilities_get_string
+	(const char *cap_name);
+
+#endif /* __SIEVE_EXTENSIONS_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-generator.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-generator.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-generator.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-generator.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,422 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "mempool.h"
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+
+#include "sieve-generator.h"
+
+/* 
+ * Jump list 
+ */
+
+struct sieve_jumplist *sieve_jumplist_create
+	(pool_t pool, struct sieve_binary *sbin)
+{
+	struct sieve_jumplist *jlist;
+	
+	jlist = p_new(pool, struct sieve_jumplist, 1);
+	jlist->binary = sbin;
+	p_array_init(&jlist->jumps, pool, 4);
+	
+	return jlist;
+}
+
+void sieve_jumplist_init_temp
+	(struct sieve_jumplist *jlist, struct sieve_binary *sbin)
+{
+	jlist->binary = sbin;
+	t_array_init(&jlist->jumps, 4);
+}
+
+void sieve_jumplist_reset
+	(struct sieve_jumplist *jlist)
+{
+	array_clear(&jlist->jumps);
+}
+
+void sieve_jumplist_add(struct sieve_jumplist *jlist, sieve_size_t jump) 
+{
+	array_append(&jlist->jumps, &jump, 1);
+}
+
+void sieve_jumplist_resolve(struct sieve_jumplist *jlist) 
+{
+	unsigned int i;
+	
+	for ( i = 0; i < array_count(&jlist->jumps); i++ ) {
+		const sieve_size_t *jump = array_idx(&jlist->jumps, i);
+	
+		sieve_binary_resolve_offset(jlist->binary, *jump);
+	}
+}
+
+/* 
+ * Code Generator 
+ */
+
+struct sieve_generator {
+	pool_t pool;
+	
+	struct sieve_error_handler *ehandler;
+
+	struct sieve_codegen_env genenv;
+	
+	ARRAY_DEFINE(ext_contexts, void *);
+};
+
+struct sieve_generator *sieve_generator_create
+	(struct sieve_ast *ast, struct sieve_error_handler *ehandler) 
+{
+	pool_t pool;
+	struct sieve_generator *gentr;
+	
+	pool = pool_alloconly_create("sieve_generator", 4096);	
+	gentr = p_new(pool, struct sieve_generator, 1);
+	gentr->pool = pool;
+
+	gentr->ehandler = ehandler;
+	sieve_error_handler_ref(ehandler);
+	
+	gentr->genenv.gentr = gentr;
+	gentr->genenv.ast = ast;	
+	gentr->genenv.script = sieve_ast_script(ast);
+	sieve_ast_ref(ast);
+
+	/* Setup storage for extension contexts */		
+	p_array_init(&gentr->ext_contexts, pool, sieve_extensions_get_count());
+		
+	return gentr;
+}
+
+void sieve_generator_free(struct sieve_generator **generator) 
+{
+	sieve_ast_unref(&(*generator)->genenv.ast);
+	
+	if ( (*generator)->genenv.sbin != NULL )
+		sieve_binary_unref(&(*generator)->genenv.sbin);
+	
+	sieve_error_handler_unref(&(*generator)->ehandler);
+
+	pool_unref(&((*generator)->pool));
+	
+	*generator = NULL;
+}
+
+/* 
+ * Accessors 
+ */
+
+struct sieve_error_handler *sieve_generator_error_handler
+(struct sieve_generator *gentr)
+{
+	return gentr->ehandler;
+}
+
+pool_t sieve_generator_pool(struct sieve_generator *gentr)
+{
+	return gentr->pool;
+}
+
+struct sieve_script *sieve_generator_script
+(struct sieve_generator *gentr)
+{
+	return gentr->genenv.script;
+}
+
+struct sieve_binary *sieve_generator_get_binary
+	(struct sieve_generator *gentr)
+{
+	return gentr->genenv.sbin;
+}
+
+/* 
+ * Error handling 
+ */
+
+void sieve_generator_warning
+(struct sieve_generator *gentr, unsigned int source_line, 
+	const char *fmt, ...) 
+{ 
+	va_list args;
+	
+	va_start(args, fmt);
+	sieve_vwarning(gentr->ehandler,
+        sieve_error_script_location(gentr->genenv.script, source_line),
+        fmt, args);
+	va_end(args);
+}
+ 
+void sieve_generator_error
+(struct sieve_generator *gentr, unsigned int source_line, 
+	const char *fmt, ...) 
+{
+	va_list args;
+	
+	va_start(args, fmt);
+	sieve_verror(gentr->ehandler,
+        sieve_error_script_location(gentr->genenv.script, source_line),
+        fmt, args);
+	va_end(args);
+}
+
+void sieve_generator_critical
+(struct sieve_generator *gentr, unsigned int source_line, 
+	const char *fmt, ...) 
+{
+	va_list args;
+	
+	va_start(args, fmt);
+	sieve_vwarning(gentr->ehandler,
+        sieve_error_script_location(gentr->genenv.script, source_line),
+        fmt, args);
+	va_end(args);
+}
+
+/* 
+ * Extension support 
+ */
+
+void sieve_generator_extension_set_context
+(struct sieve_generator *gentr, const struct sieve_extension *ext, void *context)
+{
+	array_idx_set(&gentr->ext_contexts, (unsigned int) SIEVE_EXT_ID(ext), &context);	
+}
+
+const void *sieve_generator_extension_get_context
+(struct sieve_generator *gentr, const struct sieve_extension *ext) 
+{
+	int ext_id = SIEVE_EXT_ID(ext);
+	void * const *ctx;
+
+	if  ( ext_id < 0 || ext_id >= (int) array_count(&gentr->ext_contexts) )
+		return NULL;
+	
+	ctx = array_idx(&gentr->ext_contexts, (unsigned int) ext_id);		
+
+	return *ctx;
+}
+
+/* 
+ * Code generation API
+ */
+
+bool sieve_generate_argument
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+	struct sieve_command_context *cmd)
+{
+	const struct sieve_argument *argument = arg->argument;
+	
+	if ( argument == NULL ) return FALSE;
+	
+	return ( argument->generate == NULL || 	
+		argument->generate(cgenv, arg, cmd) );
+}
+
+bool sieve_generate_arguments
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *cmd, 
+	struct sieve_ast_argument **last_arg)
+{
+	enum { ARG_START, ARG_OPTIONAL, ARG_POSITIONAL } state = ARG_START;
+	struct sieve_ast_argument *arg = sieve_ast_argument_first(cmd->ast_node);
+	
+	/* Generate all arguments with assigned generator function */
+	
+	while ( arg != NULL && arg->argument != NULL) {
+		const struct sieve_argument *argument = arg->argument;
+		
+		switch ( state ) {
+		case ARG_START: 
+			if ( arg->arg_id_code == 0 )
+				state = ARG_POSITIONAL;
+			else {
+				/* Mark start of optional operands with 0 operand identifier */
+				sieve_binary_emit_byte(cgenv->sbin, SIEVE_OPERAND_OPTIONAL);
+								
+				/* Emit argument id for optional operand */
+				sieve_binary_emit_byte(cgenv->sbin, (unsigned char) arg->arg_id_code);
+
+				state = ARG_OPTIONAL;
+			}
+			break;
+		case ARG_OPTIONAL: 
+			if ( arg->arg_id_code == 0 )
+				state = ARG_POSITIONAL;
+			
+			/* Emit argument id for optional operand (0 marks the end of the optionals) */
+			sieve_binary_emit_byte(cgenv->sbin, (unsigned char) arg->arg_id_code);
+
+			break;
+		case ARG_POSITIONAL:
+			if ( arg->arg_id_code != 0 )
+				return FALSE;
+			break;
+		}
+		
+		/* Call the generation function for the argument */ 
+		if ( argument->generate != NULL ) { 
+			if ( !argument->generate(cgenv, arg, cmd) ) 
+				return FALSE;
+		} else if ( state == ARG_POSITIONAL ) break;
+
+		arg = sieve_ast_argument_next(arg);
+	}
+
+	/* Mark end of optional list if it is still open */
+	if ( state == ARG_OPTIONAL )
+		sieve_binary_emit_byte(cgenv->sbin, 0);
+	
+	if ( last_arg != NULL )
+		*last_arg = arg;
+	
+	return TRUE;
+}
+
+bool sieve_generate_argument_parameters
+(const struct sieve_codegen_env *cgenv, 
+	struct sieve_command_context *cmd, struct sieve_ast_argument *arg)
+{
+	struct sieve_ast_argument *param = arg->parameters;
+	
+	/* Generate all parameters with assigned generator function */
+	
+	while ( param != NULL && param->argument != NULL) {
+		const struct sieve_argument *parameter = param->argument;
+				
+		/* Call the generation function for the parameter */ 
+		if ( parameter->generate != NULL ) { 
+			if ( !parameter->generate(cgenv, param, cmd) ) 
+				return FALSE;
+		}
+
+		param = sieve_ast_argument_next(param);
+	}
+		
+	return TRUE;
+}
+
+bool sieve_generate_test
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_node *tst_node,
+	struct sieve_jumplist *jlist, bool jump_true) 
+{
+	i_assert( tst_node->context != NULL && tst_node->context->command != NULL );
+
+	if ( tst_node->context->command->control_generate != NULL ) {
+		if ( tst_node->context->command->control_generate
+			(cgenv, tst_node->context, jlist, jump_true) ) 
+			return TRUE;
+		
+		return FALSE;
+	}
+	
+	if ( tst_node->context->command->generate != NULL ) {
+
+		if ( tst_node->context->command->generate(cgenv, tst_node->context) ) {
+			
+			if ( jump_true ) 
+				sieve_operation_emit_code(cgenv->sbin, &sieve_jmptrue_operation);
+			else
+				sieve_operation_emit_code(cgenv->sbin, &sieve_jmpfalse_operation);
+			sieve_jumplist_add(jlist, sieve_binary_emit_offset(cgenv->sbin, 0));
+						
+			return TRUE;
+		}	
+		
+		return FALSE;
+	}
+	
+	return TRUE;
+}
+
+static bool sieve_generate_command
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_node *cmd_node) 
+{
+	i_assert( cmd_node->context != NULL && cmd_node->context->command != NULL );
+
+	if ( cmd_node->context->command->generate != NULL ) {
+		return cmd_node->context->command->generate(cgenv, cmd_node->context);
+	}
+	
+	return TRUE;		
+}
+
+bool sieve_generate_block
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_node *block) 
+{
+	bool result = TRUE;
+	struct sieve_ast_node *command;
+
+	T_BEGIN {	
+		command = sieve_ast_command_first(block);
+		while ( result && command != NULL ) {	
+			result = sieve_generate_command(cgenv, command);	
+			command = sieve_ast_command_next(command);
+		}		
+	} T_END;
+	
+	return result;
+}
+
+bool sieve_generator_run
+(struct sieve_generator *gentr, struct sieve_binary **sbin) 
+{
+	bool topmost = ( *sbin == NULL );
+	bool result = TRUE;
+	const struct sieve_extension *const *extensions;
+	unsigned int i, ext_count;
+	
+	/* Initialize */
+	
+	if ( topmost )
+		*sbin = sieve_binary_create_new(sieve_ast_script(gentr->genenv.ast));
+	
+	sieve_binary_ref(*sbin);
+		
+	gentr->genenv.sbin = *sbin;
+		
+	/* Load extensions linked to the AST and emit a list in code */
+	extensions = sieve_ast_extensions_get(gentr->genenv.ast, &ext_count);
+	(void) sieve_binary_emit_unsigned(*sbin, ext_count);
+	for ( i = 0; i < ext_count; i++ ) {
+		const struct sieve_extension *ext = extensions[i];
+
+		/* Link to binary */
+		(void)sieve_binary_extension_link(*sbin, ext);
+	
+		/* Emit */
+		sieve_binary_emit_extension(*sbin, ext, 0);
+	
+		/* Load */
+		if ( ext->generator_load != NULL && !ext->generator_load(&gentr->genenv) )
+			return FALSE;
+	}
+
+	/* Generate code */
+	
+	if ( !sieve_generate_block
+		(&gentr->genenv, sieve_ast_root(gentr->genenv.ast))) 
+		result = FALSE;
+	else if ( topmost ) 
+		sieve_binary_activate(*sbin);
+
+	/* Cleanup */
+		
+	gentr->genenv.sbin = NULL;
+	sieve_binary_unref(sbin);
+
+	if ( topmost && !result ) {
+		sieve_binary_unref(sbin);
+		*sbin = NULL;
+	}
+	
+	return result;
+}
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-generator.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-generator.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-generator.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-generator.h	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,106 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_GENERATOR_H
+#define __SIEVE_GENERATOR_H
+
+#include "sieve-common.h"
+
+/*
+ * Code generator
+ */
+
+struct sieve_generator;
+
+struct sieve_codegen_env {
+	struct sieve_generator *gentr;
+
+    struct sieve_script *script;
+	struct sieve_ast *ast;
+	struct sieve_binary *sbin;
+};
+
+struct sieve_generator *sieve_generator_create
+	(struct sieve_ast *ast, struct sieve_error_handler *ehandler);
+void sieve_generator_free(struct sieve_generator **generator);
+
+/* 
+ * Accessors 
+ */
+
+struct sieve_error_handler *sieve_generator_error_handler
+	(struct sieve_generator *gentr);
+pool_t sieve_generator_pool(struct sieve_generator *gentr);
+struct sieve_script *sieve_generator_script
+	(struct sieve_generator *gentr);
+struct sieve_binary *sieve_generator_get_binary
+	(struct sieve_generator *gentr);
+
+/* 
+ * Error handling 
+ */
+
+void sieve_generator_warning
+(struct sieve_generator *gentr, unsigned int source_line, 
+	const char *fmt, ...) ATTR_FORMAT(3, 4);; 
+void sieve_generator_error
+(struct sieve_generator *gentr, unsigned int source_line, 
+	const char *fmt, ...) ATTR_FORMAT(3, 4);
+void sieve_generator_critical
+(struct sieve_generator *gentr, unsigned int source_line, 
+	const char *fmt, ...) ATTR_FORMAT(3, 4); 
+
+/* 
+ * Extension support 
+ */
+
+void sieve_generator_extension_set_context
+	(struct sieve_generator *gentr, const struct sieve_extension *ext, 
+		void *context);
+const void *sieve_generator_extension_get_context
+	(struct sieve_generator *gentr, const struct sieve_extension *ext);
+    		
+/* 
+ * Jump list 
+ */
+
+struct sieve_jumplist {
+	pool_t pool;
+	struct sieve_binary *binary;
+	ARRAY_DEFINE(jumps, sieve_size_t);
+};
+
+struct sieve_jumplist *sieve_jumplist_create
+	(pool_t pool, struct sieve_binary *sbin);
+void sieve_jumplist_init_temp
+	(struct sieve_jumplist *jlist, struct sieve_binary *sbin);
+void sieve_jumplist_reset
+	(struct sieve_jumplist *jlist);
+void sieve_jumplist_add
+	(struct sieve_jumplist *jlist, sieve_size_t jump);
+void sieve_jumplist_resolve(struct sieve_jumplist *jlist);
+
+/* 
+ * Code generation API 
+ */
+
+bool sieve_generate_argument
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+		struct sieve_command_context *cmd);
+bool sieve_generate_arguments
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *cmd, 
+		struct sieve_ast_argument **arg);
+bool sieve_generate_argument_parameters
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *cmd, 
+		struct sieve_ast_argument *arg);
+
+bool sieve_generate_block
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_node *block);
+bool sieve_generate_test
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_node *tst_node, 
+		struct sieve_jumplist *jlist, bool jump_true);
+bool sieve_generator_run
+	(struct sieve_generator *gentr, struct sieve_binary **sbin);
+
+#endif /* __SIEVE_GENERATOR_H */
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve.h	2009-08-02 15:20:14.000000000 +0200
@@ -0,0 +1,160 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+
+#ifndef __SIEVE_H
+#define __SIEVE_H
+
+#include <stdio.h>
+
+struct sieve_script;
+struct sieve_binary;
+
+#include "sieve-config.h"
+#include "sieve-types.h"
+#include "sieve-error.h"
+
+/*
+ * Main Sieve library interface
+ */
+
+/* sieve_init(): 
+ *   Initializes the sieve engine. Must be called before any sieve functionality
+ *   is used.
+ */
+bool sieve_init(void);
+
+/* sieve_deinit():
+ *   Frees all memory allocated by the sieve engine. 
+ */
+void sieve_deinit(void);
+
+/* sieve_get_capabilities():
+ *
+ */
+const char *sieve_get_capabilities(const char *name);
+
+/* sieve_set_extensions():
+ *
+ */
+void sieve_set_extensions(const char *extensions);
+
+/*
+ * Script compilation
+ */
+
+/* sieve_compile_script:
+ */
+struct sieve_binary *sieve_compile_script
+	(struct sieve_script *script, struct sieve_error_handler *ehandler);
+
+/* sieve_compile:
+ *
+ *   Compiles the script into a binary.
+ */
+struct sieve_binary *sieve_compile
+	(const char *script_path, const char *script_name, 
+		struct sieve_error_handler *ehandler);
+
+/* 
+ * Reading/writing Sieve binaries
+ */
+
+/* sieve_open:
+ *
+ *   First tries to open the binary version of the specified script and
+ *   if it does not exist or if it contains errors, the script is
+ *   (re-)compiled. The binary is updated if the script is recompiled.
+ *   Note that errors in the bytecode are not caught here.
+ *
+ */
+struct sieve_binary *sieve_open
+	(const char *scriptpath, const char *script_name, 
+		struct sieve_error_handler *ehandler, bool *exists_r);
+
+/* sieve_save:
+ *
+ *  Saves the binary as the file indicated by the path parameter. If 
+ *  path is NULL, it chooses the default path relative to the original
+ *  script.
+ */
+bool sieve_save
+    (struct sieve_binary *sbin, const char *bin_path);
+
+/* sieve_load:
+ *
+ *  Loads the sieve binary indicated by the provided path.
+ */
+struct sieve_binary *sieve_load
+	(const char *bin_path);
+
+/* sieve_close:
+ *
+ *   Closes a compiled/opened sieve binary.
+ */
+void sieve_close(struct sieve_binary **sbin);
+
+/*
+ * Debugging
+ */
+
+/* sieve_dump:
+ *
+ *   Dumps the byte code in human-readable form to the specified ostream.
+ */
+void sieve_dump(struct sieve_binary *sbin, struct ostream *stream);
+
+/* sieve_test:
+ *
+ *   Executes the bytecode, but only prints the result to the given stream.
+ */ 
+int sieve_test
+	(struct sieve_binary *sbin, const struct sieve_message_data *msgdata, 
+		const struct sieve_script_env *senv, struct sieve_error_handler *ehandler, 
+		struct ostream *stream, bool *keep);
+
+/*
+ * Script execution
+ */
+
+/* sieve_execute:
+ *
+ *   Executes the binary, including the result.  
+ */
+int sieve_execute
+	(struct sieve_binary *sbin, const struct sieve_message_data *msgdata,
+		const struct sieve_script_env *senv, struct sieve_error_handler *ehandler,
+		bool *keep);
+		
+/*
+ * Multiscript support
+ */
+ 
+struct sieve_multiscript;
+ 
+struct sieve_multiscript *sieve_multiscript_start_execute
+	(const struct sieve_message_data *msgdata, const struct sieve_script_env *senv);
+struct sieve_multiscript *sieve_multiscript_start_test
+	(const struct sieve_message_data *msgdata, const struct sieve_script_env *senv,
+		struct ostream *stream);
+
+bool sieve_multiscript_run
+	(struct sieve_multiscript *mscript, struct sieve_binary *sbin, 
+		struct sieve_error_handler *ehandler, bool final);
+
+int sieve_multiscript_status(struct sieve_multiscript *mscript);
+
+int sieve_multiscript_finish
+	(struct sieve_multiscript **mscript, struct sieve_error_handler *ehandler,
+		bool *keep);
+
+/*
+ * Script directory
+ */
+
+struct sieve_directory;
+
+struct sieve_directory *sieve_directory_open(const char *path);
+const char *sieve_directory_get_scriptfile(struct sieve_directory *sdir);
+void sieve_directory_close(struct sieve_directory **sdir);
+
+#endif
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-interpreter.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-interpreter.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-interpreter.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-interpreter.c	2009-08-05 13:10:01.000000000 +0200
@@ -0,0 +1,528 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "ostream.h"
+#include "mempool.h"
+#include "array.h"
+#include "hash.h"
+#include "mail-storage.h"
+
+#include "sieve-common.h"
+#include "sieve-script.h"
+#include "sieve-error.h"
+#include "sieve-extensions.h"
+#include "sieve-message.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-actions.h"
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+#include "sieve-result.h"
+#include "sieve-comparators.h"
+
+#include "sieve-interpreter.h"
+
+#include <string.h>
+
+/* 
+ * Interpreter extension 
+ */
+
+struct sieve_interpreter_extension_reg {
+	const struct sieve_interpreter_extension *int_ext;
+	void *context;
+};
+
+/* 
+ * Interpreter 
+ */
+
+struct sieve_interpreter {
+	pool_t pool;
+			
+	struct sieve_error_handler *ehandler;
+
+	/* Runtime data for extensions */
+	ARRAY_DEFINE(extensions, struct sieve_interpreter_extension_reg); 
+	
+	sieve_size_t reset_vector;	
+		
+	/* Execution status */
+	
+	sieve_size_t pc;          /* Program counter */
+	bool interrupted;         /* Interpreter interrupt requested */
+	bool test_result;         /* Result of previous test command */
+
+	/* Current operation */ 
+	const struct sieve_operation *current_op;
+	
+	/* Start address of current operation */
+	sieve_size_t current_op_addr;             
+	
+	/* Runtime environment */
+	struct sieve_runtime_env runenv; 
+};
+
+struct sieve_interpreter *sieve_interpreter_create
+(struct sieve_binary *sbin, struct sieve_error_handler *ehandler) 
+{
+	unsigned int i, ext_count;
+	bool success = TRUE;
+
+	pool_t pool;
+	struct sieve_interpreter *interp;
+	
+	pool = pool_alloconly_create("sieve_interpreter", 4096);	
+	interp = p_new(pool, struct sieve_interpreter, 1);
+	interp->pool = pool;
+
+	interp->ehandler = ehandler;
+	sieve_error_handler_ref(ehandler);
+
+	interp->runenv.interp = interp;	
+	interp->runenv.sbin = sbin;
+	interp->runenv.script = sieve_binary_script(sbin);
+	sieve_binary_ref(sbin);
+	
+	interp->pc = 0;
+
+	p_array_init(&interp->extensions, pool, sieve_extensions_get_count());
+
+	/* Pre-load core language features implemented as 'extensions' */
+	for ( i = 0; i < sieve_preloaded_extensions_count; i++ ) {
+		const struct sieve_extension *ext = sieve_preloaded_extensions[i];
+		
+		if ( ext->interpreter_load != NULL )
+			(void)ext->interpreter_load(&interp->runenv, &interp->pc);		
+	}
+
+	/* Load other extensions listed in code */
+	if ( sieve_binary_read_unsigned(sbin, &interp->pc, &ext_count) ) {
+		for ( i = 0; i < ext_count; i++ ) {
+			unsigned int code = 0;
+			const struct sieve_extension *ext;
+			
+			if ( !sieve_binary_read_extension(sbin, &interp->pc, &code, &ext) ) {
+				success = FALSE;
+				break;
+			}
+ 
+			if ( ext->interpreter_load != NULL && 
+				!ext->interpreter_load(&interp->runenv, &interp->pc) ) {
+				success = FALSE;
+				break;
+			}
+		}
+	}	else
+		success = FALSE;
+	
+	if ( !success ) {
+		sieve_interpreter_free(&interp);
+	} else {
+		interp->reset_vector = interp->pc;
+	}
+	
+	return interp;
+}
+
+void sieve_interpreter_free(struct sieve_interpreter **interp) 
+{
+	const struct sieve_interpreter_extension_reg *extrs;
+	unsigned int ext_count, i;
+
+	sieve_binary_unref(&(*interp)->runenv.sbin);
+
+	sieve_error_handler_unref(&(*interp)->ehandler);
+
+	/* Signal registered extensions that the interpreter is being destroyed */
+	extrs = array_get(&(*interp)->extensions, &ext_count);
+	for ( i = 0; i < ext_count; i++ ) {
+		if ( extrs[i].int_ext != NULL && extrs[i].int_ext->free != NULL )
+			extrs[i].int_ext->free(*interp, extrs[i].context);
+	}
+		 
+	pool_unref(&((*interp)->pool));	
+	*interp = NULL;
+}
+
+/*
+ * Accessors
+ */
+
+pool_t sieve_interpreter_pool(struct sieve_interpreter *interp)
+{
+	return interp->pool;
+}
+
+struct sieve_script *sieve_interpreter_script
+(struct sieve_interpreter *interp)
+{
+	return interp->runenv.script;
+}
+
+struct sieve_error_handler *sieve_interpreter_get_error_handler
+(struct sieve_interpreter *interp)
+{
+	return interp->ehandler;
+}
+
+/* Do not use this function for normal sieve extensions. This is intended for
+ * the testsuite only.
+ */
+void sieve_interpreter_set_result
+(struct sieve_interpreter *interp, struct sieve_result *result)
+{
+	sieve_result_unref(&interp->runenv.result);
+	interp->runenv.result = result;
+	sieve_result_ref(result);
+}
+
+/* 
+ * Error handling 
+ */
+
+/* This is not particularly user friendly, so avoid using this
+ */
+const char *sieve_runtime_location(const struct sieve_runtime_env *runenv)
+{
+	const char *op = runenv->interp->current_op == NULL ?
+		"<<NOOP>>" : runenv->interp->current_op->mnemonic;
+	return t_strdup_printf("%s: #%08llx: %s", sieve_script_name(runenv->script),
+		(unsigned long long) runenv->interp->current_op_addr, op);
+}
+
+void sieve_runtime_error
+(const struct sieve_runtime_env *runenv, const char *location,
+	const char *fmt, ...)
+{
+	va_list args;
+	
+	va_start(args, fmt);
+	T_BEGIN {
+		sieve_verror(runenv->interp->ehandler, location, fmt, args); 
+	} T_END;
+	va_end(args);
+}
+
+void sieve_runtime_warning
+(const struct sieve_runtime_env *runenv, const char *location,
+	const char *fmt, ...)
+{	
+	va_list args;
+	
+	va_start(args, fmt);
+	T_BEGIN {
+		sieve_vwarning(runenv->interp->ehandler, location, fmt, args);
+	} T_END; 
+	va_end(args);
+}
+
+void sieve_runtime_log
+(const struct sieve_runtime_env *runenv, const char *location,
+	const char *fmt, ...)
+{	
+	va_list args;
+	
+	va_start(args, fmt);
+	T_BEGIN {
+		sieve_vinfo(runenv->interp->ehandler, location, fmt, args); 
+	} T_END;
+	va_end(args);
+}
+
+/*
+ * Runtime trace
+ */
+
+#ifdef SIEVE_RUNTIME_TRACE
+void _sieve_runtime_trace
+(const struct sieve_runtime_env *runenv, const char *fmt, ...)
+{	
+	string_t *outbuf = t_str_new(128);
+	va_list args;
+	
+	va_start(args, fmt);	
+	str_printfa(outbuf, "%08llx: ", (unsigned long long) runenv->interp->current_op_addr); 
+	str_vprintfa(outbuf, fmt, args); 
+	str_append_c(outbuf, '\n');
+	va_end(args);
+	
+	o_stream_send(runenv->trace_stream, str_data(outbuf), str_len(outbuf));	
+}
+
+void _sieve_runtime_trace_error
+(const struct sieve_runtime_env *runenv, const char *fmt, ...)
+{
+	string_t *outbuf = t_str_new(128);
+	va_list args;
+
+	va_start(args, fmt);
+	str_printfa(outbuf, "%08llx: [[ERROR: %s: ", 
+		(unsigned long long) runenv->interp->pc, 
+		runenv->interp->current_op->mnemonic);
+	str_vprintfa(outbuf, fmt, args);
+    str_append(outbuf, "]]\n");
+	va_end(args);
+
+	o_stream_send(runenv->trace_stream, str_data(outbuf), str_len(outbuf));
+}
+#endif
+
+/* 
+ * Extension support 
+ */
+
+void sieve_interpreter_extension_register
+(struct sieve_interpreter *interp, 
+	const struct sieve_interpreter_extension *int_ext, void *context)
+{
+	struct sieve_interpreter_extension_reg reg = { int_ext, context };
+	int ext_id = SIEVE_EXT_ID(int_ext->ext);
+
+	if ( ext_id < 0 ) return;
+	
+	array_idx_set(&interp->extensions, (unsigned int) ext_id, &reg);	
+}
+
+void sieve_interpreter_extension_set_context
+(struct sieve_interpreter *interp, const struct sieve_extension *ext, 
+	void *context)
+{
+	struct sieve_interpreter_extension_reg reg = { NULL, context };
+	int ext_id = SIEVE_EXT_ID(ext);
+
+	if ( ext_id < 0 ) return;
+	
+	array_idx_set(&interp->extensions, (unsigned int) ext_id, &reg);	
+}
+
+void *sieve_interpreter_extension_get_context
+(struct sieve_interpreter *interp, const struct sieve_extension *ext) 
+{
+	int ext_id = SIEVE_EXT_ID(ext);
+	const struct sieve_interpreter_extension_reg *reg;
+
+	if  ( ext_id < 0 || ext_id >= (int) array_count(&interp->extensions) )
+		return NULL;
+	
+	reg = array_idx(&interp->extensions, (unsigned int) ext_id);		
+
+	return reg->context;
+}
+
+/* 
+ * Program flow 
+ */
+
+void sieve_interpreter_reset(struct sieve_interpreter *interp) 
+{
+	interp->pc = interp->reset_vector;
+	interp->interrupted = FALSE;
+	interp->test_result = FALSE;
+	interp->runenv.msgdata = NULL;
+	interp->runenv.result = NULL;
+}
+
+void sieve_interpreter_interrupt(struct sieve_interpreter *interp)
+{
+	interp->interrupted = TRUE;
+}
+
+sieve_size_t sieve_interpreter_program_counter(struct sieve_interpreter *interp)
+{
+	return interp->pc;
+}
+
+int sieve_interpreter_program_jump
+(struct sieve_interpreter *interp, bool jump)
+{
+	const struct sieve_runtime_env *renv = &interp->runenv;
+	sieve_size_t pc = interp->pc;
+	int offset;
+	
+	if ( !sieve_binary_read_offset(renv->sbin, &(interp->pc), &offset) )
+	{
+		sieve_runtime_trace_error(renv, "invalid jump offset"); 
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	if ( pc + offset <= sieve_binary_get_code_size(renv->sbin) && 
+		pc + offset > 0 ) 
+	{	
+		if ( jump )
+			interp->pc = pc + offset;
+		
+		return SIEVE_EXEC_OK;
+	}
+	
+	sieve_runtime_trace_error(renv, "jump offset out of range");
+	return SIEVE_EXEC_BIN_CORRUPT;
+}
+
+/*
+ * Test results
+ */
+
+void sieve_interpreter_set_test_result
+(struct sieve_interpreter *interp, bool result)
+{
+	interp->test_result = result;
+}
+
+bool sieve_interpreter_get_test_result
+(struct sieve_interpreter *interp)
+{
+	return interp->test_result;
+}
+
+/* 
+ * Operations and operands 
+ */
+
+int sieve_interpreter_handle_optional_operands
+(const struct sieve_runtime_env *renv, sieve_size_t *address,
+	struct sieve_side_effects_list **list)
+{
+	signed int opt_code = -1;
+	
+	if ( sieve_operand_optional_present(renv->sbin, address) ) {
+		while ( opt_code != 0 ) {
+			if ( !sieve_operand_optional_read(renv->sbin, address, &opt_code) ) {
+				sieve_runtime_trace_error(renv, "invalid optional operand");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+
+			if ( opt_code == SIEVE_OPT_SIDE_EFFECT ) {
+				void *context = NULL;
+			
+				if ( list != NULL && *list == NULL ) 
+					*list = sieve_side_effects_list_create(renv->result);
+					
+				const struct sieve_side_effect *seffect = 
+					sieve_opr_side_effect_read(renv, address);
+
+				if ( seffect == NULL ) {
+					sieve_runtime_trace_error(renv, "invalid side effect operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+			
+				if ( list != NULL ) {
+					if ( seffect->read_context != NULL && !seffect->read_context
+						(seffect, renv, address, &context) ) {
+						sieve_runtime_trace_error(renv, "invalid side effect context");
+						return SIEVE_EXEC_BIN_CORRUPT;
+					}
+				
+					sieve_side_effects_list_add(*list, seffect, context);
+				}
+			}
+		}
+	}
+	return TRUE;
+}
+ 
+/* 
+ * Code execute 
+ */
+
+static int sieve_interpreter_execute_operation
+(struct sieve_interpreter *interp) 
+{
+	const struct sieve_operation *op;
+
+	interp->current_op_addr = interp->pc;
+	interp->current_op = op =
+		sieve_operation_read(interp->runenv.sbin, &(interp->pc));
+
+	if ( op != NULL ) {
+		int result = SIEVE_EXEC_OK;
+
+		if ( op->execute != NULL ) { /* Noop ? */
+			T_BEGIN {
+				result = op->execute(op, &(interp->runenv), &(interp->pc));
+			} T_END;
+		} else {
+			sieve_runtime_trace(&interp->runenv, "OP: %s (NOOP)", op->mnemonic);
+		}
+
+		return result;
+	}
+	
+	sieve_runtime_trace(&interp->runenv, "Encountered invalid operation");	
+	return SIEVE_EXEC_BIN_CORRUPT;
+}		
+
+int sieve_interpreter_continue
+(struct sieve_interpreter *interp, bool *interrupted) 
+{
+	int ret = SIEVE_EXEC_OK;
+	
+	sieve_result_ref(interp->runenv.result);
+	interp->interrupted = FALSE;
+	
+	if ( interrupted != NULL )
+		*interrupted = FALSE;
+	
+	while ( ret == SIEVE_EXEC_OK && !interp->interrupted && 
+		interp->pc < sieve_binary_get_code_size(interp->runenv.sbin) ) {
+		
+		ret = sieve_interpreter_execute_operation(interp);
+
+		if ( ret != SIEVE_EXEC_OK ) {
+			sieve_runtime_trace(&interp->runenv, "[[EXECUTION ABORTED]]");
+		}
+	}
+	
+	if ( interrupted != NULL )
+		*interrupted = interp->interrupted;
+			
+	sieve_result_unref(&interp->runenv.result);
+	return ret;
+}
+
+int sieve_interpreter_start
+(struct sieve_interpreter *interp, const struct sieve_message_data *msgdata,
+	const struct sieve_script_env *senv, struct sieve_result *result, bool *interrupted) 
+{
+	const struct sieve_interpreter_extension_reg *extrs;
+	unsigned int ext_count, i;
+	
+	interp->runenv.msgdata = msgdata;
+	interp->runenv.result = result;
+	interp->runenv.msgctx = sieve_result_get_message_context(result);		
+	interp->runenv.scriptenv = senv;
+	interp->runenv.trace_stream = senv->trace_stream;
+
+	if ( senv->exec_status == NULL ) 
+		interp->runenv.exec_status = p_new(interp->pool, struct sieve_exec_status, 1);
+	else
+		interp->runenv.exec_status = senv->exec_status;
+	
+	/* Signal registered extensions that the interpreter is being run */
+	extrs = array_get(&interp->extensions, &ext_count);
+	for ( i = 0; i < ext_count; i++ ) {
+		if ( extrs[i].int_ext != NULL && extrs[i].int_ext->run != NULL )
+			extrs[i].int_ext->run(&interp->runenv, extrs[i].context);
+	}
+
+	return sieve_interpreter_continue(interp, interrupted); 
+}
+
+int sieve_interpreter_run
+(struct sieve_interpreter *interp, const struct sieve_message_data *msgdata,
+	const struct sieve_script_env *senv, struct sieve_result *result)
+{
+	int ret = 0;
+	
+	sieve_interpreter_reset(interp);
+	sieve_result_ref(result);
+	
+	ret = sieve_interpreter_start(interp, msgdata, senv, result, NULL);
+	
+	sieve_result_unref(&result);
+	
+	return ret;
+}
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-interpreter.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-interpreter.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-interpreter.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-interpreter.h	2009-07-21 01:47:05.000000000 +0200
@@ -0,0 +1,174 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_INTERPRETER_H
+#define __SIEVE_INTERPRETER_H
+
+#include "lib.h"
+#include "array.h"
+#include "buffer.h"
+#include "mail-storage.h"
+
+#include "sieve-common.h"
+
+/*
+ * Forward declarations
+ */
+ 
+struct sieve_interpreter;
+
+/*
+ * Runtime environment
+ */
+
+struct sieve_runtime_env {
+	struct sieve_interpreter *interp;
+
+	struct sieve_script *script;
+	const struct sieve_script_env *scriptenv;
+	
+	const struct sieve_message_data *msgdata;
+	struct sieve_message_context *msgctx;
+
+	struct sieve_binary *sbin;
+	struct sieve_result *result;
+	
+	struct sieve_exec_status *exec_status;
+	struct ostream *trace_stream;
+};
+
+/* 
+ * Interpreter 
+ */
+
+struct sieve_interpreter *sieve_interpreter_create
+	(struct sieve_binary *sbin, struct sieve_error_handler *ehandler);
+void sieve_interpreter_free(struct sieve_interpreter **interp);
+
+/*
+ * Accessors
+ */
+
+pool_t sieve_interpreter_pool
+	(struct sieve_interpreter *interp);
+struct sieve_script *sieve_interpreter_script
+	(struct sieve_interpreter *interp);
+struct sieve_error_handler *sieve_interpreter_get_error_handler
+	(struct sieve_interpreter *interp);
+
+/* Do not use this function for normal sieve extensions. This is intended for
+ * the testsuite only.
+ */
+void sieve_interpreter_set_result
+	(struct sieve_interpreter *interp, struct sieve_result *result);
+
+/*
+ * Program flow
+ */
+
+void sieve_interpreter_reset
+	(struct sieve_interpreter *interp);
+void sieve_interpreter_interrupt
+	(struct sieve_interpreter *interp);
+sieve_size_t sieve_interpreter_program_counter
+	(struct sieve_interpreter *interp);
+
+int sieve_interpreter_program_jump
+	(struct sieve_interpreter *interp, bool jump);
+	
+/*
+ * Test results
+ */	
+	
+void sieve_interpreter_set_test_result
+	(struct sieve_interpreter *interp, bool result);
+bool sieve_interpreter_get_test_result
+	(struct sieve_interpreter *interp);
+	
+/* 
+ * Error handling 
+ */
+
+/* This is not particularly user-friendly, so avoid using this.. */
+const char *sieve_runtime_location(const struct sieve_runtime_env *runenv);
+
+void sieve_runtime_error
+	(const struct sieve_runtime_env *runenv, const char *location,
+		const char *fmt, ...) ATTR_FORMAT(3, 4);
+void sieve_runtime_warning
+	(const struct sieve_runtime_env *runenv, const char *location,
+		const char *fmt, ...) ATTR_FORMAT(3, 4);
+void sieve_runtime_log
+	(const struct sieve_runtime_env *runenv, const char *location, 
+		const char *fmt, ...) ATTR_FORMAT(3, 4);
+
+/* 
+ * Runtime Trace 
+ */
+
+#ifdef SIEVE_RUNTIME_TRACE
+		
+void _sieve_runtime_trace
+	(const struct sieve_runtime_env *runenv, const char *fmt, ...)
+		ATTR_FORMAT(2, 3);
+void _sieve_runtime_trace_error
+	(const struct sieve_runtime_env *runenv, const char *fmt, ...)
+		ATTR_FORMAT(2, 3);
+		
+# define sieve_runtime_trace(runenv, ...) STMT_START { \
+		if ( (runenv)->trace_stream != NULL ) \
+			_sieve_runtime_trace((runenv), __VA_ARGS__); \
+	} STMT_END
+# define sieve_runtime_trace_error(runenv, ...) STMT_START { \
+		if ( (runenv)->trace_stream != NULL ) \
+			_sieve_runtime_trace_error((runenv), __VA_ARGS__); \
+		} STMT_END	
+
+#else
+# define sieve_runtime_trace(runenv, ...)
+# define sieve_runtime_trace_error(runenv, ...)
+#endif
+
+/* 
+ * Extension support 
+ */
+
+struct sieve_interpreter_extension {
+	const struct sieve_extension *ext;	
+
+	void (*run)(const struct sieve_runtime_env *renv, void *context);
+	void (*free)(struct sieve_interpreter *interp, void *context);
+};
+
+void sieve_interpreter_extension_register
+	(struct sieve_interpreter *interp, 
+		const struct sieve_interpreter_extension *int_ext, void *context);
+void sieve_interpreter_extension_set_context
+	(struct sieve_interpreter *interp, const struct sieve_extension *ext, 
+		void *context);
+void *sieve_interpreter_extension_get_context
+	(struct sieve_interpreter *interp, const struct sieve_extension *ext); 
+
+/* 
+ * Opcodes and operands 
+ */
+	
+int sieve_interpreter_handle_optional_operands
+	(const struct sieve_runtime_env *renv, sieve_size_t *address,
+		struct sieve_side_effects_list **list);
+
+/* 
+ * Code execute 
+ */
+
+int sieve_interpreter_continue
+	(struct sieve_interpreter *interp, bool *interrupted);
+int sieve_interpreter_start
+	(struct sieve_interpreter *interp, const struct sieve_message_data *msgdata,
+		const struct sieve_script_env *senv, struct sieve_result *result, 
+		bool *interrupted);
+int sieve_interpreter_run
+	(struct sieve_interpreter *interp, const struct sieve_message_data *msgdata,
+		const struct sieve_script_env *senv, struct sieve_result *result);
+
+#endif /* __SIEVE_INTERPRETER_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-lexer.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-lexer.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-lexer.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-lexer.c	2009-08-01 19:31:54.000000000 +0200
@@ -0,0 +1,805 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+ 
+#include "lib.h"
+#include "compat.h"
+#include "str.h"
+#include "str-sanitize.h"
+#include "istream.h"
+
+#include "sieve-common.h"
+#include "sieve-limits.h"
+#include "sieve-error.h"
+#include "sieve-script.h"
+
+#include "sieve-lexer.h"
+
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <ctype.h>
+
+/* 
+ * Useful macros
+ */
+
+#define DIGIT_VAL(c) ( c - '0' )
+
+/*
+ * Forward declarations
+ */
+ 
+inline static void sieve_lexer_error
+	(struct sieve_lexer *lexer, const char *fmt, ...) ATTR_FORMAT(2, 3);
+inline static void sieve_lexer_warning
+	(struct sieve_lexer *lexer, const char *fmt, ...) ATTR_FORMAT(2, 3);
+
+/*
+ * Lexer object
+ */
+
+struct sieve_lexer {
+	pool_t pool;
+
+	struct sieve_script *script;
+	struct istream *input;
+		
+	int current_line;
+	
+	enum sieve_token_type token_type;
+	string_t *token_str_value;
+	int token_int_value;
+	
+	struct sieve_error_handler *ehandler;
+	
+	/* Currently scanned data */
+	const unsigned char *buffer;
+	size_t buffer_size;
+	size_t buffer_pos;
+};
+
+struct sieve_lexer *sieve_lexer_create
+(struct sieve_script *script, struct sieve_error_handler *ehandler) 
+{
+	pool_t pool;
+	struct sieve_lexer *lexer;
+	struct istream *stream;
+	
+	stream = sieve_script_open(script, NULL);
+	if ( stream == NULL )
+		return NULL;
+	
+	pool = pool_alloconly_create("sieve_lexer", 1024);	
+	lexer = p_new(pool, struct sieve_lexer, 1);
+	lexer->pool = pool;
+	
+	lexer->ehandler = ehandler;
+	sieve_error_handler_ref(ehandler);
+
+	lexer->input = stream;
+	i_stream_ref(lexer->input);
+	
+	lexer->script = script;
+	sieve_script_ref(script);
+	
+	lexer->buffer = NULL;
+	lexer->buffer_size = 0;
+	lexer->buffer_pos = 0;
+	
+	lexer->current_line = 1;	
+	lexer->token_type = STT_NONE;
+	lexer->token_str_value = str_new(pool, 256);
+	lexer->token_int_value = 0;
+		
+	return lexer;
+}
+
+void sieve_lexer_free(struct sieve_lexer **lexer) 
+{	
+	i_stream_unref(&(*lexer)->input);
+
+	sieve_script_close((*lexer)->script);
+	sieve_script_unref(&(*lexer)->script);
+
+	sieve_error_handler_unref(&(*lexer)->ehandler);
+
+	pool_unref(&(*lexer)->pool); 
+
+	*lexer = NULL;
+}
+
+/*
+ * Internal error handling
+ */
+
+inline static void sieve_lexer_error
+(struct sieve_lexer *lexer, const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+
+	T_BEGIN {
+		sieve_verror(lexer->ehandler, 
+			sieve_error_script_location(lexer->script, lexer->current_line),
+			fmt, args);
+	} T_END;
+		
+	va_end(args);
+}
+
+inline static void sieve_lexer_warning
+(struct sieve_lexer *lexer, const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+
+	T_BEGIN { 
+		sieve_vwarning(lexer->ehandler, 
+			sieve_error_script_location(lexer->script, lexer->current_line),
+			fmt, args);
+	} T_END;
+		
+	va_end(args);
+}
+
+const char *sieve_lexer_token_string(struct sieve_lexer *lexer) 
+{
+	switch ( lexer->token_type ) {
+		case STT_NONE: return "no token (bug)"; 		
+		case STT_WHITESPACE: return "whitespace (bug)";
+		case STT_EOF: return "end of file";
+  
+		case STT_NUMBER: return "number"; 
+		case STT_IDENTIFIER: return "identifier"; 
+		case STT_TAG: return "tag";
+		case STT_STRING: return "string"; 
+  
+		case STT_RBRACKET: return "')'"; 
+		case STT_LBRACKET: return "'('";
+		case STT_RCURLY: return "'}'"; 
+		case STT_LCURLY: return "'{'"; 
+		case STT_RSQUARE: return "']'"; 
+		case STT_LSQUARE: return "'['"; 
+		case STT_SEMICOLON: return "';'"; 
+		case STT_COMMA: return "','"; 
+  	
+		case STT_SLASH: return "'/'";  
+		case STT_COLON: return "':'";   
+  
+		case STT_GARBAGE: return "unknown characters"; 
+		case STT_ERROR: return "error token (bug)";
+	}
+   
+	return "unknown token (bug)";
+}
+	
+/* 
+ * Debug 
+ */
+ 
+void sieve_lexer_print_token(struct sieve_lexer *lexer) 
+{
+	switch ( lexer->token_type ) {
+		case STT_NONE: printf("??NONE?? "); break;		
+		case STT_WHITESPACE: printf("??WHITESPACE?? "); break;
+		case STT_EOF: printf("EOF\n"); break;
+  
+		case STT_NUMBER: printf("NUMBER "); break;
+		case STT_IDENTIFIER: printf("IDENTIFIER "); break;
+		case STT_TAG: printf("TAG "); break;
+		case STT_STRING: printf("STRING "); break;
+  
+		case STT_RBRACKET: printf(") "); break;
+		case STT_LBRACKET: printf("( "); break;
+		case STT_RCURLY: printf("}\n"); break;
+		case STT_LCURLY: printf("{\n"); break;
+		case STT_RSQUARE: printf("] "); break;
+		case STT_LSQUARE: printf("[ "); break;
+		case STT_SEMICOLON: printf(";\n"); break;
+		case STT_COMMA: printf(", "); break;
+  
+		case STT_SLASH: printf("/ "); break; 
+		case STT_COLON: printf(": "); break;  
+  	
+		case STT_GARBAGE: printf(">>GARBAGE<<"); break;
+		case STT_ERROR: printf(">>ERROR<<"); break;
+	default: 
+		printf("UNKNOWN ");
+		break;
+	}
+}
+
+/*
+ * Token access
+ */ 
+
+enum sieve_token_type sieve_lexer_current_token(struct sieve_lexer *lexer) 
+{
+	return lexer->token_type;
+}
+
+const string_t *sieve_lexer_token_str(struct sieve_lexer *lexer) 
+{
+	i_assert(	lexer->token_type == STT_STRING );
+		
+	return lexer->token_str_value;
+}
+
+const char *sieve_lexer_token_ident(struct sieve_lexer *lexer) 
+{
+	i_assert(
+		lexer->token_type == STT_TAG ||
+		lexer->token_type == STT_IDENTIFIER);
+		
+	return str_c(lexer->token_str_value);
+}
+
+int sieve_lexer_token_int(struct sieve_lexer *lexer) 
+{
+	i_assert(lexer->token_type == STT_NUMBER);
+		
+	return lexer->token_int_value;
+}
+
+bool sieve_lexer_eof(struct sieve_lexer *lexer) 
+{
+	return lexer->token_type == STT_EOF;
+}
+
+int sieve_lexer_current_line(struct sieve_lexer *lexer) 
+{
+	return lexer->current_line;
+}
+
+/*
+ * Lexical scanning 
+ */
+
+static void sieve_lexer_shift(struct sieve_lexer *lexer) 
+{
+	if ( lexer->buffer != NULL && lexer->buffer[lexer->buffer_pos] == '\n' ) 
+		lexer->current_line++;	
+	
+	if ( lexer->buffer != NULL && lexer->buffer_pos + 1 < lexer->buffer_size )
+		lexer->buffer_pos++;
+	else {
+		if ( lexer->buffer != NULL )
+			i_stream_skip(lexer->input, lexer->buffer_size);
+		
+		lexer->buffer = i_stream_get_data(lexer->input, &lexer->buffer_size);
+	  
+		if ( lexer->buffer == NULL && i_stream_read(lexer->input) > 0 )
+	  		lexer->buffer = i_stream_get_data(lexer->input, &lexer->buffer_size);
+	  	
+		lexer->buffer_pos = 0;
+	}
+}
+
+static inline int sieve_lexer_curchar(struct sieve_lexer *lexer) 
+{	
+	if ( lexer->buffer == NULL )
+		return -1;
+	
+	return lexer->buffer[lexer->buffer_pos];
+}
+
+static inline const char *_char_sanitize(int ch)
+{
+	if ( ch > 31 && ch < 127 )
+		return t_strdup_printf("'%c'", ch);
+	
+	return t_strdup_printf("0x%02x", ch);
+}
+
+/* sieve_lexer_scan_raw_token:
+ *   Scans valid tokens and whitespace 
+ */
+static bool sieve_lexer_scan_raw_token(struct sieve_lexer *lexer) 
+{
+	sieve_number_t start_line;
+	string_t *str;
+
+	/* Read first character */
+	if ( lexer->token_type == STT_NONE ) {
+		i_stream_read(lexer->input);
+		sieve_lexer_shift(lexer);
+	}
+  
+	switch ( sieve_lexer_curchar(lexer) ) {
+	
+	/* whitespace */
+	
+	// hash-comment = ( "#" *CHAR-NOT-CRLF CRLF )
+	case '#': 
+		sieve_lexer_shift(lexer);
+		while ( sieve_lexer_curchar(lexer) != '\n' ) {
+			switch( sieve_lexer_curchar(lexer) ) {
+			case -1:
+				sieve_lexer_error(lexer, "end of file before end of hash comment");
+				lexer->token_type = STT_ERROR;
+				return FALSE;
+			case '\0':
+				sieve_lexer_error(lexer, "encountered NUL character in hash comment");
+				lexer->token_type = STT_ERROR;
+				return FALSE;				
+			default:
+				break;
+			}
+						
+			/* Stray CR is ignored */
+			
+			sieve_lexer_shift(lexer);
+		} 
+
+		sieve_lexer_shift(lexer);
+		
+		lexer->token_type = STT_WHITESPACE;
+		return TRUE;
+		
+	// bracket-comment = "/*" *(CHAR-NOT-STAR / ("*" CHAR-NOT-SLASH)) "*/"
+	//        ;; No */ allowed inside a comment.
+	//        ;; (No * is allowed unless it is the last character,
+	//        ;; or unless it is followed by a character that isn't a
+	//        ;; slash.)
+	case '/': 
+		start_line = lexer->current_line;
+		sieve_lexer_shift(lexer);
+		
+		if ( sieve_lexer_curchar(lexer) == '*' ) { 
+			sieve_lexer_shift(lexer);
+			
+			while ( TRUE ) {
+				switch ( sieve_lexer_curchar(lexer) ) {
+				case -1:
+					sieve_lexer_error(lexer, 
+						"end of file before end of bracket comment ('/* ... */') "
+						"started at line %d", start_line);
+					lexer->token_type = STT_ERROR;
+					return FALSE;
+				case '*':
+					sieve_lexer_shift(lexer);
+					
+					if ( sieve_lexer_curchar(lexer) == '/' ) {
+						sieve_lexer_shift(lexer);
+						
+						lexer->token_type = STT_WHITESPACE;
+						return TRUE;
+						
+					} else if ( sieve_lexer_curchar(lexer) == -1 ) {
+						sieve_lexer_error(lexer, 
+							"end of file before end of bracket comment ('/* ... */') "
+							"started at line %d", start_line);
+						lexer->token_type = STT_ERROR;
+						return FALSE;
+					}
+					break;
+				case '\0':
+					sieve_lexer_error(lexer, 
+						"encountered NUL character in bracket comment");
+					lexer->token_type = STT_ERROR;
+					return FALSE;				
+				default:
+					sieve_lexer_shift(lexer);
+				}
+			}
+			
+			i_unreached();
+			return FALSE;
+		}
+		
+		lexer->token_type = STT_SLASH;
+		return TRUE;
+		
+	// comment = bracket-comment / hash-comment
+  	// white-space = 1*(SP / CRLF / HTAB) / comment
+	case '\t':
+	case '\r':
+	case '\n':
+	case ' ':
+		sieve_lexer_shift(lexer);
+		
+		while ( sieve_lexer_curchar(lexer) == '\t' ||
+			sieve_lexer_curchar(lexer) == '\r' ||
+			sieve_lexer_curchar(lexer) == '\n' ||
+			sieve_lexer_curchar(lexer) == ' ' ) {
+			
+			sieve_lexer_shift(lexer);
+		}
+		
+		lexer->token_type = STT_WHITESPACE;
+		return TRUE;
+		
+	/* quoted-string */
+	case '"':
+		start_line = lexer->current_line;
+		sieve_lexer_shift(lexer);
+		str_truncate(lexer->token_str_value, 0);
+		str = lexer->token_str_value;
+		
+		while ( sieve_lexer_curchar(lexer) != '"' ) {
+			if ( sieve_lexer_curchar(lexer) == '\\' ) {
+				sieve_lexer_shift(lexer);
+			}
+
+			switch ( sieve_lexer_curchar(lexer) ) {
+		
+			/* End of file */			
+			case -1:
+				sieve_lexer_error(lexer, 
+					"end of file before end of quoted string "
+					"started at line %d", start_line);
+				lexer->token_type = STT_ERROR;
+				return FALSE;
+
+			/* NUL character */
+			case '\0':
+				sieve_lexer_error(lexer,
+					"encountered NUL character in quoted string "
+					"started at line %d", start_line);
+				lexer->token_type = STT_ERROR;
+				return FALSE;
+
+			/* CR .. check for LF */
+			case '\r':
+				sieve_lexer_shift(lexer);
+
+				if ( sieve_lexer_curchar(lexer) != '\n' ) {
+					sieve_lexer_error(lexer, 
+						"found stray carriage-return (CR) character "
+						"in quoted string started at line %d", start_line);
+					lexer->token_type = STT_ERROR;
+					return FALSE;
+				}
+
+				if ( str_len(str) <= SIEVE_MAX_STRING_LEN ) 
+					str_append(str, "\r\n");
+				break;
+
+			/* Loose LF is allowed (non-standard) and converted to CRLF */
+			case '\n':
+				if ( str_len(str) <= SIEVE_MAX_STRING_LEN ) 
+					str_append(str, "\r\n");
+				break;
+
+			/* Other characters */
+			default:
+				if ( str_len(str) <= SIEVE_MAX_STRING_LEN ) 
+					str_append_c(str, sieve_lexer_curchar(lexer));
+			}
+
+			sieve_lexer_shift(lexer);							
+		}
+
+		sieve_lexer_shift(lexer);
+
+		if ( str_len(str) > SIEVE_MAX_STRING_LEN ) {
+			sieve_lexer_error(lexer, 
+				"quoted string started at line %d is too long "
+				"(longer than %llu bytes)", start_line,
+				(long long) SIEVE_MAX_STRING_LEN);
+			lexer->token_type = STT_ERROR;
+			return FALSE;
+		}
+		
+		lexer->token_type = STT_STRING;
+		return TRUE;
+		
+	/* single character tokens */
+	case ']':
+		sieve_lexer_shift(lexer);
+		lexer->token_type = STT_RSQUARE;
+		return TRUE;
+	case '[':
+		sieve_lexer_shift(lexer);
+		lexer->token_type = STT_LSQUARE;
+		return TRUE;
+	case '}':
+		sieve_lexer_shift(lexer);
+		lexer->token_type = STT_RCURLY;
+		return TRUE;
+	case '{':
+		sieve_lexer_shift(lexer);
+		lexer->token_type = STT_LCURLY;
+		return TRUE;
+	case ')':
+		sieve_lexer_shift(lexer);
+		lexer->token_type = STT_RBRACKET;
+		return TRUE;
+	case '(':
+		sieve_lexer_shift(lexer);
+		lexer->token_type = STT_LBRACKET;	
+		return TRUE;
+	case ';':
+		sieve_lexer_shift(lexer);
+		lexer->token_type = STT_SEMICOLON;
+		return TRUE;
+	case ',':
+		sieve_lexer_shift(lexer);
+		lexer->token_type = STT_COMMA;
+		return TRUE;
+		
+	/* EOF */	
+	case -1: 
+	  lexer->token_type = STT_EOF;
+		return TRUE;
+		
+	default: 
+		/* number */
+		if ( i_isdigit(sieve_lexer_curchar(lexer)) ) {
+			sieve_number_t value = DIGIT_VAL(sieve_lexer_curchar(lexer));
+			bool overflow = FALSE;
+
+			sieve_lexer_shift(lexer);
+  		
+			while ( i_isdigit(sieve_lexer_curchar(lexer)) ) {
+				sieve_number_t valnew = 
+					value * 10 + DIGIT_VAL(sieve_lexer_curchar(lexer));
+			
+				/* Check for integer wrap */
+				if ( valnew < value )
+					overflow = TRUE;
+
+				value = valnew;
+				sieve_lexer_shift(lexer);
+ 			}
+  		
+			switch ( sieve_lexer_curchar(lexer) ) { 
+			case 'k':
+			case 'K': /* Kilo */
+				if ( value > (SIEVE_MAX_NUMBER >> 10) )
+					overflow = TRUE;
+				else
+					value = value << 10;
+				sieve_lexer_shift(lexer);
+				break;
+			case 'm': 
+			case 'M': /* Mega */
+				if ( value > (SIEVE_MAX_NUMBER >> 20) )
+					overflow = TRUE;
+				else
+					value = value << 20;
+				sieve_lexer_shift(lexer);
+				break;
+			case 'g':
+			case 'G': /* Giga */
+				if ( value > (SIEVE_MAX_NUMBER >> 30) )
+					overflow = TRUE;
+				else
+					value = value << 30;
+				sieve_lexer_shift(lexer);
+				break;
+			default:
+				/* Next token */
+				break;
+			}
+
+			/* Check for integer wrap */
+			if ( overflow ) {
+				sieve_lexer_error(lexer,
+					"number exceeds integer limits (max %llu)",
+					(long long) SIEVE_MAX_NUMBER);
+				lexer->token_type = STT_ERROR;
+				return FALSE;
+			}
+  	
+			lexer->token_type = STT_NUMBER;
+			lexer->token_int_value = value;
+			return TRUE;	
+  		
+		/* identifier / tag */	
+		} else if ( i_isalpha(sieve_lexer_curchar(lexer)) ||
+			sieve_lexer_curchar(lexer) == '_' || 
+			sieve_lexer_curchar(lexer) == ':' ) {
+  		
+			enum sieve_token_type type = STT_IDENTIFIER;
+			str_truncate(lexer->token_str_value,0);
+			str = lexer->token_str_value;
+  		
+			/* If it starts with a ':' it is a tag and not an identifier */
+ 			if ( sieve_lexer_curchar(lexer) == ':' ) {
+				sieve_lexer_shift(lexer); // discard colon
+				type = STT_TAG;
+  			
+				/* First character still can't be a DIGIT */
+ 				if ( i_isalpha(sieve_lexer_curchar(lexer)) ||
+					sieve_lexer_curchar(lexer) == '_' ) { 
+					str_append_c(str, sieve_lexer_curchar(lexer));
+					sieve_lexer_shift(lexer);
+				} else {
+					/* Hmm, otherwise it is just a spurious colon */
+					lexer->token_type = STT_COLON;
+					return TRUE;
+				}
+			} else {
+				str_append_c(str, sieve_lexer_curchar(lexer));
+				sieve_lexer_shift(lexer);
+			}
+  		
+			/* Scan the rest of the identifier */
+			while ( i_isalnum(sieve_lexer_curchar(lexer)) ||
+				sieve_lexer_curchar(lexer) == '_' ) {
+
+				if ( str_len(str) <= SIEVE_MAX_IDENTIFIER_LEN ) {
+	 				str_append_c(str, sieve_lexer_curchar(lexer));
+				}
+				sieve_lexer_shift(lexer);
+			}
+
+			/* Is this in fact a multiline text string ? */
+			if ( sieve_lexer_curchar(lexer) == ':' &&
+				type == STT_IDENTIFIER && str_len(str) == 4 &&
+				strncasecmp(str_c(str), "text", 4) == 0 ) {
+				sieve_lexer_shift(lexer); // discard colon
+
+				start_line = lexer->current_line;
+  			
+				/* Discard SP and HTAB whitespace */
+				while ( sieve_lexer_curchar(lexer) == ' ' || 
+					sieve_lexer_curchar(lexer) == '\t' )
+ 					sieve_lexer_shift(lexer);
+  				
+				/* Discard hash comment or handle single CRLF */
+				switch ( sieve_lexer_curchar(lexer) ) {
+				case '#':
+					while ( sieve_lexer_curchar(lexer) != '\n' )
+						sieve_lexer_shift(lexer);
+					break;
+				case '\r':
+					sieve_lexer_shift(lexer);
+					break;
+				}
+  			
+				/* Terminating LF required */
+ 				switch ( sieve_lexer_curchar(lexer) ) {
+				case '\n':
+					sieve_lexer_shift(lexer);
+					break;
+				case -1:
+					sieve_lexer_error(lexer, 
+						"end of file before end of multi-line string");
+					lexer->token_type = STT_ERROR;
+					return FALSE;
+				default: 
+ 					sieve_lexer_error(lexer, 
+ 						"invalid character %s after 'text:' in multiline string",
+						_char_sanitize(sieve_lexer_curchar(lexer)));
+					lexer->token_type = STT_ERROR;
+					return FALSE;
+				}
+  			
+				/* Start over */
+				str_truncate(str, 0); 
+  			
+ 				/* Parse literal lines */
+				while ( TRUE ) {
+					bool cr_shifted = FALSE;
+
+					/* Remove dot-stuffing or detect end of text */
+					if ( sieve_lexer_curchar(lexer) == '.' ) {
+						sieve_lexer_shift(lexer);
+  					
+						/* Check for CR.. */
+						if ( sieve_lexer_curchar(lexer) == '\r' ) {
+							sieve_lexer_shift(lexer);
+							cr_shifted = TRUE;
+						}
+  				
+						/* ..LF */
+						if ( sieve_lexer_curchar(lexer) == '\n' ) {
+							sieve_lexer_shift(lexer);
+
+							/* End of multi-line string */
+
+							/* Check whether length limit was violated */
+							if ( str_len(str) > SIEVE_MAX_STRING_LEN ) {
+								sieve_lexer_error(lexer, 
+									"multi-line string started at line %d is too long "
+									"(longer than %llu bytes)", start_line,
+									(long long) SIEVE_MAX_STRING_LEN);
+									lexer->token_type = STT_ERROR;
+									return FALSE;
+							}
+
+							lexer->token_type = STT_STRING;
+							return TRUE;
+						} else if ( cr_shifted ) {
+							/* Seen CR, but no LF */
+							sieve_lexer_error(lexer, 
+								"found stray carriage-return (CR) character "
+								"in multi-line string started at line %d", start_line);
+							lexer->token_type = STT_ERROR;
+							return FALSE;
+						}
+
+						/* Handle dot-stuffing */
+						if ( str_len(str) <= SIEVE_MAX_STRING_LEN ) 
+							str_append_c(str, '.');
+						if ( sieve_lexer_curchar(lexer) == '.' )
+							sieve_lexer_shift(lexer);
+					}
+  				
+					/* Scan the rest of the line */
+					while ( sieve_lexer_curchar(lexer) != '\n' &&
+						sieve_lexer_curchar(lexer) != '\r' ) {
+
+						switch ( sieve_lexer_curchar(lexer) ) {
+						case -1:
+							sieve_lexer_error(lexer, 
+								"end of file before end of multi-line string");
+ 							lexer->token_type = STT_ERROR;
+ 							return FALSE;
+						case '\0':
+							sieve_lexer_error(lexer,
+								"encountered NUL character in quoted string "
+								"started at line %d", start_line);
+							lexer->token_type = STT_ERROR;
+							return FALSE;
+						default:
+							if ( str_len(str) <= SIEVE_MAX_STRING_LEN ) 
+  								str_append_c(str, sieve_lexer_curchar(lexer));
+						}
+
+						sieve_lexer_shift(lexer);
+					}
+
+					/* If exited loop due to CR, skip it */
+					if ( sieve_lexer_curchar(lexer) == '\r' ) {
+						sieve_lexer_shift(lexer);
+					}
+
+					/* Now we must see an LF */
+					if ( sieve_lexer_curchar(lexer) != '\n' ) {					
+						sieve_lexer_error(lexer, 
+							"found stray carriage-return (CR) character "
+							"in multi-line string started at line %d", start_line);
+ 						lexer->token_type = STT_ERROR;
+ 						return FALSE;
+					}
+						
+					if ( str_len(str) <= SIEVE_MAX_STRING_LEN ) 
+						str_append(str, "\r\n");
+
+					sieve_lexer_shift(lexer);
+				}
+  			
+ 				i_unreached();
+				lexer->token_type = STT_ERROR;
+				return FALSE;
+			}
+
+			if ( str_len(str) > SIEVE_MAX_IDENTIFIER_LEN ) {
+				sieve_lexer_error(lexer, 
+					"encountered impossibly long %s%s'",
+					(type == STT_TAG ? "tag identifier ':" : "identifier '"), 
+					str_sanitize(str_c(str), SIEVE_MAX_IDENTIFIER_LEN));
+				lexer->token_type = STT_ERROR;
+				return FALSE;
+			}
+  			
+			lexer->token_type = type;
+			return TRUE;
+		}
+	
+		/* Error (unknown character and EOF handled already) */
+		if ( lexer->token_type != STT_GARBAGE ) 
+			sieve_lexer_error(lexer, "unexpected character(s) starting with %s", 
+				_char_sanitize(sieve_lexer_curchar(lexer)));
+		sieve_lexer_shift(lexer);
+		lexer->token_type = STT_GARBAGE;
+		return FALSE;
+	}
+}
+
+bool sieve_lexer_skip_token(struct sieve_lexer *lexer) 
+{
+	/* Scan token while skipping whitespace */
+	do { 
+		if ( !sieve_lexer_scan_raw_token(lexer) ) return FALSE;
+	} while ( lexer->token_type == STT_WHITESPACE );
+	
+	return TRUE;
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-lexer.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-lexer.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-lexer.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-lexer.h	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,62 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+
+#ifndef __SIEVE_LEXER_H
+#define __SIEVE_LEXER_H
+
+#include "sieve-common.h"
+
+enum sieve_token_type {
+	STT_NONE,
+	STT_WHITESPACE,
+	STT_EOF,
+  
+	STT_NUMBER,
+	STT_IDENTIFIER,
+	STT_TAG,
+	STT_STRING,
+  
+	STT_RBRACKET,
+	STT_LBRACKET,
+	STT_RCURLY,
+	STT_LCURLY,
+	STT_RSQUARE,
+	STT_LSQUARE,
+	STT_SEMICOLON,
+	STT_COMMA,
+  
+	/* These are currently not used in the lexical specification, but a token
+	 * is assigned to these to generate proper error messages (these are
+	 * technically not garbage and possibly part of mistyped but otherwise
+	 * valid tokens).
+	 */
+	STT_SLASH, 
+	STT_COLON, 
+  
+	/* Error tokens */
+	STT_GARBAGE, /* Error reporting deferred to parser */ 
+	STT_ERROR    /* Lexer is responsible for error, parser won't report additional 
+	                errors */
+};
+
+struct sieve_lexer;
+
+/* Lexer object */
+struct sieve_lexer *sieve_lexer_create
+	(struct sieve_script *script, struct sieve_error_handler *ehandler);
+void sieve_lexer_free(struct sieve_lexer **lexer);
+
+/* Scanning */
+bool sieve_lexer_skip_token(struct sieve_lexer *lexer);
+const char *sieve_lexer_token_string(struct sieve_lexer *lexer);
+void sieve_lexer_print_token(struct sieve_lexer *lexer);
+
+/* Token access */
+enum sieve_token_type sieve_lexer_current_token(struct sieve_lexer *lexer);
+const string_t *sieve_lexer_token_str(struct sieve_lexer *lexer);
+const char *sieve_lexer_token_ident(struct sieve_lexer *lexer);
+int sieve_lexer_token_int(struct sieve_lexer *lexer);
+int sieve_lexer_current_line(struct sieve_lexer *lexer);
+bool sieve_lexer_eof(struct sieve_lexer *lexer);
+
+#endif /* __SIEVE_LEXER_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-limits.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-limits.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-limits.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-limits.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,9 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-limits.h"
+
+unsigned int sieve_max_actions = SIEVE_DEFAULT_MAX_ACTIONS;
+unsigned int sieve_max_redirects = SIEVE_DEFAULT_MAX_REDIRECTS;
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-limits.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-limits.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-limits.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-limits.h	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,38 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_LIMITS_H
+#define __SIEVE_LIMITS_H
+
+/*
+ * Lexer
+ */
+
+#define SIEVE_MAX_STRING_LEN        (1 << 20)
+#define SIEVE_MAX_IDENTIFIER_LEN    32
+
+/*
+ * AST
+ */
+
+#define SIEVE_MAX_COMMAND_ARGUMENTS 32
+#define SIEVE_MAX_BLOCK_NESTING     32
+#define SIEVE_MAX_TEST_NESTING      32
+
+/*
+ * Runtime
+ */
+
+#define SIEVE_MAX_MATCH_VALUES      32
+
+/*
+ * Actions
+ */
+
+#define SIEVE_DEFAULT_MAX_ACTIONS   32
+#define SIEVE_DEFAULT_MAX_REDIRECTS 4
+
+extern unsigned int sieve_max_actions;
+extern unsigned int sieve_max_redirects;
+
+#endif /* __SIEVE_LIMITS_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-match.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-match.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-match.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-match.c	2009-08-02 15:32:07.000000000 +0200
@@ -0,0 +1,205 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "mempool.h"
+#include "hash.h"
+#include "array.h"
+
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+
+#include "sieve-match.h"
+
+/*
+ * Matching implementation
+ */
+
+struct sieve_match_context *sieve_match_begin
+(struct sieve_interpreter *interp, const struct sieve_match_type *mtch, 
+	const struct sieve_comparator *cmp, 
+	const struct sieve_match_key_extractor *kextract,
+	struct sieve_coded_stringlist *key_list)
+{
+	struct sieve_match_context *mctx;
+	pool_t pool;
+
+	pool = pool_alloconly_create("sieve_match_context", 1024);
+	mctx = p_new(pool, struct sieve_match_context, 1);  
+
+	mctx->pool = pool;
+	mctx->interp = interp;
+	mctx->match_type = mtch;
+	mctx->comparator = cmp;
+	mctx->kextract = kextract;
+	mctx->key_list = key_list;
+
+	if ( mtch->match_init != NULL ) {
+		mtch->match_init(mctx);
+	}
+
+	return mctx;
+}
+
+int sieve_match_value
+	(struct sieve_match_context *mctx, const char *value, size_t val_size)
+{
+	const struct sieve_match_type *mtch = mctx->match_type;
+	sieve_coded_stringlist_reset(mctx->key_list);
+	bool ok = TRUE;
+
+	/* Reject unimplemented match-type */
+	if ( mtch->match == NULL )
+		return FALSE;
+				
+	/* Match to all key values */
+	if ( mtch->is_iterative ) {
+		unsigned int key_index = 0;
+		string_t *key_item = NULL;
+		int ret = 0;
+	
+		while ( (ok=sieve_coded_stringlist_next_item(mctx->key_list, &key_item)) 
+			&& key_item != NULL ) 
+		{				
+			T_BEGIN {
+				if ( mctx->kextract != NULL && mtch->allow_key_extract ) {
+					const struct sieve_match_key_extractor *kext = mctx->kextract;
+					void *kctx;
+				
+					if ( (ret=kext->init(&kctx, key_item)) > 0 ) {
+						const char *key;
+						size_t key_size;
+					 			
+						while ( (ret=kext->extract_key(kctx, &key, &key_size)) > 0 ) {				
+							ret = mtch->match
+								(mctx, value, val_size, key, key_size, key_index);
+						
+							if ( ret != 0 ) break;
+						}
+					}  
+				} else {
+					ret = mtch->match(mctx, value, val_size, str_c(key_item), 
+							str_len(key_item), key_index);
+				}
+			} T_END;
+			
+			if ( ret != 0 )
+				break;
+	
+			key_index++;
+		}
+
+		if ( !ok ) 
+			return -1;
+
+		if ( ret < 0 ) 
+			return ret;
+		if ( ret > 0 )
+			return TRUE;
+
+	} else {
+		bool result;
+
+		T_BEGIN {
+			result = mtch->match(mctx, value, val_size, NULL, 0, -1);
+		} T_END;
+
+		return result;
+	}
+
+	return FALSE;
+}
+
+int sieve_match_end(struct sieve_match_context **mctx)
+{
+	const struct sieve_match_type *mtch = (*mctx)->match_type;
+	int ret = FALSE;
+
+	if ( mtch->match_deinit != NULL ) {
+		ret = mtch->match_deinit(*mctx);
+	}
+
+    pool_unref(&(*mctx)->pool);
+    *mctx = NULL;
+
+	return ret;
+}
+
+/*
+ * Reading match operands
+ */
+ 
+bool sieve_match_dump_optional_operands
+(const struct sieve_dumptime_env *denv, sieve_size_t *address, int *opt_code)
+{
+	if ( *opt_code != SIEVE_MATCH_OPT_END || 
+		sieve_operand_optional_present(denv->sbin, address) ) {
+		do {
+			if ( !sieve_operand_optional_read(denv->sbin, address, opt_code) ) 
+				return FALSE;
+
+			switch ( *opt_code ) {
+			case SIEVE_MATCH_OPT_END:
+				break;
+			case SIEVE_MATCH_OPT_COMPARATOR:
+				if ( !sieve_opr_comparator_dump(denv, address) )
+					return FALSE;
+				break;
+			case SIEVE_MATCH_OPT_MATCH_TYPE:
+				if ( !sieve_opr_match_type_dump(denv, address) )
+					return FALSE;
+				break;
+			default: 
+				return TRUE;
+			}
+ 		} while ( *opt_code != SIEVE_MATCH_OPT_END );
+	}
+	
+	return TRUE;
+}
+
+int sieve_match_read_optional_operands
+(const struct sieve_runtime_env *renv, sieve_size_t *address, int *opt_code,
+	const struct sieve_comparator **cmp_r, const struct sieve_match_type **mtch_r)
+{	 
+	/* Handle any optional arguments */
+	if ( *opt_code != SIEVE_MATCH_OPT_END || 
+		sieve_operand_optional_present(renv->sbin, address) ) {
+		do {
+			if ( !sieve_operand_optional_read(renv->sbin, address, opt_code) ) {
+				sieve_runtime_trace_error(renv, "invalid optional operand");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+
+			switch ( *opt_code ) {
+			case SIEVE_MATCH_OPT_END: 
+				break;
+			case SIEVE_MATCH_OPT_COMPARATOR:
+				if ( (*cmp_r = sieve_opr_comparator_read(renv, address)) == NULL ) {
+					sieve_runtime_trace_error(renv, "invalid comparator operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+				break;
+			case SIEVE_MATCH_OPT_MATCH_TYPE:
+				if ( (*mtch_r = sieve_opr_match_type_read(renv, address)) == NULL ) {
+					sieve_runtime_trace_error(renv, "invalid match type operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+				break;
+			default:
+				return SIEVE_EXEC_OK;
+			}
+		} while ( *opt_code != SIEVE_MATCH_OPT_END );
+	}
+	
+	return SIEVE_EXEC_OK;
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-match.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-match.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-match.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-match.h	2009-07-30 00:34:54.000000000 +0200
@@ -0,0 +1,64 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#ifndef __SIEVE_MATCH_H
+#define __SIEVE_MATCH_H
+
+#include "sieve-common.h"
+
+/*
+ * Matching context
+ */
+ 
+struct sieve_match_key_extractor {
+	int (*init)(void **context, string_t *raw_key);
+	int (*extract_key)(void *context, const char **key, size_t *size);
+};
+
+struct sieve_match_context {
+	pool_t pool;
+
+	struct sieve_interpreter *interp;
+	const struct sieve_match_type *match_type;
+	const struct sieve_comparator *comparator;
+	const struct sieve_match_key_extractor *kextract;
+
+	struct sieve_coded_stringlist *key_list;
+
+
+	void *data;
+};
+
+/*
+ * Matching implementation
+ */
+
+struct sieve_match_context *sieve_match_begin
+	(struct sieve_interpreter *interp, const struct sieve_match_type *mtch, 
+		const struct sieve_comparator *cmp, 
+		const struct sieve_match_key_extractor *kextract,
+		struct sieve_coded_stringlist *key_list);
+int sieve_match_value
+	(struct sieve_match_context *mctx, const char *value, size_t val_size);
+int sieve_match_end(struct sieve_match_context **mctx);
+
+/*
+ * Read matching operands
+ */
+ 
+enum sieve_match_opt_operand {
+	SIEVE_MATCH_OPT_END,
+	SIEVE_MATCH_OPT_COMPARATOR,
+	SIEVE_MATCH_OPT_MATCH_TYPE,
+	SIEVE_MATCH_OPT_LAST
+};
+
+bool sieve_match_dump_optional_operands
+	(const struct sieve_dumptime_env *denv, sieve_size_t *addres, int *opt_code);
+
+int sieve_match_read_optional_operands
+	(const struct sieve_runtime_env *renv, sieve_size_t *address, int *opt_code,
+		const struct sieve_comparator **cmp_r, 
+		const struct sieve_match_type **mtch_r);
+
+#endif /* __SIEVE_MATCH_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-match-types.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-match-types.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-match-types.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-match-types.c	2009-02-24 13:40:32.000000000 +0100
@@ -0,0 +1,514 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#include <stdio.h>
+
+#include "lib.h"
+#include "compat.h"
+#include "mempool.h"
+#include "hash.h"
+#include "array.h"
+
+#include "sieve-common.h"
+#include "sieve-limits.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+#include "sieve-comparators.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "sieve-match-types.h"
+
+#include <string.h>
+
+/*
+ * Types
+ */
+ 
+struct sieve_match_values {
+	pool_t pool;
+	ARRAY_DEFINE(values, string_t *);
+	unsigned count;
+};
+
+/* 
+ * Default match types
+ */ 
+
+const struct sieve_match_type *sieve_core_match_types[] = {
+	&is_match_type, &contains_match_type, &matches_match_type
+};
+
+const unsigned int sieve_core_match_types_count = 
+	N_ELEMENTS(sieve_core_match_types);
+
+/* 
+ * Match-type 'extension' 
+ */
+
+static bool mtch_validator_load(struct sieve_validator *validator);
+
+static int ext_my_id = -1;
+
+const struct sieve_extension match_type_extension = {
+	"@match-types",
+	&ext_my_id,
+	NULL, NULL,
+	mtch_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_NO_OPERATIONS,
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+static const struct sieve_extension *ext_this = &match_type_extension;
+	
+/* 
+ * Validator context:
+ *   name-based match-type registry. 
+ */
+ 
+void sieve_match_type_register
+(struct sieve_validator *validator, const struct sieve_match_type *mtch) 
+{
+	struct sieve_validator_object_registry *regs = 
+		sieve_validator_object_registry_get(validator, ext_this);
+	
+	sieve_validator_object_registry_add(regs, &mtch->object);
+}
+
+const struct sieve_match_type *sieve_match_type_find
+(struct sieve_validator *validator, const char *identifier) 
+{
+	struct sieve_validator_object_registry *regs = 
+		sieve_validator_object_registry_get(validator, ext_this);
+	const struct sieve_object *object = 
+		sieve_validator_object_registry_find(regs, identifier);
+
+  return (const struct sieve_match_type *) object;
+}
+
+bool mtch_validator_load(struct sieve_validator *validator)
+{
+	struct sieve_validator_object_registry *regs = 
+		sieve_validator_object_registry_init(validator, ext_this);
+	unsigned int i;
+
+	/* Register core match-types */
+	for ( i = 0; i < sieve_core_match_types_count; i++ ) {
+		sieve_validator_object_registry_add
+			(regs, &(sieve_core_match_types[i]->object));
+	}
+
+	return TRUE;
+}
+
+/* 
+ * Interpreter context
+ */
+
+struct mtch_interpreter_context {
+	struct sieve_match_values *match_values;
+	bool match_values_enabled;
+};
+
+static void mtch_interpreter_free
+(struct sieve_interpreter *interp ATTR_UNUSED, void *context)
+{
+	struct mtch_interpreter_context *mctx = 
+		(struct mtch_interpreter_context *) context;
+	
+	if ( mctx->match_values != NULL ) {
+		pool_unref(&mctx->match_values->pool);
+	}
+}
+
+struct sieve_interpreter_extension mtch_interpreter_extension = {
+	&match_type_extension,
+	NULL,
+	mtch_interpreter_free
+};
+
+static inline struct mtch_interpreter_context *
+get_interpreter_context(struct sieve_interpreter *interp)
+{
+	return (struct mtch_interpreter_context *)
+		sieve_interpreter_extension_get_context(interp, ext_this);
+}
+
+static struct mtch_interpreter_context *
+mtch_interpreter_context_init(struct sieve_interpreter *interp)
+{		
+	pool_t pool = sieve_interpreter_pool(interp);
+	struct mtch_interpreter_context *ctx;
+	
+	ctx = p_new(pool, struct mtch_interpreter_context, 1);
+
+	sieve_interpreter_extension_register
+		(interp, &mtch_interpreter_extension, (void *) ctx);
+
+	return ctx;
+}
+
+/*
+ * Match values
+ */
+
+bool sieve_match_values_set_enabled
+(struct sieve_interpreter *interp, bool enable)
+{
+	struct mtch_interpreter_context *ctx = get_interpreter_context(interp);
+	
+	if ( ctx == NULL && enable ) 
+		ctx = mtch_interpreter_context_init(interp);
+	
+	if ( ctx != NULL ) {
+		bool previous = ctx->match_values_enabled;
+		
+		ctx->match_values_enabled = enable;
+		return previous;
+	}
+	
+	return FALSE;
+}
+
+bool sieve_match_values_are_enabled
+(struct sieve_interpreter *interp)
+{
+	struct mtch_interpreter_context *ctx = get_interpreter_context(interp);
+		
+	return ( ctx == NULL ? FALSE : ctx->match_values_enabled );
+}
+
+struct sieve_match_values *sieve_match_values_start
+(struct sieve_interpreter *interp)
+{
+	struct mtch_interpreter_context *ctx = get_interpreter_context(interp);
+	struct sieve_match_values *match_values;
+	
+	if ( ctx == NULL || !ctx->match_values_enabled )
+		return NULL;
+	
+	pool_t pool = pool_alloconly_create("sieve_match_values", 1024);
+		
+	match_values = p_new(pool, struct sieve_match_values, 1);
+	match_values->pool = pool;
+	match_values->count = 0;
+	
+	p_array_init(&match_values->values, pool, 4);
+
+	return match_values;
+}
+
+static string_t *sieve_match_values_add_entry
+(struct sieve_match_values *mvalues) 
+{
+	string_t *entry;
+	
+	if ( mvalues == NULL ) return NULL;	
+
+	if ( mvalues->count >= SIEVE_MAX_MATCH_VALUES ) return NULL;
+		
+	if ( mvalues->count >= array_count(&mvalues->values) ) {
+		entry = str_new(mvalues->pool, 64);
+		array_append(&mvalues->values, &entry, 1);	} else {
+		string_t * const *ep = array_idx(&mvalues->values, mvalues->count);
+		entry = *ep;
+		str_truncate(entry, 0);
+	}
+	
+	mvalues->count++;
+
+	return entry;
+}
+
+void sieve_match_values_set
+(struct sieve_match_values *mvalues, unsigned int index, string_t *value)
+{
+	if ( mvalues != NULL && index < array_count(&mvalues->values) ) {
+		string_t * const *ep = array_idx(&mvalues->values, index);
+    	string_t *entry = *ep;
+
+	    if ( entry != NULL && value != NULL ) {
+			str_truncate(entry, 0);
+        	str_append_str(entry, value);
+		}
+	}
+}
+	
+void sieve_match_values_add
+(struct sieve_match_values *mvalues, string_t *value) 
+{
+	string_t *entry = sieve_match_values_add_entry(mvalues); 
+
+	if ( entry != NULL && value != NULL )
+		str_append_str(entry, value);
+}
+
+void sieve_match_values_add_char
+(struct sieve_match_values *mvalues, char c) 
+{
+	string_t *entry = sieve_match_values_add_entry(mvalues); 
+
+	if ( entry != NULL )
+		str_append_c(entry, c);
+}
+
+void sieve_match_values_skip
+(struct sieve_match_values *mvalues, int num) 
+{
+	int i;
+	
+	for ( i = 0; i < num; i++ )
+		(void) sieve_match_values_add_entry(mvalues); 
+}
+
+void sieve_match_values_commit
+(struct sieve_interpreter *interp, struct sieve_match_values **mvalues)
+{
+	struct mtch_interpreter_context *ctx;
+	
+	if ( (*mvalues) == NULL ) return;
+	
+	ctx = get_interpreter_context(interp);
+	if ( ctx == NULL || !ctx->match_values_enabled )
+		return;	
+		
+	if ( ctx->match_values != NULL ) {
+		pool_unref(&ctx->match_values->pool);
+		ctx->match_values = NULL;
+	}
+
+	ctx->match_values = *mvalues;
+	*mvalues = NULL;
+}
+
+void sieve_match_values_abort
+(struct sieve_match_values **mvalues)
+{		
+	if ( (*mvalues) == NULL ) return;
+	
+	pool_unref(&(*mvalues)->pool);
+	*mvalues = NULL;
+}
+
+void sieve_match_values_get
+(struct sieve_interpreter *interp, unsigned int index, string_t **value_r) 
+{
+	struct mtch_interpreter_context *ctx = get_interpreter_context(interp);
+	struct sieve_match_values *mvalues;
+
+	if ( ctx == NULL || ctx->match_values == NULL ) {
+		*value_r = NULL;
+		return;
+	}
+	
+	mvalues = ctx->match_values;
+	if ( index < array_count(&mvalues->values) && index < mvalues->count ) {
+		string_t * const *entry = array_idx(&mvalues->values, index);
+		
+		*value_r = *entry;
+		return;
+	}
+
+	*value_r = NULL;	
+}
+
+/* 
+ * Match-type tagged argument 
+ */
+ 
+/* Forward declarations */
+
+static bool tag_match_type_is_instance_of
+	(struct sieve_validator *validator, struct sieve_command_context *cmd, 
+		struct sieve_ast_argument *arg);
+static bool tag_match_type_validate
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+static bool tag_match_type_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+		struct sieve_command_context *cmd);
+
+/* Argument object */
+ 
+const struct sieve_argument match_type_tag = { 
+	"MATCH-TYPE",
+	tag_match_type_is_instance_of,
+	NULL, 
+	tag_match_type_validate, 
+	NULL,
+	tag_match_type_generate 
+};
+
+/* Argument implementation */
+
+static bool tag_match_type_is_instance_of
+(struct sieve_validator *validator, struct sieve_command_context *cmd, 
+	struct sieve_ast_argument *arg)
+{
+	struct sieve_match_type_context *mtctx;
+	const struct sieve_match_type *mtch = 
+		sieve_match_type_find(validator, sieve_ast_argument_tag(arg));
+		
+	if ( mtch == NULL ) return FALSE;	
+		
+	/* Create context */
+	mtctx = p_new(sieve_command_pool(cmd), struct sieve_match_type_context, 1);
+	mtctx->match_type = mtch;
+	mtctx->match_type_arg = arg;
+	mtctx->command_ctx = cmd;
+	mtctx->comparator = NULL; /* Can be filled in later */
+	
+	arg->context = (void *) mtctx;
+	
+	return TRUE;
+}
+ 
+static bool tag_match_type_validate
+(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd ATTR_UNUSED)
+{
+	struct sieve_match_type_context *mtctx = 
+		(struct sieve_match_type_context *) (*arg)->context;
+	const struct sieve_match_type *mtch = mtctx->match_type;
+
+	/* Syntax:   
+	 *   ":is" / ":contains" / ":matches" (subject to extension)
+	 */
+		
+	/* Skip tag */
+	*arg = sieve_ast_argument_next(*arg);
+	
+	/* Check whether this match type requires additional validation. 
+	 * Additional validation can override the match type recorded in the context 
+	 * for later code generation. 
+	 */
+	if ( mtch->validate != NULL ) {
+		return mtch->validate(validator, arg, mtctx);
+	}
+	
+	return TRUE;
+}
+
+static bool tag_match_type_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+	struct sieve_command_context *cmd ATTR_UNUSED)
+{
+	struct sieve_match_type_context *mtctx =
+		(struct sieve_match_type_context *) arg->context;
+	
+	(void) sieve_opr_match_type_emit(cgenv->sbin, mtctx->match_type);
+			
+	return TRUE;
+}
+
+void sieve_match_types_link_tags
+	(struct sieve_validator *validator, 
+		struct sieve_command_registration *cmd_reg, int id_code) 
+{	
+	sieve_validator_register_tag
+		(validator, cmd_reg, &match_type_tag, id_code); 	
+}
+
+/*
+ * Validation
+ */
+
+bool sieve_match_type_validate
+(struct sieve_validator *validator, struct sieve_command_context *cmd,
+	struct sieve_ast_argument *key_arg, 
+	const struct sieve_match_type *mcht_default, 
+	const struct sieve_comparator *cmp_default)
+{
+	struct sieve_ast_argument *arg = sieve_command_first_argument(cmd);
+	struct sieve_ast_argument *mt_arg = NULL;
+	struct sieve_match_type_context *mtctx;
+	const struct sieve_match_type *mcht = NULL;
+	const struct sieve_comparator *cmp = NULL;
+
+	/* Find match type and comparator among the arguments */
+	while ( arg != NULL && arg != cmd->first_positional ) {
+		if ( sieve_argument_is_comparator(arg) ) {
+			cmp = sieve_comparator_tag_get(arg);
+			if ( mt_arg != NULL ) break;
+		}
+
+		if ( sieve_argument_is_match_type(arg) ) {
+			mt_arg = arg;
+			if ( cmp != NULL ) break;
+		}
+		arg = sieve_ast_argument_next(arg);
+	}
+	
+	/* Verify using the default comparator if none is specified explicitly */
+	if ( cmp == NULL )
+		cmp = cmp_default;
+	
+	/* Verify the default match type if none is specified explicitly */
+	if ( mt_arg == NULL || mt_arg->context == NULL ) {
+		mtctx = NULL;
+		mcht = mcht_default;
+	} else {
+		mtctx = (struct sieve_match_type_context *) mt_arg->context;
+		mcht = mtctx->match_type;
+		mtctx->comparator = cmp;
+	}
+
+	/* Check whether this match type requires additional validation. 
+	 * Additional validation can override the match type recorded in the context 
+	 * for later code generation. 
+	 */
+	if ( mcht != NULL && mcht->validate_context != NULL ) {
+		return mcht->validate_context(validator, mt_arg, mtctx, key_arg);
+	}
+	
+	return TRUE;	
+}
+
+/*
+ * Match-type operand
+ */
+ 
+const struct sieve_operand_class sieve_match_type_operand_class = 
+	{ "match type" };
+	
+static const struct sieve_extension_objects core_match_types =
+	SIEVE_EXT_DEFINE_MATCH_TYPES(sieve_core_match_types);
+
+const struct sieve_operand match_type_operand = { 
+	"match-type", 
+	NULL,
+	SIEVE_OPERAND_MATCH_TYPE,
+	&sieve_match_type_operand_class,
+	&core_match_types
+};
+
+/*
+ * Common validation implementation
+ */
+
+bool sieve_match_substring_validate_context
+(struct sieve_validator *validator, struct sieve_ast_argument *arg,
+	struct sieve_match_type_context *ctx,
+	struct sieve_ast_argument *key_arg ATTR_UNUSED)
+{
+	const struct sieve_comparator *cmp = ctx->comparator;
+		
+	if ( cmp == NULL )
+		return TRUE;
+			
+	if ( (cmp->flags & SIEVE_COMPARATOR_FLAG_SUBSTRING_MATCH) == 0 ) {
+		sieve_argument_validate_error(validator, arg,
+			"the specified %s comparator does not support "
+			"sub-string matching as required by the :%s match type",
+			cmp->object.identifier, ctx->match_type->object.identifier );
+
+		return FALSE;
+	}
+	
+	return TRUE;
+} 
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-match-types.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-match-types.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-match-types.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-match-types.h	2009-02-24 13:40:12.000000000 +0100
@@ -0,0 +1,201 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#ifndef __SIEVE_MATCH_TYPES_H
+#define __SIEVE_MATCH_TYPES_H
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-objects.h"
+
+/*
+ * Types
+ */
+
+struct sieve_match_type_context;
+
+/*
+ * Core match types 
+ */
+ 
+enum sieve_match_type_code {
+	SIEVE_MATCH_TYPE_IS,
+	SIEVE_MATCH_TYPE_CONTAINS,
+	SIEVE_MATCH_TYPE_MATCHES,
+	SIEVE_MATCH_TYPE_CUSTOM
+};
+
+extern const struct sieve_match_type is_match_type;
+extern const struct sieve_match_type contains_match_type;
+extern const struct sieve_match_type matches_match_type;
+
+/*
+ * Match type object
+ */
+ 
+struct sieve_match_type {
+	struct sieve_object object;
+
+	/* Match function called for every key value or should it be called once
+	 * for every tested value? (TRUE = first alternative)
+	 */
+	bool is_iterative;
+	
+	/* Is the key value allowed to contain formatting to extract multiple keys
+	 * out of the same string?
+	 */
+	bool allow_key_extract;
+		
+	bool (*validate)
+		(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+			struct sieve_match_type_context *ctx);
+	bool (*validate_context)
+		(struct sieve_validator *validator, struct sieve_ast_argument *arg, 
+			struct sieve_match_type_context *ctx, struct sieve_ast_argument *key_arg);
+			
+	/*
+	 * Matching
+ 	 */
+
+	void (*match_init)(struct sieve_match_context *mctx);
+
+	/* WARNING: some tests may pass a val == NULL parameter indicating that the 
+	 * passed value has no significance. For string-type matches this should map 
+	 * to the empty string "", but for match types that consider the passed values 
+	 * as objects rather than strings (e.g. :count) this means that the passed 
+	 * value should be skipped. 
+	 */
+	int (*match)
+		(struct sieve_match_context *mctx, const char *val, size_t val_size, 
+			const char *key, size_t key_size, int key_index);
+	int (*match_deinit)(struct sieve_match_context *mctx);
+};
+
+struct sieve_match_type_context {
+	struct sieve_command_context *command_ctx;
+	struct sieve_ast_argument *match_type_arg;
+
+	const struct sieve_match_type *match_type;
+	
+	/* Only filled in when match_type->validate_context() is called */
+	const struct sieve_comparator *comparator;
+	
+	/* Context data could be used in the future to pass data between validator and
+	 * generator in match types that use extra parameters. Currently not 
+	 * necessary, not even for the relational extension.
+	 */
+	void *ctx_data;
+};
+
+/*
+ * Match type registration
+ */
+
+void sieve_match_type_register
+	(struct sieve_validator *validator, const struct sieve_match_type *mcht);
+const struct sieve_match_type *sieve_match_type_find
+	(struct sieve_validator *validator, const char *identifier);
+
+/* 
+ * Match values 
+ */
+
+struct sieve_match_values;
+
+bool sieve_match_values_set_enabled
+	(struct sieve_interpreter *interp, bool enable);
+bool sieve_match_values_are_enabled
+	(struct sieve_interpreter *interp);	
+	
+struct sieve_match_values *sieve_match_values_start
+	(struct sieve_interpreter *interp);
+void sieve_match_values_set
+	(struct sieve_match_values *mvalues, unsigned int index, string_t *value);
+void sieve_match_values_add
+	(struct sieve_match_values *mvalues, string_t *value);
+void sieve_match_values_add_char
+	(struct sieve_match_values *mvalues, char c);	
+void sieve_match_values_skip
+	(struct sieve_match_values *mvalues, int num);
+	
+void sieve_match_values_commit
+	(struct sieve_interpreter *interp, struct sieve_match_values **mvalues);
+void sieve_match_values_abort
+	(struct sieve_match_values **mvalues);
+	
+void sieve_match_values_get
+	(struct sieve_interpreter *interp, unsigned int index, string_t **value_r);
+
+/*
+ * Match type tagged argument 
+ */
+
+extern const struct sieve_argument match_type_tag;
+
+static inline bool sieve_argument_is_match_type
+	(struct sieve_ast_argument *arg)
+{
+	return ( arg->argument == &match_type_tag );
+}
+
+void sieve_match_types_link_tags
+	(struct sieve_validator *validator, 
+		struct sieve_command_registration *cmd_reg, int id_code);
+
+/*
+ * Validation
+ */
+
+bool sieve_match_type_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd,
+		struct sieve_ast_argument *key_arg, 
+		const struct sieve_match_type *mcht_default, 
+		const struct sieve_comparator *cmp_default);
+
+/*
+ * Match type operand
+ */
+ 
+extern const struct sieve_operand match_type_operand;
+extern const struct sieve_operand_class sieve_match_type_operand_class;
+
+#define SIEVE_EXT_DEFINE_MATCH_TYPE(OP) SIEVE_EXT_DEFINE_OBJECT(OP)
+#define SIEVE_EXT_DEFINE_MATCH_TYPES(OPS) SIEVE_EXT_DEFINE_OBJECTS(OPS)
+
+static inline bool sieve_operand_is_match_type
+(const struct sieve_operand *operand)
+{
+	return ( operand != NULL && 
+		operand->class == &sieve_match_type_operand_class );
+}
+
+static inline void sieve_opr_match_type_emit
+(struct sieve_binary *sbin, const struct sieve_match_type *mtch)
+{ 
+	sieve_opr_object_emit(sbin, &mtch->object);
+}
+
+static inline const struct sieve_match_type *sieve_opr_match_type_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	return (const struct sieve_match_type *) sieve_opr_object_read
+		(renv, &sieve_match_type_operand_class, address);
+}
+
+static inline bool sieve_opr_match_type_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	return sieve_opr_object_dump
+		(denv, &sieve_match_type_operand_class, address, NULL);
+}
+
+/* Common validation implementation */
+
+bool sieve_match_substring_validate_context
+	(struct sieve_validator *validator, struct sieve_ast_argument *arg,
+		struct sieve_match_type_context *ctx, 
+		struct sieve_ast_argument *key_arg);
+
+#endif /* __SIEVE_MATCH_TYPES_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-message.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-message.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-message.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-message.c	2009-07-21 02:51:39.000000000 +0200
@@ -0,0 +1,190 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "ioloop.h"
+#include "mempool.h"
+#include "array.h"
+
+#include "sieve-common.h"
+#include "sieve-error.h"
+#include "sieve-extensions.h"
+#include "sieve-address.h"
+
+#include "sieve-message.h"
+
+/*
+ * Message transmission
+ */
+ 
+const char *sieve_message_get_new_id
+(const struct sieve_script_env *senv)
+{
+	static int count = 0;
+	
+	return t_strdup_printf("<dovecot-sieve-%s-%s-%d@%s>",
+		dec2str(ioloop_timeval.tv_sec), dec2str(ioloop_timeval.tv_usec),
+    count++, senv->hostname);
+}
+
+/* 
+ * Message context 
+ */
+
+struct sieve_message_context {
+	pool_t pool;
+	int refcount;
+
+	const struct sieve_message_data *msgdata;
+
+	/* Normalized envelope addresses */
+
+	bool envelope_parsed;
+
+	const struct sieve_address *envelope_sender;
+	const struct sieve_address *envelope_recipient;
+	
+	/* Context data for extensions */
+	ARRAY_DEFINE(ext_contexts, void *); 
+};
+
+struct sieve_message_context *sieve_message_context_create
+(const struct sieve_message_data *msgdata)
+{
+	struct sieve_message_context *msgctx;
+	
+	msgctx = i_new(struct sieve_message_context, 1);
+	msgctx->refcount = 1;
+
+	msgctx->msgdata = msgdata;
+		
+	sieve_message_context_flush(msgctx);
+
+	return msgctx;
+}
+
+void sieve_message_context_ref(struct sieve_message_context *msgctx)
+{
+	msgctx->refcount++;
+}
+
+void sieve_message_context_unref(struct sieve_message_context **msgctx)
+{
+	i_assert((*msgctx)->refcount > 0);
+
+	if (--(*msgctx)->refcount != 0)
+		return;
+	
+	pool_unref(&((*msgctx)->pool));
+		
+	i_free(*msgctx);
+	*msgctx = NULL;
+}
+
+void sieve_message_context_flush(struct sieve_message_context *msgctx)
+{
+	pool_t pool;
+
+	if ( msgctx->pool != NULL ) {
+		pool_unref(&msgctx->pool);
+	}
+
+	pool = pool_alloconly_create("sieve_message_context", 1024);
+	msgctx->pool = pool;
+
+	msgctx->envelope_recipient = NULL;
+	msgctx->envelope_sender = NULL;
+	msgctx->envelope_parsed = FALSE;
+
+	p_array_init(&msgctx->ext_contexts, pool, sieve_extensions_get_count());
+}
+
+pool_t sieve_message_context_pool(struct sieve_message_context *msgctx)
+{
+	return msgctx->pool;
+}
+
+/* Extension support */
+
+void sieve_message_context_extension_set
+(struct sieve_message_context *msgctx, const struct sieve_extension *ext, 
+	void *context)
+{
+	array_idx_set(&msgctx->ext_contexts, (unsigned int) SIEVE_EXT_ID(ext), &context);	
+}
+
+const void *sieve_message_context_extension_get
+(struct sieve_message_context *msgctx, const struct sieve_extension *ext) 
+{
+	int ext_id = SIEVE_EXT_ID(ext);
+	void * const *ctx;
+
+	if  ( ext_id < 0 || ext_id >= (int) array_count(&msgctx->ext_contexts) )
+		return NULL;
+	
+	ctx = array_idx(&msgctx->ext_contexts, (unsigned int) ext_id);		
+
+	return *ctx;
+}
+
+/* Envelope */
+
+static void sieve_message_envelope_parse(struct sieve_message_context *msgctx)
+{
+	/* FIXME: log parse problems properly; logs only 'failure' now */
+
+	msgctx->envelope_recipient = sieve_address_parse_envelope_path
+		(msgctx->pool, msgctx->msgdata->to_address);	
+
+	if ( msgctx->envelope_recipient == NULL )
+		sieve_sys_error("envelope recipient address '%s' is unparseable", msgctx->msgdata->to_address); 
+	else if ( msgctx->envelope_recipient->local_part == NULL )
+		sieve_sys_error("envelope recipient address '%s' is a null path", msgctx->msgdata->to_address); 
+
+	msgctx->envelope_sender = sieve_address_parse_envelope_path
+		(msgctx->pool, msgctx->msgdata->return_path);	
+
+	if ( msgctx->envelope_sender == NULL )
+		sieve_sys_error("envelope sender address '%s' is unparseable", msgctx->msgdata->return_path); 
+
+	msgctx->envelope_parsed = TRUE;
+}
+
+const struct sieve_address *sieve_message_get_recipient_address
+(struct sieve_message_context *msgctx)
+{
+	if ( !msgctx->envelope_parsed ) 
+		sieve_message_envelope_parse(msgctx);
+
+	return msgctx->envelope_recipient;
+} 
+
+const struct sieve_address *sieve_message_get_sender_address
+(struct sieve_message_context *msgctx)
+{
+	if ( !msgctx->envelope_parsed ) 
+		sieve_message_envelope_parse(msgctx);
+
+	return msgctx->envelope_sender;	
+} 
+
+const char *sieve_message_get_recipient
+(struct sieve_message_context *msgctx)
+{
+	if ( !msgctx->envelope_parsed ) 
+		sieve_message_envelope_parse(msgctx);
+
+	return sieve_address_to_string(msgctx->envelope_recipient);
+}
+
+const char *sieve_message_get_sender
+(struct sieve_message_context *msgctx)
+{
+	if ( !msgctx->envelope_parsed ) 
+		sieve_message_envelope_parse(msgctx);
+
+	return sieve_address_to_string(msgctx->envelope_sender);
+} 
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-message.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-message.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-message.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-message.h	2009-07-21 02:50:36.000000000 +0200
@@ -0,0 +1,52 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_MESSAGE_H
+#define __SIEVE_MESSAGE_H
+
+/* 
+ * Message transmission
+ */
+
+const char *sieve_message_get_new_id
+	(const struct sieve_script_env *senv);
+
+/* 
+ * Message context 
+ */
+
+struct sieve_message_context;
+
+struct sieve_message_context *sieve_message_context_create
+	(const struct sieve_message_data *msgdata);
+void sieve_message_context_ref(struct sieve_message_context *msgctx);
+void sieve_message_context_unref(struct sieve_message_context **msgctx);
+
+void sieve_message_context_flush(struct sieve_message_context *msgctx);
+
+pool_t sieve_message_context_pool
+	(struct sieve_message_context *msgctx);
+
+/* Extension support */
+
+void sieve_message_context_extension_set
+	(struct sieve_message_context *msgctx, const struct sieve_extension *ext, 
+		void *context);
+const void *sieve_message_context_extension_get
+	(struct sieve_message_context *msgctx, const struct sieve_extension *ext);
+
+/* Envelope */
+
+const struct sieve_address *sieve_message_get_recipient_address
+	(struct sieve_message_context *msgctx);
+
+const struct sieve_address *sieve_message_get_sender_address
+	(struct sieve_message_context *msgctx);
+
+const char *sieve_message_get_recipient
+	(struct sieve_message_context *msgctx);
+
+const char *sieve_message_get_sender
+	(struct sieve_message_context *msgctx);
+	
+#endif /* __SIEVE_MESSAGE_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-objects.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-objects.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-objects.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-objects.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,96 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+#include "sieve-dump.h"
+#include "sieve-interpreter.h"
+
+#include "sieve-objects.h"
+
+/*
+ * Object coding
+ */
+
+void sieve_opr_object_emit
+(struct sieve_binary *sbin, const struct sieve_object *obj)
+{
+	struct sieve_extension_objects *objs = 
+		(struct sieve_extension_objects *) obj->operand->interface;
+		 
+	(void) sieve_operand_emit_code(sbin, obj->operand);
+	
+	if ( objs->count > 1 ) {	
+		(void) sieve_binary_emit_byte(sbin, obj->code);
+	} 
+}
+
+const struct sieve_object *sieve_opr_object_read_data
+(struct sieve_binary *sbin, const struct sieve_operand *operand,
+	const struct sieve_operand_class *opclass, sieve_size_t *address)
+{
+	const struct sieve_extension_objects *objs;
+	unsigned int obj_code; 
+
+	if ( operand == NULL || operand->class != opclass )
+		return NULL;
+	
+	objs = (struct sieve_extension_objects *) operand->interface;
+	if ( objs == NULL ) 
+		return NULL;
+			
+	if ( objs->count > 1 ) {
+		if ( !sieve_binary_read_byte(sbin, address, &obj_code) ) 
+			return NULL;
+
+		if ( obj_code < objs->count ) {
+			const struct sieve_object *const *objects = 
+				(const struct sieve_object* const *) objs->objects;
+			return objects[obj_code]; 
+		}
+	}
+	
+	return (const struct sieve_object *) objs->objects; 
+}
+
+const struct sieve_object *sieve_opr_object_read
+(const struct sieve_runtime_env *renv, 
+	const struct sieve_operand_class *opclass, sieve_size_t *address)
+{
+	const struct sieve_operand *operand = sieve_operand_read(renv->sbin, address);
+	
+	return sieve_opr_object_read_data(renv->sbin, operand, opclass, address);
+}
+
+bool sieve_opr_object_dump
+(const struct sieve_dumptime_env *denv, 
+	const struct sieve_operand_class *opclass, sieve_size_t *address,
+	const struct sieve_object **object_r)
+{
+	const struct sieve_operand *operand;
+	const struct sieve_object *obj;
+	const char *class;
+	
+	sieve_code_mark(denv);
+	
+	operand = sieve_operand_read(denv->sbin, address); 
+	obj = sieve_opr_object_read_data(denv->sbin, operand, opclass, address);
+	
+	if ( obj == NULL )
+		return FALSE;
+		
+	if ( operand->class == NULL )
+		class = "OBJECT";
+	else
+		class = operand->class->name;
+			
+	sieve_code_dumpf(denv, "%s: %s", class, obj->identifier);
+	
+	if ( object_r != NULL )
+		*object_r = obj;
+	
+	return TRUE;
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-objects.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-objects.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-objects.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-objects.h	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,41 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_OBJECTS_H
+#define __SIEVE_OBJECTS_H
+
+/*
+ * Object
+ */
+
+struct sieve_object {
+	const char *identifier;
+	const struct sieve_operand *operand;
+	unsigned int code;
+};
+
+#define SIEVE_OBJECT(identifier, operand, code) \
+	{ identifier, operand, code }
+
+/*
+ * Object coding
+ */
+ 
+void sieve_opr_object_emit
+	(struct sieve_binary *sbin, const struct sieve_object *obj);
+
+const struct sieve_object *sieve_opr_object_read_data
+	(struct sieve_binary *sbin, const struct sieve_operand *operand,
+		const struct sieve_operand_class *opclass, sieve_size_t *address);
+
+const struct sieve_object *sieve_opr_object_read
+	(const struct sieve_runtime_env *renv, 
+		const struct sieve_operand_class *opclass, sieve_size_t *address);
+
+bool sieve_opr_object_dump
+	(const struct sieve_dumptime_env *denv, 
+		const struct sieve_operand_class *opclass, sieve_size_t *address,
+		const struct sieve_object **object_r);
+
+
+#endif /* __SIEVE_OBJECTS_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-parser.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-parser.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-parser.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-parser.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,655 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+ 
+#include <stdio.h>
+
+#include "lib.h"
+#include "istream.h"
+#include "failures.h"
+
+#include "sieve-common.h"
+#include "sieve-limits.h"
+#include "sieve-script.h"
+#include "sieve-lexer.h"
+#include "sieve-parser.h"
+#include "sieve-error.h"
+#include "sieve-ast.h"
+
+/*
+ * Forward declarations
+ */
+ 
+inline static void sieve_parser_error
+	(struct sieve_parser *parser, const char *fmt, ...) ATTR_FORMAT(2, 3);
+inline static void sieve_parser_warning
+	(struct sieve_parser *parser, const char *fmt, ...) ATTR_FORMAT(2, 3); 
+ 
+static int sieve_parser_recover
+	(struct sieve_parser *parser, enum sieve_token_type end_token);
+
+/*
+ * Parser object
+ */
+
+struct sieve_parser {
+	pool_t pool;
+	
+	bool valid;
+	
+	struct sieve_script *script;
+		
+	struct sieve_error_handler *ehandler;
+	
+	struct sieve_lexer *lexer;
+	struct sieve_ast *ast;
+};
+
+struct sieve_parser *sieve_parser_create
+(struct sieve_script *script, struct sieve_error_handler *ehandler)
+{
+	struct sieve_parser *parser;
+	struct sieve_lexer *lexer;
+	
+	lexer = sieve_lexer_create(script, ehandler);
+  
+	if ( lexer != NULL ) {
+		pool_t pool = pool_alloconly_create("sieve_parser", 4096);	
+
+		parser = p_new(pool, struct sieve_parser, 1);
+		parser->pool = pool;
+		parser->valid = TRUE;
+		
+		parser->ehandler = ehandler;
+		sieve_error_handler_ref(ehandler);
+
+		parser->script = script;
+		sieve_script_ref(script);
+				
+		parser->lexer = lexer;
+		parser->ast = NULL;
+				
+		return parser;
+	}
+	
+	return NULL;
+}
+
+void sieve_parser_free(struct sieve_parser **parser)
+{
+	if ((*parser)->ast != NULL)	  
+		sieve_ast_unref(&(*parser)->ast);
+
+	sieve_lexer_free(&(*parser)->lexer);
+	sieve_script_unref(&(*parser)->script);
+
+	sieve_error_handler_unref(&(*parser)->ehandler);
+
+	pool_unref(&(*parser)->pool);
+	
+	*parser = NULL;
+}
+
+/*
+ * Internal error handling
+ */
+
+inline static void sieve_parser_error
+(struct sieve_parser *parser, const char *fmt, ...)
+{ 
+	va_list args;
+	va_start(args, fmt);
+
+	/* Don't report a parse error if the lexer complained already */ 
+	if ( sieve_lexer_current_token(parser->lexer) != STT_ERROR )  
+	{
+		T_BEGIN {
+			sieve_verror(parser->ehandler,
+				sieve_error_script_location(parser->script, 
+					sieve_lexer_current_line(parser->lexer)),
+				fmt, args);
+		} T_END; 
+	}
+	
+	parser->valid = FALSE;
+	
+	va_end(args);
+}
+
+inline static void sieve_parser_warning
+(struct sieve_parser *parser, const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+
+	T_BEGIN	{
+		sieve_vwarning(parser->ehandler, 
+			sieve_error_script_location(parser->script, 
+				sieve_lexer_current_line(parser->lexer)),
+			fmt, args);
+	} T_END;
+		
+	va_end(args);
+} 
+
+/*
+ * Sieve grammar parsing
+ */
+
+/* sieve_parse_arguments():
+ *
+ * Parses both command arguments and sub-tests:
+ *   arguments = *argument [test / test-list]
+ *   argument = string-list / number / tag
+ *   string = quoted-string / multi-line   [[implicitly handled in lexer]]
+ *   string-list = "[" string *("," string) "]" / string         ;; if
+ *     there is only a single string, the brackets are optional
+ *   test-list = "(" test *("," test) ")"
+ *   test = identifier arguments
+ */
+static int sieve_parse_arguments
+(struct sieve_parser *parser, struct sieve_ast_node *node, unsigned int depth) 
+{	
+	struct sieve_lexer *lexer = parser->lexer;
+	struct sieve_ast_node *test = NULL;
+	bool test_present = TRUE;
+	bool arg_present = TRUE;
+	int result = TRUE; /* Indicates whether the parser is in a defined, not 
+	                       necessarily error-free state */
+
+	/* Parse arguments */
+	while ( arg_present && result > 0 && 
+		(parser->valid || sieve_errors_more_allowed(parser->ehandler)) ) {
+		struct sieve_ast_argument *arg;
+		
+		switch ( sieve_lexer_current_token(lexer) ) {
+		
+		/* String list */
+		case STT_LSQUARE:
+			/* Create stinglist object */
+			arg = sieve_ast_argument_stringlist_create
+				(node, sieve_lexer_current_line(parser->lexer));
+
+			if ( arg == NULL ) break;
+				
+			sieve_lexer_skip_token(lexer);			
+			
+			if ( sieve_lexer_current_token(lexer) == STT_STRING ) {
+				bool add_failed = FALSE;
+
+				/* Add the string to the list */
+				if ( !sieve_ast_stringlist_add
+					(arg, sieve_lexer_token_str(lexer), 
+						sieve_lexer_current_line(parser->lexer)) )
+					add_failed = TRUE;
+				
+				sieve_lexer_skip_token(lexer);
+				 
+				while ( !add_failed && sieve_lexer_current_token(lexer) == STT_COMMA &&
+					(parser->valid || sieve_errors_more_allowed(parser->ehandler)) ) {
+			
+					sieve_lexer_skip_token(lexer);
+				
+					if ( sieve_lexer_current_token(lexer) == STT_STRING ) {
+						/* Add the string to the list */
+						if ( !sieve_ast_stringlist_add
+							(arg, sieve_lexer_token_str(lexer), 
+								sieve_lexer_current_line(parser->lexer)) )
+							add_failed = TRUE;
+							
+						sieve_lexer_skip_token(lexer);
+					} else {
+						sieve_parser_error(parser, 
+							"expecting string after ',' in string list, but found %s",
+							sieve_lexer_token_string(lexer));
+					
+						result = sieve_parser_recover(parser, STT_RSQUARE);
+						break;
+					}
+				}
+				
+				if ( add_failed ) {
+					sieve_parser_error(parser, 
+						"failed to accept more items in string list");
+					return -1;
+				}
+			} else {
+				sieve_parser_error(parser, 
+					"expecting string after '[' in string list, but found %s",
+					sieve_lexer_token_string(lexer));
+			
+				result = sieve_parser_recover(parser, STT_RSQUARE);
+			}
+		
+			/* Finish the string list */
+			if ( sieve_lexer_current_token(lexer) == STT_RSQUARE ) {
+				sieve_lexer_skip_token(lexer);
+			} else {
+				sieve_parser_error(parser, 
+					"expecting ',' or end of string list ']', but found %s",
+					sieve_lexer_token_string(lexer));
+			
+				if ( (result=sieve_parser_recover(parser, STT_RSQUARE)) == TRUE ) 
+					sieve_lexer_skip_token(lexer);
+			}
+	
+			break;
+			
+		/* Single string */
+		case STT_STRING: 
+			arg = sieve_ast_argument_string_create
+				(node, sieve_lexer_token_str(lexer), 
+					sieve_lexer_current_line(parser->lexer));
+
+			sieve_lexer_skip_token(lexer);
+			break;
+		
+		/* Number */
+		case STT_NUMBER:
+			arg = sieve_ast_argument_number_create
+				(node, sieve_lexer_token_int(lexer), 
+					sieve_lexer_current_line(parser->lexer));
+			sieve_lexer_skip_token(lexer);
+			break;
+			
+		/* Tag */
+		case STT_TAG:
+			arg = sieve_ast_argument_tag_create
+				(node, sieve_lexer_token_ident(lexer), 
+					sieve_lexer_current_line(parser->lexer));
+			sieve_lexer_skip_token(lexer);
+			break;
+			
+		/* End of argument list, continue with tests */
+		default:
+			arg_present = FALSE;
+			break;
+		}
+
+		if ( arg_present && arg == NULL ) {
+			sieve_parser_error(parser, 
+				"failed to accept more arguments for command '%s'", node->identifier);
+			return -1;
+		}
+
+		if ( sieve_ast_argument_count(node) > SIEVE_MAX_COMMAND_ARGUMENTS ) {
+			sieve_parser_error(parser, 
+				"too many arguments for command '%s'", node->identifier);
+			return FALSE;
+		}
+	}
+	
+	if ( result <= 0 ) return result; /* Defer recovery to caller */
+	
+	/* --> [ test / test-list ] 
+ 	 * test-list = "(" test *("," test) ")"
+	 * test = identifier arguments
+	 */
+	switch ( sieve_lexer_current_token(lexer) ) {
+
+	/* Single test */
+	case STT_IDENTIFIER:
+		if ( depth+1 > SIEVE_MAX_TEST_NESTING ) {
+			sieve_parser_error(parser, 
+				"cannot nest tests deeper than %u levels",
+				SIEVE_MAX_TEST_NESTING);
+			return FALSE;
+		}
+
+		test = sieve_ast_test_create
+			(node, sieve_lexer_token_ident(lexer), 
+				sieve_lexer_current_line(parser->lexer));
+		sieve_lexer_skip_token(lexer);
+		
+		/* Theoretically, test can be NULL */
+		if ( test == NULL ) break;
+
+		/* Parse test arguments, which may include more tests (recurse) */
+		if ( !sieve_parse_arguments(parser, test, depth+1) ) {
+			return FALSE; /* Defer recovery to caller */
+		}
+		
+		break;
+		
+	/* Test list */
+	case STT_LBRACKET:	
+		sieve_lexer_skip_token(lexer);
+
+		if ( depth+1 > SIEVE_MAX_TEST_NESTING ) {
+			sieve_parser_error(parser, 
+				"cannot nest tests deeper than %u levels",
+				SIEVE_MAX_TEST_NESTING);
+			result = sieve_parser_recover(parser, STT_RBRACKET);
+
+			if ( result ) sieve_lexer_skip_token(lexer);
+			return result;
+		}
+
+		node->test_list = TRUE;
+		
+		/* Test starts with identifier */
+		if ( sieve_lexer_current_token(lexer) == STT_IDENTIFIER ) {
+			test = sieve_ast_test_create
+				(node, sieve_lexer_token_ident(lexer), 
+					sieve_lexer_current_line(parser->lexer));
+			sieve_lexer_skip_token(lexer);
+		
+			if ( test == NULL ) break;
+
+			/* Parse test arguments, which may include more tests (recurse) */
+			if ( (result=sieve_parse_arguments(parser, test, depth+1)) > 0 ) {
+			
+				/* More tests ? */
+				while ( sieve_lexer_current_token(lexer) == STT_COMMA && 
+					(parser->valid && sieve_errors_more_allowed(parser->ehandler)) ) {
+					sieve_lexer_skip_token(lexer);
+					
+					/* Test starts with identifier */
+					if ( sieve_lexer_current_token(lexer) == STT_IDENTIFIER ) {
+						test = sieve_ast_test_create
+							(node, sieve_lexer_token_ident(lexer), 
+								sieve_lexer_current_line(parser->lexer));
+						sieve_lexer_skip_token(lexer);
+
+						if ( test == NULL ) break;
+						
+						/* Parse test arguments, which may include more tests (recurse) */
+						if ( (result=sieve_parse_arguments(parser, test, depth+1)) <= 0 ) {
+							if ( result < 0 ) return result;
+
+							result = sieve_parser_recover(parser, STT_RBRACKET);
+							break;
+						}
+					} else {
+						sieve_parser_error(parser, 
+							"expecting test identifier after ',' in test list, but found %s",
+							sieve_lexer_token_string(lexer));
+										
+						result = sieve_parser_recover(parser, STT_RBRACKET);
+						break;
+					}
+				}
+
+				if ( test == NULL ) break;
+			} else { 
+				if ( result < 0 ) return result;
+
+				result = sieve_parser_recover(parser, STT_RBRACKET);
+			}
+		} else {
+			sieve_parser_error(parser, 
+				"expecting test identifier after '(' in test list, but found %s",
+				sieve_lexer_token_string(lexer));
+			
+			result = sieve_parser_recover(parser, STT_RBRACKET);
+		}
+		
+		/* The next token should be a ')', indicating the end of the test list
+		 *   --> previous sieve_parser_recover calls try to restore this situation 
+		 *       after parse errors.  
+		 */
+ 		if ( sieve_lexer_current_token(lexer) == STT_RBRACKET ) {
+			sieve_lexer_skip_token(lexer);
+		} else {
+			sieve_parser_error(parser, 
+				"expecting ',' or end of test list ')', but found %s",
+				sieve_lexer_token_string(lexer));
+			
+			/* Recover function tries to make next token equal to ')'. If it succeeds 
+			 * we need to skip it.
+			 */
+			if ( (result=sieve_parser_recover(parser, STT_RBRACKET)) == TRUE ) 
+				sieve_lexer_skip_token(lexer);
+		}
+		break;
+		
+	default:
+		/* Not an error: test / test-list is optional
+		 *   --> any errors are detected by the caller  
+		 */
+		test_present = FALSE;
+		break;
+	}
+
+	if ( test_present && test == NULL ) {
+		sieve_parser_error(parser, 
+			"failed to accept more tests for command '%s'", node->identifier);
+		return -1;
+	}			
+	
+	return result;
+}
+
+/* commands = *command
+ * command = identifier arguments ( ";" / block )
+ * block = "{" commands "}"
+ */
+static int sieve_parse_commands
+(struct sieve_parser *parser, struct sieve_ast_node *block, unsigned int depth) 
+{ 
+	struct sieve_lexer *lexer = parser->lexer;
+	int result = TRUE;
+
+	while ( result > 0 && 
+		sieve_lexer_current_token(lexer) == STT_IDENTIFIER && 
+		(parser->valid || sieve_errors_more_allowed(parser->ehandler)) ) {
+		struct sieve_ast_node *command = 
+			sieve_ast_command_create
+				(block, sieve_lexer_token_ident(lexer), 
+					sieve_lexer_current_line(parser->lexer));
+	
+		if ( command == NULL ) {
+			sieve_parser_error(parser, 
+				"failed to accept more commands inside the block of command '%s'", 
+				block->identifier);
+			return -1;
+		}
+
+		/* Defined state */
+		result = TRUE;		
+		
+		sieve_lexer_skip_token(lexer);
+		
+		result = sieve_parse_arguments(parser, command, 1);
+
+		/* Check whether the command is properly terminated 
+		 * (i.e. with ; or a new block) 
+		 */
+		if ( result > 0 &&
+			sieve_lexer_current_token(lexer) != STT_SEMICOLON &&
+			sieve_lexer_current_token(lexer) != STT_LCURLY ) {
+			
+			sieve_parser_error(parser, 
+				"expected end of command ';' or the beginning of a compound block '{', "
+				"but found %s",
+				sieve_lexer_token_string(lexer));	
+			result = FALSE;
+		}
+		
+		/* Try to recover from parse errors to reacquire a defined state */
+		if ( result == 0 ) {
+			result = sieve_parser_recover(parser, STT_SEMICOLON);
+		}
+
+		/* Don't bother to continue if we are not in a defined state */
+		if ( result <= 0 ) return result;
+			
+		switch ( sieve_lexer_current_token(lexer) ) {
+		
+		/* End of the command */
+		case STT_SEMICOLON:
+			sieve_lexer_skip_token(lexer);
+			break;
+
+		/* Command has a block {...} */		
+		case STT_LCURLY:
+			sieve_lexer_skip_token(lexer);
+			
+			/* Check current depth first */
+			if ( depth+1 > SIEVE_MAX_BLOCK_NESTING ) {
+				sieve_parser_error(parser, 
+					"cannot nest command blocks deeper than %u levels",
+					SIEVE_MAX_BLOCK_NESTING);
+				result = sieve_parser_recover(parser, STT_RCURLY);
+
+				if ( result > 0 )
+					sieve_lexer_skip_token(lexer);
+				break;
+			}
+
+			command->block = TRUE;
+			
+			if ( (result=sieve_parse_commands(parser, command, depth+1)) > 0 ) {
+			
+				if ( sieve_lexer_current_token(lexer) != STT_RCURLY ) {
+					sieve_parser_error(parser, 
+						"expected end of compound block '}', but found %s",
+						sieve_lexer_token_string(lexer));
+					result = sieve_parser_recover(parser, STT_RCURLY);				
+				} else 
+					sieve_lexer_skip_token(lexer);
+			} else {
+				if ( result < 0 ) return result;
+
+				if ( (result=sieve_parser_recover(parser, STT_RCURLY)) == 0 ) 
+					sieve_lexer_skip_token(lexer);
+			}
+
+			break;
+			
+		default:
+			/* Recovered previously, so this cannot happen */
+			i_unreached();
+		}
+	}
+
+	return result;
+}
+
+bool sieve_parser_run
+(struct sieve_parser *parser, struct sieve_ast **ast) 
+{
+	if ( parser->ast != NULL )
+		sieve_ast_unref(&parser->ast);
+	
+	/* Create AST object if none is provided */
+	if ( *ast == NULL )
+		*ast = sieve_ast_create(parser->script);
+	else 
+		sieve_ast_ref(*ast);
+		
+	parser->ast = *ast;
+
+	/* Scan first token */
+	sieve_lexer_skip_token(parser->lexer);
+
+	/* Parse */
+	if ( sieve_parse_commands(parser, sieve_ast_root(parser->ast), 1) > 0 && 
+		parser->valid ) {
+		 
+		/* Parsed right to EOF ? */
+		if ( sieve_lexer_current_token(parser->lexer) != STT_EOF ) { 
+			sieve_parser_error(parser, 
+				"unexpected %s found at (the presumed) end of file",
+				sieve_lexer_token_string(parser->lexer));
+			parser->valid = FALSE;
+		}
+	} else parser->valid = FALSE;
+	
+	/* Clean up AST if parse failed */
+	if ( !parser->valid ) {
+		parser->ast = NULL;
+		sieve_ast_unref(ast);
+	}
+	
+	return parser->valid;
+}	
+
+/* Error recovery:
+ *   To continue parsing after an error it is important to find the next 
+ *   parsible item in the stream. The recover function skips over the remaining 
+ *   garbage after an error. It tries  to find the end of the failed syntax 
+ *   structure and takes nesting of structures into account. 
+ */
+
+/* Assign useful names to priorities for readability */ 
+enum sieve_grammatical_prio {
+	SGP_BLOCK = 3,
+	SGP_COMMAND = 2,
+	SGP_TEST_LIST = 1,
+	SGP_STRING_LIST = 0,
+  
+	SGP_OTHER = -1
+};
+
+static inline enum sieve_grammatical_prio __get_token_priority
+(enum sieve_token_type token) 
+{
+	switch ( token ) {
+	case STT_LCURLY:
+	case STT_RCURLY: 
+		return SGP_BLOCK;
+	case STT_SEMICOLON: 
+		return SGP_COMMAND;
+	case STT_LBRACKET:
+	case STT_RBRACKET: 
+		return SGP_TEST_LIST;
+	case STT_LSQUARE:
+	case STT_RSQUARE: 
+		return SGP_STRING_LIST;
+	default:
+		break;
+	}
+	
+	return SGP_OTHER;
+}
+
+static int sieve_parser_recover
+(struct sieve_parser *parser, enum sieve_token_type end_token) 
+{
+	/* The tokens that begin/end a specific block/command/list in order 
+ 	 * of ascending grammatical priority.
+ 	 */ 
+ 	static const enum sieve_token_type begin_tokens[4] = 
+ 		{ STT_LSQUARE, STT_LBRACKET, STT_NONE, STT_LCURLY };
+	static const enum sieve_token_type end_tokens[4] = 
+		{ STT_RSQUARE, STT_RBRACKET, STT_SEMICOLON, STT_RCURLY};
+
+	struct sieve_lexer *lexer = parser->lexer;
+	int nesting = 1;
+	enum sieve_grammatical_prio end_priority = __get_token_priority(end_token);
+			
+	i_assert( end_priority != SGP_OTHER );
+			
+	while ( sieve_lexer_current_token(lexer) != STT_EOF && 
+		__get_token_priority(sieve_lexer_current_token(lexer)) <= end_priority ) {
+			
+		if ( sieve_lexer_current_token(lexer) == begin_tokens[end_priority] ) {
+			nesting++;
+			sieve_lexer_skip_token(lexer);
+			continue;
+		}
+		
+		if ( sieve_lexer_current_token(lexer) == end_tokens[end_priority] ) {
+			nesting--;
+
+			if ( nesting == 0 ) {
+				/* Next character is the end */
+				return TRUE; 
+			}
+		}
+		
+		sieve_lexer_skip_token(lexer);
+	}
+	
+	/* Special case: COMMAND */
+	if (end_token == STT_SEMICOLON && 
+		sieve_lexer_current_token(lexer) == STT_LCURLY)
+		return TRUE;
+	
+	/* End not found before eof or end of surrounding grammatical structure 
+	 */
+	return FALSE; 
+}
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-parser.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-parser.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-parser.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-parser.h	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,18 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+ 
+#ifndef __SIEVE_PARSER_H
+#define __SIEVE_PARSER_H
+
+#include "lib.h"
+
+#include "sieve-common.h"
+
+struct sieve_parser;
+
+struct sieve_parser *sieve_parser_create
+	(struct sieve_script *script, struct sieve_error_handler *ehandler);
+void sieve_parser_free(struct sieve_parser **parser);
+bool sieve_parser_run(struct sieve_parser *parser, struct sieve_ast **ast);
+
+#endif /* __SIEVE_PARSER_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-result.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-result.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-result.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-result.c	2009-08-02 10:21:02.000000000 +0200
@@ -0,0 +1,1199 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#include "lib.h"
+#include "mempool.h"
+#include "ostream.h"
+#include "hash.h"
+#include "str.h"
+#include "strfuncs.h"
+#include "str-sanitize.h"
+
+#include "sieve-common.h"
+#include "sieve-limits.h"
+#include "sieve-script.h"
+#include "sieve-error.h"
+#include "sieve-interpreter.h"
+#include "sieve-actions.h"
+#include "sieve-message.h"
+
+#include "sieve-result.h"
+
+#include <stdio.h>
+
+/*
+ * Types
+ */
+ 
+struct sieve_result_action {
+	struct sieve_result *result;
+	struct sieve_action_data data;
+	
+	void *tr_context;
+	bool success;
+	
+	bool keep;
+
+	struct sieve_side_effects_list *seffects;
+	
+	struct sieve_result_action *prev, *next; 
+};
+
+struct sieve_side_effects_list {
+	struct sieve_result *result;
+
+	struct sieve_result_side_effect *first_effect;
+	struct sieve_result_side_effect *last_effect;
+};
+
+struct sieve_result_side_effect {
+	const struct sieve_side_effect *seffect;
+	void *context;
+	struct sieve_result_side_effect *prev, *next; 
+};
+
+struct sieve_result_action_context {
+	const struct sieve_action *action;
+	struct sieve_side_effects_list *seffects;
+};
+
+/*
+ * Result object
+ */
+
+struct sieve_result {
+	pool_t pool;
+	int refcount;
+
+	/* Context data for extensions */
+	ARRAY_DEFINE(ext_contexts, void *); 
+
+	struct sieve_error_handler *ehandler;
+		
+	struct sieve_action_exec_env action_env;
+	
+	const struct sieve_action *keep_action;
+	const struct sieve_action *failure_action;
+
+	unsigned int action_count;
+	struct sieve_result_action *first_action;
+	struct sieve_result_action *last_action;
+	
+	struct sieve_result_action *last_attempted_action;
+	
+	struct hash_table *action_contexts;
+};
+
+struct sieve_result *sieve_result_create
+(const struct sieve_message_data *msgdata, const struct sieve_script_env *senv,
+	struct sieve_error_handler *ehandler)
+{
+	pool_t pool;
+	struct sieve_result *result;
+	 
+	pool = pool_alloconly_create("sieve_result", 4096);	
+	result = p_new(pool, struct sieve_result, 1);
+	result->refcount = 1;
+	result->pool = pool;
+	
+	p_array_init(&result->ext_contexts, pool, 4);
+
+	if ( ehandler != NULL )
+		sieve_error_handler_ref(ehandler);	
+	result->ehandler = ehandler;
+
+	result->action_env.result = result;
+	result->action_env.scriptenv = senv;
+	result->action_env.msgdata = msgdata;
+	result->action_env.msgctx = sieve_message_context_create(msgdata); 
+		
+	result->keep_action = &act_store;
+	result->failure_action = &act_store;
+	
+	result->action_count = 0;
+	result->first_action = NULL;
+	result->last_action = NULL;
+
+	result->action_contexts = NULL;
+	return result;
+}
+
+void sieve_result_ref(struct sieve_result *result) 
+{
+	result->refcount++;
+}
+
+void sieve_result_unref(struct sieve_result **result) 
+{
+	i_assert((*result)->refcount > 0);
+
+	if (--(*result)->refcount != 0)
+		return;
+
+	sieve_message_context_unref(&(*result)->action_env.msgctx);
+
+	if ( (*result)->action_contexts != NULL )
+        hash_table_destroy(&(*result)->action_contexts);
+
+	if ( (*result)->ehandler != NULL )
+		sieve_error_handler_unref(&(*result)->ehandler);
+
+	pool_unref(&(*result)->pool);
+
+ 	*result = NULL;
+}
+
+pool_t sieve_result_pool(struct sieve_result *result)
+{
+	return result->pool;
+}
+
+/*
+ * Getters/Setters
+ */
+
+struct sieve_error_handler *sieve_result_get_error_handler
+(struct sieve_result *result)
+{
+	return result->ehandler;
+}
+const struct sieve_script_env *sieve_result_get_script_env
+(struct sieve_result *result)
+{
+    return result->action_env.scriptenv;
+}
+
+const struct sieve_message_data *sieve_result_get_message_data
+(struct sieve_result *result)
+{
+	return result->action_env.msgdata;
+}
+
+struct sieve_message_context *sieve_result_get_message_context
+(struct sieve_result *result)
+{
+	return result->action_env.msgctx;
+}
+
+void sieve_result_set_error_handler
+(struct sieve_result *result, struct sieve_error_handler *ehandler)
+{
+	if ( result->ehandler != ehandler ) {
+		sieve_error_handler_ref(ehandler);
+		sieve_error_handler_unref(&result->ehandler);
+		result->ehandler = ehandler;
+	}
+}
+
+/*
+ * Extension support
+ */
+
+void sieve_result_extension_set_context
+(struct sieve_result *result, const struct sieve_extension *ext, void *context)
+{
+	array_idx_set(&result->ext_contexts, (unsigned int) SIEVE_EXT_ID(ext), 
+		&context);	
+}
+
+const void *sieve_result_extension_get_context
+(struct sieve_result *result, const struct sieve_extension *ext) 
+{
+	int ext_id = SIEVE_EXT_ID(ext);
+	void * const *ctx;
+
+	if  ( ext_id < 0 || ext_id >= (int) array_count(&result->ext_contexts) )
+		return NULL;
+	
+	ctx = array_idx(&result->ext_contexts, (unsigned int) ext_id);		
+
+	return *ctx;
+}
+
+/* 
+ * Error handling 
+ */
+
+void sieve_result_error
+	(const struct sieve_action_exec_env *aenv, const char *fmt, ...)
+{
+	va_list args;
+	
+	if ( aenv->result->ehandler == NULL ) return;
+
+	va_start(args, fmt);	
+	sieve_verror(aenv->result->ehandler, sieve_action_get_location(aenv), fmt, 
+		args); 
+	va_end(args);
+}
+
+void sieve_result_warning
+	(const struct sieve_action_exec_env *aenv, const char *fmt, ...)
+{
+	va_list args;
+
+	if ( aenv->result->ehandler == NULL ) return;
+	
+	va_start(args, fmt);	
+	sieve_vwarning(aenv->result->ehandler, sieve_action_get_location(aenv), fmt, 
+		args); 
+	va_end(args);
+}
+
+void sieve_result_log
+	(const struct sieve_action_exec_env *aenv, const char *fmt, ...)
+{
+	va_list args;
+	
+	if ( aenv->result->ehandler == NULL ) return;
+
+	va_start(args, fmt);	
+	sieve_vinfo(aenv->result->ehandler, sieve_action_get_location(aenv), fmt, 
+		args); 
+	va_end(args);
+}
+
+/* 
+ * Result composition 
+ */
+
+void sieve_result_add_implicit_side_effect
+(struct sieve_result *result, const struct sieve_action *to_action, 
+	const struct sieve_side_effect *seffect, void *context)
+{
+	struct sieve_result_action_context *actctx = NULL;
+	
+	if ( result->action_contexts == NULL ) {
+		result->action_contexts = hash_table_create
+			(default_pool, result->pool, 0, NULL, NULL);
+	} else {
+		actctx = (struct sieve_result_action_context *) 
+			hash_table_lookup(result->action_contexts, to_action);
+	}
+
+	if ( actctx == NULL ) {
+		actctx = p_new
+			(result->pool, struct sieve_result_action_context, 1);
+		actctx->action = to_action;
+		actctx->seffects = sieve_side_effects_list_create(result);
+		
+		hash_table_insert(result->action_contexts, (void *) to_action, 
+			(void *) actctx);
+	}	
+	
+	sieve_side_effects_list_add(actctx->seffects, seffect, context);
+}
+
+static int sieve_result_side_effects_merge
+(const struct sieve_runtime_env *renv, const struct sieve_action *action, 
+	struct sieve_side_effects_list *old_seffects,
+	struct sieve_side_effects_list *new_seffects)
+{
+	int ret;
+	struct sieve_result_side_effect *rsef, *nrsef;
+
+	/* Allow side-effects to merge with existing copy */
+		
+	/* Merge existing side effects */
+	rsef = old_seffects != NULL ? old_seffects->first_effect : NULL;
+	while ( rsef != NULL ) {
+		const struct sieve_side_effect *seffect = rsef->seffect;
+		bool found = FALSE;
+		
+		if ( seffect->merge != NULL ) {
+
+			/* Try to find it among the new */
+			nrsef = new_seffects != NULL ? new_seffects->first_effect : NULL;
+			while ( nrsef != NULL ) {
+				if ( nrsef->seffect == seffect ) {
+					if ( seffect->merge
+						(renv, action, seffect, &rsef->context, nrsef->context) < 0 )
+						return -1;
+			
+					found = TRUE;
+					break;
+				}
+		
+				nrsef = nrsef->next;
+			}
+	
+			/* Not found? */
+			if ( !found && seffect->merge
+				(renv, action, seffect, &rsef->context, NULL) < 0 )
+				return -1;
+		}
+	
+		rsef = rsef->next;
+	}
+
+	/* Merge new Side effects */
+	nrsef = new_seffects != NULL ? new_seffects->first_effect : NULL;
+	while ( nrsef != NULL ) {
+		const struct sieve_side_effect *seffect = nrsef->seffect;
+		bool found = FALSE;
+		
+		if ( seffect->merge != NULL ) {
+		
+			/* Try to find it among the exising */
+			rsef = old_seffects != NULL ? old_seffects->first_effect : NULL;
+			while ( rsef != NULL ) {
+				if ( rsef->seffect == seffect ) {
+					found = TRUE;
+					break;
+				}
+				rsef = rsef->next;
+			}
+	
+			/* Not found? */
+			if ( !found ) {
+				void *new_context = NULL; 
+		
+				if ( (ret=seffect->merge
+					(renv, action, seffect, &new_context, nrsef->context)) < 0 ) 
+					return -1;
+					
+				if ( ret != 0 ) {
+					/* Add side effect */
+					sieve_side_effects_list_add(old_seffects, seffect, new_context);
+				}
+			}
+		}
+	
+		nrsef = nrsef->next;
+	}
+	
+	return 1;
+}
+
+static void sieve_result_action_detach(struct sieve_result_action *raction)
+{
+	struct sieve_result *result = raction->result;
+	
+	if ( result->first_action == raction ) 
+		result->first_action = raction->next;
+		
+	if ( result->last_action == raction ) 
+		result->last_action = raction->prev;
+		
+	if ( raction->next != NULL ) raction->next->prev = raction->prev;
+	if ( raction->prev != NULL ) raction->prev->next = raction->next;
+	
+	raction->next = NULL;
+	raction->prev = NULL;
+	
+	if ( result->action_count > 0 )
+		result->action_count--;
+}
+
+static int _sieve_result_add_action
+(const struct sieve_runtime_env *renv,
+	const struct sieve_action *action, struct sieve_side_effects_list *seffects,
+	unsigned int source_line, void *context, unsigned int instance_limit, 
+	bool keep)		
+{
+	int ret = 0;
+	unsigned int instance_count = 0;
+	struct sieve_result *result = renv->result;
+	struct sieve_result_action *raction = NULL, *kaction = NULL;
+	struct sieve_action_data act_data;
+			
+	act_data.action = action;
+	act_data.location = sieve_error_script_location(renv->script, source_line);
+	act_data.context = context;
+	act_data.executed = FALSE;
+		
+	/* First, check for duplicates or conflicts */
+	raction = result->first_action;
+	while ( raction != NULL ) {
+		const struct sieve_action *oact = raction->data.action;
+		
+		if ( keep && raction->keep ) {
+		
+			/* Duplicate keep */
+			if ( raction->data.executed ) {
+				/* Keep action from preceeding execution */
+			
+				/* Detach existing keep action */
+				sieve_result_action_detach(raction);
+
+				/* Merge existing side-effects with new keep action */
+				if ( kaction == NULL )
+					kaction = raction;
+			
+				if ( (ret=sieve_result_side_effects_merge
+					(renv, action, kaction->seffects, seffects)) <= 0 )	 
+					return ret;				
+			} else {
+				/* True duplicate */
+				
+				return sieve_result_side_effects_merge
+					(renv, action, raction->seffects, seffects);
+			}
+			
+		} if ( raction->data.action == action ) {
+			instance_count++;
+
+			/* Possible duplicate */
+			if ( action->check_duplicate != NULL ) {
+				if ( (ret=action->check_duplicate(renv, &act_data, &raction->data)) 
+					< 0 )
+					return ret;
+				
+				/* Duplicate */	
+				if ( ret == 1 ) {
+					if ( keep && !raction->keep ) {
+						/* New keep has higher precedence than existing duplicate non-keep 
+						 * action. So, take over the result action object and transform it
+						 * into a keep.
+						 */
+						 
+						if ( (ret=sieve_result_side_effects_merge
+							(renv, action, raction->seffects, seffects)) < 0 ) 
+							return ret;
+						 
+						if ( kaction == NULL ) {								
+							raction->data.context = NULL;
+							raction->data.location = p_strdup(result->pool, act_data.location);
+							
+							/* Note that existing execution status is retained, making sure 
+							 * that keep is not executed multiple times.
+							 */
+							
+							kaction = raction;
+												
+						} else {
+							sieve_result_action_detach(raction);
+
+							if ( (ret=sieve_result_side_effects_merge
+								(renv, action, kaction->seffects, raction->seffects)) < 0 ) 
+								return ret;
+						}
+					} else {
+						/* Merge side-effects, but don't add new action */
+						return sieve_result_side_effects_merge
+							(renv, action, raction->seffects, seffects);
+					}
+				}
+			}
+		} else {
+			if ( action != NULL && oact != NULL ) {
+				/* Check conflict */
+				if ( action->check_conflict != NULL &&
+					(ret=action->check_conflict(renv, &act_data, &raction->data)) != 0 ) 
+					return ret;
+			
+				if ( !raction->data.executed && oact->check_conflict != NULL &&
+					(ret=oact->check_conflict(renv, &raction->data, &act_data)) != 0 )
+					return ret;
+			}
+		}
+		raction = raction->next;
+	}
+
+	/* Check policy limit on total number of actions */
+	if ( sieve_max_actions > 0 && result->action_count >= sieve_max_actions ) {
+		sieve_runtime_error(renv, act_data.location, 
+			"total number of actions exceeds policy limit");
+		return -1;
+	}
+
+	/* Check policy limit on number of this class of actions */
+	if ( instance_limit > 0 && instance_count >= instance_limit ) {
+		sieve_runtime_error(renv, act_data.location, 
+			"number of %s actions exceeds policy limit", action->name);
+		return -1;
+	}	
+		
+	if ( kaction != NULL )
+		/* Use existing keep action to define new one */
+		raction = kaction;
+	else {
+		/* Create new action object */
+		raction = p_new(result->pool, struct sieve_result_action, 1);
+		raction->data.executed = FALSE;
+		raction->result = result;
+		raction->seffects = seffects;
+		raction->tr_context = NULL;
+		raction->success = FALSE;
+	}
+	
+	raction->data.context =	context;
+	raction->data.action = action;
+	raction->data.location = p_strdup(result->pool, act_data.location);
+	raction->keep = keep;
+
+	if ( raction->prev == NULL ) {
+		/* Add */
+		if ( result->first_action == NULL ) {
+			result->first_action = raction;
+			result->last_action = raction;
+			raction->prev = NULL;
+			raction->next = NULL;
+		} else {
+			result->last_action->next = raction;
+			raction->prev = result->last_action;
+			result->last_action = raction;
+			raction->next = NULL;
+		}
+		result->action_count++;
+	
+		/* Apply any implicit side effects */
+		if ( result->action_contexts != NULL ) {
+			struct sieve_result_action_context *actctx;
+		
+			/* Check for implicit side effects to this particular action */
+			actctx = (struct sieve_result_action_context *) 
+					hash_table_lookup(result->action_contexts, action);
+		
+			if ( actctx != NULL ) {
+				struct sieve_result_side_effect *iseff;
+			
+				/* Iterate through all implicit side effects and add those that are 
+				 * missing.
+				 */
+				iseff = actctx->seffects->first_effect;
+				while ( iseff != NULL ) {
+					struct sieve_result_side_effect *seff;
+					bool exists = FALSE;
+				
+					/* Scan for presence */
+					if ( seffects != NULL ) {
+						seff = seffects->first_effect;
+						while ( seff != NULL ) {
+							if ( seff->seffect == iseff->seffect ) {
+								exists = TRUE;
+								break;
+							}
+					
+							seff = seff->next;
+						}
+					} else {
+						raction->seffects = seffects = 
+							sieve_side_effects_list_create(result);
+					}
+				
+					/* If not present, add it */
+					if ( !exists ) {
+						sieve_side_effects_list_add
+							(seffects, iseff->seffect, iseff->context);
+					}
+				
+					iseff = iseff->next;
+				}
+			}
+		}
+	}
+	
+	return 0;
+}
+
+int sieve_result_add_action
+(const struct sieve_runtime_env *renv,
+	const struct sieve_action *action, struct sieve_side_effects_list *seffects,
+	unsigned int source_line, void *context, unsigned int instance_limit)
+{
+	return _sieve_result_add_action
+		(renv, action, seffects, source_line, context, instance_limit, FALSE);
+}
+
+int sieve_result_add_keep
+(const struct sieve_runtime_env *renv, struct sieve_side_effects_list *seffects,
+	unsigned int source_line)
+{
+	return _sieve_result_add_action
+		(renv, renv->result->keep_action, seffects, source_line, NULL, 0, TRUE);
+}
+
+void sieve_result_set_keep_action
+(struct sieve_result *result, const struct sieve_action *action)
+{
+	result->keep_action = action;
+}
+
+void sieve_result_set_failure_action
+(struct sieve_result *result, const struct sieve_action *action)
+{
+	result->failure_action = action;
+}
+
+/*
+ * Result printing
+ */
+
+void sieve_result_vprintf
+(const struct sieve_result_print_env *penv, const char *fmt, va_list args)
+{	
+	string_t *outbuf = t_str_new(128);
+
+	str_vprintfa(outbuf, fmt, args);
+	
+	o_stream_send(penv->stream, str_data(outbuf), str_len(outbuf));
+}
+
+void sieve_result_printf
+(const struct sieve_result_print_env *penv, const char *fmt, ...)
+{	
+	va_list args;
+	
+	va_start(args, fmt);	
+	sieve_result_vprintf(penv, fmt, args);
+	va_end(args);	
+}
+
+void sieve_result_action_printf
+(const struct sieve_result_print_env *penv, const char *fmt, ...)
+{	
+	string_t *outbuf = t_str_new(128);
+	va_list args;
+	
+	va_start(args, fmt);	
+	str_append(outbuf, " * ");
+	str_vprintfa(outbuf, fmt, args);
+	str_append_c(outbuf, '\n');
+	va_end(args);
+	
+	o_stream_send(penv->stream, str_data(outbuf), str_len(outbuf));
+}
+
+void sieve_result_seffect_printf
+(const struct sieve_result_print_env *penv, const char *fmt, ...)
+{	
+	string_t *outbuf = t_str_new(128);
+	va_list args;
+	
+	va_start(args, fmt);	
+	str_append(outbuf, "        + ");
+	str_vprintfa(outbuf, fmt, args);
+	str_append_c(outbuf, '\n');
+	va_end(args);
+	
+	o_stream_send(penv->stream, str_data(outbuf), str_len(outbuf));
+}
+
+static void sieve_result_print_side_effect
+(struct sieve_result_print_env *rpenv, const struct sieve_action *action,
+	struct sieve_side_effects_list *slist, bool *implicit_keep)
+{
+	struct sieve_result_side_effect *rsef;
+	const struct sieve_side_effect *sef;
+	
+	/* Print side effects */
+	rsef = slist != NULL ? slist->first_effect : NULL;
+	while ( rsef != NULL ) {
+		sef = rsef->seffect;
+		if ( sef->print != NULL ) 
+			sef->print(sef, action, rpenv, rsef->context, implicit_keep);
+		rsef = rsef->next;
+	}
+}
+
+bool sieve_result_print
+(struct sieve_result *result, const struct sieve_script_env *senv, 
+	struct ostream *stream, bool *keep)
+{
+	const struct sieve_action *act_keep = result->keep_action;
+	struct sieve_result_print_env penv;
+	bool implicit_keep = TRUE;
+	struct sieve_result_action *rac, *first_action;
+	
+	first_action = ( result->last_attempted_action == NULL ?
+		result->first_action : result->last_attempted_action->next );
+	
+	if ( keep != NULL ) *keep = FALSE;
+	
+	/* Prepare environment */
+	
+	penv.result = result;
+	penv.stream = stream;
+	penv.scriptenv = senv;
+	
+	sieve_result_printf(&penv, "\nPerformed actions:\n\n");
+	
+	if ( first_action == NULL ) {
+		sieve_result_printf(&penv, "  (none)\n");
+	} else {		
+		rac = first_action;
+		while ( rac != NULL ) {		
+			bool impl_keep = TRUE;
+			const struct sieve_action *act = rac->data.action;
+
+			if ( rac->keep && keep != NULL ) *keep = TRUE;
+
+			if ( act != NULL ) {
+				if ( act->print != NULL )
+					act->print(act, &penv, rac->data.context, &impl_keep);
+				else
+					sieve_result_action_printf(&penv, "%s", act->name); 
+			} else {
+				if ( rac->keep ) {
+					sieve_result_action_printf(&penv, "keep");
+					impl_keep = FALSE;
+				} else {
+					sieve_result_action_printf(&penv, "[NULL]");
+				}
+			}
+	
+			/* Print side effects */
+			sieve_result_print_side_effect
+				(&penv, rac->data.action, rac->seffects, &impl_keep);
+			
+			implicit_keep = implicit_keep && impl_keep;		
+		
+			rac = rac->next;	
+		}
+	}
+	
+	if ( implicit_keep && keep != NULL ) *keep = TRUE;
+		
+	sieve_result_printf(&penv, "\nImplicit keep:\n\n");
+		
+	if ( implicit_keep ) {
+		bool dummy = TRUE;
+			
+		if ( act_keep == NULL ) 
+			sieve_result_action_printf(&penv, "keep");
+		else {
+			/* Scan for execution of keep-equal actions */	
+			rac = result->first_action;
+			while ( act_keep != NULL && rac != NULL ) {
+				if ( rac->data.action == act_keep && act_keep->equals != NULL && 
+					act_keep->equals(senv, NULL, rac->data.context) 
+						&& rac->data.executed ) {
+					act_keep = NULL;
+				}
+	 		
+				rac = rac->next;	
+			}
+			
+			if ( act_keep == NULL ) {
+				sieve_result_printf(&penv, 
+					"  (none; keep or equivalent action executed earlier)\n");
+			} else {
+				act_keep->print(act_keep, &penv, NULL, &dummy);
+			
+				/* Apply any implicit side effects if applicable */
+				if ( result->action_contexts != NULL ) {
+					struct sieve_result_action_context *actctx;
+		
+					/* Check for implicit side effects to keep action */
+					actctx = (struct sieve_result_action_context *) 
+							hash_table_lookup(result->action_contexts, act_keep);
+		
+					if ( actctx != NULL && actctx->seffects != NULL ) 
+						sieve_result_print_side_effect
+							(&penv, act_keep, actctx->seffects, &dummy);
+				}
+			}
+		}
+	} else 
+		sieve_result_printf(&penv, "  (none)\n");
+	
+	sieve_result_printf(&penv, "\n");
+	
+	return TRUE;
+}
+
+/*
+ * Result execution
+ */
+
+static bool _sieve_result_implicit_keep
+	(struct sieve_result *result, bool rollback)
+{	
+	struct sieve_result_action *rac;
+	bool success = TRUE;
+	bool dummy = TRUE;
+	struct sieve_result_side_effect *rsef, *rsef_first = NULL;
+	void *tr_context = NULL;
+	const struct sieve_action *act_keep;
+	
+	if ( rollback )
+		act_keep = result->failure_action;
+	else 
+		act_keep = result->keep_action;
+	
+	/* If keep is a non-action, return right away */
+	if ( act_keep == NULL ) return TRUE; 
+
+	/* Scan for execution of keep-equal actions */	
+	rac = result->first_action;
+	while ( rac != NULL ) {
+		if ( rac->data.action == act_keep && act_keep->equals != NULL && 
+			act_keep->equals(result->action_env.scriptenv, NULL, rac->data.context) &&
+			rac->data.executed )
+			return TRUE;
+ 		
+		rac = rac->next;	
+	}
+	
+	/* Apply any implicit side effects if applicable */
+	if ( !rollback && result->action_contexts != NULL ) {
+		struct sieve_result_action_context *actctx;
+		
+		/* Check for implicit side effects to keep action */
+		actctx = (struct sieve_result_action_context *) 
+				hash_table_lookup(result->action_contexts, act_keep);
+		
+		if ( actctx != NULL && actctx->seffects != NULL ) 
+			rsef_first = actctx->seffects->first_effect;
+	}
+	
+	/* Start keep action */
+	if ( act_keep->start != NULL ) 
+		success = act_keep->start
+			(act_keep, &result->action_env, NULL, &tr_context);
+
+	/* Execute keep action */
+	if ( success ) {
+		rsef = rsef_first;
+		while ( success && rsef != NULL ) {
+			const struct sieve_side_effect *sef = rsef->seffect;
+			if ( sef->pre_execute != NULL ) 
+				success = success && sef->pre_execute
+					(sef, act_keep, &result->action_env, &rsef->context, tr_context);
+			rsef = rsef->next;
+		}
+
+		if ( act_keep->execute != NULL )
+			success = success && act_keep->execute
+				(act_keep, &result->action_env, tr_context);
+
+		rsef = rsef_first;
+		while ( success && rsef != NULL ) {
+			const struct sieve_side_effect *sef = rsef->seffect;
+			if ( sef->post_execute != NULL ) 
+				success = success && sef->post_execute
+					(sef, act_keep, &result->action_env, rsef->context, tr_context);
+			rsef = rsef->next;
+		}
+	}
+	
+	/* Finish keep action */
+	if ( success ) {
+		if ( act_keep->commit != NULL ) 
+			success = act_keep->commit
+				(act_keep, &result->action_env, tr_context, &dummy);
+
+		rsef = rsef_first;
+		while ( rsef != NULL ) {
+			const struct sieve_side_effect *sef = rsef->seffect;
+			bool keep = TRUE;
+			
+			if ( sef->post_commit != NULL ) 
+				sef->post_commit
+					(sef, act_keep, &result->action_env, rsef->context, tr_context, 
+						&keep);
+			rsef = rsef->next;
+		}
+			
+		return success; 
+	}
+	
+	/* Failed, rollback */
+	if ( act_keep->rollback != NULL )
+		act_keep->rollback(act_keep, &result->action_env, tr_context, success);
+
+	return FALSE;
+}
+
+bool sieve_result_implicit_keep
+(struct sieve_result *result)
+{
+	const struct sieve_script_env *senv = result->action_env.scriptenv;
+	struct sieve_exec_status dummy_status;
+
+	result->action_env.exec_status = 
+		( senv->exec_status == NULL ? &dummy_status : senv->exec_status );
+
+	return _sieve_result_implicit_keep(result, TRUE);	
+}
+
+void sieve_result_mark_executed(struct sieve_result *result)
+{
+	struct sieve_result_action *first_action, *rac;
+	
+	first_action = ( result->last_attempted_action == NULL ?
+		result->first_action : result->last_attempted_action->next );
+	result->last_attempted_action = result->last_action;
+
+	rac = first_action;
+	while ( rac != NULL ) {
+		if ( rac->data.action != NULL )
+			rac->data.executed = TRUE;
+ 		
+		rac = rac->next;	
+	}
+}
+
+int sieve_result_execute
+(struct sieve_result *result, bool *keep)
+{
+	const struct sieve_script_env *senv = result->action_env.scriptenv;
+	struct sieve_exec_status dummy_status;
+	bool implicit_keep = TRUE;
+	bool success = TRUE, commit_ok;
+	struct sieve_result_action *rac, *first_action;
+	struct sieve_result_action *last_attempted;
+
+	if ( keep != NULL ) *keep = FALSE;
+
+	/* Prepare environment */
+
+	result->action_env.exec_status = 
+		( senv->exec_status == NULL ? &dummy_status : senv->exec_status );
+	
+	/* Make notice of this attempt */
+	
+	first_action = ( result->last_attempted_action == NULL ?
+		result->first_action : result->last_attempted_action->next );
+	result->last_attempted_action = result->last_action;
+		
+	/* 
+	 * Transaction start 
+	 */
+	
+	rac = first_action;
+	while ( success && rac != NULL ) {
+		const struct sieve_action *act = rac->data.action;
+	
+		/* Skip non-actions (inactive keep) and executed ones */
+		if ( act == NULL || rac->data.executed ) {
+			rac = rac->next;	
+			continue;
+		}
+	
+		if ( act->start != NULL ) {
+			rac->success = act->start(act, &result->action_env, rac->data.context, 
+				&rac->tr_context);
+			success = success && rac->success;
+		} else {
+			rac->tr_context = rac->data.context;
+		}
+ 
+		rac = rac->next;	
+	}
+	
+	/* 
+	 * Transaction execute 
+	 */
+	
+	last_attempted = rac;
+	rac = first_action;
+	while ( success && rac != NULL ) {
+		const struct sieve_action *act = rac->data.action;
+		struct sieve_result_side_effect *rsef;
+		const struct sieve_side_effect *sef;
+		
+		/* Skip non-actions (inactive keep) and executed ones */
+		if ( act == NULL || rac->data.executed ) {
+			rac = rac->next;	
+			continue;
+		}
+				
+		/* Execute pre-execute event of side effects */
+		rsef = rac->seffects != NULL ? rac->seffects->first_effect : NULL;
+		while ( success && rsef != NULL ) {
+			sef = rsef->seffect;
+			if ( sef->pre_execute != NULL ) 
+				success = success & sef->pre_execute
+					(sef, act, &result->action_env, &rsef->context, rac->tr_context);
+			rsef = rsef->next;
+		}
+	
+		/* Execute the action itself */
+		if ( success && act->execute != NULL ) {
+			rac->success = act->execute(act, &result->action_env, rac->tr_context);
+			success = success && rac->success;
+		}
+		
+		/* Execute post-execute event of side effects */
+		rsef = rac->seffects != NULL ? rac->seffects->first_effect : NULL;
+		while ( success && rsef != NULL ) {
+			sef = rsef->seffect;
+			if ( sef->post_execute != NULL ) 
+				success = success && sef->post_execute
+					(sef, act, &result->action_env, rsef->context, rac->tr_context);
+			rsef = rsef->next;
+		}
+		 
+		rac = rac->next;	
+	}
+	
+	/* 
+	 * Transaction commit/rollback 
+	 */
+
+	commit_ok = success;
+	rac = first_action;
+	while ( rac != NULL && rac != last_attempted ) {
+		const struct sieve_action *act = rac->data.action;
+		struct sieve_result_side_effect *rsef;
+		const struct sieve_side_effect *sef;
+		
+		if ( success ) {
+			bool impl_keep = TRUE;
+			
+			if ( rac->keep && keep != NULL ) *keep = TRUE;
+
+			/* Skip non-actions (inactive keep) and executed ones */
+			if ( act == NULL || rac->data.executed ) {
+				rac = rac->next;	
+				continue;
+			}
+			
+			if ( act->commit != NULL ) { 
+				rac->data.executed = act->commit
+					(act, &result->action_env, rac->tr_context, &impl_keep);
+				commit_ok = rac->data.executed && commit_ok;
+			}
+	
+			/* Execute post_commit event of side effects */
+			rsef = rac->seffects != NULL ? rac->seffects->first_effect : NULL;
+			while ( rsef != NULL ) {
+				sef = rsef->seffect;
+				if ( sef->post_commit != NULL ) 
+					sef->post_commit
+						(sef, act, &result->action_env, rsef->context, rac->tr_context, 
+							&impl_keep);
+				rsef = rsef->next;
+			}
+			
+			implicit_keep = implicit_keep && impl_keep;
+		} else {
+			/* Skip non-actions (inactive keep) and executed ones */
+			if ( act == NULL || rac->data.executed ) {
+				rac = rac->next;	
+				continue;
+			}
+		
+			if ( act->rollback != NULL ) 
+				act->rollback(act, &result->action_env, rac->tr_context, rac->success);
+				
+			/* Rollback side effects */
+			rsef = rac->seffects != NULL ? rac->seffects->first_effect : NULL;
+			while ( rsef != NULL ) {
+				sef = rsef->seffect;
+				if ( sef->rollback != NULL ) 
+					sef->rollback
+						(sef, act, &result->action_env, rsef->context, rac->tr_context, 
+						rac->success);
+				rsef = rsef->next;
+			}
+		}
+		
+		rac = rac->next;	
+	}
+	
+	if ( implicit_keep && keep != NULL ) *keep = TRUE;
+	
+	/* Return value indicates whether the caller should attempt an implicit keep 
+	 * of its own. So, if the above transaction fails, but the implicit keep below
+	 * succeeds, the return value is still true. An error is/should be logged 
+	 * though.
+	 */
+	
+	/* Execute implicit keep if the transaction failed or when the implicit keep
+	 * was not canceled during transaction. 
+	 */
+	if ( !commit_ok || implicit_keep ) {		
+		if ( !_sieve_result_implicit_keep(result, !commit_ok) ) 
+			return SIEVE_EXEC_KEEP_FAILED;
+			
+		return ( commit_ok ? 
+			SIEVE_EXEC_OK            /* Success */ :
+			SIEVE_EXEC_FAILURE       /* Implicit keep executed */ );
+	}
+	
+	/* Unconditional success */
+	return SIEVE_EXEC_OK;
+}
+
+/*
+ * Result evaluation
+ */
+
+struct sieve_result_iterate_context {
+	struct sieve_result *result;
+	struct sieve_result_action *action;
+};
+
+struct sieve_result_iterate_context *sieve_result_iterate_init
+(struct sieve_result *result)
+{
+	struct sieve_result_iterate_context *rictx = 
+		t_new(struct sieve_result_iterate_context, 1);
+	
+	rictx->result = result;
+	rictx->action = result->first_action;
+
+	return rictx;
+}
+
+const struct sieve_action *sieve_result_iterate_next
+	(struct sieve_result_iterate_context *rictx, bool *keep, void **context)
+{
+	struct sieve_result_action *rac;
+
+	if ( rictx == NULL )
+		return  NULL;
+
+	rac = rictx->action;
+	if ( rac != NULL ) {
+		rictx->action = rac->next;
+		
+		if ( keep != NULL )
+			*keep = rac->keep;
+
+		if ( context != NULL )
+			*context = rac->data.context;
+	
+		return rac->data.action;
+	}
+
+	return NULL;
+}
+
+/*
+ * Side effects list
+ */
+ 
+struct sieve_side_effects_list *sieve_side_effects_list_create
+	(struct sieve_result *result)
+{
+	struct sieve_side_effects_list *list = 
+		p_new(result->pool, struct sieve_side_effects_list, 1);
+	
+	list->result = result;
+	list->first_effect = NULL;
+	list->last_effect = NULL;
+	
+	return list;
+};
+
+void sieve_side_effects_list_add
+(struct sieve_side_effects_list *list, const struct sieve_side_effect *seffect, 
+	void *context)		
+{
+	struct sieve_result_side_effect *reffect;
+	
+	/* Create new side effect object */
+	reffect = p_new(list->result->pool, struct sieve_result_side_effect, 1);
+	reffect->seffect = seffect;
+	reffect->context = context;
+	
+	/* Add */
+	if ( list->first_effect == NULL ) {
+		list->first_effect = reffect;
+		list->last_effect = reffect;
+		reffect->prev = NULL;
+		reffect->next = NULL;
+	} else {
+		list->last_effect->next = reffect;
+		reffect->prev = list->last_effect;
+		list->last_effect = reffect;
+		reffect->next = NULL;
+	}	
+}	
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-result.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-result.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-result.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-result.h	2009-08-02 10:20:22.000000000 +0200
@@ -0,0 +1,149 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_RESULT_H
+#define __SIEVE_RESULT_H
+
+#include "sieve-common.h"
+
+/*
+ * Types
+ */
+ 
+struct sieve_side_effects_list;
+
+/*
+ * Result object
+ */
+
+struct sieve_result;
+
+struct sieve_result *sieve_result_create
+	(const struct sieve_message_data *msgdata, const struct sieve_script_env *senv,
+		struct sieve_error_handler *ehandler);
+
+void sieve_result_ref(struct sieve_result *result); 
+
+void sieve_result_unref(struct sieve_result **result); 
+
+pool_t sieve_result_pool(struct sieve_result *result);
+
+/*
+ * Getters/Setters
+ */
+
+struct sieve_error_handler *sieve_result_get_error_handler
+	(struct sieve_result *result);
+void sieve_result_set_error_handler
+	(struct sieve_result *result, struct sieve_error_handler *ehandler);
+
+const struct sieve_script_env *sieve_result_get_script_env
+	(struct sieve_result *result);
+const struct sieve_message_data *sieve_result_get_message_data
+	(struct sieve_result *result);
+struct sieve_message_context *sieve_result_get_message_context
+	(struct sieve_result *result);
+
+/*
+ * Extension support
+ */
+
+void sieve_result_extension_set_context
+	(struct sieve_result *result, const struct sieve_extension *ext,
+		void *context);
+const void *sieve_result_extension_get_context
+	(struct sieve_result *result, const struct sieve_extension *ext); 
+
+/* 
+ * Result printing 
+ */
+
+struct sieve_result_print_env {
+	struct sieve_result *result;
+	const struct sieve_script_env *scriptenv;
+	struct ostream *stream;
+};
+
+void sieve_result_vprintf
+	(const struct sieve_result_print_env *penv, const char *fmt, va_list args);
+void sieve_result_printf
+	(const struct sieve_result_print_env *penv, const char *fmt, ...)
+		ATTR_FORMAT(2, 3);
+void sieve_result_action_printf
+	(const struct sieve_result_print_env *penv, const char *fmt, ...)
+		ATTR_FORMAT(2, 3);
+void sieve_result_seffect_printf
+	(const struct sieve_result_print_env *penv, const char *fmt, ...)
+		ATTR_FORMAT(2, 3);
+
+bool sieve_result_print
+	(struct sieve_result *result, const struct sieve_script_env *senv, 
+		struct ostream *stream, bool *keep);
+
+/* 
+ * Error handling 
+ */
+
+void sieve_result_log
+	(const struct sieve_action_exec_env *aenv, const char *fmt, ...)
+		ATTR_FORMAT(2, 3);
+void sieve_result_warning
+	(const struct sieve_action_exec_env *aenv, const char *fmt, ...)
+		ATTR_FORMAT(2, 3);
+void sieve_result_error
+	(const struct sieve_action_exec_env *aenv, const char *fmt, ...)
+		ATTR_FORMAT(2, 3);
+
+/*
+ * Result composition
+ */
+ 
+void sieve_result_add_implicit_side_effect
+(struct sieve_result *result, const struct sieve_action *to_action, 
+	const struct sieve_side_effect *seffect, void *context);
+	
+int sieve_result_add_action
+	(const struct sieve_runtime_env *renv, const struct sieve_action *action, 
+		struct sieve_side_effects_list *seffects, unsigned int source_line, 
+		void *context, unsigned int instance_limit);
+int sieve_result_add_keep
+	(const struct sieve_runtime_env *renv, 
+		struct sieve_side_effects_list *seffects, unsigned int source_line);
+
+void sieve_result_set_keep_action
+	(struct sieve_result *result, const struct sieve_action *action);
+void sieve_result_set_failure_action
+	(struct sieve_result *result, const struct sieve_action *action);
+
+/*
+ * Result execution
+ */
+ 
+bool sieve_result_implicit_keep(struct sieve_result *result);
+
+void sieve_result_mark_executed(struct sieve_result *result);
+
+int sieve_result_execute(struct sieve_result *result, bool *keep);
+
+/*
+ * Result evaluation
+ */
+
+struct sieve_result_iterate_context;
+
+struct sieve_result_iterate_context *sieve_result_iterate_init
+	(struct sieve_result *result);
+const struct sieve_action *sieve_result_iterate_next
+	(struct sieve_result_iterate_context *rictx, bool *keep, void **context);
+	
+/*
+ * Side effects list
+ */
+ 
+struct sieve_side_effects_list *sieve_side_effects_list_create
+	(struct sieve_result *result);
+void sieve_side_effects_list_add
+(struct sieve_side_effects_list *list, const struct sieve_side_effect *seffect, 
+	void *context);
+
+#endif
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-script.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-script.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-script.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-script.c	2009-08-21 00:52:15.000000000 +0200
@@ -0,0 +1,353 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "compat.h"
+#include "istream.h"
+#include "eacces-error.h"
+
+#include "sieve-common.h"
+#include "sieve-error.h"
+
+#include "sieve-script-private.h"
+
+#include <unistd.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+/*
+ * Configuration
+ */
+ 
+#define SIEVE_READ_BLOCK_SIZE (1024*8)
+
+/*
+ * Filename to name/name to filename
+ */
+
+static inline const char *_sieve_scriptfile_get_basename(const char *filename)
+{
+	const char *ext;
+
+	/* Extract the script name */
+	ext = strrchr(filename, '.');
+	if ( ext == NULL || ext == filename || strncmp(ext,".sieve",6) != 0 )
+		return filename;
+	
+	return t_strdup_until(filename, ext);	
+}
+
+bool sieve_script_file_has_extension(const char *filename)
+{
+	const char *ext;
+
+ 	/* See if it ends in .sieve already */
+	ext = strrchr(filename, '.');
+	if ( ext == NULL || ext == filename || strncmp(ext,".sieve",6) != 0 )
+		return FALSE;
+
+	return TRUE;
+}
+
+static inline const char *_sieve_scriptfile_from_name(const char *name)
+{
+	if ( !sieve_script_file_has_extension(name) )
+		return t_strconcat(name, ".sieve", NULL);
+
+	return name;
+}
+
+
+/* 
+ * Script object 
+ */
+ 
+struct sieve_script *sieve_script_init
+(struct sieve_script *script, const char *path, const char *name, 
+	struct sieve_error_handler *ehandler, bool *exists_r)
+{
+	int ret;
+	pool_t pool;
+	struct stat st;
+	struct stat lnk_st;
+	const char *filename, *dirpath, *basename, *binpath;
+
+	if ( exists_r != NULL )
+		*exists_r = TRUE;
+
+	T_BEGIN {
+
+		/* Extract filename from path */
+
+		filename = strrchr(path, '/');
+		if ( filename == NULL ) {
+			dirpath = "";
+			filename = path;
+		} else {
+			dirpath = t_strdup_until(path, filename);
+			filename++;
+		}
+
+		basename = _sieve_scriptfile_get_basename(filename);
+
+		if ( *dirpath == '\0' )
+			binpath = t_strconcat(basename, ".svbin", NULL);
+		else
+			binpath = t_strconcat(dirpath, "/", basename, ".svbin", NULL);
+				
+		if ( name == NULL ) {
+			name = basename; 
+		} else if ( *name == '\0' ) {
+			name = NULL;
+		} else {
+			basename = name;
+		}
+			
+		/* First obtain stat data from the system */
+		
+		if ( (ret=lstat(path, &st)) < 0 ) {
+			if ( errno == ENOENT ) {
+				if ( exists_r == NULL ) 
+					sieve_error(ehandler, basename, "sieve script does not exist");
+				else
+					*exists_r = FALSE;
+			} else
+				sieve_critical(ehandler, basename, 
+					"failed to stat sieve script: lstat(%s) failed: %m", path);
+
+			script = NULL;
+			ret = 1;
+
+		} else {
+			/* Record stat information from the symlink */
+			lnk_st = st;
+
+			/* Only create/init the object if it stat()s without problems */
+			if (S_ISLNK(st.st_mode)) {
+				if ( (ret=stat(path, &st)) < 0 ) { 
+					if ( errno == ENOENT ) {
+						if ( exists_r == NULL )
+							sieve_error(ehandler, basename, "sieve script does not exist");
+						else
+							*exists_r = FALSE;
+					} else
+						sieve_critical(ehandler, basename, 
+							"failed to stat sieve script: stat(%s) failed: %m", path);
+
+					script = NULL;	
+					ret = 1;
+				}
+			}
+
+			if ( ret == 0 && !S_ISREG(st.st_mode) ) {
+				sieve_critical(ehandler, basename, 
+					"sieve script file '%s' is not a regular file.", path);
+				script = NULL;
+				ret = 1;
+			} 
+		}
+
+		if ( ret <= 0 ) {
+			if ( script == NULL ) {
+				pool = pool_alloconly_create("sieve_script", 1024);
+				script = p_new(pool, struct sieve_script, 1);
+				script->pool = pool;
+			} else 
+				pool = script->pool;
+		
+			script->refcount = 1;
+			script->ehandler = ehandler;
+			sieve_error_handler_ref(ehandler);
+		
+			script->st = st;
+			script->lnk_st = lnk_st;
+			script->path = p_strdup(pool, path);
+			script->filename = p_strdup(pool, filename);
+			script->dirpath = p_strdup(pool, dirpath);
+			script->binpath = p_strdup(pool, binpath);
+			script->basename = p_strdup(pool, basename);
+
+			if ( name != NULL )
+				script->name = p_strdup(pool, name);
+			else
+				script->name = NULL;
+		}
+	} T_END;	
+
+	return script;
+}
+
+struct sieve_script *sieve_script_create
+(const char *path, const char *name, 
+	struct sieve_error_handler *ehandler, bool *exists_r)
+{
+	return sieve_script_init(NULL, path, name, ehandler, exists_r);
+}
+
+struct sieve_script *sieve_script_create_in_directory
+(const char *dirpath, const char *name,
+    struct sieve_error_handler *ehandler, bool *exists_r)
+{
+	const char *path;
+
+	if ( dirpath[strlen(dirpath)-1] == '/' )
+		path = t_strconcat(dirpath, 
+			_sieve_scriptfile_from_name(name), NULL);
+	else
+		path = t_strconcat(dirpath, "/",
+			_sieve_scriptfile_from_name(name), NULL);
+
+	return sieve_script_init(NULL, path, name, ehandler, exists_r);
+}
+
+void sieve_script_ref(struct sieve_script *script)
+{
+	script->refcount++;
+}
+
+void sieve_script_unref(struct sieve_script **script)
+{
+	i_assert((*script)->refcount > 0);
+
+	if (--(*script)->refcount != 0)
+		return;
+
+	if ( (*script)->stream != NULL )
+		i_stream_destroy(&(*script)->stream);
+
+	sieve_error_handler_unref(&(*script)->ehandler);
+
+	pool_unref(&(*script)->pool);
+
+	*script = NULL;
+}
+
+/* 
+ * Accessors 
+ */
+
+const char *sieve_script_name(const struct sieve_script *script)
+{
+	return script->name;
+}
+
+const char *sieve_script_filename(const struct sieve_script *script)
+{
+	return script->filename;
+}
+
+const char *sieve_script_path(const struct sieve_script *script)
+{
+	return script->path;
+}
+
+const char *sieve_script_dirpath(const struct sieve_script *script)
+{
+	return script->dirpath;
+}
+
+const char *sieve_script_binpath(const struct sieve_script *script)
+{
+	return script->binpath;
+}
+
+mode_t sieve_script_permissions(const struct sieve_script *script)
+{
+	return script->st.st_mode & (S_IRWXU | S_IRWXG | S_IRWXO);
+}
+
+/* 
+ * Stream manageement 
+ */
+
+struct istream *sieve_script_open
+(struct sieve_script *script, bool *deleted_r)
+{
+	int fd;
+	struct stat st;
+	struct istream *result;
+
+	if ( deleted_r != NULL )
+		*deleted_r = FALSE;
+
+	if ( (fd=open(script->path, O_RDONLY)) < 0 ) {
+		if ( errno == ENOENT ) {
+			if ( deleted_r == NULL ) 
+				/* Not supposed to occur, create() does stat already */
+				sieve_error(script->ehandler, script->basename, 
+					"sieve script does not exist");
+			else 
+				*deleted_r = TRUE;
+		} else if ( errno == EACCES ) {
+			sieve_critical(script->ehandler, script->path,
+				"failed to open sieve script: %s",
+				eacces_error_get("open", script->path));
+		} else {
+			sieve_critical(script->ehandler, script->path, 
+				"failed to open sieve script: open(%s) failed: %m", script->path);
+		}
+		return NULL;
+	}	
+	
+	if ( fstat(fd, &st) != 0 ) {
+		sieve_critical(script->ehandler, script->path, 
+			"failed to open sieve script: fstat(fd=%s) failed: %m", script->path);
+		result = NULL;
+	} else {
+		/* Re-check the file type just to be sure */
+		if ( !S_ISREG(st.st_mode) ) {
+			sieve_critical(script->ehandler, script->path,
+				"sieve script file '%s' is not a regular file", script->path);
+			result = NULL;
+		} else {
+			result = script->stream = 
+				i_stream_create_fd(fd, SIEVE_READ_BLOCK_SIZE, TRUE);
+			script->st = script->lnk_st = st;
+		}
+	}
+
+	if ( result == NULL ) {
+		/* Something went wrong, close the fd */
+		if ( close(fd) != 0 ) {
+			sieve_sys_error(
+				"failed to close sieve script: close(fd=%s) failed: %m", 
+				script->path);
+		}
+	}
+	
+	return result;
+}
+
+void sieve_script_close(struct sieve_script *script)
+{
+	i_stream_destroy(&script->stream);
+}
+
+uoff_t sieve_script_get_size(const struct sieve_script *script)
+{
+	return script->st.st_size;
+}
+
+/* 
+ * Comparison 
+ */
+
+int sieve_script_cmp
+(const struct sieve_script *script1, const struct sieve_script *script2)
+{
+	if ( script1 == NULL || script2 == NULL ) 
+		return -1;	
+
+	return ( script1->st.st_ino == script2->st.st_ino ) ? 0 : -1;
+}
+
+unsigned int sieve_script_hash(const struct sieve_script *script)
+{	
+	return (unsigned int) script->st.st_ino;
+}
+
+bool sieve_script_older
+(const struct sieve_script *script, time_t time)
+{
+	return ( script->st.st_mtime < time && script->lnk_st.st_mtime < time );
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-script.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-script.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-script.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-script.h	2009-02-12 21:01:37.000000000 +0100
@@ -0,0 +1,70 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_SCRIPT_H
+#define __SIEVE_SCRIPT_H
+
+#include "sieve-common.h"
+
+#include <sys/types.h>
+
+/*
+ * Sieve script object
+ */
+
+struct sieve_script;
+
+struct sieve_script *sieve_script_create
+	(const char *path, const char *name, 
+		struct sieve_error_handler *ehandler, bool *exists_r);
+
+struct sieve_script *sieve_script_create_in_directory
+	(const char *dirpath, const char *name,
+    	struct sieve_error_handler *ehandler, bool *exists_r);
+
+void sieve_script_ref(struct sieve_script *script);
+void sieve_script_unref(struct sieve_script **script);
+
+/*
+ * Filename filter
+ */
+ 
+bool sieve_script_file_has_extension(const char *filename);
+
+/*
+ * Accessors
+ */
+ 
+const char *sieve_script_name(const struct sieve_script *script);
+const char *sieve_script_filename(const struct sieve_script *script);
+const char *sieve_script_path(const struct sieve_script *script);
+const char *sieve_script_binpath(const struct sieve_script *script);
+const char *sieve_script_dirpath(const struct sieve_script *script);
+
+mode_t sieve_script_permissions(const struct sieve_script *script);
+
+/* 
+ * Stream management 
+ */
+
+struct istream *sieve_script_open(struct sieve_script *script, bool *deleted_r);
+void sieve_script_close(struct sieve_script *script);
+
+uoff_t sieve_script_get_size(const struct sieve_script *script);
+
+/*
+ * Comparison
+ */
+ 
+int sieve_script_cmp
+	(const struct sieve_script *script1, const struct sieve_script *script2);
+unsigned int sieve_script_hash(const struct sieve_script *script);
+bool sieve_script_older(const struct sieve_script *script, time_t time);
+
+static inline bool sieve_script_equals
+	(const struct sieve_script *script1, const struct sieve_script *script2)
+{
+	return ( sieve_script_cmp(script1, script2) == 0 );
+}
+
+#endif /* __SIEVE_SCRIPT_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-script-private.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-script-private.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-script-private.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-script-private.h	2009-01-10 20:32:19.000000000 +0100
@@ -0,0 +1,40 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_SCRIPT_PRIVATE_H
+#define __SIEVE_SCRIPT_PRIVATE_H
+
+#include "sieve-script.h"
+
+/*
+ * Script object
+ */
+
+struct sieve_script {
+	pool_t pool;
+	unsigned int refcount;
+
+	struct stat st;
+	struct stat lnk_st;
+	time_t mtime;
+
+	struct sieve_error_handler *ehandler;
+
+	/* Parameters */
+	const char *name;
+	const char *basename;
+	const char *filename;
+	const char *path;
+	const char *dirpath;
+	const char *binpath;
+
+	/* Stream */
+	int fd; /* FIXME: we could use the stream's autoclose facility */
+	struct istream *stream;
+};
+
+struct sieve_script *sieve_script_init
+(struct sieve_script *script, const char *path, const char *name,
+    struct sieve_error_handler *ehandler, bool *exists_r);
+
+#endif /* __SIEVE_SCRIPT_PRIVATE_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-types.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-types.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-types.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-types.h	2009-07-27 13:30:18.000000000 +0200
@@ -0,0 +1,103 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+
+#ifndef __SIEVE_TYPES_H
+#define __SIEVE_TYPES_H
+
+#include "lib.h"
+
+#include <stdio.h>
+
+/* Enable runtime trace functionality */
+#define SIEVE_RUNTIME_TRACE
+
+/*
+ * Forward declarations
+ */
+
+struct sieve_script;
+struct sieve_binary;
+
+struct sieve_message_data;
+struct sieve_script_env;
+struct sieve_exec_status;
+
+/* 
+ * Message data
+ *
+ * - The mail message + envelope data 
+ */
+
+struct sieve_message_data {
+	struct mail *mail;
+	const char *return_path;
+	const char *to_address;
+	const char *auth_user;
+	const char *id;
+};
+
+/* 
+ * Script environment
+ *
+ * - Environment for currently executing script 
+ */
+
+struct sieve_script_env {
+	/* Mail-related */
+	struct mail_namespace *namespaces;
+	const char *default_mailbox;
+	bool mailbox_autocreate;
+	bool mailbox_autosubscribe;
+	
+	/* System-related */
+	const char *username;
+	const char *hostname;
+	const char *postmaster_address;
+		
+	/* Callbacks */
+	
+	/* Interface for sending mail */
+	void *(*smtp_open)
+		(const char *destination, const char *return_path, FILE **file_r);
+	bool (*smtp_close)(void *handle);
+	
+	/* Interface for marking and checking duplicates */
+	int (*duplicate_check)
+		(const void *id, size_t id_size, const char *user);
+	void (*duplicate_mark)
+		(const void *id, size_t id_size, const char *user, time_t time);
+	
+	/* Execution status record */	
+	struct sieve_exec_status *exec_status;
+		
+	/* Trace stream */
+	struct ostream *trace_stream;
+};
+
+#define SIEVE_SCRIPT_DEFAULT_MAILBOX(senv) \
+	(senv->default_mailbox == NULL ? "INBOX" : senv->default_mailbox )
+
+/*
+ * Script executionstatus
+ */	
+
+struct sieve_exec_status {
+	bool message_saved;
+	bool message_forwarded;
+	bool tried_default_save;
+	bool keep_original;
+	struct mail_storage *last_storage;
+};
+
+/*
+ * Execution exit codes
+ */
+
+enum sieve_execution_exitcode {
+	SIEVE_EXEC_OK          = 1,
+	SIEVE_EXEC_FAILURE     = 0,
+	SIEVE_EXEC_BIN_CORRUPT = -1,
+	SIEVE_EXEC_KEEP_FAILED = -2
+};
+
+#endif /* __SIEVE_TYPES_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-validator.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-validator.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-validator.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-validator.c	2009-07-22 10:40:43.000000000 +0200
@@ -0,0 +1,1327 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "str-sanitize.h"
+#include "array.h"
+#include "buffer.h"
+#include "mempool.h"
+#include "hash.h"
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-script.h"
+#include "sieve-ast.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+
+#include "sieve-comparators.h"
+#include "sieve-address-parts.h"
+
+/*
+ * Forward declarations
+ */
+ 
+static void sieve_validator_register_core_commands
+	(struct sieve_validator *validator);
+static void sieve_validator_register_core_tests
+	(struct sieve_validator *validator);
+	
+/*
+ * Types
+ */
+ 
+/* Tag registration */
+
+struct sieve_tag_registration {
+	const struct sieve_argument *tag;
+	const char *identifier;	
+	int id_code;
+};
+
+/* Command registration */
+
+struct sieve_command_registration {
+	const struct sieve_command *command;
+	
+	ARRAY_DEFINE(normal_tags, struct sieve_tag_registration *); 
+	ARRAY_DEFINE(instanced_tags, struct sieve_tag_registration *); 
+	ARRAY_DEFINE(persistent_tags, struct sieve_tag_registration *); 
+};
+ 
+/* Default (literal) arguments */
+
+struct sieve_default_argument {
+	const struct sieve_argument *argument;
+	struct sieve_default_argument *overrides;
+};
+
+/* 
+ * Validator extension
+ */
+
+struct sieve_validator_extension_reg {
+	const struct sieve_validator_extension *val_ext;
+	struct sieve_ast_argument *arg;
+	void *context;
+
+	bool loaded;
+};
+
+/* 
+ * Validator
+ */
+
+struct sieve_validator {
+	pool_t pool;
+
+	struct sieve_ast *ast;
+	struct sieve_script *script;
+	
+	struct sieve_error_handler *ehandler;
+
+	bool finished_require;
+	
+	/* Registries */
+	
+	struct hash_table *commands;
+	
+	ARRAY_DEFINE(extensions, struct sieve_validator_extension_reg);
+	
+	/* This is currently a wee bit ugly and needs more thought */
+	struct sieve_default_argument default_arguments[SAT_COUNT];
+
+	/* Default argument processing state (FIXME: ugly) */
+	struct sieve_default_argument *current_defarg;
+	enum sieve_argument_type current_defarg_type;
+	bool current_defarg_constant;
+};
+
+/* 
+ * Error handling 
+ */
+
+void sieve_validator_warning
+(struct sieve_validator *validator, unsigned int source_line, 
+	const char *fmt, ...) 
+{ 
+	va_list args;
+	
+	va_start(args, fmt);
+	sieve_vwarning(validator->ehandler, 
+		sieve_error_script_location(validator->script, source_line),
+		fmt, args);
+	va_end(args);
+	
+}
+ 
+void sieve_validator_error
+(struct sieve_validator *validator, unsigned int source_line, 
+	const char *fmt, ...) 
+{
+	va_list args;
+	
+	va_start(args, fmt);
+	sieve_verror(validator->ehandler, 
+		sieve_error_script_location(validator->script, source_line),
+		fmt, args);
+	va_end(args);
+}
+
+void sieve_validator_critical
+(struct sieve_validator *validator, unsigned int source_line, 
+	const char *fmt, ...) 
+{
+	va_list args;
+	
+	va_start(args, fmt);
+	sieve_vcritical(validator->ehandler, 
+		sieve_error_script_location(validator->script, source_line),
+		fmt, args);
+	va_end(args);
+}
+
+/* 
+ * Validator object 
+ */
+
+struct sieve_validator *sieve_validator_create
+(struct sieve_ast *ast, struct sieve_error_handler *ehandler) 
+{
+	unsigned int i;
+	pool_t pool;
+	struct sieve_validator *validator;
+	
+	pool = pool_alloconly_create("sieve_validator", 8192);	
+	validator = p_new(pool, struct sieve_validator, 1);
+	validator->pool = pool;
+	
+	validator->ehandler = ehandler;
+	sieve_error_handler_ref(ehandler);
+	
+	validator->ast = ast;	
+	validator->script = sieve_ast_script(ast);
+	sieve_ast_ref(ast);
+
+	/* Setup default arguments */
+	validator->default_arguments[SAT_NUMBER].
+		argument = &number_argument;
+	validator->default_arguments[SAT_VAR_STRING].
+		argument = &string_argument;
+	validator->default_arguments[SAT_CONST_STRING].
+		argument = &string_argument;
+	validator->default_arguments[SAT_STRING_LIST].
+		argument = &string_list_argument;
+
+	/* Setup storage for extension contexts */		
+	p_array_init(&validator->extensions, pool, sieve_extensions_get_count());
+		
+	/* Setup command registry */
+	validator->commands = hash_table_create
+		(default_pool, pool, 0, strcase_hash, (hash_cmp_callback_t *)strcasecmp);
+	sieve_validator_register_core_commands(validator);
+	sieve_validator_register_core_tests(validator);
+	
+	/* Pre-load core language features implemented as 'extensions' */
+	for ( i = 0; i < sieve_preloaded_extensions_count; i++ ) {
+		const struct sieve_extension *ext = sieve_preloaded_extensions[i];
+		
+		if ( ext->validator_load != NULL )
+			(void)ext->validator_load(validator);
+	}
+	
+	return validator;
+}
+
+void sieve_validator_free(struct sieve_validator **validator) 
+{
+	const struct sieve_validator_extension_reg *extrs;
+	unsigned int ext_count, i;
+
+	hash_table_destroy(&(*validator)->commands);
+	sieve_ast_unref(&(*validator)->ast);
+
+	sieve_error_handler_unref(&(*validator)->ehandler);
+
+	/* Signal registered extensions that the validator is being destroyed */
+	extrs = array_get(&(*validator)->extensions, &ext_count);
+	for ( i = 0; i < ext_count; i++ ) {
+		if ( extrs[i].val_ext != NULL && extrs[i].val_ext->free != NULL )
+			extrs[i].val_ext->free(*validator, extrs[i].context);
+	}
+
+	pool_unref(&(*validator)->pool);
+
+	*validator = NULL;
+}
+
+/*
+ * Accessors
+ */
+
+pool_t sieve_validator_pool(struct sieve_validator *validator)
+{
+	return validator->pool;
+}
+
+struct sieve_error_handler *sieve_validator_error_handler
+(struct sieve_validator *validator)
+{
+	return validator->ehandler;
+}
+
+struct sieve_ast *sieve_validator_ast
+(struct sieve_validator *validator)
+{
+	return validator->ast;
+}
+
+struct sieve_script *sieve_validator_script
+(struct sieve_validator *validator)
+{
+	return validator->script;
+}
+
+/* 
+ * Command registry 
+ */
+
+/* Dummy command object to mark unknown commands in the registry */
+
+static bool _cmd_unknown_validate
+(struct sieve_validator *validator ATTR_UNUSED, 
+	struct sieve_command_context *cmd ATTR_UNUSED) 
+{
+	i_unreached();
+	return FALSE;
+}
+
+static const struct sieve_command unknown_command = { 
+	"", SCT_NONE, 0, 0, FALSE, FALSE , 
+	NULL, NULL, _cmd_unknown_validate, NULL, NULL 
+};
+
+/* Registration of the core commands of the language */
+
+static void sieve_validator_register_core_tests
+(struct sieve_validator *validator) 
+{
+	unsigned int i;
+	
+	for ( i = 0; i < sieve_core_tests_count; i++ ) {
+		sieve_validator_register_command(validator, sieve_core_tests[i]); 
+	}
+}
+
+static void sieve_validator_register_core_commands
+(struct sieve_validator *validator) 
+{
+	unsigned int i;
+	
+	for ( i = 0; i < sieve_core_commands_count; i++ ) {
+		sieve_validator_register_command(validator, sieve_core_commands[i]); 
+	}
+}
+
+/* Registry functions */
+
+static struct sieve_command_registration *
+sieve_validator_find_command_registration
+(struct sieve_validator *validator, const char *command) 
+{
+	return (struct sieve_command_registration *) 
+		hash_table_lookup(validator->commands, command);
+}
+
+static struct sieve_command_registration *_sieve_validator_register_command
+(struct sieve_validator *validator, const struct sieve_command *command,
+	const char *identifier) 
+{
+	struct sieve_command_registration *record = 
+		p_new(validator->pool, struct sieve_command_registration, 1);
+	record->command = command;
+	hash_table_insert(validator->commands, (void *) identifier, (void *) record);
+		
+	return record;
+}
+
+void sieve_validator_register_command
+(struct sieve_validator *validator, const struct sieve_command *command) 
+{
+	struct sieve_command_registration *cmd_reg =
+		sieve_validator_find_command_registration(validator, command->identifier);
+		
+	if ( cmd_reg == NULL ) 
+		cmd_reg = _sieve_validator_register_command
+			(validator, command, command->identifier);
+	else
+		cmd_reg->command = command;
+	
+	if ( command->registered != NULL ) 
+		command->registered(validator, cmd_reg);
+}
+
+static void sieve_validator_register_unknown_command
+(struct sieve_validator *validator, const char *command) 
+{
+	(void)_sieve_validator_register_command(validator, &unknown_command, command);		
+}
+
+const struct sieve_command *sieve_validator_find_command
+(struct sieve_validator *validator, const char *command) 
+{
+  struct sieve_command_registration *record = 
+  	sieve_validator_find_command_registration(validator, command);
+  
+  return ( record == NULL ? NULL : record->command );
+}
+
+/* 
+ * Per-command tagged argument registry 
+ */
+
+/* Dummy argument object to mark unknown arguments in the registry */
+
+static bool _unknown_tag_validate
+(struct sieve_validator *validator ATTR_UNUSED, 
+	struct sieve_ast_argument **arg ATTR_UNUSED, 
+	struct sieve_command_context *tst ATTR_UNUSED)
+{
+	i_unreached();
+	return FALSE;
+}
+
+static const struct sieve_argument _unknown_tag = { 
+	"", 
+	NULL, NULL, 
+	_unknown_tag_validate, 
+	NULL, NULL 
+};
+
+/* Registry functions */
+
+static void _sieve_validator_register_tag
+(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg, 
+	const struct sieve_argument *tag, const char *identifier, int id_code) 
+{
+	struct sieve_tag_registration *reg;
+
+	reg = p_new(validator->pool, struct sieve_tag_registration, 1);
+	reg->tag = tag;
+	reg->id_code = id_code;
+	if ( identifier == NULL )
+		reg->identifier = tag->identifier;
+	else
+		reg->identifier = p_strdup(validator->pool, identifier);
+	
+	if ( !array_is_created(&cmd_reg->normal_tags) )
+		p_array_init(&cmd_reg->normal_tags, validator->pool, 4);
+
+	array_append(&cmd_reg->normal_tags, &reg, 1);
+}
+
+void sieve_validator_register_persistent_tag
+(struct sieve_validator *validator, const struct sieve_argument *tag, 
+	const char *command)
+{
+	struct sieve_command_registration *cmd_reg = 
+		sieve_validator_find_command_registration(validator, command);
+	struct sieve_tag_registration *reg = 
+		p_new(validator->pool, struct sieve_tag_registration, 1);
+	
+	reg->tag = tag;
+	reg->id_code = -1;
+	
+	if ( cmd_reg == NULL ) {
+		cmd_reg = _sieve_validator_register_command(validator, NULL, command);
+	}	
+		
+	/* Add the tag to the persistent tags list if necessary */
+	if ( tag->validate_persistent != NULL ) {
+		if ( !array_is_created(&cmd_reg->persistent_tags) ) 
+			p_array_init(&cmd_reg->persistent_tags, validator->pool, 4);
+				
+		array_append(&cmd_reg->persistent_tags, &reg, 1);
+	}
+}
+
+void sieve_validator_register_external_tag
+(struct sieve_validator *validator, const struct sieve_argument *tag, 
+	const char *command, int id_code) 
+{
+	struct sieve_command_registration *cmd_reg = 
+		sieve_validator_find_command_registration(validator, command);
+		
+	if ( cmd_reg == NULL ) {
+		cmd_reg = _sieve_validator_register_command(validator, NULL, command);
+	}
+	
+	_sieve_validator_register_tag
+		(validator, cmd_reg, tag, NULL, id_code);
+}
+
+void sieve_validator_register_tag
+(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg, 
+	const struct sieve_argument *tag, int id_code) 
+{
+	if ( tag->is_instance_of == NULL )
+		_sieve_validator_register_tag(validator, cmd_reg, tag, NULL, id_code);
+	else {
+		struct sieve_tag_registration *reg = 
+			p_new(validator->pool, struct sieve_tag_registration, 1);
+		reg->tag = tag;
+		reg->id_code = id_code;
+
+		if ( !array_is_created(&cmd_reg->instanced_tags) ) 
+				p_array_init(&cmd_reg->instanced_tags, validator->pool, 4);
+				
+		array_append(&cmd_reg->instanced_tags, &reg, 1);
+	}
+}
+
+static void sieve_validator_register_unknown_tag
+(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg, 
+	const char *tag) 
+{
+	_sieve_validator_register_tag(validator, cmd_reg, &_unknown_tag, tag, 0);
+}
+
+static const struct sieve_argument *sieve_validator_find_tag
+(struct sieve_validator *valdtr, struct sieve_command_context *cmd, 
+	struct sieve_ast_argument *arg, int *id_code) 
+{
+	struct sieve_command_registration *cmd_reg = cmd->cmd_reg;
+	const char *tag = sieve_ast_argument_tag(arg);
+	unsigned int i;
+			
+	if ( id_code != NULL )
+		*id_code = 0;
+	
+	/* First check normal tags */
+	if ( array_is_created(&cmd_reg->normal_tags) ) {
+		for ( i = 0; i < array_count(&cmd_reg->normal_tags); i++ ) {
+			struct sieve_tag_registration * const *reg =
+				array_idx(&cmd_reg->normal_tags, i);
+
+			if ( (*reg)->tag != NULL && strcasecmp((*reg)->identifier,tag) == 0) {
+				if ( id_code != NULL )				
+					*id_code = (*reg)->id_code;
+
+				return (*reg)->tag;
+			}
+		}
+	}	
+  
+	/* Not found so far, try the instanced tags */
+	if ( array_is_created(&cmd_reg->instanced_tags) ) {
+		for ( i = 0; i < array_count(&cmd_reg->instanced_tags); i++ ) {
+			struct sieve_tag_registration * const *reg = 
+				array_idx(&cmd_reg->instanced_tags, i);
+  	
+			if ( (*reg)->tag != NULL && 
+				(*reg)->tag->is_instance_of(valdtr, cmd, arg) ) {
+				if ( id_code != NULL )
+					*id_code = (*reg)->id_code;
+				
+				return (*reg)->tag;
+			}
+		}
+	}
+	
+	return NULL;
+}
+
+static const struct sieve_argument *sieve_validator_find_tag_by_identifier
+(struct sieve_validator *valdtr, struct sieve_command_context *cmd, 
+	const char *tag) 
+{
+	struct sieve_ast_argument *arg;
+
+	/* Construct dummy argument */
+	arg = t_new(struct sieve_ast_argument, 1);
+	arg->type = SAAT_TAG;
+	arg->_value.tag = tag; 
+
+	return sieve_validator_find_tag(valdtr, cmd, arg, NULL);  
+}
+
+/* 
+ * Extension support 
+ */
+
+const struct sieve_extension *sieve_validator_extension_load
+(struct sieve_validator *valdtr, struct sieve_command_context *cmd,
+	struct sieve_ast_argument *ext_arg, string_t *ext_name) 
+{
+	int ext_id;
+	struct sieve_validator_extension_reg *reg;
+	const struct sieve_extension *ext;
+	const char *name = str_c(ext_name);
+
+	if ( str_len(ext_name) > 128 ) {
+		sieve_argument_validate_error(valdtr, ext_arg, 
+			"%s %s: unknown Sieve capability '%s' (name is impossibly long)",
+			cmd->command->identifier, sieve_command_type_name(cmd->command),
+			str_sanitize(name, 128));
+		return NULL;
+	}
+
+	ext = sieve_extension_get_by_name(name); 
+	
+	if ( ext == NULL ) {
+		unsigned int i;
+		bool core_test = FALSE;
+		bool core_command = FALSE;
+
+		for ( i = 0; !core_command && i < sieve_core_commands_count; i++ ) {
+			if ( strcasecmp(sieve_core_commands[i]->identifier, name) == 0 )
+				core_command = TRUE;
+		}
+
+		for ( i = 0; !core_test && i < sieve_core_tests_count; i++ ) {
+			if ( strcasecmp(sieve_core_tests[i]->identifier, name) == 0 )
+				core_test = TRUE;
+		}
+
+		if ( core_test || core_command ) {
+			sieve_argument_validate_error(valdtr, ext_arg,
+                "%s %s: '%s' is not known as a Sieve capability, "
+				"but it is known as a Sieve %s that is always available",
+                cmd->command->identifier, sieve_command_type_name(cmd->command),
+                name, ( core_test ? "test" : "command" ));
+		} else {
+			sieve_argument_validate_error(valdtr, ext_arg,
+				"%s %s: unknown Sieve capability '%s'", 
+				cmd->command->identifier, sieve_command_type_name(cmd->command),
+				name);
+		}
+		return NULL;
+	}
+	
+	sieve_ast_extension_link(valdtr->ast, ext);
+
+	if ( ext->validator_load != NULL && !ext->validator_load(valdtr) ) {
+		sieve_argument_validate_error(valdtr, ext_arg, 
+			"%s %s: failed to load Sieve capability '%s'",
+			cmd->command->identifier, sieve_command_type_name(cmd->command),
+			ext->name);
+		return NULL;
+	}
+
+	/* Register extension no matter what and store the AST argument registering it */
+	ext_id = SIEVE_EXT_ID(ext);
+	if ( ext_id >= 0 ) {
+		reg = array_idx_modifiable(&valdtr->extensions, (unsigned int) ext_id);
+		reg->arg = ext_arg;
+		reg->loaded = TRUE;
+	}
+
+	return ext;
+}
+
+void sieve_validator_extension_register
+(struct sieve_validator *valdtr, 
+	const struct sieve_validator_extension *val_ext, void *context)
+{
+	struct sieve_validator_extension_reg *reg;
+	int ext_id = SIEVE_EXT_ID(val_ext->ext);
+
+	if ( ext_id < 0 ) return;
+	
+	reg = array_idx_modifiable(&valdtr->extensions, (unsigned int) ext_id);
+	reg->val_ext = val_ext;
+	reg->context = context;
+}
+
+bool sieve_validator_extension_loaded
+	(struct sieve_validator *valdtr, const struct sieve_extension *ext)
+{
+	int ext_id = SIEVE_EXT_ID(ext);
+	const struct sieve_validator_extension_reg *reg;
+
+	if ( ext_id < 0 || ext_id >= (int) array_count(&valdtr->extensions))
+		return FALSE;
+
+	reg = array_idx(&valdtr->extensions, (unsigned int) ext_id);
+
+	return ( reg->loaded );
+}
+
+void sieve_validator_extension_set_context
+(struct sieve_validator *valdtr, const struct sieve_extension *ext, 
+	void *context)
+{
+	struct sieve_validator_extension_reg *reg;
+	int ext_id = SIEVE_EXT_ID(ext);
+
+	if ( ext_id < 0 ) return;
+	
+	reg = array_idx_modifiable(&valdtr->extensions, (unsigned int) ext_id);
+	reg->context = context;
+}
+
+void *sieve_validator_extension_get_context
+(struct sieve_validator *valdtr, const struct sieve_extension *ext) 
+{
+	int ext_id = SIEVE_EXT_ID(ext);
+	const struct sieve_validator_extension_reg *reg;
+
+	if  ( ext_id < 0 || ext_id >= (int) array_count(&valdtr->extensions) )
+		return NULL;
+	
+	reg = array_idx(&valdtr->extensions, (unsigned int) ext_id);		
+
+	return reg->context;
+}
+
+/* 
+ * Overriding the default literal arguments
+ */
+
+void sieve_validator_argument_override
+(struct sieve_validator *validator, enum sieve_argument_type type, 
+	const struct sieve_argument *argument)
+{
+	struct sieve_default_argument *arg;
+	
+	if ( validator->default_arguments[type].argument != NULL ) {
+		arg = p_new(validator->pool, struct sieve_default_argument, 1);
+		*arg = validator->default_arguments[type];	
+		
+		validator->default_arguments[type].overrides = arg;
+	}
+	
+	validator->default_arguments[type].argument = argument;
+}
+
+static bool sieve_validator_argument_default_activate
+(struct sieve_validator *validator, struct sieve_command_context *cmd,
+	struct sieve_default_argument *defarg, struct sieve_ast_argument *arg)
+{
+	bool result = TRUE;
+	struct sieve_default_argument *prev_defarg;
+	
+	prev_defarg = validator->current_defarg;
+	validator->current_defarg = defarg;
+	
+	arg->argument = defarg->argument;
+	if (defarg->argument != NULL && defarg->argument->validate != NULL )
+		result = defarg->argument->validate(validator, &arg, cmd); 
+		
+	validator->current_defarg = prev_defarg;	
+		
+	return result;
+}
+
+bool sieve_validator_argument_activate_super
+(struct sieve_validator *validator, struct sieve_command_context *cmd, 
+	struct sieve_ast_argument *arg, bool constant ATTR_UNUSED)
+{
+	struct sieve_default_argument *defarg;
+
+	if ( validator->current_defarg == NULL ||	
+		validator->current_defarg->overrides == NULL )
+		return FALSE;
+	
+	if ( validator->current_defarg->overrides->argument == &string_argument ) {
+		switch ( validator->current_defarg_type) {
+		case SAT_CONST_STRING:
+			if ( !validator->current_defarg_constant ) {
+				validator->current_defarg_type = SAT_VAR_STRING;
+				defarg = &validator->default_arguments[SAT_VAR_STRING];
+			} else
+				defarg = validator->current_defarg->overrides;
+			break;
+		case SAT_VAR_STRING:
+			defarg = validator->current_defarg->overrides;
+			break;
+		default:
+			return FALSE;
+		}
+	} else
+		defarg = validator->current_defarg->overrides;
+	
+	return sieve_validator_argument_default_activate
+		(validator, cmd, defarg, arg);
+}
+
+/* 
+ * Argument Validation API 
+ */
+
+bool sieve_validator_argument_activate
+(struct sieve_validator *validator, struct sieve_command_context *cmd, 
+	struct sieve_ast_argument *arg, bool constant)
+{
+	struct sieve_default_argument *defarg;
+	
+	switch ( sieve_ast_argument_type(arg) ) {
+	case SAAT_NUMBER:	
+		validator->current_defarg_type = SAT_NUMBER;
+		break;
+	case SAAT_STRING:
+		validator->current_defarg_type = SAT_CONST_STRING;
+		break;
+	case SAAT_STRING_LIST:
+		validator->current_defarg_type = SAT_STRING_LIST;
+		break;
+	default:
+		return FALSE;
+	}
+
+	validator->current_defarg_constant = constant;
+	defarg = &validator->default_arguments[validator->current_defarg_type];
+
+	if ( !constant && defarg->argument == &string_argument ) {
+		validator->current_defarg_type = SAT_VAR_STRING;
+		defarg = &validator->default_arguments[SAT_VAR_STRING];
+	}
+	
+	return sieve_validator_argument_default_activate(validator, cmd, defarg, arg);
+}
+
+bool sieve_validate_positional_argument
+(struct sieve_validator *validator, struct sieve_command_context *cmd,
+	struct sieve_ast_argument *arg, const char *arg_name, unsigned int arg_pos,
+	enum sieve_ast_argument_type req_type)
+{
+	if ( sieve_ast_argument_type(arg) != req_type && 
+		(sieve_ast_argument_type(arg) != SAAT_STRING || 
+			req_type != SAAT_STRING_LIST) ) 
+	{
+		sieve_argument_validate_error(validator, arg, 
+			"the %s %s expects %s as argument %d (%s), but %s was found", 
+			cmd->command->identifier, sieve_command_type_name(cmd->command), 
+			sieve_ast_argument_type_name(req_type),
+			arg_pos, arg_name, sieve_ast_argument_name(arg));
+		return FALSE; 
+	}
+	
+	return TRUE;
+}
+
+bool sieve_validate_tag_parameter
+(struct sieve_validator *validator, struct sieve_command_context *cmd,
+	struct sieve_ast_argument *tag, struct sieve_ast_argument *param,
+	enum sieve_ast_argument_type req_type)
+{
+	if ( param == NULL ) {
+		sieve_argument_validate_error(validator, tag, 
+			"the :%s tag for the %s %s requires %s as parameter, "
+			"but no more arguments were found", sieve_ast_argument_tag(tag), 
+			cmd->command->identifier, sieve_command_type_name(cmd->command),
+			sieve_ast_argument_type_name(req_type));
+		return FALSE;	
+	}
+
+	if ( sieve_ast_argument_type(param) != req_type && 
+		(sieve_ast_argument_type(param) != SAAT_STRING || 
+			req_type != SAAT_STRING_LIST) ) 
+	{
+		sieve_argument_validate_error(validator, param, 
+			"the :%s tag for the %s %s requires %s as parameter, "
+			"but %s was found", sieve_ast_argument_tag(tag), 
+			cmd->command->identifier, sieve_command_type_name(cmd->command),
+			sieve_ast_argument_type_name(req_type),	sieve_ast_argument_name(param));
+		return FALSE;
+	}
+
+	param->arg_id_code = tag->arg_id_code;
+
+	return sieve_validator_argument_activate(validator, cmd, param, FALSE);
+}
+
+/* 
+ * Command argument validation 
+ */
+
+static bool sieve_validate_command_arguments
+(struct sieve_validator *validator, struct sieve_command_context *cmd) 
+{
+	int arg_count = cmd->command->positional_arguments;
+	int real_count = 0;
+	struct sieve_ast_argument *arg;
+	struct sieve_command_registration *cmd_reg = cmd->cmd_reg;
+
+	/* Validate any tags that might be present */
+	arg = sieve_ast_argument_first(cmd->ast_node);
+		
+	/* Visit tagged and optional arguments */
+	while ( sieve_ast_argument_type(arg) == SAAT_TAG ) {
+		int id_code;
+		struct sieve_ast_argument *parg; 
+		const struct sieve_argument *tag = 
+			sieve_validator_find_tag(validator, cmd, arg, &id_code);
+		
+		if ( tag == NULL ) {
+			sieve_argument_validate_error(validator, arg, 
+				"unknown tagged argument ':%s' for the %s %s "
+				"(reported only once at first occurence)",
+				sieve_ast_argument_tag(arg), cmd->command->identifier, 
+				sieve_command_type_name(cmd->command));
+			sieve_validator_register_unknown_tag
+				(validator, cmd_reg, sieve_ast_argument_tag(arg));
+			return FALSE;					
+		}
+		
+		/* Check whether previously tagged as unknown */
+		if ( tag->identifier != NULL && *(tag->identifier) == '\0' ) 
+			return FALSE;
+		
+		/* Assign the tagged argument type to the ast for later reference 
+		 * (in generator) 
+		 */
+		arg->argument = tag;
+		arg->arg_id_code = id_code;  
+			
+		/* Scan backwards for any duplicates */
+		parg = sieve_ast_argument_prev(arg);
+		while ( parg != NULL ) {
+			if ( (sieve_ast_argument_type(parg) == SAAT_TAG && parg->argument == tag) 
+				|| (id_code > 0 && parg->arg_id_code == id_code) ) 
+			{
+				const char *tag_id = sieve_ast_argument_tag(arg);
+				const char *tag_desc =
+					strcmp(tag->identifier, tag_id) != 0 ?
+					t_strdup_printf("%s argument (:%s)", tag->identifier, tag_id) : 
+					t_strdup_printf(":%s argument", tag->identifier); 	 
+				
+				sieve_argument_validate_error(validator, arg, 
+					"encountered duplicate %s for the %s %s",
+					tag_desc, cmd->command->identifier, 
+					sieve_command_type_name(cmd->command));
+					
+				return FALSE;	
+			}
+			
+			parg = sieve_ast_argument_prev(parg);
+		}
+		
+		/* Call the validation function for the tag (if present)
+		 *   Fail if the validation fails:
+		 *     Let's not whine multiple	times about a single command having multiple 
+		 *     bad arguments...
+		 */ 
+		if ( tag->validate != NULL ) { 
+			if ( !tag->validate(validator, &arg, cmd) ) 
+				return FALSE;
+		} else
+			arg = sieve_ast_argument_next(arg);
+	} 
+	
+	/* Remaining arguments should be positional (tags are not allowed here) */
+	cmd->first_positional = arg;
+	
+	while ( arg != NULL ) {
+		if ( sieve_ast_argument_type(arg) == SAAT_TAG ) {
+			sieve_argument_validate_error(validator, arg, 
+				"encountered an unexpected tagged argument ':%s' "
+				"while validating positional arguments for the %s %s",
+				sieve_ast_argument_tag(arg), cmd->command->identifier, 
+				sieve_command_type_name(cmd->command));
+			return FALSE;
+		}
+		
+		real_count++;
+	 
+		arg = sieve_ast_argument_next(arg);
+	}
+	
+	/* Check the required count versus the real number of arguments */
+	if ( arg_count >= 0 && real_count != arg_count ) {
+		sieve_command_validate_error(validator, cmd, 
+			"the %s %s requires %d positional argument(s), but %d is/are specified",
+			cmd->command->identifier, sieve_command_type_name(cmd->command), 
+			arg_count, real_count);
+		return FALSE;
+	}
+	
+	/* Call initial validation for persistent arguments */
+	if ( array_is_created(&cmd_reg->persistent_tags) ) {
+  		unsigned int i;
+  	
+		for ( i = 0; i < array_count(&cmd_reg->persistent_tags); i++ ) {
+			struct sieve_tag_registration * const *reg = 
+	  			array_idx(&cmd_reg->persistent_tags, i);
+			const struct sieve_argument *tag = (*reg)->tag;
+  
+			if ( tag != NULL && tag->validate_persistent != NULL ) { /* To be sure */
+				if ( !tag->validate_persistent(validator, cmd) )
+	  				return FALSE;
+			}
+		}
+	}
+
+	return TRUE;
+}
+
+static bool sieve_validate_arguments_context
+(struct sieve_validator *validator, struct sieve_command_context *cmd)
+{ 
+	struct sieve_ast_argument *arg = 
+		sieve_command_first_argument(cmd);
+	
+	while ( arg != NULL ) {
+		const struct sieve_argument *argument = arg->argument;
+		
+		if ( argument != NULL && argument->validate_context != NULL ) { 
+			if ( !argument->validate_context(validator, arg, cmd) ) 
+				return FALSE;
+		}
+		
+		arg = sieve_ast_argument_next(arg);
+	}
+
+	return TRUE;
+}
+ 
+/* 
+ * Command Validation API 
+ */ 
+                 
+static bool sieve_validate_command_subtests
+(struct sieve_validator *valdtr, struct sieve_command_context *cmd, 
+	const unsigned int count) 
+{
+	switch ( count ) {
+	
+	case 0:
+	 	if ( sieve_ast_test_count(cmd->ast_node) > 0 ) {
+			/* Unexpected command specified */
+			enum sieve_command_type ctype = SCT_NONE;
+			struct sieve_command_registration *cmd_reg;
+			struct sieve_ast_node *test = sieve_ast_test_first(cmd->ast_node);
+
+			cmd_reg = sieve_validator_find_command_registration
+				(valdtr, test->identifier);
+	
+			/* First check what we are dealing with */
+			if ( cmd_reg != NULL && cmd_reg->command != NULL )
+				ctype = cmd_reg->command->type;
+
+			switch ( ctype ) {
+			case SCT_TEST: /* Spurious test */
+			case SCT_HYBRID:
+				sieve_command_validate_error(valdtr, cmd, 
+					"the %s %s accepts no sub-tests, but tests are specified", 
+					cmd->command->identifier, sieve_command_type_name(cmd->command));
+				break;
+
+			case SCT_NONE: /* Unknown command */
+
+				/* Is it perhaps a tag for which the ':' was omitted ? */
+				if ( 	sieve_validator_find_tag_by_identifier
+					(valdtr, cmd, test->identifier) != NULL ) {
+					sieve_command_validate_error(valdtr, cmd, 
+						"missing colon ':' before ':%s' tag in %s %s", test->identifier, 
+						cmd->command->identifier, sieve_command_type_name(cmd->command));
+					break;
+				} 
+				/* Fall through */
+			
+			case SCT_COMMAND:
+				sieve_command_validate_error(valdtr, cmd, 
+					"missing semicolon ';' after %s %s", 
+					cmd->command->identifier, sieve_command_type_name(cmd->command));
+				break;
+			}
+			return FALSE;
+		}
+		break;
+	case 1:
+		if ( sieve_ast_test_count(cmd->ast_node) == 0 ) {
+			sieve_command_validate_error(valdtr, cmd, 
+				"the %s %s requires one sub-test, but none is specified", 
+				cmd->command->identifier, sieve_command_type_name(cmd->command));
+				
+			return FALSE;
+			
+		} else if ( sieve_ast_test_count(cmd->ast_node) > 1 || 
+			cmd->ast_node->test_list ) {
+			
+			sieve_command_validate_error(valdtr, cmd, 
+				"the %s %s requires one sub-test, but a list of tests is specified", 
+				cmd->command->identifier, sieve_command_type_name(cmd->command));
+				
+			return FALSE;
+		}
+		break;
+		
+	default:
+		if ( sieve_ast_test_count(cmd->ast_node) == 0 ) {
+			sieve_command_validate_error(valdtr, cmd, 
+				"the %s %s requires a list of sub-tests, but none is specified", 
+				cmd->command->identifier, sieve_command_type_name(cmd->command));
+			
+			return FALSE;
+			
+		} else if ( sieve_ast_test_count(cmd->ast_node) == 1 && 
+			!cmd->ast_node->test_list ) {
+			
+			sieve_command_validate_error(valdtr, cmd, 
+				"the %s %s requires a list of sub-tests, "
+				"but a single test is specified", 
+				cmd->command->identifier, sieve_command_type_name(cmd->command) );
+			
+			return FALSE;
+		}
+		break;		
+	}
+
+	return TRUE;
+}
+
+static bool sieve_validate_command_block
+(struct sieve_validator *validator, struct sieve_command_context *cmd, 
+	bool block_allowed, bool block_required) 
+{
+	i_assert( cmd->ast_node->type == SAT_COMMAND );
+	
+	if ( block_required ) {
+		if ( !cmd->ast_node->block ) {
+			sieve_command_validate_error(validator, cmd, 
+				"the %s command requires a command block, but it is missing", 
+				cmd->command->identifier);
+			
+			return FALSE;
+		}
+	} else if ( !block_allowed && cmd->ast_node->block ) {
+		sieve_command_validate_error(validator, cmd, 
+			"the %s command does not accept a command block, "
+			"but one is specified anyway", 
+			cmd->command->identifier );
+		
+		return FALSE;
+	}
+	
+	return TRUE;
+} 
+
+/* 
+ * AST Validation 
+ */
+
+static bool sieve_validate_test_list
+	(struct sieve_validator *validator, struct sieve_ast_node *test_list); 
+static bool sieve_validate_block
+	(struct sieve_validator *validator, struct sieve_ast_node *block);
+static bool sieve_validate_command
+	(struct sieve_validator *validator, struct sieve_ast_node *cmd_node);
+	
+static bool sieve_validate_command_context
+(struct sieve_validator *valdtr, struct sieve_ast_node *cmd_node) 
+{
+	enum sieve_ast_type ast_type = sieve_ast_node_type(cmd_node);
+	struct sieve_command_registration *cmd_reg;
+	
+	i_assert( ast_type == SAT_TEST || ast_type == SAT_COMMAND );
+	
+	/* Verify the command specified by this node */
+	
+	cmd_reg = sieve_validator_find_command_registration
+		(valdtr, cmd_node->identifier);
+	
+	if ( cmd_reg != NULL && cmd_reg->command != NULL ) {
+		const struct sieve_command *command = cmd_reg->command;
+
+		/* Identifier = "" when the command was previously marked as unknown */
+		if ( *(command->identifier) != '\0' ) {
+			if ( (command->type == SCT_COMMAND && ast_type == SAT_TEST)
+				|| (command->type == SCT_TEST && ast_type == SAT_COMMAND) ) {
+				sieve_validator_error(
+					valdtr, cmd_node->source_line, "attempted to use %s '%s' as %s", 
+					sieve_command_type_name(command), cmd_node->identifier,
+					sieve_ast_type_name(ast_type));
+			
+			 	return FALSE;
+			} 
+			 
+			struct sieve_command_context *ctx = 
+				sieve_command_context_create(cmd_node, command, cmd_reg); 
+			cmd_node->context = ctx;
+
+		} else {
+			return FALSE;
+		}
+
+	}	else {
+		sieve_validator_error(
+			valdtr, cmd_node->source_line, 
+			"unknown %s '%s' (only reported once at first occurence)", 
+			sieve_ast_type_name(ast_type), cmd_node->identifier);
+			
+		sieve_validator_register_unknown_command(valdtr, cmd_node->identifier);
+		
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+static bool sieve_validate_command
+(struct sieve_validator *valdtr, struct sieve_ast_node *cmd_node) 
+{
+	enum sieve_ast_type ast_type = sieve_ast_node_type(cmd_node);
+	struct sieve_command_context *ctx = cmd_node->context;
+	const struct sieve_command *command = ( ctx != NULL ? ctx->command : NULL );
+	bool result = TRUE;
+	
+	i_assert( ast_type == SAT_TEST || ast_type == SAT_COMMAND );
+
+	if ( command != NULL && *(command->identifier) != '\0' ) {
+		
+		if ( command->pre_validate == NULL 
+			|| command->pre_validate(valdtr, ctx) ) {
+	
+			/* Check argument syntax */
+			if ( !sieve_validate_command_arguments(valdtr, ctx) ) {
+				result = FALSE;
+
+				/* A missing ':' causes a tag to become a test. This can be the cause
+				 * of the arguments validation failing. Therefore we must produce an
+				 * error for the sub-tests as well if appropriate.
+				 */
+				(void)sieve_validate_command_subtests(valdtr, ctx, command->subtests);
+
+			} else if (
+				!sieve_validate_command_subtests(valdtr, ctx, command->subtests) || 
+				(ast_type == SAT_COMMAND && !sieve_validate_command_block
+					(valdtr, ctx, command->block_allowed, command->block_required)) ) {
+
+				result = FALSE;
+
+			} else {
+				/* Call command validation function if specified */
+				if ( command->validate != NULL )
+					result = command->validate(valdtr, ctx) && result;
+			}
+		} else {
+			/* If pre-validation fails, don't bother to validate further 
+			 * as context might be missing and doing so is not very useful for 
+			 * further error reporting anyway
+			 */
+			return FALSE;
+		}
+			
+		result = result && sieve_validate_arguments_context(valdtr, ctx);
+								
+	}
+
+	/*  
+	 * Descend further into the AST 
+	 */
+	
+	if ( command != NULL ) {
+		/* Tests */
+		if ( command->subtests > 0 && 
+			(result || sieve_errors_more_allowed(valdtr->ehandler)) )
+			result = sieve_validate_test_list(valdtr, cmd_node) && result;
+
+		/* Command block */
+		if ( command->block_allowed && ast_type == SAT_COMMAND && 
+			(result || sieve_errors_more_allowed(valdtr->ehandler)) )
+			result = sieve_validate_block(valdtr, cmd_node) && result;
+	}
+	
+	return result;
+}
+
+static bool sieve_validate_test_list
+(struct sieve_validator *valdtr, struct sieve_ast_node *test_list) 
+{
+	bool result = TRUE;
+	struct sieve_ast_node *test;
+
+	test = sieve_ast_test_first(test_list);
+	while ( test != NULL 
+		&& (result || sieve_errors_more_allowed(valdtr->ehandler)) ) {
+	
+		result = 
+			sieve_validate_command_context(valdtr, test) && 
+			sieve_validate_command(valdtr, test) &&
+			result;	
+		
+		test = sieve_ast_test_next(test);
+	}		
+	
+	return result;
+}
+
+static bool sieve_validate_block
+(struct sieve_validator *valdtr, struct sieve_ast_node *block) 
+{
+	bool result = TRUE, fatal = FALSE;
+	struct sieve_ast_node *command, *next;
+
+	T_BEGIN {	
+		command = sieve_ast_command_first(block);
+		while ( !fatal &&  command != NULL
+			&& (result || sieve_errors_more_allowed(valdtr->ehandler)) ) {	
+			bool command_success;
+
+			next = sieve_ast_command_next(command);
+			command_success = sieve_validate_command_context(valdtr, command);
+			result = command_success && result;	
+
+	 		/* Check if this is the first non-require command */
+			if ( command_success && sieve_ast_node_type(block) == SAT_ROOT
+				&& !valdtr->finished_require && command->context != NULL
+				&& command->context->command != &cmd_require ) {
+				const struct sieve_validator_extension_reg *extrs;
+				unsigned int ext_count, i;
+
+				valdtr->finished_require = TRUE;
+
+				/* Validate all 'require'd extensions */
+				extrs = array_get(&valdtr->extensions, &ext_count);
+				for ( i = 0; i < ext_count; i++ ) {
+					if ( extrs[i].val_ext != NULL 
+						&& extrs[i].val_ext->validate != NULL ) {
+
+						if ( !extrs[i].val_ext->validate
+							(valdtr, extrs[i].context, extrs[i].arg) )
+						fatal = TRUE;
+						break;
+					} 
+				}
+			}
+
+			result = !fatal && sieve_validate_command(valdtr, command) && result;
+			
+			command = next;
+		}		
+	} T_END;
+	
+	return result && !fatal;
+}
+
+bool sieve_validator_run(struct sieve_validator *validator) 
+{	
+	return sieve_validate_block(validator, sieve_ast_root(validator->ast));
+}
+
+/*
+ * Validator object registry
+ */
+
+struct sieve_validator_object_registry {
+	struct sieve_validator *validator;
+	ARRAY_DEFINE(registrations, const struct sieve_object *);
+};
+
+struct sieve_validator_object_registry *sieve_validator_object_registry_get
+(struct sieve_validator *validator, const struct sieve_extension *ext)
+{
+	return (struct sieve_validator_object_registry *) 
+		sieve_validator_extension_get_context(validator, ext);
+}
+
+void sieve_validator_object_registry_add
+(struct sieve_validator_object_registry *regs, 
+	const struct sieve_object *object) 
+{
+    array_append(&regs->registrations, &object, 1);
+}
+
+const struct sieve_object *sieve_validator_object_registry_find
+(struct sieve_validator_object_registry *regs, const char *identifier) 
+{
+	unsigned int i;
+
+	for ( i = 0; i < array_count(&regs->registrations); i++ ) {
+		const struct sieve_object * const *obj = array_idx(&regs->registrations, i);
+
+		if ( strcasecmp((*obj)->identifier, identifier) == 0)
+			return *obj;
+	}
+
+	return NULL;
+}
+
+struct sieve_validator_object_registry *sieve_validator_object_registry_create
+(struct sieve_validator *validator)
+{
+	pool_t pool = validator->pool;
+	struct sieve_validator_object_registry *regs = 
+		p_new(pool, struct sieve_validator_object_registry, 1);
+	
+	/* Setup registry */        
+	p_array_init(&regs->registrations, validator->pool, 4);
+
+	regs->validator = validator;
+
+	return regs;
+}
+
+struct sieve_validator_object_registry *sieve_validator_object_registry_init
+(struct sieve_validator *validator, const struct sieve_extension *ext)
+{
+	struct sieve_validator_object_registry *regs = 
+		sieve_validator_object_registry_create(validator);
+	
+	sieve_validator_extension_set_context(validator, ext, regs);
+	return regs;
+}
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-validator.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-validator.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/sieve-validator.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/sieve-validator.h	2009-04-18 09:35:33.000000000 +0200
@@ -0,0 +1,164 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+ 
+#ifndef __SIEVE_VALIDATOR_H
+#define __SIEVE_VALIDATOR_H
+
+#include "lib.h"
+
+#include "sieve-common.h"
+
+/*
+ * Types
+ */
+
+enum sieve_argument_type {
+	SAT_NUMBER,
+	SAT_CONST_STRING,
+	SAT_VAR_STRING,
+	SAT_STRING_LIST,
+	
+	SAT_COUNT
+};
+
+struct sieve_command_registration;
+
+/*
+ * Validator
+ */
+ 
+struct sieve_validator;
+
+struct sieve_validator *sieve_validator_create
+	(struct sieve_ast *ast, struct sieve_error_handler *ehandler);
+void sieve_validator_free(struct sieve_validator **validator);
+pool_t sieve_validator_pool(struct sieve_validator *validator);
+
+bool sieve_validator_run(struct sieve_validator *validator);
+
+/*
+ * Accessors
+ */
+ 
+struct sieve_error_handler *sieve_validator_error_handler
+	(struct sieve_validator *validator);
+struct sieve_ast *sieve_validator_ast
+	(struct sieve_validator *validator);
+struct sieve_script *sieve_validator_script
+	(struct sieve_validator *validator);
+
+/*
+ * Error handling
+ */
+
+void sieve_validator_warning
+	(struct sieve_validator *validator, unsigned int source_line, 
+		const char *fmt, ...) ATTR_FORMAT(3, 4);
+void sieve_validator_error
+	(struct sieve_validator *validator, unsigned int source_line, 
+		const char *fmt, ...) ATTR_FORMAT(3, 4);
+void sieve_validator_critical
+	(struct sieve_validator *validator, unsigned int source_line, 
+		const char *fmt, ...) ATTR_FORMAT(3, 4);
+		
+/* 
+ * Command/Test registry
+ */
+ 
+void sieve_validator_register_command
+	(struct sieve_validator *validator, const struct sieve_command *command);
+const struct sieve_command *sieve_validator_find_command
+	(struct sieve_validator *validator, const char *command);	
+	
+void sieve_validator_register_external_tag
+	(struct sieve_validator *validator, const struct sieve_argument *tag, 
+		const char *command, int id_code);
+
+/* 
+ * Per-command tagged argument registry
+ */
+
+void sieve_validator_register_tag
+	(struct sieve_validator *validator, 
+		struct sieve_command_registration *cmd_reg, 
+		const struct sieve_argument *argument, int id_code);
+void sieve_validator_register_persistent_tag
+	(struct sieve_validator *validator, const struct sieve_argument *tag, 
+		const char *command);
+	
+/*
+ * Overriding the default literal arguments
+ */	
+ 
+void sieve_validator_argument_override
+(struct sieve_validator *validator, enum sieve_argument_type type, 
+	const struct sieve_argument *argument);
+bool sieve_validator_argument_activate_super
+(struct sieve_validator *validator, struct sieve_command_context *cmd, 
+	struct sieve_ast_argument *arg, bool constant);
+		
+/* 
+ * Argument validation API
+ */
+
+bool sieve_validate_positional_argument
+	(struct sieve_validator *validator, struct sieve_command_context *cmd,
+	struct sieve_ast_argument *arg, const char *arg_name, unsigned int arg_pos,
+	enum sieve_ast_argument_type req_type);
+bool sieve_validator_argument_activate
+(struct sieve_validator *validator, struct sieve_command_context *cmd,
+	struct sieve_ast_argument *arg, bool constant);
+		
+bool sieve_validate_tag_parameter
+	(struct sieve_validator *validator, struct sieve_command_context *cmd,
+	struct sieve_ast_argument *tag, struct sieve_ast_argument *param,
+	enum sieve_ast_argument_type req_type);
+	
+/* 
+ * Extension support
+ */
+
+struct sieve_validator_extension {
+	const struct sieve_extension *ext;	
+
+	bool (*validate)(struct sieve_validator *valdtr, void *context,
+		struct sieve_ast_argument *require_arg);
+
+	void (*free)(struct sieve_validator *valdtr, void *context);
+};
+
+const struct sieve_extension *sieve_validator_extension_load
+	(struct sieve_validator *validator, struct sieve_command_context *cmd,
+		struct sieve_ast_argument *ext_arg, string_t *ext_name); 
+
+void sieve_validator_extension_register
+	(struct sieve_validator *valdtr, 
+		const struct sieve_validator_extension *val_ext, void *context);
+bool sieve_validator_extension_loaded
+    (struct sieve_validator *valdtr, const struct sieve_extension *ext);
+
+void sieve_validator_extension_set_context
+(struct sieve_validator *valdtr, const struct sieve_extension *ext, 
+	void *context);
+void *sieve_validator_extension_get_context
+(struct sieve_validator *valdtr, const struct sieve_extension *ext);
+
+/*
+ * Validator object registry
+ */
+
+struct sieve_validator_object_registry;
+
+struct sieve_validator_object_registry *sieve_validator_object_registry_get
+	(struct sieve_validator *validator, const struct sieve_extension *ext);
+void sieve_validator_object_registry_add
+	(struct sieve_validator_object_registry *regs,
+		const struct sieve_object *object);
+const struct sieve_object *sieve_validator_object_registry_find
+	(struct sieve_validator_object_registry *regs, const char *identifier);
+struct sieve_validator_object_registry *sieve_validator_object_registry_create
+	(struct sieve_validator *validator);
+struct sieve_validator_object_registry *sieve_validator_object_registry_init
+	(struct sieve_validator *validator, const struct sieve_extension *ext);
+
+#endif /* __SIEVE_VALIDATOR_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/tst-address.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/tst-address.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/tst-address.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/tst-address.c	2009-07-30 00:45:54.000000000 +0200
@@ -0,0 +1,294 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str-sanitize.h"
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-address-parts.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+#include <stdio.h>
+
+/* 
+ * Address test
+ *
+ * Syntax:
+ *    address [ADDRESS-PART] [COMPARATOR] [MATCH-TYPE]
+ *       <header-list: string-list> <key-list: string-list>
+ */
+
+static bool tst_address_registered
+	(struct sieve_validator *valdtr, struct sieve_command_registration *cmd_reg);
+static bool tst_address_validate
+	(struct sieve_validator *valdtr, struct sieve_command_context *tst);
+static bool tst_address_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command tst_address = { 
+	"address", 
+	SCT_TEST, 
+	2, 0, FALSE, FALSE,
+	tst_address_registered,
+	NULL, 
+	tst_address_validate, 
+	tst_address_generate, 
+	NULL 
+};
+
+/* 
+ * Address operation 
+ */
+
+static bool tst_address_operation_dump
+	(const struct sieve_operation *op, 
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_address_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation tst_address_operation = { 
+	"ADDRESS",
+	NULL,
+	SIEVE_OPERATION_ADDRESS,
+	tst_address_operation_dump, 
+	tst_address_operation_execute 
+};
+
+/* 
+ * Test registration 
+ */
+
+static bool tst_address_registered
+	(struct sieve_validator *valdtr, struct sieve_command_registration *cmd_reg) 
+{
+	/* The order of these is not significant */
+	sieve_comparators_link_tag(valdtr, cmd_reg, SIEVE_AM_OPT_COMPARATOR );
+	sieve_address_parts_link_tags(valdtr, cmd_reg, SIEVE_AM_OPT_ADDRESS_PART);
+	sieve_match_types_link_tags(valdtr, cmd_reg, SIEVE_AM_OPT_MATCH_TYPE);
+
+	return TRUE;
+}
+
+/* 
+ * Validation 
+ */
+ 
+/* List of valid headers:
+ *   Implementations MUST restrict the address test to headers that
+ *   contain addresses, but MUST include at least From, To, Cc, Bcc,
+ *   Sender, Resent-From, and Resent-To, and it SHOULD include any other
+ *   header that utilizes an "address-list" structured header body.
+ *
+ * This list explicitly does not contain the envelope-to and return-path 
+ * headers. The envelope test must be used to test against these addresses.
+ *
+ * FIXME: this restriction is somewhat odd. Sieve list advises to allow 
+ *        any other header as long as its content matches the address-list
+ *        grammar.
+ */
+static const char * const _allowed_headers[] = {
+	/* Required */
+	"from", "to", "cc", "bcc", "sender", "resent-from", "resent-to",
+
+	/* Additional (RFC 822 / RFC 2822) */
+	"reply-to", "resent-reply-to", "resent-sender", "resent-cc", "resent-bcc",  
+
+	/* Non-standard (RFC 2076, draft-palme-mailext-headers-08.txt) */
+	"for-approval", "for-handling", "for-comment", "apparently-to", "errors-to", 
+	"delivered-to", "return-receipt-to", "x-admin", "read-receipt-to", 
+	"x-confirm-reading-to", "return-receipt-requested", 
+	"registered-mail-reply-requested-by", "mail-followup-to", "mail-reply-to",
+	"abuse-reports-to", "x-complaints-to", "x-report-abuse-to",
+	
+	/* Undocumented */
+	"x-beenthere",
+	
+	NULL  
+};
+
+static int _header_is_allowed
+(void *context ATTR_UNUSED, struct sieve_ast_argument *arg)
+{
+	if ( sieve_argument_is_string_literal(arg) ) {
+		const char *header = sieve_ast_strlist_strc(arg);
+
+		const char * const *hdsp = _allowed_headers;
+		while ( *hdsp != NULL ) {
+			if ( strcasecmp( *hdsp, header ) == 0 ) 
+				return TRUE;
+
+			hdsp++;
+		}
+		
+		return FALSE;
+	}
+	
+	return TRUE;
+}
+
+static bool tst_address_validate
+	(struct sieve_validator *valdtr, struct sieve_command_context *tst) 
+{
+	struct sieve_ast_argument *arg = tst->first_positional;
+	struct sieve_ast_argument *header;
+		
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "header list", 1, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+	
+	if ( !sieve_validator_argument_activate(valdtr, tst, arg, FALSE) )
+		return FALSE;
+
+	if ( !sieve_command_verify_headers_argument(valdtr, arg) )
+        return FALSE;
+
+	/* Check if supplied header names are allowed
+	 *   FIXME: verify dynamic header names at runtime 
+	 */
+	header = arg;
+	if ( !sieve_ast_stringlist_map(&header, NULL, _header_is_allowed) ) {		
+		sieve_argument_validate_error(valdtr, header, 
+			"specified header '%s' is not allowed for the address test", 
+			str_sanitize(sieve_ast_strlist_strc(header), 64));
+		return FALSE;
+	}
+
+	/* Check key list */
+	
+	arg = sieve_ast_argument_next(arg);
+	
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "key list", 2, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(valdtr, tst, arg, FALSE) )
+		return FALSE;
+	
+	/* Validate the key argument to a specified match type */
+	return sieve_match_type_validate
+		(valdtr, tst, arg, &is_match_type, &i_ascii_casemap_comparator); 
+}
+
+/* 
+ * Code generation 
+ */
+
+static bool tst_address_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx) 
+{
+	sieve_operation_emit_code(cgenv->sbin, &tst_address_operation);
+	
+	/* Generate arguments */  	
+	return sieve_generate_arguments(cgenv, ctx, NULL);
+}
+
+/* 
+ * Code dump 
+ */
+
+static bool tst_address_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,	
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	sieve_code_dumpf(denv, "ADDRESS");
+	sieve_code_descend(denv);
+	
+	/* Handle any optional arguments */
+	if ( !sieve_addrmatch_default_dump_optionals(denv, address) )
+		return FALSE;
+
+	return
+		sieve_opr_stringlist_dump(denv, address, "header list") &&
+		sieve_opr_stringlist_dump(denv, address, "key list");
+}
+
+/* 
+ * Code execution 
+ */
+
+static int tst_address_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED, 
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{	
+	bool result = TRUE;
+	const struct sieve_comparator *cmp = &i_ascii_casemap_comparator;
+	const struct sieve_match_type *mtch = &is_match_type;
+	const struct sieve_address_part *addrp = &all_address_part;
+	struct sieve_match_context *mctx;
+	struct sieve_coded_stringlist *hdr_list;
+	struct sieve_coded_stringlist *key_list;
+	string_t *hdr_item;
+	bool matched;
+	int ret;
+	
+	/* Read optional operands */
+	if ( (ret=sieve_addrmatch_default_get_optionals
+		(renv, address, &addrp, &mtch, &cmp)) <= 0 ) 
+		return ret;
+		
+	/* Read header-list */
+	if ( (hdr_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid header-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Read key-list */
+	if ( (key_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid key-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	sieve_runtime_trace(renv, "ADDRESS test");
+
+	/* Initialize match context */
+	mctx = sieve_match_begin(renv->interp, mtch, cmp, NULL, key_list);
+	
+	/* Iterate through all requested headers to match */
+	hdr_item = NULL;
+	matched = FALSE;
+	while ( result && !matched && 
+		(result=sieve_coded_stringlist_next_item(hdr_list, &hdr_item)) 
+		&& hdr_item != NULL ) {
+		const char *const *headers;
+			
+		if ( mail_get_headers_utf8(renv->msgdata->mail, str_c(hdr_item), &headers) >= 0 ) {	
+			int i;
+
+			for ( i = 0; !matched && headers[i] != NULL; i++ ) {
+				if ( (ret=sieve_address_match(addrp, mctx, headers[i])) < 0 ) {
+					result = FALSE;
+					break;
+				}
+				
+				matched = ret > 0;				
+			} 
+		}
+	}
+	
+	/* Finish match */
+
+	if ( (ret=sieve_match_end(&mctx)) < 0 )
+		result = FALSE;
+	else
+		matched = ( ret > 0 || matched );
+	
+	/* Set test result for subsequent conditional jump */
+	if ( result ) {
+		sieve_interpreter_set_test_result(renv->interp, matched);
+		return SIEVE_EXEC_OK;
+	}
+
+	sieve_runtime_trace_error(renv, "invalid string-list item");	
+	return SIEVE_EXEC_BIN_CORRUPT;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/tst-allof.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/tst-allof.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/tst-allof.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/tst-allof.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,86 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+
+/* 
+ * Allof test 
+ * 
+ * Syntax 
+ *   allof <tests: test-list>   
+ */
+
+static bool tst_allof_generate
+	(const struct sieve_codegen_env *cgenv, 
+		struct sieve_command_context *ctx,
+		struct sieve_jumplist *jumps, bool jump_true);
+
+const struct sieve_command tst_allof = { 
+	"allof", 
+	SCT_TEST, 
+	0, 2, FALSE, FALSE,
+	NULL, NULL, NULL, NULL, 
+	tst_allof_generate 
+};
+
+/* 
+ * Code generation 
+ */
+
+static bool tst_allof_generate
+(const struct sieve_codegen_env *cgenv, 
+	struct sieve_command_context *ctx,
+	struct sieve_jumplist *jumps, bool jump_true)
+{
+	struct sieve_binary *sbin = cgenv->sbin;
+	struct sieve_ast_node *test;
+	struct sieve_jumplist false_jumps;
+
+	if ( sieve_ast_test_count(ctx->ast_node) > 1 ) {	
+		if ( jump_true ) {
+			/* Prepare jumplist */
+			sieve_jumplist_init_temp(&false_jumps, sbin);
+		}
+	
+		test = sieve_ast_test_first(ctx->ast_node);
+		while ( test != NULL ) {	
+			bool result; 
+
+			/* If this test list must jump on false, all sub-tests can simply add their jumps
+			 * to the caller's jump list, otherwise this test redirects all false jumps to the 
+			 * end of the currently generated code. This is just after a final jump to the true
+			 * case 
+			 */
+			if ( jump_true ) 
+				result = sieve_generate_test(cgenv, test, &false_jumps, FALSE);
+			else
+				result = sieve_generate_test(cgenv, test, jumps, FALSE);
+		
+			if ( !result ) return FALSE;
+
+			test = sieve_ast_test_next(test);
+		}	
+	
+		if ( jump_true ) {
+			/* All tests succeeded, jump to case TRUE */
+			sieve_operation_emit_code(cgenv->sbin, &sieve_jmp_operation);
+			sieve_jumplist_add(jumps, sieve_binary_emit_offset(sbin, 0));
+			
+			/* All false exits jump here */
+			sieve_jumplist_resolve(&false_jumps);
+		}
+	} else {
+		/* Script author is being inefficient; we can optimize the allof test away */
+		test = sieve_ast_test_first(ctx->ast_node);
+		sieve_generate_test(cgenv, test, jumps, jump_true);
+	}
+		
+	return TRUE;
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/tst-anyof.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/tst-anyof.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/tst-anyof.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/tst-anyof.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,83 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-generator.h"
+#include "sieve-validator.h"
+#include "sieve-binary.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+
+/* 
+ * Anyof test 
+ *
+ * Syntax 
+ *   anyof <tests: test-list>   
+ */
+
+static bool tst_anyof_generate	
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx,
+		struct sieve_jumplist *jumps, bool jump_true);
+
+const struct sieve_command tst_anyof = { 
+	"anyof", 
+	SCT_TEST, 
+	0, 2, FALSE, FALSE,
+	NULL, NULL, NULL, NULL, 
+	tst_anyof_generate 
+};
+
+/* 
+ * Code generation 
+ */
+
+static bool tst_anyof_generate	
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx,
+		struct sieve_jumplist *jumps, bool jump_true)
+{
+	struct sieve_binary *sbin = cgenv->sbin;
+	struct sieve_ast_node *test;
+	struct sieve_jumplist true_jumps;
+
+	if ( sieve_ast_test_count(ctx->ast_node) > 1 ) {	
+		if ( !jump_true ) {
+			/* Prepare jumplist */
+			sieve_jumplist_init_temp(&true_jumps, sbin);
+		}
+	
+		test = sieve_ast_test_first(ctx->ast_node);
+		while ( test != NULL ) {	
+			bool result;
+
+			/* If this test list must jump on true, all sub-tests can simply add their jumps
+			 * to the caller's jump list, otherwise this test redirects all true jumps to the 
+			 * end of the currently generated code. This is just after a final jump to the false
+			 * case 
+			 */
+			if ( !jump_true ) 
+				result = sieve_generate_test(cgenv, test, &true_jumps, TRUE);
+			else
+				result = sieve_generate_test(cgenv, test, jumps, TRUE);
+
+			if ( !result ) return FALSE;
+		
+			test = sieve_ast_test_next(test);
+		}	
+	
+		if ( !jump_true ) {
+			/* All tests failed, jump to case FALSE */
+			sieve_operation_emit_code(sbin, &sieve_jmp_operation);
+			sieve_jumplist_add(jumps, sieve_binary_emit_offset(sbin, 0));
+			
+			/* All true exits jump here */
+			sieve_jumplist_resolve(&true_jumps);
+		}
+	} else {
+		/* Script author is being inefficient; we can optimize the allof test away */
+        test = sieve_ast_test_first(ctx->ast_node);
+        sieve_generate_test(cgenv, test, jumps, jump_true);
+    }		
+		
+	return TRUE;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/tst-exists.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/tst-exists.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/tst-exists.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/tst-exists.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,145 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-code-dumper.h"
+
+/* 
+ * Exists test
+ *  
+ * Syntax:
+ *    exists <header-names: string-list>
+ */
+
+static bool tst_exists_validate
+	(struct sieve_validator *valdtr, struct sieve_command_context *tst);
+static bool tst_exists_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command tst_exists = { 
+	"exists", 
+	SCT_TEST, 
+	1, 0, FALSE, FALSE,
+	NULL, 
+	NULL,
+	tst_exists_validate, 
+	tst_exists_generate, 
+	NULL 
+};
+
+/* 
+ * Exists operation 
+ */
+
+static bool tst_exists_operation_dump
+	(const struct sieve_operation *op, 
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_exists_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation tst_exists_operation = { 
+	"EXISTS",
+	NULL,
+	SIEVE_OPERATION_EXISTS,
+	tst_exists_operation_dump, 
+	tst_exists_operation_execute 
+};
+
+/* 
+ * Validation 
+ */
+
+static bool tst_exists_validate
+  (struct sieve_validator *valdtr, struct sieve_command_context *tst) 
+{
+	struct sieve_ast_argument *arg = tst->first_positional;
+		
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "header names", 1, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+	
+	if ( !sieve_validator_argument_activate(valdtr, tst, arg, FALSE) )
+		return FALSE;
+
+	return sieve_command_verify_headers_argument(valdtr, arg);
+}
+
+/* 
+ * Code generation 
+ */
+
+static bool tst_exists_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx) 
+{
+	sieve_operation_emit_code(cgenv->sbin, &tst_exists_operation);
+
+ 	/* Generate arguments */
+    return sieve_generate_arguments(cgenv, ctx, NULL);
+}
+
+/* 
+ * Code dump 
+ */
+
+static bool tst_exists_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED, 
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+    sieve_code_dumpf(denv, "EXISTS");
+	sieve_code_descend(denv);
+
+	return sieve_opr_stringlist_dump(denv, address, "header names");
+}
+
+/* 
+ * Code execution 
+ */
+
+static int tst_exists_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED, 
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	bool result = TRUE;
+	struct sieve_coded_stringlist *hdr_list;
+	string_t *hdr_item;
+	bool matched;
+	
+	/* Read header-list */
+	if ( (hdr_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid header-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	sieve_runtime_trace(renv, "EXISTS test");
+		
+	/* Iterate through all requested headers to match (must find all specified) */
+	hdr_item = NULL;
+	matched = TRUE;
+	while ( matched &&
+		(result=sieve_coded_stringlist_next_item(hdr_list, &hdr_item)) 
+		&& hdr_item != NULL ) {
+		const char *const *headers;
+			
+		if ( mail_get_headers
+			(renv->msgdata->mail, str_c(hdr_item), &headers) < 0 ||
+			headers[0] == NULL ) {	
+			matched = FALSE;				 
+		}
+	}
+	
+	/* Set test result for subsequent conditional jump */
+	if ( result ) {
+		sieve_interpreter_set_test_result(renv->interp, matched);
+		return SIEVE_EXEC_OK;
+	}
+	
+	sieve_runtime_trace_error(renv, "invalid header-list item");
+	return SIEVE_EXEC_BIN_CORRUPT;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/tst-header.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/tst-header.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/tst-header.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/tst-header.c	2009-07-30 00:43:35.000000000 +0200
@@ -0,0 +1,249 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+/* 
+ * Header test 
+ *
+ * Syntax:
+ *   header [COMPARATOR] [MATCH-TYPE]
+ *     <header-names: string-list> <key-list: string-list>
+ */
+
+static bool tst_header_registered
+	(struct sieve_validator *valdtr, struct sieve_command_registration *cmd_reg);
+static bool tst_header_validate
+	(struct sieve_validator *valdtr, struct sieve_command_context *tst);
+static bool tst_header_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command tst_header = { 
+	"header", 
+	SCT_TEST, 
+	2, 0, FALSE, FALSE,
+	tst_header_registered, 
+	NULL,
+	tst_header_validate, 
+	tst_header_generate, 
+	NULL 
+};
+
+/* 
+ * Header operation 
+ */
+
+static bool tst_header_operation_dump
+	(const struct sieve_operation *op, 
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_header_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation tst_header_operation = { 
+	"HEADER",
+	NULL,
+	SIEVE_OPERATION_HEADER,
+	tst_header_operation_dump, 
+	tst_header_operation_execute 
+};
+
+/* 
+ * Test registration 
+ */
+
+static bool tst_header_registered
+	(struct sieve_validator *valdtr, struct sieve_command_registration *cmd_reg) 
+{
+	/* The order of these is not significant */
+	sieve_comparators_link_tag(valdtr, cmd_reg, SIEVE_MATCH_OPT_COMPARATOR);
+	sieve_match_types_link_tags(valdtr, cmd_reg, SIEVE_MATCH_OPT_MATCH_TYPE);
+
+	return TRUE;
+}
+
+/* 
+ * Validation 
+ */
+ 
+static bool tst_header_validate
+	(struct sieve_validator *valdtr, struct sieve_command_context *tst) 
+{ 		
+	struct sieve_ast_argument *arg = tst->first_positional;
+	
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "header names", 1, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+	
+	if ( !sieve_validator_argument_activate(valdtr, tst, arg, FALSE) )
+		return FALSE;
+
+	if ( !sieve_command_verify_headers_argument(valdtr, arg) )
+		return FALSE;
+	
+	arg = sieve_ast_argument_next(arg);
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "key list", 2, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+	
+	if ( !sieve_validator_argument_activate(valdtr, tst, arg, FALSE) )
+		return FALSE;
+
+	/* Validate the key argument to a specified match type */
+	return sieve_match_type_validate
+		(valdtr, tst, arg, &is_match_type, &i_ascii_casemap_comparator);
+}
+
+/*
+ * Code generation 
+ */
+
+static bool tst_header_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx) 
+{
+	sieve_operation_emit_code(cgenv->sbin, &tst_header_operation);
+
+ 	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, ctx, NULL);
+}
+
+/* 
+ * Code dump 
+ */
+
+static bool tst_header_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	int opt_code = 0;
+
+	sieve_code_dumpf(denv, "HEADER");
+	sieve_code_descend(denv);
+
+	/* Handle any optional arguments */
+	if ( !sieve_match_dump_optional_operands(denv, address, &opt_code) )
+		return FALSE;
+
+	if ( opt_code != SIEVE_MATCH_OPT_END )
+		return FALSE;
+	
+	return
+		sieve_opr_stringlist_dump(denv, address, "header names") &&
+		sieve_opr_stringlist_dump(denv, address, "key list");
+}
+
+/* 
+ * Code execution 
+ */
+
+static inline string_t *_header_right_trim(const char *raw) 
+{
+	string_t *result;
+	int i;
+	
+	for ( i = strlen(raw)-1; i >= 0; i-- ) {
+		if ( raw[i] != ' ' && raw[i] != '\t' ) break;
+	}
+	
+	result = t_str_new(i+1);
+	str_append_n(result, raw, i + 1);
+	return result;
+}
+
+static int tst_header_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED, 
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	bool result = TRUE;
+	int opt_code = 0;
+	const struct sieve_comparator *cmp = &i_ascii_casemap_comparator;
+	const struct sieve_match_type *mtch = &is_match_type;
+	struct sieve_match_context *mctx;
+	struct sieve_coded_stringlist *hdr_list;
+	struct sieve_coded_stringlist *key_list;
+	string_t *hdr_item;
+	bool matched;
+	int ret;
+	
+	/* Handle match-type and comparator operands */
+	if ( (ret=sieve_match_read_optional_operands
+		(renv, address, &opt_code, &cmp, &mtch)) <= 0 )
+		return ret;
+	
+	/* Check whether we neatly finished the list of optional operands*/
+	if ( opt_code != SIEVE_MATCH_OPT_END) {
+		sieve_runtime_trace_error(renv, "invalid optional operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+		
+	/* Read header-list */
+	if ( (hdr_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid header-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/* Read key-list */
+	if ( (key_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid key-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	sieve_runtime_trace(renv, "HEADER test");
+
+	/* Initialize match */
+	mctx = sieve_match_begin(renv->interp, mtch, cmp, NULL, key_list); 	
+
+	/* Iterate through all requested headers to match */
+	hdr_item = NULL;
+	matched = FALSE;
+	while ( result && !matched && 
+		(result=sieve_coded_stringlist_next_item(hdr_list, &hdr_item)) 
+		&& hdr_item != NULL ) {
+		const char *const *headers;
+			
+		if ( mail_get_headers_utf8
+			(renv->msgdata->mail, str_c(hdr_item), &headers) >= 0 ) {	
+			int i;
+
+			for ( i = 0; !matched && headers[i] != NULL; i++ ) {
+				string_t *theader = _header_right_trim(headers[i]);
+			
+				if ( (ret=sieve_match_value(mctx, str_c(theader), str_len(theader))) 
+					< 0 ) 
+				{
+					result = FALSE;
+					break;
+				}
+
+				matched = ret > 0;				
+			} 
+		}
+	}
+
+	/* Finish match */
+	if ( (ret=sieve_match_end(&mctx)) < 0 ) 
+		result = FALSE;
+	else
+		matched = ( ret > 0 || matched );
+	
+	/* Set test result for subsequent conditional jump */
+	if ( result ) {
+		sieve_interpreter_set_test_result(renv->interp, matched);
+		return SIEVE_EXEC_OK;
+	}	
+
+	sieve_runtime_trace_error(renv, "invalid string-list item");
+	return SIEVE_EXEC_BIN_CORRUPT;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/tst-not.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/tst-not.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/tst-not.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/tst-not.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,43 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+
+/* 
+ * Not test 
+ *
+ * Syntax:
+ *   not <tests: test-list>   
+ */
+
+static bool tst_not_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx,
+		struct sieve_jumplist *jumps, bool jump_true);
+
+const struct sieve_command tst_not = { 
+	"not", 
+	SCT_TEST, 
+	0, 1, FALSE, FALSE,
+	NULL, NULL, NULL, NULL, 
+	tst_not_generate 
+};
+
+/* 
+ * Code generation 
+ */
+
+static bool tst_not_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx,
+	struct sieve_jumplist *jumps, bool jump_true)
+{
+	struct sieve_ast_node *test;
+	
+	/* Validator verified the existance of the single test already */
+	test = sieve_ast_test_first(ctx->ast_node); 
+	
+	return sieve_generate_test(cgenv, test, jumps, !jump_true);
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/tst-size.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/tst-size.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/tst-size.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/tst-size.c	2009-02-11 21:38:58.000000000 +0100
@@ -0,0 +1,276 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+
+#include "sieve-common.h"
+#include "sieve-code.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-code-dumper.h"
+
+/* 
+ * Size test 
+ *
+ * Syntax:
+ *    size <":over" / ":under"> <limit: number>
+ */
+
+static bool tst_size_registered
+	(struct sieve_validator *validator, 
+		struct sieve_command_registration *cmd_reg);
+static bool tst_size_pre_validate
+	(struct sieve_validator *validator, struct sieve_command_context *tst);
+static bool tst_size_validate
+	(struct sieve_validator *validator, struct sieve_command_context *tst);
+static bool tst_size_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx); 
+
+const struct sieve_command tst_size = { 
+	"size", 
+	SCT_TEST, 
+	1, 0, FALSE, FALSE,
+	tst_size_registered, 
+	tst_size_pre_validate,
+	tst_size_validate, 
+	tst_size_generate, 
+	NULL 
+};
+
+/* 
+ * Size operations 
+ */
+
+static bool tst_size_operation_dump
+	(const struct sieve_operation *op, 
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_size_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation tst_size_over_operation = { 
+	"SIZE-OVER",
+	NULL, 
+	SIEVE_OPERATION_SIZE_OVER,
+	tst_size_operation_dump, 
+	tst_size_operation_execute 
+};
+
+const struct sieve_operation tst_size_under_operation = {
+	"SIZE-UNDER",
+	NULL, 
+	SIEVE_OPERATION_SIZE_UNDER,
+	tst_size_operation_dump, 
+	tst_size_operation_execute 
+};
+
+/* 
+ * Context data
+ */
+
+struct tst_size_context_data {
+	enum { SIZE_UNASSIGNED, SIZE_UNDER, SIZE_OVER } type;
+};
+
+#define TST_SIZE_ERROR_DUP_TAG \
+	"exactly one of the ':under' or ':over' tags must be specified " \
+	"for the size test, but more were found"
+
+/* 
+ * Tag validation 
+ */
+
+static bool tst_size_validate_over_tag
+(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *tst)
+{
+	struct tst_size_context_data *ctx_data = 
+		(struct tst_size_context_data *) tst->data;	
+	
+	if ( ctx_data->type != SIZE_UNASSIGNED ) {
+		sieve_argument_validate_error(validator, *arg, TST_SIZE_ERROR_DUP_TAG);
+		return FALSE;		
+	}
+	
+	ctx_data->type = SIZE_OVER;
+	
+	/* Delete this tag */
+	*arg = sieve_ast_arguments_detach(*arg, 1);
+	
+	return TRUE;
+}
+
+static bool tst_size_validate_under_tag
+(struct sieve_validator *validator, struct sieve_ast_argument **arg ATTR_UNUSED, 
+	struct sieve_command_context *tst)
+{
+	struct tst_size_context_data *ctx_data = 
+		(struct tst_size_context_data *) tst->data;	
+	
+	if ( ctx_data->type != SIZE_UNASSIGNED ) {
+		sieve_argument_validate_error(validator, *arg, TST_SIZE_ERROR_DUP_TAG);
+		return FALSE;		
+	}
+	
+	ctx_data->type = SIZE_UNDER;
+	
+	/* Delete this tag */
+	*arg = sieve_ast_arguments_detach(*arg, 1);
+		
+	return TRUE;
+}
+
+/* 
+ * Test registration 
+ */
+
+static const struct sieve_argument size_over_tag = { 
+	"over", 
+	NULL, NULL,
+	tst_size_validate_over_tag, 
+	NULL, NULL 
+};
+
+static const struct sieve_argument size_under_tag = { 
+	"under", 
+	NULL, NULL, 
+	tst_size_validate_under_tag, 
+	NULL, NULL 
+};
+
+static bool tst_size_registered
+(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg) 
+{
+	/* Register our tags */
+	sieve_validator_register_tag(validator, cmd_reg, &size_over_tag, 0); 	
+	sieve_validator_register_tag(validator, cmd_reg, &size_under_tag, 0); 	
+
+	return TRUE;
+}
+
+/* 
+ * Test validation 
+ */
+
+static bool tst_size_pre_validate
+(struct sieve_validator *validator ATTR_UNUSED, 
+	struct sieve_command_context *tst) 
+{
+	struct tst_size_context_data *ctx_data;
+	
+	/* Assign context */
+	ctx_data = p_new(sieve_command_pool(tst), struct tst_size_context_data, 1);
+	ctx_data->type = SIZE_UNASSIGNED;
+	tst->data = ctx_data;
+
+	return TRUE;
+}
+
+static bool tst_size_validate
+	(struct sieve_validator *validator, struct sieve_command_context *tst) 
+{
+	struct tst_size_context_data *ctx_data = 
+		(struct tst_size_context_data *) tst->data;
+	struct sieve_ast_argument *arg = tst->first_positional;
+	
+	if ( ctx_data->type == SIZE_UNASSIGNED ) {
+		sieve_command_validate_error(validator, tst, 
+			"the size test requires either the :under or the :over tag "
+			"to be specified");
+		return FALSE;		
+	}
+		
+	if ( !sieve_validate_positional_argument
+		(validator, tst, arg, "limit", 1, SAAT_NUMBER) ) {
+		return FALSE;
+	}
+	
+	return sieve_validator_argument_activate(validator, tst, arg, FALSE);
+}
+
+/* 
+ * Code generation 
+ */
+
+bool tst_size_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx) 
+{
+	struct tst_size_context_data *ctx_data = 
+		(struct tst_size_context_data *) ctx->data;
+
+	if ( ctx_data->type == SIZE_OVER ) 
+		sieve_operation_emit_code(cgenv->sbin, &tst_size_over_operation);
+	else
+		sieve_operation_emit_code(cgenv->sbin, &tst_size_under_operation);
+
+ 	/* Generate arguments */
+	if ( !sieve_generate_arguments(cgenv, ctx, NULL) )
+		return FALSE;
+	  
+	return TRUE;
+}
+
+/* 
+ * Code dump 
+ */
+
+static bool tst_size_operation_dump
+(const struct sieve_operation *op,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+    sieve_code_dumpf(denv, "%s", op->mnemonic);
+	sieve_code_descend(denv);
+	
+	return 
+		sieve_opr_number_dump(denv, address, "limit");
+}
+
+/* 
+ * Code execution 
+ */
+
+static inline bool tst_size_get
+(const struct sieve_runtime_env *renv, sieve_number_t *size) 
+{
+	uoff_t psize;
+
+	if ( mail_get_physical_size(renv->msgdata->mail, &psize) < 0 )
+		return FALSE;
+
+	*size = psize;
+  
+	return TRUE;
+}
+
+static int tst_size_operation_execute
+(const struct sieve_operation *op,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	sieve_number_t mail_size, limit;
+		
+	/* Read size limit */
+	if ( !sieve_opr_number_read(renv, address, &limit) ) {
+		sieve_runtime_trace_error(renv, "invalid limit operand");
+		return SIEVE_EXEC_BIN_CORRUPT;	
+	}
+
+	sieve_runtime_trace(renv, "%s test", op->mnemonic);
+	
+	/* Get the size of the message */
+	if ( !tst_size_get(renv, &mail_size) ) {
+		/* FIXME: improve this error */
+		sieve_sys_error("failed to assess message size");
+		return SIEVE_EXEC_FAILURE;
+	}
+	
+	/* Perform the test */
+	if ( op == &tst_size_over_operation )
+		sieve_interpreter_set_test_result(renv->interp, (mail_size > limit));
+	else
+		sieve_interpreter_set_test_result(renv->interp, (mail_size < limit));
+
+	return SIEVE_EXEC_OK;
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/tst-truefalse.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/tst-truefalse.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve/tst-truefalse.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve/tst-truefalse.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,65 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-ast.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-interpreter.h"
+
+/*
+ * True/False test command
+ */
+
+static bool tst_false_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *cmd,
+		struct sieve_jumplist *jumps, bool jump_true);
+static bool tst_true_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *cmd,
+		struct sieve_jumplist *jumps, bool jump_true);
+
+const struct sieve_command tst_false = { 
+	"false", 
+	SCT_TEST, 
+	0, 0, FALSE, FALSE,
+	NULL, NULL, NULL, NULL, 
+	tst_false_generate 
+};
+
+const struct sieve_command tst_true = { 
+	"true", 
+	SCT_TEST, 
+	0, 0, FALSE, FALSE,
+	NULL, NULL, NULL, NULL, 
+	tst_true_generate 
+};
+
+static bool tst_false_generate
+(const struct sieve_codegen_env *cgenv, 
+	struct sieve_command_context *cmd ATTR_UNUSED,
+	struct sieve_jumplist *jumps, bool jump_true)
+{
+	if ( !jump_true ) {
+		sieve_operation_emit_code(cgenv->sbin, &sieve_jmp_operation);
+		sieve_jumplist_add(jumps, sieve_binary_emit_offset(cgenv->sbin, 0));
+	}
+	
+	return TRUE;
+}
+
+static bool tst_true_generate
+(const struct sieve_codegen_env *cgenv,	
+	struct sieve_command_context *cmd ATTR_UNUSED,
+	struct sieve_jumplist *jumps, bool jump_true)
+{
+	if ( jump_true ) {
+		sieve_operation_emit_code(cgenv->sbin, &sieve_jmp_operation);
+		sieve_jumplist_add(jumps, sieve_binary_emit_offset(cgenv->sbin, 0));
+	}
+	
+	return TRUE;
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve-tool/mail-raw.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve-tool/mail-raw.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve-tool/mail-raw.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve-tool/mail-raw.c	2009-05-29 22:29:27.000000000 +0200
@@ -0,0 +1,284 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* FIXME: This file was gratefully stolen from dovecot/src/deliver/deliver.c and 
+ * altered to suit our needs. So, this contains lots and lots of duplicated 
+ * code. 
+ */
+
+#include "lib.h"
+#include "istream.h"
+#include "istream-seekable.h"
+#include "fd-set-nonblock.h"
+#include "str.h"
+#include "str-sanitize.h"
+#include "strescape.h"
+#include "safe-mkstemp.h"
+#include "close-keep-errno.h"
+#include "mkdir-parents.h"
+#include "message-address.h"
+#include "mbox-from.h"
+#include "raw-storage.h"
+#include "mail-namespace.h"
+
+#include "mail-raw.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <pwd.h>
+
+/*
+ * Configuration
+ */
+
+#define DEFAULT_ENVELOPE_SENDER "MAILER-DAEMON"
+
+/* After buffer grows larger than this, create a temporary file to /tmp
+   where to read the mail. */
+#define MAIL_MAX_MEMORY_BUFFER (1024*128)
+
+static const char *wanted_headers[] = {
+	"From", "Message-ID", "Subject", "Return-Path",
+	NULL
+};
+
+/*
+ * Global data
+ */
+
+static struct mail_namespace *raw_ns;
+static struct mail_user *raw_mail_user;
+
+/*
+ * Raw mail implementation
+ */
+
+static int seekable_fd_callback
+(const char **path_r, void *context ATTR_UNUSED)
+{
+	const char *dir, *p;
+	string_t *path;
+	int fd;
+
+	path = t_str_new(128);
+	str_append(path, "/tmp/dovecot.sieve-tool.");
+	fd = safe_mkstemp(path, 0600, (uid_t)-1, (gid_t)-1);
+	if (fd == -1 && errno == ENOENT) {
+		dir = str_c(path);
+		p = strrchr(dir, '/');
+		if (p != NULL) {
+			dir = t_strdup_until(dir, p);
+			if ( mkdir_parents(dir, 0600) < 0 ) {
+				i_error("mkdir_parents(%s) failed: %m", dir);
+				return -1;
+			}
+			fd = safe_mkstemp(path, 0600, (uid_t)-1, (gid_t)-1);
+		}
+	}
+
+	if (fd == -1) {
+		i_error("safe_mkstemp(%s) failed: %m", str_c(path));
+		return -1;
+	}
+
+	/* we just want the fd, unlink it */
+	if (unlink(str_c(path)) < 0) {
+		/* shouldn't happen.. */
+		i_error("unlink(%s) failed: %m", str_c(path));
+		close_keep_errno(fd);
+		return -1;
+	}
+
+	*path_r = str_c(path);
+	return fd;
+}
+
+static struct istream *create_raw_stream
+(int fd, time_t *mtime_r, const char **sender)
+{
+	struct istream *input, *input2, *input_list[2];
+	const unsigned char *data;
+	size_t i, size;
+	int ret, tz;
+	char *env_sender;
+
+	*mtime_r = (time_t)-1;
+	fd_set_nonblock(fd, FALSE);
+
+	input = i_stream_create_fd(fd, 4096, FALSE);
+	input->blocking = TRUE;
+	/* If input begins with a From-line, drop it */
+	ret = i_stream_read_data(input, &data, &size, 5);
+	if (ret > 0 && size >= 5 && memcmp(data, "From ", 5) == 0) {
+		/* skip until the first LF */
+		i_stream_skip(input, 5);
+		while ((ret = i_stream_read_data(input, &data, &size, 0)) > 0) {
+			for (i = 0; i < size; i++) {
+				if (data[i] == '\n')
+					break;
+			}
+			if (i != size) {
+				(void)mbox_from_parse(data, i, mtime_r, &tz, &env_sender);
+				i_stream_skip(input, i + 1);
+				break;
+			}
+			i_stream_skip(input, size);
+		}
+	}
+
+	if (sender != NULL) {
+		*sender = t_strdup(env_sender);
+	}
+	i_free(env_sender);
+
+	if (input->v_offset == 0) {
+		input2 = input;
+		i_stream_ref(input2);
+	} else {
+		input2 = i_stream_create_limit(input, (uoff_t)-1);
+	}
+	i_stream_unref(&input);
+
+    input_list[0] = input2; input_list[1] = NULL;
+    input = i_stream_create_seekable(input_list, MAIL_MAX_MEMORY_BUFFER,
+                     seekable_fd_callback, raw_mail_user);
+    i_stream_unref(&input2);
+    return input;
+
+}
+
+/*
+ * Init/Deinit
+ */
+
+void mail_raw_init(const char *user) 
+{
+	const char *error;
+
+	raw_mail_user = mail_user_init(user);
+	mail_user_set_home(raw_mail_user, NULL);
+	raw_ns = mail_namespaces_init_empty(raw_mail_user);
+	raw_ns->flags |= NAMESPACE_FLAG_NOQUOTA | NAMESPACE_FLAG_NOACL;
+	
+	if ( mail_storage_create(raw_ns, "raw", "/tmp",
+		MAIL_STORAGE_FLAG_FULL_FS_ACCESS,
+		FILE_LOCK_METHOD_FCNTL, &error) < 0 ) {
+ 		i_fatal("Couldn't create internal raw storage: %s", error);
+	}
+}
+
+void mail_raw_deinit(void)
+{
+	mail_user_unref(&raw_mail_user);
+}
+
+
+/*
+ * Open raw mail data
+ */
+
+static struct mail_raw *mail_raw_create
+(struct istream *input, const char *mailfile, const char *sender,
+	time_t mtime)
+{
+	pool_t pool;
+	struct raw_mailbox *raw_box;
+	struct mail_raw *mailr;
+	enum mail_error error;
+
+	if ( mailfile != NULL ) {
+		if ( *mailfile != '/') {
+			char cwd[PATH_MAX];
+
+			/* Expand relative paths */
+			if (getcwd(cwd, sizeof(cwd)) == NULL)
+				i_fatal("getcwd() failed: %m");
+
+			mailfile = t_strconcat(cwd, "/", mailfile, NULL);		
+		} 
+	}
+
+	pool = pool_alloconly_create("mail_raw", 1024);
+	mailr = p_new(pool, struct mail_raw, 1);
+	mailr->pool = pool;
+
+	if ( mailfile == NULL ) {
+		mailr->box = mailbox_open(&raw_ns->storage, "Dovecot Raw Mail",
+				   input, MAILBOX_OPEN_NO_INDEX_FILES);
+	} else {
+		mtime = (time_t)-1;
+		mailr->box = mailbox_open(&raw_ns->storage, mailfile, NULL,
+				   MAILBOX_OPEN_NO_INDEX_FILES);
+	}
+
+	if ( mailr->box == NULL ) {
+		i_fatal("Can't open mail stream as raw: %s",
+			mail_storage_get_last_error(raw_ns->storage, &error));
+	}
+
+	if ( mailbox_sync(mailr->box, 0, 0, NULL ) < 0) {
+		enum mail_error error;
+
+		i_fatal("Can't sync delivery mail: %s",
+			mail_storage_get_last_error(raw_ns->storage, &error));
+	}
+
+	raw_box = (struct raw_mailbox *)mailr->box;
+	raw_box->envelope_sender = sender != NULL ? sender : DEFAULT_ENVELOPE_SENDER;
+	raw_box->mtime = mtime;
+
+	mailr->trans = mailbox_transaction_begin(mailr->box, 0);
+	mailr->headers_ctx = mailbox_header_lookup_init(mailr->box, wanted_headers);
+	mailr->mail = mail_alloc(mailr->trans, 0, mailr->headers_ctx);
+	mail_set_seq(mailr->mail, 1);
+
+	return mailr;
+}
+
+struct mail_raw *mail_raw_open_data(string_t *mail_data)
+{
+	struct mail_raw *mailr;
+	struct istream *input;
+
+	input = i_stream_create_from_data(str_data(mail_data), str_len(mail_data));
+	
+	mailr = mail_raw_create(input, NULL, NULL, (time_t)-1);
+
+	i_stream_unref(&input);
+
+	return mailr;
+}
+	
+struct mail_raw *mail_raw_open_file(const char *path)
+{
+	struct mail_raw *mailr;
+	struct istream *input = NULL;
+	time_t mtime;
+	const char *sender = NULL;
+	
+	if ( path == NULL || strcmp(path, "-") == 0 ) {
+		path = NULL;
+		input = create_raw_stream(0, &mtime, &sender);
+	}
+
+	mailr = mail_raw_create(input, path, sender, mtime);
+
+	if ( input != NULL )
+		i_stream_unref(&input);
+
+	return mailr;
+}
+
+void mail_raw_close(struct mail_raw *mailr) 
+{
+	mailbox_header_lookup_unref(&mailr->headers_ctx);
+
+	mail_free(&mailr->mail);
+	mailbox_transaction_rollback(&mailr->trans);
+	mailbox_close(&mailr->box);
+
+	pool_unref(&mailr->pool);
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve-tool/mail-raw.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve-tool/mail-raw.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve-tool/mail-raw.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve-tool/mail-raw.h	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,24 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __MAIL_RAW_H
+#define __MAIL_RAW_H
+
+struct mail_raw {
+	pool_t pool;
+	struct mail *mail;
+
+	struct mailbox *box;
+	struct mailbox_header_lookup_ctx *headers_ctx;
+	struct mailbox_transaction_context *trans;
+};
+
+void mail_raw_init(const char *user);
+void mail_raw_deinit(void);
+
+struct mail_raw *mail_raw_open_file(const char *path);
+struct mail_raw *mail_raw_open_data(string_t *mail_data);
+void mail_raw_close(struct mail_raw *mailr);
+
+
+#endif /* __MAIL_RAW_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve-tool/Makefile.am dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve-tool/Makefile.am
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve-tool/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve-tool/Makefile.am	2008-11-05 15:33:35.000000000 +0100
@@ -0,0 +1,19 @@
+noinst_LTLIBRARIES = libsieve-tool.la
+
+AM_CPPFLAGS = \
+	-I$(top_srcdir)/src/lib-sieve \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-index \
+	-I$(dovecot_incdir)/src/lib-storage \
+	-I$(dovecot_incdir)/src/lib-storage/index \
+	-I$(dovecot_incdir)/src/lib-storage/index/raw
+
+libsieve_tool_la_SOURCES = \
+	sieve-tool.c \
+	mail-raw.c
+
+noinst_HEADERS = \
+	sieve-tool.h \
+	mail-raw.h
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve-tool/Makefile.in dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve-tool/Makefile.in
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve-tool/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve-tool/Makefile.in	2009-08-21 00:55:42.000000000 +0200
@@ -0,0 +1,465 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve-tool
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libsieve_tool_la_LIBADD =
+am_libsieve_tool_la_OBJECTS = sieve-tool.lo mail-raw.lo
+libsieve_tool_la_OBJECTS = $(am_libsieve_tool_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_tool_la_SOURCES)
+DIST_SOURCES = $(libsieve_tool_la_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LTLIBRARIES = libsieve-tool.la
+AM_CPPFLAGS = \
+	-I$(top_srcdir)/src/lib-sieve \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-index \
+	-I$(dovecot_incdir)/src/lib-storage \
+	-I$(dovecot_incdir)/src/lib-storage/index \
+	-I$(dovecot_incdir)/src/lib-storage/index/raw
+
+libsieve_tool_la_SOURCES = \
+	sieve-tool.c \
+	mail-raw.c
+
+noinst_HEADERS = \
+	sieve-tool.h \
+	mail-raw.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/lib-sieve-tool/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  src/lib-sieve-tool/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve-tool.la: $(libsieve_tool_la_OBJECTS) $(libsieve_tool_la_DEPENDENCIES) 
+	$(LINK)  $(libsieve_tool_la_OBJECTS) $(libsieve_tool_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mail-raw.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-tool.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve-tool/sieve-tool.c dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve-tool/sieve-tool.c
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve-tool/sieve-tool.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve-tool/sieve-tool.c	2009-04-08 18:41:46.000000000 +0200
@@ -0,0 +1,190 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "lib-signals.h"
+#include "ioloop.h"
+#include "ostream.h"
+#include "hostpid.h"
+#include "mail-storage.h"
+
+#include "sieve.h"
+#include "sieve-tool.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <pwd.h>
+
+/*
+ * Global state
+ */
+
+static struct ioloop *ioloop;
+
+/*
+ * Signal handlers
+ */
+
+static void sig_die(const siginfo_t *si, void *context ATTR_UNUSED)
+{
+	/* warn about being killed because of some signal, except SIGINT (^C)
+	 * which is too common at least while testing :) 
+	 */
+        if (si->si_signo != SIGINT) {
+		/* FIMXE: strange error for a command line tool */
+		i_warning("Killed with signal %d (by pid=%s uid=%s code=%s)",
+ 			si->si_signo, dec2str(si->si_pid),
+			dec2str(si->si_uid),
+			lib_signal_code_to_str(si->si_signo, si->si_code));
+        }
+        io_loop_stop(current_ioloop);
+}
+
+/*
+ * Initialization
+ */
+
+void sieve_tool_init(void) 
+{
+	lib_init();
+
+	ioloop = io_loop_create();
+
+	lib_signals_init();
+	lib_signals_set_handler(SIGINT, TRUE, sig_die, NULL);
+	lib_signals_set_handler(SIGTERM, TRUE, sig_die, NULL);
+	lib_signals_ignore(SIGPIPE, TRUE);
+	lib_signals_ignore(SIGALRM, FALSE);
+
+	if ( !sieve_init() ) 
+		i_fatal("failed to initialize sieve implementation\n");
+}
+
+void sieve_tool_deinit(void)
+{
+	sieve_deinit();
+	
+	lib_signals_deinit();
+
+	io_loop_destroy(&ioloop);
+	lib_deinit();
+}
+
+/*
+ * Commonly needed functionality
+ */
+
+const char *sieve_tool_get_user(void)
+{
+	const char *user;
+	uid_t process_euid;
+	struct passwd *pw;
+
+	user = getenv("USER");
+
+	if ( user == NULL || *user == '\0' ) {
+		process_euid = geteuid();
+
+		if ((pw = getpwuid(process_euid)) != NULL) {
+			user = t_strdup(pw->pw_name);
+		}
+
+		if ( user == NULL || *user == '\0' ) {
+			i_fatal("couldn't lookup our username (uid=%s)", dec2str(process_euid));
+		}
+	}
+	
+	return user;
+}
+
+void sieve_tool_get_envelope_data
+	(struct mail *mail, const char **recipient, const char **sender)
+{
+	/* Get recipient address */
+	if ( *recipient == NULL ) 
+		(void)mail_get_first_header(mail, "Envelope-To", recipient);
+	if ( *recipient == NULL ) 
+		(void)mail_get_first_header(mail, "To", recipient);
+	if ( *recipient == NULL ) 
+		*recipient = "recipient@example.com";
+	
+	/* Get sender address */
+	if ( *sender == NULL ) 
+		(void)mail_get_first_header(mail, "Return-path", sender);
+	if ( *sender == NULL ) 
+		(void)mail_get_first_header(mail, "Sender", sender);
+	if ( *sender == NULL ) 
+		(void)mail_get_first_header(mail, "From", sender);
+	if ( *sender == NULL ) 
+		*sender = "sender@example.com";
+}
+
+/*
+ * Sieve script handling
+ */
+
+struct sieve_binary *sieve_tool_script_compile
+(const char *filename, const char *name)
+{
+	struct sieve_error_handler *ehandler;
+	struct sieve_binary *sbin;
+	
+	ehandler = sieve_stderr_ehandler_create(0);
+	sieve_error_handler_accept_infolog(ehandler, TRUE);
+
+	if ( (sbin = sieve_compile(filename, name, ehandler)) == NULL )
+		i_error("failed to compile sieve script '%s'\n", filename);
+
+	sieve_error_handler_unref(&ehandler);
+		
+	return sbin;
+}
+	
+struct sieve_binary *sieve_tool_script_open(const char *filename)
+{
+	struct sieve_error_handler *ehandler;
+	struct sieve_binary *sbin;
+	
+	ehandler = sieve_stderr_ehandler_create(0);
+	sieve_error_handler_accept_infolog(ehandler, TRUE);
+
+	if ( (sbin = sieve_open(filename, NULL, ehandler, NULL)) == NULL ) {
+		sieve_error_handler_unref(&ehandler);
+		i_fatal("Failed to compile sieve script\n");
+	}
+
+	sieve_error_handler_unref(&ehandler);
+		
+	return sbin;
+}
+	
+void sieve_tool_dump_binary_to(struct sieve_binary *sbin, const char *filename)	
+{
+	int dfd = -1;
+	struct ostream *dumpstream;
+	
+	if ( filename == NULL ) return;
+	
+	if ( strcmp(filename, "-") == 0 ) 
+		dumpstream = o_stream_create_fd(1, 0, FALSE);
+	else {
+		if ( (dfd = open(filename, O_WRONLY | O_TRUNC | O_CREAT, 0600)) < 0 ) {
+			i_fatal("failed to open dump-file for writing: %m");
+		}
+		
+		dumpstream = o_stream_create_fd(dfd, 0, FALSE);
+	}
+	
+	if ( dumpstream != NULL ) {
+		(void) sieve_dump(sbin, dumpstream);
+		o_stream_destroy(&dumpstream);
+	} else {
+		i_fatal("Failed to create stream for sieve code dump.");
+	}
+	
+	if ( dfd != -1 )
+		close(dfd);
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/lib-sieve-tool/sieve-tool.h dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve-tool/sieve-tool.h
--- dovecot-1.2.4/dovecot-libsieve/src/lib-sieve-tool/sieve-tool.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/lib-sieve-tool/sieve-tool.h	2009-01-10 20:32:19.000000000 +0100
@@ -0,0 +1,34 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_TOOL_H
+#define __SIEVE_TOOL_H
+
+/* Functionality common to all Sieve command line tools. */
+
+/*
+ * Initialization
+ */
+
+void sieve_tool_init(void);
+void sieve_tool_deinit(void);
+
+/*
+ * Commonly needed functionality
+ */
+
+const char *sieve_tool_get_user(void);
+
+void sieve_tool_get_envelope_data
+	(struct mail *mail, const char **recipient, const char **sender);
+
+/*
+ * Sieve script handling
+ */
+
+struct sieve_binary *sieve_tool_script_compile
+	(const char *filename, const char *name);
+struct sieve_binary *sieve_tool_script_open(const char *filename);
+void sieve_tool_dump_binary_to(struct sieve_binary *sbin, const char *filename);
+
+#endif /* __SIEVE_TOOL_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/Makefile.am dovecot-1.2.4.debian/dovecot-libsieve/src/Makefile.am
--- dovecot-1.2.4/dovecot-libsieve/src/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/Makefile.am	2008-11-12 15:08:08.000000000 +0100
@@ -0,0 +1,6 @@
+if HAVE_DOVECOT_LIBS
+LIB_DEPEND_DIRS=lib-sieve-tool sieve-tools testsuite
+endif
+
+SUBDIRS = lib-sieve plugins $(LIB_DEPEND_DIRS)
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/Makefile.in dovecot-1.2.4.debian/dovecot-libsieve/src/Makefile.in
--- dovecot-1.2.4/dovecot-libsieve/src/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/Makefile.in	2009-08-21 00:55:42.000000000 +0200
@@ -0,0 +1,494 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+SOURCES =
+DIST_SOURCES =
+RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
+	html-recursive info-recursive install-data-recursive \
+	install-dvi-recursive install-exec-recursive \
+	install-html-recursive install-info-recursive \
+	install-pdf-recursive install-ps-recursive install-recursive \
+	installcheck-recursive installdirs-recursive pdf-recursive \
+	ps-recursive uninstall-recursive
+RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
+  distclean-recursive maintainer-clean-recursive
+ETAGS = etags
+CTAGS = ctags
+DIST_SUBDIRS = lib-sieve plugins lib-sieve-tool sieve-tools testsuite
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+@HAVE_DOVECOT_LIBS_TRUE@LIB_DEPEND_DIRS = lib-sieve-tool sieve-tools testsuite
+SUBDIRS = lib-sieve plugins $(LIB_DEPEND_DIRS)
+all: all-recursive
+
+.SUFFIXES:
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  src/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run `make' without going through this Makefile.
+# To change the values of `make' variables: instead of editing Makefiles,
+# (1) if the variable is set in `config.status', edit `config.status'
+#     (which will cause the Makefiles to be regenerated when you run `make');
+# (2) otherwise, pass the desired values on the `make' command line.
+$(RECURSIVE_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+$(RECURSIVE_CLEAN_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	rev=''; for subdir in $$list; do \
+	  if test "$$subdir" = "."; then :; else \
+	    rev="$$subdir $$rev"; \
+	  fi; \
+	done; \
+	rev="$$rev ."; \
+	target=`echo $@ | sed s/-recursive//`; \
+	for subdir in $$rev; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done && test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
+	done
+ctags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	  empty_fix=.; \
+	else \
+	  include_option=--include; \
+	  empty_fix=; \
+	fi; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test ! -f $$subdir/TAGS || \
+	      tags="$$tags $$include_option=$$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+	list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test -d "$(distdir)/$$subdir" \
+	    || $(MKDIR_P) "$(distdir)/$$subdir" \
+	    || exit 1; \
+	    distdir=`$(am__cd) $(distdir) && pwd`; \
+	    top_distdir=`$(am__cd) $(top_distdir) && pwd`; \
+	    (cd $$subdir && \
+	      $(MAKE) $(AM_MAKEFLAGS) \
+	        top_distdir="$$top_distdir" \
+	        distdir="$$distdir/$$subdir" \
+		am__remove_distdir=: \
+		am__skip_length_check=: \
+	        distdir) \
+	      || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-recursive
+all-am: Makefile
+installdirs: installdirs-recursive
+installdirs-am:
+install: install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-recursive
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-recursive
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-recursive
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-tags
+
+dvi: dvi-recursive
+
+dvi-am:
+
+html: html-recursive
+
+info: info-recursive
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-recursive
+
+install-exec-am:
+
+install-html: install-html-recursive
+
+install-info: install-info-recursive
+
+install-man:
+
+install-pdf: install-pdf-recursive
+
+install-ps: install-ps-recursive
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-recursive
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-recursive
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-recursive
+
+pdf-am:
+
+ps: ps-recursive
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) install-am \
+	install-strip
+
+.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
+	all all-am check check-am clean clean-generic clean-libtool \
+	ctags ctags-recursive distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs installdirs-am maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-recursive \
+	uninstall uninstall-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.2.4/dovecot-libsieve/src/plugins/lda-sieve/lda-sieve-plugin.c dovecot-1.2.4.debian/dovecot-libsieve/src/plugins/lda-sieve/lda-sieve-plugin.c
--- dovecot-1.2.4/dovecot-libsieve/src/plugins/lda-sieve/lda-sieve-plugin.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/plugins/lda-sieve/lda-sieve-plugin.c	2009-08-04 18:46:26.000000000 +0200
@@ -0,0 +1,665 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+
+#include "lib.h"
+#include "array.h"
+#include "home-expand.h"
+#include "deliver.h"
+#include "duplicate.h"
+#include "smtp-client.h"
+
+#include "sieve.h"
+
+#include "lda-sieve-plugin.h"
+
+#include <stdlib.h>
+#include <sys/stat.h>
+#include <dirent.h>
+
+/*
+ * Configuration
+ */
+
+#define SIEVE_SCRIPT_PATH "~/.dovecot.sieve"
+
+#define LDA_SIEVE_MAX_USER_ERRORS 10
+#define LDA_SIEVE_MAX_SYSTEM_ERRORS 100
+
+/*
+ * Global variables 
+ */
+
+static deliver_mail_func_t *next_deliver_mail;
+
+static bool lda_sieve_debug = FALSE;
+
+/*
+ * Mail transmission
+ */
+
+static void *lda_sieve_smtp_open(const char *destination,
+	const char *return_path, FILE **file_r)
+{
+	return (void *) smtp_client_open(destination, return_path, file_r);
+}
+
+static bool lda_sieve_smtp_close(void *handle)
+{
+	struct smtp_client *smtp_client = (struct smtp_client *) handle;
+
+	return ( smtp_client_close(smtp_client) == 0 );
+}
+
+/*
+ * Plugin implementation
+ */
+
+struct lda_sieve_run_context {
+	const char *const *script_files;
+	unsigned int script_count;
+
+	const char *user_script;
+	const char *main_script;
+
+	const struct sieve_message_data *msgdata;
+	const struct sieve_script_env *scriptenv;
+
+	struct sieve_error_handler *user_ehandler;
+	struct sieve_error_handler *master_ehandler;
+	const char *userlog;
+};
+
+static const char *lda_sieve_get_personal_path(void)
+{
+	const char *script_path, *home;
+
+	home = getenv("HOME");
+
+	/* userdb may specify Sieve path */
+	script_path = getenv("SIEVE");
+	if (script_path != NULL) {
+		if (*script_path == '\0') {
+			/* disabled */
+			if ( lda_sieve_debug )
+				sieve_sys_info("empty script path, disabled");
+			return NULL;
+		}
+
+		script_path = home_expand(script_path);
+
+		if (*script_path != '/' && *script_path != '\0') {
+			/* relative path. change to absolute. */
+			script_path = t_strconcat(getenv("HOME"), "/",
+						  script_path, NULL);
+		}
+	} else {
+		if (home == NULL) {
+			sieve_sys_error(
+				"path to user's main active personal script is unknown. "
+				"See http://wiki.dovecot.org/LDA/Sieve/Dovecot#configuration");
+			return NULL;
+		}
+
+		script_path = home_expand(SIEVE_SCRIPT_PATH);
+	}
+
+	return script_path;
+}
+
+static const char *lda_sieve_get_default_path(void)
+{
+	const char *script_path;
+
+	/* Use global script path, if one exists */
+	script_path = getenv("SIEVE_GLOBAL_PATH");
+	if (script_path == NULL) {
+		/* For backwards compatibility */
+		script_path = getenv("GLOBAL_SCRIPT_PATH");
+	}
+
+	return script_path;
+}
+
+static void lda_sieve_multiscript_get_scriptfiles
+(const char *script_path, ARRAY_TYPE(const_string) *scriptfiles)
+{
+	struct sieve_directory *sdir = sieve_directory_open(script_path);
+
+	if ( sdir != NULL ) {
+		const char *file;
+
+		while ( (file=sieve_directory_get_scriptfile(sdir)) != NULL ) {
+			const char *const *scripts;
+			unsigned int count, i;
+
+			/* Insert into sorted array */
+
+			scripts = array_get(scriptfiles, &count);
+			for ( i = 0; i < count; i++ ) {
+				if ( strcmp(file, scripts[i]) < 0 )
+					break;			
+			}
+	
+			if ( i == count ) 
+				array_append(scriptfiles, &file, 1);
+			else
+				array_insert(scriptfiles, i, &file, 1);
+		}
+
+		sieve_directory_close(&sdir);
+	} 
+}
+
+static int lda_sieve_open
+(struct lda_sieve_run_context *srctx, unsigned int script_index,
+	struct sieve_binary **sbin)
+{
+	const char *script_path = srctx->script_files[script_index];
+	const char *script_name = 
+		( script_path == srctx->main_script ? "main_script" : NULL );
+	struct sieve_error_handler *ehandler;
+	bool exists = TRUE;
+	int ret = 0;
+
+	if ( script_path == srctx->user_script )
+		ehandler = srctx->user_ehandler;
+	else
+		ehandler = srctx->master_ehandler;
+
+	if ( lda_sieve_debug )
+		sieve_sys_info("opening script %s", script_path);		
+
+	sieve_error_handler_reset(ehandler);
+
+	if ( (*sbin=sieve_open(script_path, script_name, ehandler, &exists)) 
+		== NULL ) {
+
+		ret = sieve_get_errors(ehandler) > 0 ? -1 : 0;
+
+		if ( !exists && ret == 0 ) {
+			if ( lda_sieve_debug )
+				sieve_sys_info("script file %s is missing", script_path);
+		} else {
+			if ( script_path == srctx->user_script && srctx->userlog != NULL ) {
+				sieve_sys_error
+					("failed to open script %s "
+						"(view logfile %s for more information)", 
+						script_path, srctx->userlog);
+			} else {
+				sieve_sys_error
+					("failed to open script %s", 
+						script_path);
+			}
+		}
+
+		return ret;
+	}
+
+	return 1;
+}
+
+static struct sieve_binary *lda_sieve_recompile
+(struct lda_sieve_run_context *srctx, unsigned int script_index)
+{
+	const char *script_path = srctx->script_files[script_index];
+    const char *script_name = 
+		( script_path == srctx->main_script ? "main_script" : NULL );
+    struct sieve_error_handler *ehandler;
+	struct sieve_binary *sbin;
+
+	/* Warn */
+
+	sieve_sys_warning("encountered corrupt binary: recompiling script %s", 
+		script_path);
+
+	/* Recompile */	
+
+	if ( script_path == srctx->user_script )
+		ehandler = srctx->user_ehandler;
+	else
+		ehandler = srctx->master_ehandler;
+
+	if ( (sbin=sieve_compile(script_path, script_name, ehandler)) == NULL ) {
+
+		if ( script_path == srctx->user_script && srctx->userlog != NULL ) {
+			sieve_sys_error
+				("failed to re-compile script %s "
+					"(view logfile %s for more information)",
+					script_path, srctx->userlog);
+		} else {
+			sieve_sys_error
+				("failed to re-compile script %s", script_path);
+		}
+
+		return NULL;
+	}
+
+	return sbin;
+}
+
+static int lda_sieve_handle_exec_status(const char *script_path, int status)
+{
+	int ret; 
+
+	switch ( status ) {
+	case SIEVE_EXEC_FAILURE:
+		sieve_sys_error
+			("execution of script %s failed, but implicit keep was successful", 
+				script_path);
+		ret = 1;
+		break;
+	case SIEVE_EXEC_BIN_CORRUPT:		
+		sieve_sys_error
+			("!!BUG!!: binary compiled from %s is still corrupt; "
+				"bailing out and reverting to default delivery", 
+				script_path);
+		ret = -1;
+		break;
+	case SIEVE_EXEC_KEEP_FAILED:
+		sieve_sys_error
+			("script %s failed with unsuccessful implicit keep", script_path);
+		ret = -1;
+		break;
+	default:
+		ret = status > 0 ? 1 : -1;
+		break;
+	}
+
+	return ret;
+}
+
+static int lda_sieve_singlescript_execute
+(struct lda_sieve_run_context *srctx)
+{
+	const char *script_file = srctx->script_files[0];
+    bool user_script = ( script_file == srctx->user_script );
+	struct sieve_error_handler *ehandler;
+	struct sieve_binary *sbin;
+	int ret;
+
+	/* Open the script */
+
+	if ( (ret=lda_sieve_open(srctx, 0, &sbin)) <= 0 )
+		return ret;
+
+	/* Execute */
+
+	if ( lda_sieve_debug )
+		sieve_sys_info("executing compiled script %s", script_file);
+
+	if ( user_script ) {
+		ehandler = srctx->user_ehandler;
+		sieve_error_handler_copy_masterlog(ehandler, TRUE);	
+	} else {
+		ehandler = srctx->master_ehandler;
+	}
+
+	ret = sieve_execute(sbin, srctx->msgdata, srctx->scriptenv, ehandler, NULL);
+
+	sieve_error_handler_copy_masterlog(ehandler, FALSE);	
+
+	/* Recompile if corrupt binary */
+
+	if ( ret == SIEVE_EXEC_BIN_CORRUPT ) {
+		/* Close corrupt script */
+
+		sieve_close(&sbin);
+
+		/* Recompile */
+
+		if ( (sbin=lda_sieve_recompile(srctx, 0)) == NULL ) {
+			return -1;
+		}
+
+		/* Execute again */
+
+		if ( user_script )
+        	sieve_error_handler_copy_masterlog(ehandler, TRUE);
+
+		ret = sieve_execute(sbin, srctx->msgdata, srctx->scriptenv, ehandler, NULL);
+
+		sieve_error_handler_copy_masterlog(ehandler, FALSE);
+
+		/* Save new version */
+
+		if ( ret != SIEVE_EXEC_BIN_CORRUPT )
+			sieve_save(sbin, NULL);
+	}
+
+	sieve_close(&sbin);
+
+	/* Report status */
+	return lda_sieve_handle_exec_status(script_file, ret);
+}
+
+static int lda_sieve_multiscript_execute
+(struct lda_sieve_run_context *srctx)
+{
+	const char *const *scripts = srctx->script_files;
+	unsigned int count = srctx->script_count;
+	struct sieve_multiscript *mscript;
+	struct sieve_error_handler *ehandler = srctx->master_ehandler;
+	const char *last_script = NULL;
+	bool user_script = FALSE;
+	unsigned int i;
+	int ret = 1; 
+	bool more = TRUE;
+
+	/* Start execution */
+
+	mscript = sieve_multiscript_start_execute(srctx->msgdata, srctx->scriptenv);
+
+	/* Execute scripts before main script */
+
+	for ( i = 0; i < count && more; i++ ) {
+		struct sieve_binary *sbin = NULL;
+		const char *script_file = scripts[i];
+		bool final = ( i == count - 1 );
+
+		user_script = ( script_file == srctx->user_script );
+		last_script = script_file;		
+
+		if ( user_script )
+			ehandler = srctx->user_ehandler;
+		else
+			ehandler = srctx->master_ehandler;
+
+		/* Open */
+	
+		if ( (ret=lda_sieve_open(srctx, i, &sbin)) <= 0 )
+			break;
+
+		/* Execute */
+
+		if ( user_script )	
+			sieve_error_handler_copy_masterlog(ehandler, TRUE);
+
+		more = sieve_multiscript_run(mscript, sbin, ehandler, final);
+
+		sieve_error_handler_copy_masterlog(ehandler, FALSE);
+
+		if ( !more ) {
+			if ( sieve_multiscript_status(mscript) == SIEVE_EXEC_BIN_CORRUPT ) {
+				/* Close corrupt script */
+
+				sieve_close(&sbin);
+
+				/* Recompile */
+
+				if ( (sbin=lda_sieve_recompile(srctx, i))
+					== NULL ) {
+					ret = -1;
+					break;
+				}
+
+				/* Execute again */
+
+				if ( user_script )
+					sieve_error_handler_copy_masterlog(ehandler, TRUE);
+
+				more = sieve_multiscript_run(mscript, sbin, ehandler, final);
+
+				sieve_error_handler_copy_masterlog(ehandler, FALSE);
+
+				/* Save new version */
+
+				if ( more && 
+					sieve_multiscript_status(mscript) != SIEVE_EXEC_BIN_CORRUPT )
+					sieve_save(sbin, NULL);
+			}
+		}
+
+		sieve_close(&sbin);
+	}
+
+	/* Finish execution */
+
+	if ( user_script )	
+		sieve_error_handler_copy_masterlog(ehandler, TRUE);
+
+	ret = sieve_multiscript_finish(&mscript, ehandler, NULL);
+
+	sieve_error_handler_copy_masterlog(ehandler, FALSE);
+
+	return lda_sieve_handle_exec_status(last_script, ret);
+}
+
+static int lda_sieve_run
+(struct mail_namespace *namespaces, struct mail *mail, 
+	const char *user_script, const char *default_script,
+	const ARRAY_TYPE (const_string) *scripts_before, 
+	const ARRAY_TYPE (const_string) *scripts_after, 
+	const char *destaddr, const char *username, const char *mailbox, 
+	struct mail_storage **storage_r)
+{
+	ARRAY_TYPE (const_string) scripts;
+
+	struct lda_sieve_run_context srctx;
+	struct sieve_message_data msgdata;
+	struct sieve_script_env scriptenv;
+	struct sieve_exec_status estatus;
+	int ret = 0;
+
+	*storage_r = NULL;
+
+	/* Initialize */
+
+	memset(&srctx, 0, sizeof(srctx));
+
+	/* Compose execution sequence */
+
+	t_array_init(&scripts, 32);
+
+	array_append_array(&scripts, scripts_before);
+
+	if ( user_script != NULL ) {
+		array_append(&scripts, &user_script, 1);
+		srctx.user_script = user_script;
+		srctx.main_script = user_script;
+	} else if ( default_script != NULL ) {
+		array_append(&scripts, &default_script, 1);
+		srctx.user_script = NULL;
+		srctx.main_script = default_script;
+	} else {
+		srctx.user_script = NULL;
+        srctx.main_script = NULL;
+	}
+
+	array_append_array(&scripts, scripts_after);
+
+	/* Create error handlers */
+
+	if ( user_script != NULL ) {
+		srctx.userlog = t_strconcat(user_script, ".log", NULL);
+		srctx.user_ehandler = sieve_logfile_ehandler_create(srctx.userlog, LDA_SIEVE_MAX_USER_ERRORS);
+	}
+
+	srctx.master_ehandler = sieve_master_ehandler_create(LDA_SIEVE_MAX_SYSTEM_ERRORS);
+	sieve_error_handler_accept_infolog(srctx.master_ehandler, TRUE);
+
+	/* Collect necessary message data */
+
+	memset(&msgdata, 0, sizeof(msgdata));
+
+	msgdata.mail = mail;
+	msgdata.return_path = deliver_get_return_address(mail);
+	msgdata.to_address = destaddr;
+	msgdata.auth_user = username;
+	(void)mail_get_first_header(mail, "Message-ID", &msgdata.id);
+
+	srctx.msgdata = &msgdata;
+
+	/* Compose script execution environment */
+
+	memset(&scriptenv, 0, sizeof(scriptenv));
+	memset(&estatus, 0, sizeof(estatus));
+
+	scriptenv.default_mailbox = mailbox;
+	scriptenv.mailbox_autocreate = deliver_set->mailbox_autocreate;
+	scriptenv.mailbox_autosubscribe = deliver_set->mailbox_autosubscribe;
+	scriptenv.namespaces = namespaces;
+	scriptenv.username = username;
+	scriptenv.hostname = deliver_set->hostname;
+	scriptenv.postmaster_address = deliver_set->postmaster_address;
+	scriptenv.smtp_open = lda_sieve_smtp_open;
+	scriptenv.smtp_close = lda_sieve_smtp_close;
+	scriptenv.duplicate_mark = duplicate_mark;
+	scriptenv.duplicate_check = duplicate_check;
+	scriptenv.exec_status = &estatus;
+
+	srctx.scriptenv = &scriptenv;
+
+	/* Assign script sequence */
+
+	srctx.script_files = array_get(&scripts, &srctx.script_count);
+
+	/* Execute script(s) */
+
+	if ( srctx.script_count == 1 )
+		ret = lda_sieve_singlescript_execute(&srctx);
+	else
+		ret = lda_sieve_multiscript_execute(&srctx);	
+
+	/* Record status */
+
+	tried_default_save = estatus.tried_default_save;
+	*storage_r = estatus.last_storage;
+
+	/* Clean up */
+
+	if ( srctx.user_ehandler != NULL )
+		sieve_error_handler_unref(&srctx.user_ehandler);
+	sieve_error_handler_unref(&srctx.master_ehandler);
+
+	return ret;
+}
+
+static int lda_sieve_deliver_mail
+(struct mail_namespace *namespaces, struct mail_storage **storage_r, 
+	struct mail *mail, const char *destaddr, const char *mailbox)
+{
+	const char *user_script, *default_script, *sieve_before, *sieve_after;
+	ARRAY_TYPE (const_string) scripts_before;
+	ARRAY_TYPE (const_string) scripts_after;
+	int ret = 0;
+
+	*storage_r = NULL;
+
+	T_BEGIN { 
+		struct stat st;
+
+		/* Find the personal script to execute */
+	
+		user_script = lda_sieve_get_personal_path();
+		default_script = lda_sieve_get_default_path();
+
+		if ( stat(user_script, &st) < 0 ) {
+			if (errno != ENOENT)
+				sieve_sys_error("stat(%s) failed: %m "
+					"(using global script path in stead)", user_script);
+			else if (getenv("DEBUG") != NULL)
+				sieve_sys_info("local script path %s doesn't exist "
+					"(using global script path in stead)", user_script);
+
+			user_script = NULL;
+		}
+
+		if ( lda_sieve_debug ) {
+			const char *script = user_script == NULL ? default_script : user_script;
+
+			if ( script == NULL )
+				sieve_sys_info("user has no valid personal script");
+			else
+				sieve_sys_info("using sieve path for user's script: %s", script);
+		}
+
+		/* Check for multiscript */
+
+		t_array_init(&scripts_before, 16);
+		t_array_init(&scripts_after, 16);
+
+		sieve_before = getenv("SIEVE_BEFORE");
+		sieve_after = getenv("SIEVE_AFTER");
+
+		if ( sieve_before != NULL && *sieve_before != '\0' ) {
+			lda_sieve_multiscript_get_scriptfiles(sieve_before, &scripts_before);
+		}
+
+		if ( sieve_after != NULL && *sieve_after != '\0' ) {
+			lda_sieve_multiscript_get_scriptfiles(sieve_after, &scripts_after);
+		}
+
+		if ( lda_sieve_debug ) {
+			const char *const *scriptfiles;
+			unsigned int count, i;
+
+			scriptfiles = array_get(&scripts_before, &count);
+			for ( i = 0; i < count; i ++ ) {
+				sieve_sys_info("executed before user's script(%d): %s", i+1, scriptfiles[i]);				
+			}
+
+			scriptfiles = array_get(&scripts_after, &count);
+			for ( i = 0; i < count; i ++ ) {
+				sieve_sys_info("executed after user's script(%d): %s", i+1, scriptfiles[i]);				
+			}
+		}
+
+		/* Check whether there are any scripts to execute */
+
+		if ( array_count(&scripts_before) == 0 && array_count(&scripts_after) == 0 &&
+			user_script == NULL && default_script == NULL ) {
+			if ( lda_sieve_debug )
+				sieve_sys_info("no scripts to execute: reverting to default delivery.");
+
+			/* No error, but no delivery by this plugin either. A return value of <= 0 for a 
+			 * deliver plugin is is considered a failure. In deliver itself, saved_mail and 
+			 * tried_default_save remain unset, meaning that deliver will then attempt the 
+			 * default delivery. We return 0 to signify the lack of a real error. 
+			 */
+			ret = 0; 
+		} else {
+			/* Run the script(s) */
+				
+			ret = lda_sieve_run
+				(namespaces, mail, user_script,	default_script,
+					&scripts_before, &scripts_after, 
+					destaddr, getenv("USER"), mailbox, storage_r);
+		}
+
+	} T_END;
+
+	return ret; 
+}
+
+/*
+ * Plugin interface
+ */
+
+void sieve_plugin_init(void)
+{
+	const char *extensions = NULL;
+
+	/* Initialize Sieve engine */
+	sieve_init();
+
+	extensions = getenv("SIEVE_EXTENSIONS");
+	if ( extensions != NULL ) {
+		sieve_set_extensions(extensions);
+	}
+
+	/* Debug mode */
+	lda_sieve_debug = getenv("DEBUG");
+
+	/* Hook into the delivery process */
+	next_deliver_mail = deliver_mail;
+	deliver_mail = lda_sieve_deliver_mail;
+}
+
+void sieve_plugin_deinit(void)
+{
+	/* Remove hook */
+	deliver_mail = next_deliver_mail;
+
+	/* Deinitialize Sieve engine */
+	sieve_deinit();
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/plugins/lda-sieve/lda-sieve-plugin.h dovecot-1.2.4.debian/dovecot-libsieve/src/plugins/lda-sieve/lda-sieve-plugin.h
--- dovecot-1.2.4/dovecot-libsieve/src/plugins/lda-sieve/lda-sieve-plugin.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/plugins/lda-sieve/lda-sieve-plugin.h	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,14 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __LDA_SIEVE_PLUGIN_H
+#define __LDA_SIEVE_PLUGIN_H
+
+/*
+ * Plugin interface
+ */
+
+void sieve_plugin_init(void);
+void sieve_plugin_deinit(void);
+
+#endif /* __LDA_SIEVE_PLUGIN_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/plugins/lda-sieve/Makefile.am dovecot-1.2.4.debian/dovecot-libsieve/src/plugins/lda-sieve/Makefile.am
--- dovecot-1.2.4/dovecot-libsieve/src/plugins/lda-sieve/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/plugins/lda-sieve/Makefile.am	2008-07-18 12:11:28.000000000 +0200
@@ -0,0 +1,23 @@
+AM_CPPFLAGS = \
+	-I$(top_srcdir)/src/lib-sieve \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-dict \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage \
+	-I$(dovecot_incdir)/src/deliver
+
+lda_moduledir = $(moduledir)/lda
+
+lib90_sieve_plugin_la_LDFLAGS = -module -avoid-version
+
+lda_module_LTLIBRARIES = lib90_sieve_plugin.la
+
+lib90_sieve_plugin_la_LIBADD = \
+	$(top_srcdir)/src/lib-sieve/libsieve.la
+
+lib90_sieve_plugin_la_SOURCES = \
+	lda-sieve-plugin.c 
+
+noinst_HEADERS = \
+	lda-sieve-plugin.h
diff -urN dovecot-1.2.4/dovecot-libsieve/src/plugins/lda-sieve/Makefile.in dovecot-1.2.4.debian/dovecot-libsieve/src/plugins/lda-sieve/Makefile.in
--- dovecot-1.2.4/dovecot-libsieve/src/plugins/lda-sieve/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/plugins/lda-sieve/Makefile.in	2009-08-21 00:55:44.000000000 +0200
@@ -0,0 +1,500 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/plugins/lda-sieve
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+am__installdirs = "$(DESTDIR)$(lda_moduledir)"
+lda_moduleLTLIBRARIES_INSTALL = $(INSTALL)
+LTLIBRARIES = $(lda_module_LTLIBRARIES)
+lib90_sieve_plugin_la_DEPENDENCIES =  \
+	$(top_srcdir)/src/lib-sieve/libsieve.la
+am_lib90_sieve_plugin_la_OBJECTS = lda-sieve-plugin.lo
+lib90_sieve_plugin_la_OBJECTS = $(am_lib90_sieve_plugin_la_OBJECTS)
+lib90_sieve_plugin_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(lib90_sieve_plugin_la_LDFLAGS) $(LDFLAGS) -o $@
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(lib90_sieve_plugin_la_SOURCES)
+DIST_SOURCES = $(lib90_sieve_plugin_la_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+AM_CPPFLAGS = \
+	-I$(top_srcdir)/src/lib-sieve \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-dict \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage \
+	-I$(dovecot_incdir)/src/deliver
+
+lda_moduledir = $(moduledir)/lda
+lib90_sieve_plugin_la_LDFLAGS = -module -avoid-version
+lda_module_LTLIBRARIES = lib90_sieve_plugin.la
+lib90_sieve_plugin_la_LIBADD = \
+	$(top_srcdir)/src/lib-sieve/libsieve.la
+
+lib90_sieve_plugin_la_SOURCES = \
+	lda-sieve-plugin.c 
+
+noinst_HEADERS = \
+	lda-sieve-plugin.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/plugins/lda-sieve/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  src/plugins/lda-sieve/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+install-lda_moduleLTLIBRARIES: $(lda_module_LTLIBRARIES)
+	@$(NORMAL_INSTALL)
+	test -z "$(lda_moduledir)" || $(MKDIR_P) "$(DESTDIR)$(lda_moduledir)"
+	@list='$(lda_module_LTLIBRARIES)'; for p in $$list; do \
+	  if test -f $$p; then \
+	    f=$(am__strip_dir) \
+	    echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(lda_moduleLTLIBRARIES_INSTALL) $(INSTALL_STRIP_FLAG) '$$p' '$(DESTDIR)$(lda_moduledir)/$$f'"; \
+	    $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(lda_moduleLTLIBRARIES_INSTALL) $(INSTALL_STRIP_FLAG) "$$p" "$(DESTDIR)$(lda_moduledir)/$$f"; \
+	  else :; fi; \
+	done
+
+uninstall-lda_moduleLTLIBRARIES:
+	@$(NORMAL_UNINSTALL)
+	@list='$(lda_module_LTLIBRARIES)'; for p in $$list; do \
+	  p=$(am__strip_dir) \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(lda_moduledir)/$$p'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f "$(DESTDIR)$(lda_moduledir)/$$p"; \
+	done
+
+clean-lda_moduleLTLIBRARIES:
+	-test -z "$(lda_module_LTLIBRARIES)" || rm -f $(lda_module_LTLIBRARIES)
+	@list='$(lda_module_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+lib90_sieve_plugin.la: $(lib90_sieve_plugin_la_OBJECTS) $(lib90_sieve_plugin_la_DEPENDENCIES) 
+	$(lib90_sieve_plugin_la_LINK) -rpath $(lda_moduledir) $(lib90_sieve_plugin_la_OBJECTS) $(lib90_sieve_plugin_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lda-sieve-plugin.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+	for dir in "$(DESTDIR)$(lda_moduledir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-lda_moduleLTLIBRARIES clean-libtool \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am: install-lda_moduleLTLIBRARIES
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-lda_moduleLTLIBRARIES
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-lda_moduleLTLIBRARIES clean-libtool ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am \
+	install-lda_moduleLTLIBRARIES install-man install-pdf \
+	install-pdf-am install-ps install-ps-am install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-lda_moduleLTLIBRARIES
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.2.4/dovecot-libsieve/src/plugins/Makefile.am dovecot-1.2.4.debian/dovecot-libsieve/src/plugins/Makefile.am
--- dovecot-1.2.4/dovecot-libsieve/src/plugins/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/plugins/Makefile.am	2008-07-18 12:11:28.000000000 +0200
@@ -0,0 +1 @@
+SUBDIRS = lda-sieve
diff -urN dovecot-1.2.4/dovecot-libsieve/src/plugins/Makefile.in dovecot-1.2.4.debian/dovecot-libsieve/src/plugins/Makefile.in
--- dovecot-1.2.4/dovecot-libsieve/src/plugins/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/plugins/Makefile.in	2009-08-21 00:55:44.000000000 +0200
@@ -0,0 +1,493 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/plugins
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+SOURCES =
+DIST_SOURCES =
+RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
+	html-recursive info-recursive install-data-recursive \
+	install-dvi-recursive install-exec-recursive \
+	install-html-recursive install-info-recursive \
+	install-pdf-recursive install-ps-recursive install-recursive \
+	installcheck-recursive installdirs-recursive pdf-recursive \
+	ps-recursive uninstall-recursive
+RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
+  distclean-recursive maintainer-clean-recursive
+ETAGS = etags
+CTAGS = ctags
+DIST_SUBDIRS = $(SUBDIRS)
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+SUBDIRS = lda-sieve
+all: all-recursive
+
+.SUFFIXES:
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/plugins/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  src/plugins/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run `make' without going through this Makefile.
+# To change the values of `make' variables: instead of editing Makefiles,
+# (1) if the variable is set in `config.status', edit `config.status'
+#     (which will cause the Makefiles to be regenerated when you run `make');
+# (2) otherwise, pass the desired values on the `make' command line.
+$(RECURSIVE_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+$(RECURSIVE_CLEAN_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	rev=''; for subdir in $$list; do \
+	  if test "$$subdir" = "."; then :; else \
+	    rev="$$subdir $$rev"; \
+	  fi; \
+	done; \
+	rev="$$rev ."; \
+	target=`echo $@ | sed s/-recursive//`; \
+	for subdir in $$rev; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done && test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
+	done
+ctags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	  empty_fix=.; \
+	else \
+	  include_option=--include; \
+	  empty_fix=; \
+	fi; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test ! -f $$subdir/TAGS || \
+	      tags="$$tags $$include_option=$$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+	list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test -d "$(distdir)/$$subdir" \
+	    || $(MKDIR_P) "$(distdir)/$$subdir" \
+	    || exit 1; \
+	    distdir=`$(am__cd) $(distdir) && pwd`; \
+	    top_distdir=`$(am__cd) $(top_distdir) && pwd`; \
+	    (cd $$subdir && \
+	      $(MAKE) $(AM_MAKEFLAGS) \
+	        top_distdir="$$top_distdir" \
+	        distdir="$$distdir/$$subdir" \
+		am__remove_distdir=: \
+		am__skip_length_check=: \
+	        distdir) \
+	      || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-recursive
+all-am: Makefile
+installdirs: installdirs-recursive
+installdirs-am:
+install: install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-recursive
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-recursive
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-recursive
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-tags
+
+dvi: dvi-recursive
+
+dvi-am:
+
+html: html-recursive
+
+info: info-recursive
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-recursive
+
+install-exec-am:
+
+install-html: install-html-recursive
+
+install-info: install-info-recursive
+
+install-man:
+
+install-pdf: install-pdf-recursive
+
+install-ps: install-ps-recursive
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-recursive
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-recursive
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-recursive
+
+pdf-am:
+
+ps: ps-recursive
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) install-am \
+	install-strip
+
+.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
+	all all-am check check-am clean clean-generic clean-libtool \
+	ctags ctags-recursive distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs installdirs-am maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-recursive \
+	uninstall uninstall-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.2.4/dovecot-libsieve/src/sieve-tools/debug/cmd-debug-print.c dovecot-1.2.4.debian/dovecot-libsieve/src/sieve-tools/debug/cmd-debug-print.c
--- dovecot-1.2.4/dovecot-libsieve/src/sieve-tools/debug/cmd-debug-print.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/sieve-tools/debug/cmd-debug-print.c	2009-03-26 17:53:38.000000000 +0100
@@ -0,0 +1,133 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "ext-debug-common.h"
+
+/* 
+ * Debug_print command
+ *
+ * Syntax
+ *   debug_print <message: string>
+ */
+
+static bool cmd_debug_print_validate
+	(struct sieve_validator *validator, struct sieve_command_context *tst);
+static bool cmd_debug_print_generate
+	(const struct sieve_codegen_env *cgenv,	struct sieve_command_context *ctx);
+
+const struct sieve_command debug_print_command = { 
+	"debug_print", 
+	SCT_COMMAND, 
+	1, 0, FALSE, FALSE,
+	NULL, NULL,
+	cmd_debug_print_validate, 
+	cmd_debug_print_generate, 
+	NULL 
+};
+
+/* 
+ * Body operation 
+ */
+
+static bool cmd_debug_print_operation_dump
+	(const struct sieve_operation *op, 
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_debug_print_operation_execute
+	(const struct sieve_operation *op,
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation debug_print_operation = { 
+	"debug_print",
+	&debug_extension,
+	0,
+	cmd_debug_print_operation_dump, 
+	cmd_debug_print_operation_execute 
+};
+
+/* 
+ * Validation 
+ */
+ 
+static bool cmd_debug_print_validate
+(struct sieve_validator *validator, struct sieve_command_context *tst) 
+{ 		
+	struct sieve_ast_argument *arg = tst->first_positional;
+					
+	if ( !sieve_validate_positional_argument
+		(validator, tst, arg, "message", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+
+	return sieve_validator_argument_activate(validator, tst, arg, FALSE);
+}
+
+/*
+ * Code generation
+ */
+ 
+static bool cmd_debug_print_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx) 
+{
+	(void)sieve_operation_emit_code(cgenv->sbin, &debug_print_operation);
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, ctx, NULL);
+}
+
+/* 
+ * Code dump 
+ */
+ 
+static bool cmd_debug_print_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED, 
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	sieve_code_dumpf(denv, "DEBUG_PRINT");
+	sieve_code_descend(denv);
+
+	return sieve_opr_string_dump(denv, address, "key list");
+}
+
+/*
+ * Interpretation
+ */
+
+static int cmd_debug_print_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	string_t *message;
+	int ret = SIEVE_EXEC_OK;
+
+	/*
+	 * Read operands
+	 */
+	
+	/* Read message */
+
+	if ( sieve_opr_string_read(renv, address, &message) < 0 ) {
+		sieve_runtime_trace_error(renv, "invalid message operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "DEBUG_PRINT");
+	
+	/* FIXME: give this proper source location */
+	sieve_runtime_log(renv, "DEBUG", "%s", str_c(message));
+
+	return ret;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/sieve-tools/debug/ext-debug.c dovecot-1.2.4.debian/dovecot-libsieve/src/sieve-tools/debug/ext-debug.c
--- dovecot-1.2.4/dovecot-libsieve/src/sieve-tools/debug/ext-debug.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/sieve-tools/debug/ext-debug.c	2009-03-26 17:53:38.000000000 +0100
@@ -0,0 +1,57 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension debug 
+ * ------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: vendor-defined
+ * Implementation: full
+ * Status: experimental
+ *
+ */
+ 
+#include "lib.h"
+#include "array.h"
+
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-address-parts.h"
+
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "ext-debug-common.h"
+
+/* 
+ * Extension 
+ */
+
+static bool ext_debug_validator_load(struct sieve_validator *validator);
+
+int ext_debug_my_id = -1;
+
+const struct sieve_extension debug_extension = { 
+	"vnd.dovecot.debug", 
+	&ext_debug_my_id,
+	NULL, NULL,
+	ext_debug_validator_load, 
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATION(debug_print_operation), 
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+static bool ext_debug_validator_load(struct sieve_validator *validator)
+{
+	/* Register new test */
+	sieve_validator_register_command(validator, &debug_print_command);
+
+	return TRUE;
+}
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/sieve-tools/debug/ext-debug-common.h dovecot-1.2.4.debian/dovecot-libsieve/src/sieve-tools/debug/ext-debug-common.h
--- dovecot-1.2.4/dovecot-libsieve/src/sieve-tools/debug/ext-debug-common.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/sieve-tools/debug/ext-debug-common.h	2009-03-26 17:53:38.000000000 +0100
@@ -0,0 +1,21 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#ifndef __EXT_DEBUG_COMMON_H
+#define __EXT_DEBUG_COMMON_H
+
+#include "sieve-ext-debug.h"
+
+/* 
+ * Commands
+ */
+
+extern const struct sieve_command debug_print_command;
+ 
+/*
+ * Operations
+ */
+
+extern const struct sieve_operation debug_print_operation;
+
+#endif /* __EXT_DEBUG_COMMON_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/sieve-tools/debug/Makefile.am dovecot-1.2.4.debian/dovecot-libsieve/src/sieve-tools/debug/Makefile.am
--- dovecot-1.2.4/dovecot-libsieve/src/sieve-tools/debug/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/sieve-tools/debug/Makefile.am	2009-03-26 17:53:38.000000000 +0100
@@ -0,0 +1,19 @@
+noinst_LTLIBRARIES = libsieve_ext_debug.la
+
+AM_CPPFLAGS = \
+	-I$(top_srcdir)/src/lib-sieve \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+commands = \
+	cmd-debug-print.c
+
+libsieve_ext_debug_la_SOURCES = \
+	$(commands) \
+	ext-debug.c
+
+noinst_HEADERS = \
+	sieve-ext-debug.h \
+	ext-debug-common.h
diff -urN dovecot-1.2.4/dovecot-libsieve/src/sieve-tools/debug/Makefile.in dovecot-1.2.4.debian/dovecot-libsieve/src/sieve-tools/debug/Makefile.in
--- dovecot-1.2.4/dovecot-libsieve/src/sieve-tools/debug/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/sieve-tools/debug/Makefile.in	2009-08-21 00:55:44.000000000 +0200
@@ -0,0 +1,466 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/sieve-tools/debug
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libsieve_ext_debug_la_LIBADD =
+am__objects_1 = cmd-debug-print.lo
+am_libsieve_ext_debug_la_OBJECTS = $(am__objects_1) ext-debug.lo
+libsieve_ext_debug_la_OBJECTS = $(am_libsieve_ext_debug_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_ext_debug_la_SOURCES)
+DIST_SOURCES = $(libsieve_ext_debug_la_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LTLIBRARIES = libsieve_ext_debug.la
+AM_CPPFLAGS = \
+	-I$(top_srcdir)/src/lib-sieve \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+commands = \
+	cmd-debug-print.c
+
+libsieve_ext_debug_la_SOURCES = \
+	$(commands) \
+	ext-debug.c
+
+noinst_HEADERS = \
+	sieve-ext-debug.h \
+	ext-debug-common.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/sieve-tools/debug/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  src/sieve-tools/debug/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve_ext_debug.la: $(libsieve_ext_debug_la_OBJECTS) $(libsieve_ext_debug_la_DEPENDENCIES) 
+	$(LINK)  $(libsieve_ext_debug_la_OBJECTS) $(libsieve_ext_debug_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-debug-print.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-debug.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.2.4/dovecot-libsieve/src/sieve-tools/debug/sieve-ext-debug.h dovecot-1.2.4.debian/dovecot-libsieve/src/sieve-tools/debug/sieve-ext-debug.h
--- dovecot-1.2.4/dovecot-libsieve/src/sieve-tools/debug/sieve-ext-debug.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/sieve-tools/debug/sieve-ext-debug.h	2009-03-26 17:53:38.000000000 +0100
@@ -0,0 +1,13 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#ifndef __SIEVE_EXT_DEBUG_H
+#define __SIEVE_EXT_DEBUG_H
+
+/*
+ * Extension
+ */
+ 
+extern const struct sieve_extension debug_extension;
+
+#endif /* __SIEVE_EXT_DEBUG_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/sieve-tools/Makefile.am dovecot-1.2.4.debian/dovecot-libsieve/src/sieve-tools/Makefile.am
--- dovecot-1.2.4/dovecot-libsieve/src/sieve-tools/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/sieve-tools/Makefile.am	2009-07-20 23:30:49.000000000 +0200
@@ -0,0 +1,72 @@
+pkglibexecdir = $(libexecdir)/dovecot
+
+SUBDIRS = debug
+
+bin_PROGRAMS = sievec sieved sieve-test
+
+if BUILD_UNFINISHED
+bin_PROGRAMS += sieve-filter
+endif
+
+AM_CPPFLAGS = \
+	-I$(top_srcdir)/src/lib-sieve \
+	-I$(top_srcdir)/src/lib-sieve-tool \
+	-I./debug \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-index \
+	-I$(dovecot_incdir)/src/lib-storage \
+	-I$(dovecot_incdir)/src/deliver
+
+libs = \
+	$(top_srcdir)/src/lib-sieve/libsieve.la \
+	$(top_srcdir)/src/lib-sieve-tool/libsieve-tool.la \
+	./debug/libsieve_ext_debug.la \
+	$(STORAGE_LIBS) 
+
+ldadd = \
+	$(libs) \
+ 	$(LIBICONV) \
+	$(RAND_LIBS) \
+	$(MODULE_LIBS)
+
+# Sieve Compile Tool
+
+sievec_LDFLAGS = -export-dynamic 
+sievec_LDADD = $(ldadd)
+sievec_DEPENDENCIES = $(libs)
+
+sievec_SOURCES = \
+	sievec.c 
+
+# Sieve Dump Tool
+
+sieved_LDFLAGS = -export-dynamic 
+sieved_LDADD = $(ldadd)
+sieved_DEPENDENCIES = $(libs)
+
+sieved_SOURCES = \
+	sieved.c 
+
+# Sieve Test Tool
+
+sieve_test_LDFLAGS = -export-dynamic
+sieve_test_LDADD = $(ldadd)
+sieve_test_DEPENDENCIES = $(libs)
+
+sieve_test_SOURCES = \
+	sieve-test.c 
+
+## Unfinished tools
+
+# Sieve Filter Tool
+
+sieve_filter_LDFLAGS = -export-dynamic
+sieve_filter_LDADD = $(ldadd)
+sieve_filter_DEPENDENCIES = $(libs)
+
+sieve_filter_SOURCES = \
+	sieve-filter.c 
+
+noinst_HEADERS =
diff -urN dovecot-1.2.4/dovecot-libsieve/src/sieve-tools/Makefile.in dovecot-1.2.4.debian/dovecot-libsieve/src/sieve-tools/Makefile.in
--- dovecot-1.2.4/dovecot-libsieve/src/sieve-tools/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/sieve-tools/Makefile.in	2009-08-21 00:55:44.000000000 +0200
@@ -0,0 +1,683 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+bin_PROGRAMS = sievec$(EXEEXT) sieved$(EXEEXT) sieve-test$(EXEEXT) \
+	$(am__EXEEXT_1)
+@BUILD_UNFINISHED_TRUE@am__append_1 = sieve-filter
+subdir = src/sieve-tools
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+@BUILD_UNFINISHED_TRUE@am__EXEEXT_1 = sieve-filter$(EXEEXT)
+am__installdirs = "$(DESTDIR)$(bindir)"
+binPROGRAMS_INSTALL = $(INSTALL_PROGRAM)
+PROGRAMS = $(bin_PROGRAMS)
+am_sieve_filter_OBJECTS = sieve-filter.$(OBJEXT)
+sieve_filter_OBJECTS = $(am_sieve_filter_OBJECTS)
+am__DEPENDENCIES_1 =
+am__DEPENDENCIES_2 = $(top_srcdir)/src/lib-sieve/libsieve.la \
+	$(top_srcdir)/src/lib-sieve-tool/libsieve-tool.la \
+	./debug/libsieve_ext_debug.la $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_3 = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1) \
+	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1)
+sieve_filter_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(sieve_filter_LDFLAGS) $(LDFLAGS) -o $@
+am_sieve_test_OBJECTS = sieve-test.$(OBJEXT)
+sieve_test_OBJECTS = $(am_sieve_test_OBJECTS)
+sieve_test_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(sieve_test_LDFLAGS) $(LDFLAGS) -o $@
+am_sievec_OBJECTS = sievec.$(OBJEXT)
+sievec_OBJECTS = $(am_sievec_OBJECTS)
+sievec_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(sievec_LDFLAGS) \
+	$(LDFLAGS) -o $@
+am_sieved_OBJECTS = sieved.$(OBJEXT)
+sieved_OBJECTS = $(am_sieved_OBJECTS)
+sieved_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(sieved_LDFLAGS) \
+	$(LDFLAGS) -o $@
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(sieve_filter_SOURCES) $(sieve_test_SOURCES) \
+	$(sievec_SOURCES) $(sieved_SOURCES)
+DIST_SOURCES = $(sieve_filter_SOURCES) $(sieve_test_SOURCES) \
+	$(sievec_SOURCES) $(sieved_SOURCES)
+RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
+	html-recursive info-recursive install-data-recursive \
+	install-dvi-recursive install-exec-recursive \
+	install-html-recursive install-info-recursive \
+	install-pdf-recursive install-ps-recursive install-recursive \
+	installcheck-recursive installdirs-recursive pdf-recursive \
+	ps-recursive uninstall-recursive
+HEADERS = $(noinst_HEADERS)
+RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
+  distclean-recursive maintainer-clean-recursive
+ETAGS = etags
+CTAGS = ctags
+DIST_SUBDIRS = $(SUBDIRS)
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+pkglibexecdir = $(libexecdir)/dovecot
+SUBDIRS = debug
+AM_CPPFLAGS = \
+	-I$(top_srcdir)/src/lib-sieve \
+	-I$(top_srcdir)/src/lib-sieve-tool \
+	-I./debug \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-index \
+	-I$(dovecot_incdir)/src/lib-storage \
+	-I$(dovecot_incdir)/src/deliver
+
+libs = \
+	$(top_srcdir)/src/lib-sieve/libsieve.la \
+	$(top_srcdir)/src/lib-sieve-tool/libsieve-tool.la \
+	./debug/libsieve_ext_debug.la \
+	$(STORAGE_LIBS) 
+
+ldadd = \
+	$(libs) \
+ 	$(LIBICONV) \
+	$(RAND_LIBS) \
+	$(MODULE_LIBS)
+
+
+# Sieve Compile Tool
+sievec_LDFLAGS = -export-dynamic 
+sievec_LDADD = $(ldadd)
+sievec_DEPENDENCIES = $(libs)
+sievec_SOURCES = \
+	sievec.c 
+
+
+# Sieve Dump Tool
+sieved_LDFLAGS = -export-dynamic 
+sieved_LDADD = $(ldadd)
+sieved_DEPENDENCIES = $(libs)
+sieved_SOURCES = \
+	sieved.c 
+
+
+# Sieve Test Tool
+sieve_test_LDFLAGS = -export-dynamic
+sieve_test_LDADD = $(ldadd)
+sieve_test_DEPENDENCIES = $(libs)
+sieve_test_SOURCES = \
+	sieve-test.c 
+
+
+# Sieve Filter Tool
+sieve_filter_LDFLAGS = -export-dynamic
+sieve_filter_LDADD = $(ldadd)
+sieve_filter_DEPENDENCIES = $(libs)
+sieve_filter_SOURCES = \
+	sieve-filter.c 
+
+noinst_HEADERS = 
+all: all-recursive
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/sieve-tools/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  src/sieve-tools/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+install-binPROGRAMS: $(bin_PROGRAMS)
+	@$(NORMAL_INSTALL)
+	test -z "$(bindir)" || $(MKDIR_P) "$(DESTDIR)$(bindir)"
+	@list='$(bin_PROGRAMS)'; for p in $$list; do \
+	  p1=`echo $$p|sed 's/$(EXEEXT)$$//'`; \
+	  if test -f $$p \
+	     || test -f $$p1 \
+	  ; then \
+	    f=`echo "$$p1" | sed 's,^.*/,,;$(transform);s/$$/$(EXEEXT)/'`; \
+	   echo " $(INSTALL_PROGRAM_ENV) $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(binPROGRAMS_INSTALL) '$$p' '$(DESTDIR)$(bindir)/$$f'"; \
+	   $(INSTALL_PROGRAM_ENV) $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(binPROGRAMS_INSTALL) "$$p" "$(DESTDIR)$(bindir)/$$f" || exit 1; \
+	  else :; fi; \
+	done
+
+uninstall-binPROGRAMS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(bin_PROGRAMS)'; for p in $$list; do \
+	  f=`echo "$$p" | sed 's,^.*/,,;s/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/'`; \
+	  echo " rm -f '$(DESTDIR)$(bindir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(bindir)/$$f"; \
+	done
+
+clean-binPROGRAMS:
+	@list='$(bin_PROGRAMS)'; for p in $$list; do \
+	  f=`echo $$p|sed 's/$(EXEEXT)$$//'`; \
+	  echo " rm -f $$p $$f"; \
+	  rm -f $$p $$f ; \
+	done
+sieve-filter$(EXEEXT): $(sieve_filter_OBJECTS) $(sieve_filter_DEPENDENCIES) 
+	@rm -f sieve-filter$(EXEEXT)
+	$(sieve_filter_LINK) $(sieve_filter_OBJECTS) $(sieve_filter_LDADD) $(LIBS)
+sieve-test$(EXEEXT): $(sieve_test_OBJECTS) $(sieve_test_DEPENDENCIES) 
+	@rm -f sieve-test$(EXEEXT)
+	$(sieve_test_LINK) $(sieve_test_OBJECTS) $(sieve_test_LDADD) $(LIBS)
+sievec$(EXEEXT): $(sievec_OBJECTS) $(sievec_DEPENDENCIES) 
+	@rm -f sievec$(EXEEXT)
+	$(sievec_LINK) $(sievec_OBJECTS) $(sievec_LDADD) $(LIBS)
+sieved$(EXEEXT): $(sieved_OBJECTS) $(sieved_DEPENDENCIES) 
+	@rm -f sieved$(EXEEXT)
+	$(sieved_LINK) $(sieved_OBJECTS) $(sieved_LDADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-filter.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-test.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sievec.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieved.Po@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run `make' without going through this Makefile.
+# To change the values of `make' variables: instead of editing Makefiles,
+# (1) if the variable is set in `config.status', edit `config.status'
+#     (which will cause the Makefiles to be regenerated when you run `make');
+# (2) otherwise, pass the desired values on the `make' command line.
+$(RECURSIVE_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+$(RECURSIVE_CLEAN_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	rev=''; for subdir in $$list; do \
+	  if test "$$subdir" = "."; then :; else \
+	    rev="$$subdir $$rev"; \
+	  fi; \
+	done; \
+	rev="$$rev ."; \
+	target=`echo $@ | sed s/-recursive//`; \
+	for subdir in $$rev; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done && test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
+	done
+ctags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	  empty_fix=.; \
+	else \
+	  include_option=--include; \
+	  empty_fix=; \
+	fi; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test ! -f $$subdir/TAGS || \
+	      tags="$$tags $$include_option=$$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+	list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test -d "$(distdir)/$$subdir" \
+	    || $(MKDIR_P) "$(distdir)/$$subdir" \
+	    || exit 1; \
+	    distdir=`$(am__cd) $(distdir) && pwd`; \
+	    top_distdir=`$(am__cd) $(top_distdir) && pwd`; \
+	    (cd $$subdir && \
+	      $(MAKE) $(AM_MAKEFLAGS) \
+	        top_distdir="$$top_distdir" \
+	        distdir="$$distdir/$$subdir" \
+		am__remove_distdir=: \
+		am__skip_length_check=: \
+	        distdir) \
+	      || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-recursive
+all-am: Makefile $(PROGRAMS) $(HEADERS)
+installdirs: installdirs-recursive
+installdirs-am:
+	for dir in "$(DESTDIR)$(bindir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-recursive
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-recursive
+
+clean-am: clean-binPROGRAMS clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-recursive
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-recursive
+
+dvi-am:
+
+html: html-recursive
+
+info: info-recursive
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-recursive
+
+install-exec-am: install-binPROGRAMS
+
+install-html: install-html-recursive
+
+install-info: install-info-recursive
+
+install-man:
+
+install-pdf: install-pdf-recursive
+
+install-ps: install-ps-recursive
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-recursive
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-recursive
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-recursive
+
+pdf-am:
+
+ps: ps-recursive
+
+ps-am:
+
+uninstall-am: uninstall-binPROGRAMS
+
+.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) install-am \
+	install-strip
+
+.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
+	all all-am check check-am clean clean-binPROGRAMS \
+	clean-generic clean-libtool ctags ctags-recursive distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-binPROGRAMS install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs installdirs-am maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags tags-recursive uninstall uninstall-am \
+	uninstall-binPROGRAMS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.2.4/dovecot-libsieve/src/sieve-tools/sievec.c dovecot-1.2.4.debian/dovecot-libsieve/src/sieve-tools/sievec.c
--- dovecot-1.2.4/dovecot-libsieve/src/sieve-tools/sievec.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/sieve-tools/sievec.c	2009-08-04 21:31:07.000000000 +0200
@@ -0,0 +1,153 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+
+#include "sieve.h"
+#include "sieve-extensions.h"
+#include "sieve-script.h"
+#include "sieve-tool.h"
+
+#include "sieve-ext-debug.h"
+
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <dirent.h>
+
+/*
+ * Print help
+ */
+
+static void print_help(void)
+{
+	printf(
+"Usage: sievec [-d] [-x <extensions>] <script-file> [<out-file>]\n"
+	);
+}
+
+/* 
+ * Tool implementation
+ */
+
+int main(int argc, char **argv) {
+	int i;
+	struct stat st;
+	struct sieve_binary *sbin;
+	bool dump = FALSE;
+	const char *scriptfile, *outfile, *extensions;
+		
+	sieve_tool_init();	
+		
+	scriptfile = outfile = extensions = NULL;
+	for (i = 1; i < argc; i++) {
+		if (strcmp(argv[i], "-d") == 0) {
+			/* dump file */
+			dump = TRUE;
+		} else if (strcmp(argv[i], "-x") == 0) {
+			/* extensions */
+			i++;
+			if (i == argc) {
+				print_help();
+				i_fatal("Missing -x argument");
+			}
+			extensions = argv[i];
+		} else if ( scriptfile == NULL ) {
+			scriptfile = argv[i];
+		} else if ( outfile == NULL ) {
+			outfile = argv[i];
+		} else {
+			print_help();
+			i_fatal("Unknown argument: %s", argv[i]);
+		}
+	}
+	
+	if ( scriptfile == NULL ) {
+		print_help();
+		i_fatal("Missing <script-file> argument");
+	}
+	
+	if ( outfile == NULL && dump )
+		outfile = "-";
+
+	if ( extensions != NULL ) {
+		sieve_set_extensions(extensions);
+	}
+
+	/* Register tool-specific extensions */
+	(void) sieve_extension_register(&debug_extension, TRUE);
+
+	if ( stat(scriptfile, &st) == 0 && S_ISDIR(st.st_mode) ) {
+		/* Script directory */
+		DIR *dirp;
+		struct dirent *dp;
+		
+		/* Sanity checks on some of the arguments */
+		
+		if ( dump )
+			i_fatal("the -d option is not allowed when scriptfile is a directory."); 
+		
+		if ( outfile != NULL )
+			i_fatal("the outfile argument is not allowed when scriptfile is a "
+				"directory."); 
+		
+		/* Open the directory */
+		if ( (dirp = opendir(scriptfile)) == NULL )
+			i_fatal("opendir(%s) failed: %m", scriptfile);
+			
+		/* Compile each sieve file */
+		for (;;) {
+		
+			errno = 0;
+			if ( (dp = readdir(dirp)) == NULL ) {
+				if ( errno != 0 ) 
+					i_fatal("readdir(%s) failed: %m", scriptfile);
+				break;
+			}
+											
+			if ( sieve_script_file_has_extension(dp->d_name) ) {
+				const char *file;
+				
+				if ( scriptfile[strlen(scriptfile)-1] == '/' )
+					file = t_strconcat(scriptfile, dp->d_name, NULL);
+				else
+					file = t_strconcat(scriptfile, "/", dp->d_name, NULL);
+
+				sbin = sieve_tool_script_compile(file, dp->d_name);
+
+				if ( sbin != NULL ) {
+					sieve_save(sbin, NULL);
+		
+					sieve_close(&sbin);
+				}
+			}
+		}
+   
+		/* Close the directory */
+		if ( closedir(dirp) < 0 ) 
+			i_fatal("closedir(%s) failed: %m", scriptfile);
+ 	
+	} else {
+		/* Script file (i.e. not a directory)
+		 * 
+		 *   NOTE: For consistency, stat errors are handled here as well 
+		 */	
+		sbin = sieve_tool_script_compile(scriptfile, NULL);
+
+		if ( sbin != NULL ) {
+			if ( dump ) 
+				sieve_tool_dump_binary_to(sbin, outfile);
+			else {
+				sieve_save(sbin, outfile);
+			}
+		
+			sieve_close(&sbin);
+		}
+	}
+		
+	sieve_tool_deinit();
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/sieve-tools/sieved.c dovecot-1.2.4.debian/dovecot-libsieve/src/sieve-tools/sieved.c
--- dovecot-1.2.4/dovecot-libsieve/src/sieve-tools/sieved.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/sieve-tools/sieved.c	2009-08-04 21:31:07.000000000 +0200
@@ -0,0 +1,85 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+
+#include "sieve.h"
+#include "sieve-extensions.h"
+#include "sieve-tool.h"
+
+#include "sieve-ext-debug.h"
+
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <stdio.h>
+
+/*
+ * Print help
+ */
+
+static void print_help(void)
+{
+	printf(
+"Usage: sieved [-x <extensions>] <sieve-binary> [<out-file>]\n"
+	);
+}
+
+/*
+ * Tool implementation
+ */
+
+int main(int argc, char **argv) {
+	int i;
+	struct sieve_binary *sbin;
+	const char *binfile, *outfile, *extensions;
+	
+	sieve_tool_init();
+	
+	binfile = outfile = extensions = NULL;
+	for (i = 1; i < argc; i++) {
+		if (strcmp(argv[i], "-x") == 0) {
+			/* extensions */
+			i++;
+			if (i == argc) {
+				print_help();
+				i_fatal("Missing -x argument");
+			}
+			extensions = argv[i];
+		} else if ( binfile == NULL ) {
+			binfile = argv[i];
+		} else if ( outfile == NULL ) {
+			outfile = argv[i];
+		} else {
+			print_help();
+			i_fatal("unknown argument: %s", argv[i]);
+		}
+	}
+	
+	if ( binfile == NULL ) {
+		print_help();
+		i_fatal("missing <sieve-binary> argument");
+	}
+
+	if ( extensions != NULL ) {
+		sieve_set_extensions(extensions);
+	}
+
+	/* Register tool-specific extensions */
+	(void) sieve_extension_register(&debug_extension, TRUE);
+		
+	sbin = sieve_load(binfile);
+
+	if ( sbin != NULL ) {
+		sieve_tool_dump_binary_to(sbin, outfile == NULL ? "-" : outfile);
+	
+		sieve_close(&sbin);
+	} else 
+		i_error("failed to load binary: %s", binfile);
+	
+	sieve_tool_deinit();
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/sieve-tools/sieve-filter.c dovecot-1.2.4.debian/dovecot-libsieve/src/sieve-tools/sieve-filter.c
--- dovecot-1.2.4/dovecot-libsieve/src/sieve-tools/sieve-filter.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/sieve-tools/sieve-filter.c	2009-07-27 17:40:27.000000000 +0200
@@ -0,0 +1,390 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "ostream.h"
+#include "array.h"
+#include "mail-namespace.h"
+#include "mail-storage.h"
+#include "mail-search-build.h"
+#include "env-util.h"
+
+#include "sieve.h"
+#include "sieve-extensions.h"
+#include "sieve-binary.h"
+
+#include "mail-raw.h"
+#include "sieve-tool.h"
+
+#include "sieve-ext-debug.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <pwd.h>
+
+/*
+ * Print help
+ */
+
+static void print_help(void)
+{
+	printf(
+"Usage: sieve-filter [-m <mailbox>] [-x <extensions>] [-s <script-file>] [-c]\n"
+"                    <script-file> <src-mail-store> [<dest-mail-store>]\n"
+	);
+}
+
+enum discard_action_type {
+	DISCARD_ACTION_KEEP,            /* Always keep messages in source folder */ 
+	DISCARD_ACTION_DELETE,          /* Flag discarded messages as \DELETED */
+	DISCARD_ACTION_TRASH_FOLDER,    /* Move discarded messages to Trash folder */      
+	DISCARD_ACTION_EXPUNGE          /* Expunge discarded messages */
+};
+
+struct discard_action {
+	enum discard_action_type type;
+	const char *trash_folder;
+};
+
+static int filter_message
+(struct mail *mail, struct sieve_binary *main_sbin, 
+	struct sieve_script_env *senv, struct sieve_error_handler *ehandler,
+	struct discard_action discard_action)
+{
+	struct sieve_exec_status estatus;
+	struct sieve_binary *sbin;
+	struct sieve_message_data msgdata;
+	const char *recipient, *sender;
+	int ret;
+
+	sieve_tool_get_envelope_data(mail, &recipient, &sender);
+
+	/* Initialize execution status */
+	memset(&estatus, 0, sizeof(estatus));
+	senv->exec_status = &estatus;
+
+	/* Collect necessary message data */
+	memset(&msgdata, 0, sizeof(msgdata));
+	msgdata.mail = mail;
+	msgdata.return_path = sender;
+	msgdata.to_address = recipient;
+	msgdata.auth_user = senv->username;
+	(void)mail_get_first_header(mail, "Message-ID", &msgdata.id);
+
+	/* Single script */
+	sbin = main_sbin;
+	main_sbin = NULL;
+
+	/* Execute script */
+	ret = sieve_execute(sbin, &msgdata, senv, ehandler, NULL);
+
+	/* Handle message in source folder */
+	if ( ret > 0 && !estatus.keep_original ) {
+		switch ( discard_action.type ) {
+		/* Leave it there */
+		case DISCARD_ACTION_KEEP:
+			sieve_info(ehandler, NULL, "message left in source folder");
+			break;
+		/* Flag message as \DELETED */
+		case DISCARD_ACTION_DELETE:					
+			sieve_info(ehandler, NULL, "message flagged as deleted in source folder");
+			mail_update_flags(mail, MODIFY_ADD, MAIL_DELETED);
+			break;
+		/* Move message to Trash folder */
+		case DISCARD_ACTION_TRASH_FOLDER:			
+			sieve_info(ehandler, NULL, 
+				"message in source folder moved to folder '%s'", 
+				discard_action.trash_folder);
+			break;
+		/* Expunge the message immediately */
+		case DISCARD_ACTION_EXPUNGE:
+			sieve_info(ehandler, NULL, "message removed from source folder");
+			mail_expunge(mail);
+			break;
+		/* Unknown */
+		default:
+			i_unreached();
+			break;
+		}
+	}
+
+	return ret;
+}
+
+/* FIXME: introduce this into Dovecot */
+static void mail_search_build_add_flags
+(struct mail_search_args *args, enum mail_flags flags, bool not)
+{
+	struct mail_search_arg *arg;
+
+	arg = p_new(args->pool, struct mail_search_arg, 1);
+	arg->type = SEARCH_FLAGS;
+	arg->value.flags = flags;
+	arg->not = not;
+
+	arg->next = args->args;
+	args->args = arg;
+}
+
+static int filter_mailbox
+(struct mailbox *box, struct sieve_binary *main_sbin, 
+	struct sieve_script_env *senv, struct sieve_error_handler *ehandler,
+	struct discard_action discard_action)
+{
+	struct mail_search_args *search_args;
+	struct mailbox_transaction_context *t;
+	struct mail_search_context *search_ctx;
+	struct mail *mail;
+	int ret = 1;
+
+	/* Sync mailbox */
+
+	if ( mailbox_sync(box, MAILBOX_SYNC_FLAG_FULL_READ, 0, NULL) < 0 ) {
+		return -1;
+	}
+
+	/* Search non-deleted messages in the source folder */
+
+	search_args = mail_search_build_init();
+	mail_search_build_add_flags(search_args, MAIL_DELETED, TRUE);
+
+	/* Iterate through all requested messages */
+
+	t = mailbox_transaction_begin(box, 0);
+	search_ctx = mailbox_search_init(t, search_args, NULL);
+	mail_search_args_unref(&search_args);
+
+	mail = mail_alloc(t, 0, NULL);
+	while ( ret > 0 && mailbox_search_next(search_ctx, mail) > 0 ) {
+		const char *subject, *date;
+		uoff_t size = 0;
+					
+		/* Request message size */
+
+		if ( mail_get_virtual_size(mail, &size) < 0 ) {
+			if ( mail->expunged )
+				continue;
+			
+			sieve_error(ehandler, NULL, "failed to obtain message size");
+			continue;
+		}
+
+		if ( mail_get_first_header(mail, "date", &date) <= 0 )
+			date = "";
+		if ( mail_get_first_header(mail, "subject", &subject) <= 0 ) 
+			subject = "";
+		
+		sieve_info(ehandler, NULL,
+			"filtering: [%s; %"PRIuUOFF_T" bytes] %s", date, size, subject);
+	
+		ret = filter_message(mail, main_sbin, senv, ehandler, discard_action);
+	}
+	mail_free(&mail);
+	
+	/* Cleanup */
+
+	if ( mailbox_search_deinit(&search_ctx) < 0 ) {
+		ret = -1;
+	}
+
+	if ( ret < 0 ) {
+		mailbox_transaction_rollback(&t);
+		return -1;
+	} else {
+		if ( mailbox_transaction_commit(&t) < 0 ) {
+			return -1;
+		}
+	}
+
+	/* Sync mailbox */
+
+	if ( mailbox_sync(box, MAILBOX_SYNC_FLAG_FULL_WRITE, 0, NULL) < 0 ) {
+		return -1;
+	}
+	
+	return ret;
+}
+
+/*
+ * Tool implementation
+ */
+
+int main(int argc, char **argv) 
+{
+	const char *scriptfile, *recipient, *sender, *extensions,
+		*src_mailbox, *dst_mailbox, *src_mailstore, *dst_mailstore; 
+	bool force_compile;
+	struct mail_namespace *src_ns = NULL, *dst_ns = NULL;
+	struct mail_user *mail_user = NULL;
+	struct sieve_binary *main_sbin;
+	struct sieve_script_env scriptenv;
+	struct sieve_error_handler *ehandler;
+	struct mail_storage *dst_storage, *src_storage;
+	struct discard_action discard_action = 
+		{ DISCARD_ACTION_KEEP, "Trash" };
+	struct mailbox *src_box;
+	enum mail_error error;
+	enum mailbox_open_flags open_flags = 
+		MAILBOX_OPEN_KEEP_RECENT | MAILBOX_OPEN_IGNORE_ACLS;
+	const char *user, *home, *folder;
+	int i;
+
+	sieve_tool_init();
+	
+	/* Parse arguments */
+	scriptfile = recipient = sender = extensions = src_mailstore = dst_mailstore 
+		= NULL;
+	src_mailbox = dst_mailbox = "INBOX";
+	force_compile = FALSE;
+	for (i = 1; i < argc; i++) {
+		if (strcmp(argv[i], "-m") == 0) {
+			/* default mailbox (keep box) */
+			i++;
+			if (i == argc) 
+				i_fatal("Missing -m argument");
+			dst_mailbox = argv[i];
+		} else if (strcmp(argv[i], "-x") == 0) {
+			/* extensions */
+			i++;
+			if (i == argc)
+				i_fatal("Missing -x argument");
+			extensions = argv[i];
+		} else if (strcmp(argv[i], "-c") == 0) {
+			/* force compile */
+			force_compile = TRUE;
+		} else if ( scriptfile == NULL ) {
+			scriptfile = argv[i];
+		} else if ( src_mailstore == NULL ) {
+			src_mailstore = argv[i];
+		} else if ( dst_mailstore == NULL ) {
+			dst_mailstore = argv[i];
+		} else {
+			print_help();
+			i_fatal("Unknown argument: %s", argv[i]);
+		}
+	}
+	
+	if ( scriptfile == NULL ) {
+		print_help();
+		i_fatal("Missing <scriptfile> argument");
+	}
+	
+	if ( src_mailstore == NULL ) {
+		print_help();
+		i_fatal("Missing <mailstore> argument");
+	}
+
+	if ( extensions != NULL ) {
+		sieve_set_extensions(extensions);
+	}
+
+	/* Register tool-specific extensions */
+	(void) sieve_extension_register(&debug_extension, TRUE);
+
+	/* Create error handler */
+	ehandler = sieve_stderr_ehandler_create(0);
+	sieve_system_ehandler_set(ehandler);
+	sieve_error_handler_accept_infolog(ehandler, TRUE);
+
+	/* Compile main sieve script */
+	if ( force_compile ) {
+		main_sbin = sieve_tool_script_compile(scriptfile, NULL);
+		(void) sieve_save(main_sbin, NULL);
+	} else {
+		main_sbin = sieve_tool_script_open(scriptfile);
+	}
+	
+	user = sieve_tool_get_user();
+	home = getenv("HOME");
+
+	/* Initialize mail storages */
+	mail_users_init(getenv("AUTH_SOCKET_PATH"), getenv("DEBUG") != NULL);
+	mail_storage_init();
+	mail_storage_register_all();
+	mailbox_list_register_all();
+
+	/* Build namespaces environment (ugly!) */
+	env_put(t_strdup_printf("NAMESPACE_1=%s", src_mailstore));
+	env_put("NAMESPACE_1_INBOX=1");
+	env_put("NAMESPACE_1_LIST=1");
+	env_put("NAMESPACE_1_SEP=/");
+	env_put("NAMESPACE_1_SUBSCRIPTIONS=1");
+
+	if ( dst_mailstore != NULL ) {
+		env_put(t_strdup_printf("NAMESPACE_2=%s", dst_mailstore));
+		env_put("NAMESPACE_2_LIST=1");
+		env_put("NAMESPACE_2_SEP=/");
+		env_put("NAMESPACE_2_SUBSCRIPTIONS=1");
+
+		env_put("NAMESPACE_1_PREFIX=#src/");
+	}
+
+	/* Initialize namespaces */
+	mail_user = mail_user_init(user);
+	mail_user_set_home(mail_user, home);
+	if (mail_namespaces_init(mail_user) < 0)
+		i_fatal("Namespace initialization failed");	
+
+	if ( dst_mailstore != NULL ) {
+		folder = "#src/";
+		src_ns = mail_namespace_find(mail_user->namespaces, &folder);
+
+		folder = "/";
+		dst_ns = mail_namespace_find(mail_user->namespaces, &folder);	
+
+		discard_action.type = DISCARD_ACTION_KEEP;	
+	} else {
+		dst_ns = src_ns = mail_user->namespaces;
+		discard_action.type = DISCARD_ACTION_DELETE;	
+	}
+
+	src_storage = src_ns->storage;
+	dst_storage = dst_ns->storage;
+
+	/* Open the source mailbox */	
+	src_box = mailbox_open(&src_storage, src_mailbox, NULL, open_flags);
+	if ( src_box == NULL ) {
+		i_fatal("Couldn't open mailbox '%s': %s", 
+			src_mailbox, mail_storage_get_last_error(src_storage, &error));
+	}
+
+	/* Compose script environment */
+	memset(&scriptenv, 0, sizeof(scriptenv));
+	scriptenv.mailbox_autocreate = TRUE;
+	scriptenv.default_mailbox = dst_mailbox;
+	scriptenv.namespaces = dst_ns;
+	scriptenv.username = user;
+	scriptenv.hostname = "host.example.com";
+	scriptenv.postmaster_address = "postmaster@example.com";
+	scriptenv.smtp_open = NULL;
+	scriptenv.smtp_close = NULL;
+	scriptenv.duplicate_mark = NULL;
+	scriptenv.duplicate_check = NULL;
+	scriptenv.trace_stream = NULL;
+
+	/* Apply Sieve filter to all messages found */
+	(void) filter_mailbox
+		(src_box, main_sbin, &scriptenv, ehandler, discard_action);
+	
+	/* Close the mailbox */
+	if ( src_box != NULL )
+		mailbox_close(&src_box);
+
+	/* Cleanup error handler */
+	sieve_error_handler_unref(&ehandler);
+	sieve_system_ehandler_reset();	
+
+	/* De-initialize mail user object */
+	if ( mail_user != NULL )
+		mail_user_unref(&mail_user);
+
+	/* De-initialize mail storages */
+	mail_storage_deinit();
+	mail_users_deinit();	
+	
+	sieve_tool_deinit();
+	
+	return 0;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/sieve-tools/sieve-test.c dovecot-1.2.4.debian/dovecot-libsieve/src/sieve-tools/sieve-test.c
--- dovecot-1.2.4/dovecot-libsieve/src/sieve-tools/sieve-test.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/sieve-tools/sieve-test.c	2009-08-04 21:31:07.000000000 +0200
@@ -0,0 +1,417 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "ostream.h"
+#include "array.h"
+#include "mail-namespace.h"
+#include "mail-storage.h"
+#include "env-util.h"
+
+#include "sieve.h"
+#include "sieve-binary.h"
+#include "sieve-extensions.h"
+
+#include "mail-raw.h"
+#include "sieve-tool.h"
+
+#include "sieve-ext-debug.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <pwd.h>
+
+/* 
+ * Configuration
+ */
+
+#define DEFAULT_SENDMAIL_PATH "/usr/lib/sendmail"
+#define DEFAULT_ENVELOPE_SENDER "MAILER-DAEMON"
+
+/*
+ * Print help
+ */
+
+static void print_help(void)
+{
+	printf(
+"Usage: sieve-test [-c] [-d <dump-filename>] [-e] [-f <envelope-sender>]\n"
+"                  [-l <mail-location>] [-m <default-mailbox>]\n" 
+"                  [-r <recipient-address>] [-s <script-file>]\n"
+"                  [-t] [-x <extensions>] <script-file> <mail-file>\n"
+	);
+}
+
+/*
+ * Dummy SMTP session
+ */
+
+static void *sieve_smtp_open(const char *destination,
+	const char *return_path, FILE **file_r)
+{
+	i_info("sending message from <%s> to <%s>:",
+		( return_path == NULL ? "" : return_path ), destination);
+	printf("\nSTART MESSAGE:\n");
+	
+	*file_r = stdout;
+	
+	return NULL;	
+}
+
+static bool sieve_smtp_close(void *handle ATTR_UNUSED)
+{
+	printf("END MESSAGE\n\n");
+	return TRUE;
+}
+
+/*
+ * Dummy duplicate check implementation
+ */
+
+static int duplicate_check(const void *id ATTR_UNUSED, size_t id_size ATTR_UNUSED, 
+	const char *user)
+{
+	i_info("checked duplicate for user %s.\n", user);
+	return 0;
+}
+
+static void duplicate_mark
+(const void *id ATTR_UNUSED, size_t id_size ATTR_UNUSED, const char *user, 
+	time_t time ATTR_UNUSED)
+{
+	i_info("marked duplicate for user %s.\n", user);
+}
+
+/*
+ * Tool implementation
+ */
+
+int main(int argc, char **argv) 
+{
+	ARRAY_DEFINE(scriptfiles, const char *);
+	const char *scriptfile, *recipient, *sender, *mailbox, *dumpfile, *mailfile, 
+		*mailloc, *extensions; 
+	const char *user, *home;
+	int i;
+	struct mail_raw *mailr;
+	struct mail_namespace *ns = NULL;
+	struct mail_user *mail_user = NULL;
+	struct sieve_binary *main_sbin, *sbin = NULL;
+	struct sieve_message_data msgdata;
+	struct sieve_script_env scriptenv;
+	struct sieve_exec_status estatus;
+	struct sieve_error_handler *ehandler;
+	struct ostream *teststream = NULL;
+	bool force_compile = FALSE, execute = FALSE;
+	bool trace = FALSE;
+	int ret;
+
+	sieve_tool_init();
+	
+	t_array_init(&scriptfiles, 16);
+
+	/* Parse arguments (ugly) */
+	scriptfile = recipient = sender = mailbox = dumpfile = mailfile = mailloc = 
+		extensions = NULL;
+	for (i = 1; i < argc; i++) {
+		if (strcmp(argv[i], "-r") == 0) {
+			/* recipient address */
+			i++;
+			if (i == argc) {
+				print_help();
+				i_fatal("Missing -r argument");
+			}
+			recipient = argv[i];
+		} else if (strcmp(argv[i], "-f") == 0) {
+			/* envelope sender */
+			i++;
+			if (i == argc) {
+				print_help();
+				i_fatal("Missing -f argument");
+			}
+			sender = argv[i];
+		} else if (strcmp(argv[i], "-m") == 0) {
+			/* default mailbox (keep box) */
+			i++;
+			if (i == argc) {
+				print_help();
+				i_fatal("Missing -m argument");
+			}
+			mailbox = argv[i];
+		} else if (strcmp(argv[i], "-d") == 0) {
+			/* dump file */
+			i++;
+			if (i == argc) {
+				print_help();
+				i_fatal("Missing -d argument");
+			}
+			dumpfile = argv[i];
+		} else if (strcmp(argv[i], "-l") == 0) {
+			/* mail location */
+			i++;
+			if (i == argc) {
+				print_help();
+				i_fatal("Missing -l argument");
+			}
+			mailloc = argv[i];
+		} else if (strcmp(argv[i], "-x") == 0) {
+			/* extensions */
+			i++;
+			if (i == argc) {
+				print_help();
+				i_fatal("Missing -x argument");
+			}
+			extensions = argv[i];
+		} else if (strcmp(argv[i], "-s") == 0) {
+			const char *file;
+			
+			/* scriptfile executed before main script */
+			i++;
+			if (i == argc) {
+				print_help();
+				i_fatal("Missing -s argument");
+			}
+				
+			file = t_strdup(argv[i]);
+			array_append(&scriptfiles, &file, 1);
+		} else if (strcmp(argv[i], "-c") == 0) {
+			/* force compile */
+			force_compile = TRUE;
+		} else if (strcmp(argv[i], "-e") == 0) {
+			/* execute */
+			execute = TRUE;
+#ifdef SIEVE_RUNTIME_TRACE
+		} else if (strcmp(argv[i], "-t") == 0) {
+			/* runtime trace */
+			trace = TRUE;
+#endif
+		} else if ( scriptfile == NULL ) {
+			scriptfile = argv[i];
+		} else if ( mailfile == NULL ) {
+			mailfile = argv[i];
+		} else {
+			print_help();
+			i_fatal("Unknown argument: %s", argv[i]);
+		}
+	}
+	
+	if ( scriptfile == NULL ) {
+		print_help();
+		i_fatal("Missing <script-file> argument");
+	}
+	
+	if ( mailfile == NULL ) {
+		print_help();
+		i_fatal("Missing <mail-file> argument");
+	}
+
+	if ( extensions != NULL ) {
+		sieve_set_extensions(extensions);
+	}
+
+	/* Register tool-specific extensions */
+	(void) sieve_extension_register(&debug_extension, TRUE);
+	
+	/* Create error handler */
+	ehandler = sieve_stderr_ehandler_create(0);
+	sieve_system_ehandler_set(ehandler);
+	sieve_error_handler_accept_infolog(ehandler, TRUE);
+
+	/* Compile main sieve script */
+	if ( force_compile ) {
+		main_sbin = sieve_tool_script_compile(scriptfile, NULL);
+		(void) sieve_save(main_sbin, NULL);
+	} else {
+		main_sbin = sieve_tool_script_open(scriptfile);
+	}
+
+	if ( main_sbin != NULL ) {
+		/* Dump script */
+		sieve_tool_dump_binary_to(main_sbin, dumpfile);
+	
+		user = sieve_tool_get_user();
+		home = getenv("HOME");
+
+		/* Initialize mail storages */
+		mail_users_init(getenv("AUTH_SOCKET_PATH"), getenv("DEBUG") != NULL);
+		mail_storage_init();
+		mail_storage_register_all();
+		mailbox_list_register_all();
+	
+		/* Obtain mail namespaces from -l argument */
+		if ( mailloc != NULL ) {
+			env_put(t_strdup_printf("NAMESPACE_1=%s", mailloc));
+			env_put("NAMESPACE_1_INBOX=1");
+			env_put("NAMESPACE_1_LIST=1");
+			env_put("NAMESPACE_1_SEP=.");
+			env_put("NAMESPACE_1_SUBSCRIPTIONS=1");
+
+			mail_user = mail_user_init(user);
+			mail_user_set_home(mail_user, home);
+			if (mail_namespaces_init(mail_user) < 0)
+				i_fatal("Namespace initialization failed");	
+
+			ns = mail_user->namespaces;
+		}
+
+		/* Initialize raw mail object */
+		mail_raw_init(user);
+		mailr = mail_raw_open_file(mailfile);
+
+		sieve_tool_get_envelope_data(mailr->mail, &recipient, &sender);
+
+		if ( mailbox == NULL )
+			mailbox = "INBOX";
+
+		/* Collect necessary message data */
+		memset(&msgdata, 0, sizeof(msgdata));
+		msgdata.mail = mailr->mail;
+		msgdata.return_path = sender;
+		msgdata.to_address = recipient;
+		msgdata.auth_user = user;
+		(void)mail_get_first_header(mailr->mail, "Message-ID", &msgdata.id);
+
+		/* Create stream for test and trace output */
+		if ( !execute || trace )
+			teststream = o_stream_create_fd(1, 0, FALSE);	
+		
+		/* Compose script environment */
+		memset(&scriptenv, 0, sizeof(scriptenv));
+		scriptenv.default_mailbox = "INBOX";
+		scriptenv.namespaces = ns;
+		scriptenv.username = user;
+		scriptenv.hostname = "host.example.com";
+		scriptenv.postmaster_address = "postmaster@example.com";
+		scriptenv.smtp_open = sieve_smtp_open;
+		scriptenv.smtp_close = sieve_smtp_close;
+		scriptenv.duplicate_mark = duplicate_mark;
+		scriptenv.duplicate_check = duplicate_check;
+		scriptenv.trace_stream = ( trace ? teststream : NULL );
+		scriptenv.exec_status = &estatus;
+	
+		/* Run the test */
+		ret = 1;
+		if ( array_count(&scriptfiles) == 0 ) {
+			/* Single script */
+			sbin = main_sbin;
+			main_sbin = NULL;
+	
+			/* Execute/Test script */
+			if ( execute )
+				ret = sieve_execute
+					(sbin, &msgdata, &scriptenv, ehandler, NULL);
+			else
+				ret = sieve_test
+					(sbin, &msgdata, &scriptenv, ehandler, teststream, NULL);				
+		} else {
+			/* Multiple scripts */
+			const char *const *sfiles;
+			unsigned int i, count;
+			struct sieve_multiscript *mscript;
+			bool more = TRUE;
+			int result;
+
+			if ( execute )
+				mscript = sieve_multiscript_start_execute
+					(&msgdata, &scriptenv);
+			else
+				mscript = sieve_multiscript_start_test
+					(&msgdata, &scriptenv, teststream);
+		
+			/* Execute scripts sequentially */
+			sfiles = array_get(&scriptfiles, &count); 
+			for ( i = 0; i < count && more; i++ ) {
+				if ( teststream != NULL ) 
+					o_stream_send_str(teststream, 
+						t_strdup_printf("\n## Executing script: %s\n", sfiles[i]));
+			
+				/* Close previous script */
+				if ( sbin != NULL )						
+					sieve_close(&sbin);
+		
+				/* Compile sieve script */
+				if ( force_compile ) {
+					sbin = sieve_tool_script_compile(sfiles[i], sfiles[i]);
+					(void) sieve_save(sbin, NULL);
+				} else {
+					sbin = sieve_tool_script_open(sfiles[i]);
+				}
+			
+				if ( sbin == NULL ) {
+					ret = SIEVE_EXEC_FAILURE;
+					break;
+				}
+			
+				/* Execute/Test script */
+				more = sieve_multiscript_run(mscript, sbin, ehandler, FALSE);
+			}
+		
+			/* Execute/Test main script */
+			if ( more && ret > 0 ) {
+				if ( teststream != NULL ) 
+					o_stream_send_str(teststream, 
+						t_strdup_printf("## Executing script: %s\n", scriptfile));
+				
+				/* Close previous script */
+				if ( sbin != NULL )						
+					sieve_close(&sbin);	
+				
+				sbin = main_sbin;
+				main_sbin = NULL;
+			
+				sieve_multiscript_run(mscript, sbin, ehandler, TRUE);
+			}
+			
+			result = sieve_multiscript_finish(&mscript, ehandler, NULL);
+			
+			ret = ret > 0 ? result : ret;
+		}
+	
+		/* Run */
+		switch ( ret ) {
+		case SIEVE_EXEC_OK:
+			i_info("final result: success");
+			break;
+		case SIEVE_EXEC_BIN_CORRUPT:
+			i_info("corrupt binary deleted.");
+			(void) unlink(sieve_binary_path(sbin));
+		case SIEVE_EXEC_FAILURE:
+			i_info("final result: failed; resolved with successful implicit keep");
+			break;
+		case SIEVE_EXEC_KEEP_FAILED:
+			i_info("final result: utter failure");
+			break;
+		default:
+			i_info("final result: unrecognized return value?!");	
+		}
+
+		if ( teststream != NULL )
+			o_stream_destroy(&teststream);
+
+		/* Cleanup remaining binaries */
+		sieve_close(&sbin);
+		if ( main_sbin != NULL ) sieve_close(&main_sbin);
+		
+		/* De-initialize raw mail object */
+		mail_raw_close(mailr);
+		mail_raw_deinit();
+
+		/* De-initialize mail user object */
+		if ( mail_user != NULL )
+			mail_user_unref(&mail_user);
+
+		/* De-initialize mail storages */
+		mail_storage_deinit();
+		mail_users_deinit();
+	}
+
+	/* Cleanup error handler */
+	sieve_error_handler_unref(&ehandler);
+	sieve_system_ehandler_reset();
+
+	sieve_tool_deinit();
+	
+	return 0;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/cmd-test-binary.c dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/cmd-test-binary.c
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/cmd-test-binary.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/cmd-test-binary.c	2009-08-21 00:52:15.000000000 +0200
@@ -0,0 +1,269 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+#include "sieve-dump.h"
+
+#include "testsuite-common.h"
+#include "testsuite-binary.h"
+#include "testsuite-script.h"
+
+/*
+ * Test_binary command
+ *
+ * Syntax:   
+ *   test_binary ( :load / :save ) <mailbox: string>
+ */
+
+static bool cmd_test_binary_registered
+	(struct sieve_validator *valdtr, 
+		struct sieve_command_registration *cmd_reg);
+static bool cmd_test_binary_validate
+	(struct sieve_validator *valdtr, struct sieve_command_context *cmd);
+static bool cmd_test_binary_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command cmd_test_binary = { 
+	"test_binary", 
+	SCT_COMMAND, 
+	1, 0, FALSE, FALSE,
+	cmd_test_binary_registered, 
+	NULL,
+	cmd_test_binary_validate, 
+	cmd_test_binary_generate, 
+	NULL 
+};
+
+/* 
+ * Operations
+ */ 
+
+static bool cmd_test_binary_operation_dump
+	(const struct sieve_operation *op,
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_test_binary_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+ 
+/* test_binary_create operation */
+
+const struct sieve_operation test_binary_load_operation = { 
+	"TEST_BINARY_LOAD",
+	&testsuite_extension, 
+	TESTSUITE_OPERATION_TEST_BINARY_LOAD,
+	cmd_test_binary_operation_dump, 
+	cmd_test_binary_operation_execute 
+};
+
+/* test_binary_delete operation */
+
+const struct sieve_operation test_binary_save_operation = { 
+	"TEST_BINARY_SAVE",
+	&testsuite_extension, 
+	TESTSUITE_OPERATION_TEST_BINARY_SAVE,
+	cmd_test_binary_operation_dump, 
+	cmd_test_binary_operation_execute 
+};
+
+/*
+ * Compiler context data
+ */
+ 
+enum test_binary_operation {
+	BINARY_OP_LOAD, 
+	BINARY_OP_SAVE,
+	BINARY_OP_LAST
+};
+
+const struct sieve_operation *test_binary_operations[] = {
+	&test_binary_load_operation,
+	&test_binary_save_operation
+};
+
+struct cmd_test_binary_context_data {
+	enum test_binary_operation binary_op;
+	const char *folder;
+};
+
+/* 
+ * Command tags 
+ */
+ 
+static bool cmd_test_binary_validate_tag
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+
+static const struct sieve_argument test_binary_load_tag = { 
+	"load", 
+	NULL, NULL,
+	cmd_test_binary_validate_tag,
+	NULL, NULL 
+};
+
+static const struct sieve_argument test_binary_save_tag = { 
+	"save", 
+	NULL, NULL, 
+	cmd_test_binary_validate_tag,
+	NULL, NULL 
+};
+
+static bool cmd_test_binary_registered
+(struct sieve_validator *valdtr, struct sieve_command_registration *cmd_reg) 
+{
+	/* Register our tags */
+	sieve_validator_register_tag(valdtr, cmd_reg, &test_binary_load_tag, 0); 	
+	sieve_validator_register_tag(valdtr, cmd_reg, &test_binary_save_tag, 0); 	
+
+	return TRUE;
+}
+
+static bool cmd_test_binary_validate_tag
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd)
+{
+	struct cmd_test_binary_context_data *ctx_data = 
+		(struct cmd_test_binary_context_data *) cmd->data;	
+	
+	if ( ctx_data != NULL ) {
+		sieve_argument_validate_error
+			(valdtr, *arg, "exactly one of the ':load' or ':save' tags must be "
+				"specified for the test_binary command, but more were found");
+		return NULL;		
+	}
+	
+	ctx_data = p_new
+		(sieve_command_pool(cmd), struct cmd_test_binary_context_data, 1);
+	cmd->data = ctx_data;
+	
+	if ( (*arg)->argument == &test_binary_load_tag ) 
+		ctx_data->binary_op = BINARY_OP_LOAD;
+	else
+		ctx_data->binary_op = BINARY_OP_SAVE;
+
+	/* Delete this tag */
+	*arg = sieve_ast_arguments_detach(*arg, 1);
+
+	return TRUE;
+}
+
+/* 
+ * Validation 
+ */
+
+static bool cmd_test_binary_validate
+(struct sieve_validator *valdtr, struct sieve_command_context *cmd) 
+{
+	struct sieve_ast_argument *arg = cmd->first_positional;
+	
+	if ( cmd->data == NULL ) {
+		sieve_command_validate_error(valdtr, cmd, 
+			"the test_binary command requires either the :load or the :save tag "
+			"to be specified");
+		return FALSE;		
+	}
+		
+	if ( !sieve_validate_positional_argument
+		(valdtr, cmd, arg, "binary-name", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+	
+	return sieve_validator_argument_activate(valdtr, cmd, arg, FALSE);
+}
+
+/* 
+ * Code generation 
+ */
+
+static bool cmd_test_binary_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *cmd)
+{
+	struct cmd_test_binary_context_data *ctx_data =
+		(struct cmd_test_binary_context_data *) cmd->data; 
+
+	i_assert( ctx_data->binary_op < BINARY_OP_LAST );
+	
+	/* Emit operation */
+	sieve_operation_emit_code(cgenv->sbin, 
+		test_binary_operations[ctx_data->binary_op]);
+	  	
+ 	/* Generate arguments */
+	if ( !sieve_generate_arguments(cgenv, cmd, NULL) )
+		return FALSE;
+
+	return TRUE;
+}
+
+/* 
+ * Code dump
+ */
+ 
+static bool cmd_test_binary_operation_dump
+(const struct sieve_operation *op,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	sieve_code_dumpf(denv, "%s:", op->mnemonic);
+	
+	sieve_code_descend(denv);
+	
+	return sieve_opr_string_dump(denv, address, "binary-name");
+}
+
+
+/*
+ * Intepretation
+ */
+ 
+static int cmd_test_binary_operation_execute
+(const struct sieve_operation *op,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	string_t *binary_name = NULL;
+
+	/* 
+	 * Read operands 
+	 */
+
+	/* Binary Name */
+
+	if ( !sieve_opr_string_read(renv, address, &binary_name) ) {
+		sieve_runtime_trace_error(renv, "invalid mailbox operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Perform operation
+	 */
+		
+	sieve_runtime_trace(renv, "%s %s:", op->mnemonic, str_c(binary_name));
+
+	if ( op == &test_binary_load_operation ) {
+		struct sieve_binary *sbin = testsuite_binary_load(str_c(binary_name));
+
+		if ( sbin != NULL ) {
+			testsuite_script_set_binary(sbin);
+
+			sieve_binary_unref(&sbin);
+		} else {
+			sieve_sys_error("failed to load binary %s", str_c(binary_name));
+			return SIEVE_EXEC_FAILURE;
+		}
+
+	} else if ( op == &test_binary_save_operation ) {
+		struct sieve_binary *sbin = testsuite_script_get_binary();
+
+		if ( sbin != NULL ) 
+			testsuite_binary_save(sbin, str_c(binary_name));
+		else {
+			sieve_sys_error("no compiled binary to save as %s", str_c(binary_name));
+			return SIEVE_EXEC_FAILURE;
+		}
+	}
+
+	return SIEVE_EXEC_OK;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/cmd-test.c dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/cmd-test.c
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/cmd-test.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/cmd-test.c	2009-04-11 17:47:41.000000000 +0200
@@ -0,0 +1,185 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+#include "sieve-dump.h"
+
+#include "testsuite-common.h"
+
+/*
+ * Test command
+ *
+ * Syntax:   
+ *   test <test-name: string> <block>
+ */
+
+static bool cmd_test_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd);
+static bool cmd_test_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command cmd_test = { 
+	"test", 
+	SCT_COMMAND, 
+	1, 0, TRUE, TRUE,
+	NULL, NULL,
+	cmd_test_validate, 
+	cmd_test_generate, 
+	NULL 
+};
+
+/* 
+ * Test operations 
+ */
+
+/* Test operation */
+
+static bool cmd_test_operation_dump
+	(const struct sieve_operation *op,
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_test_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation test_operation = { 
+	"TEST",
+	&testsuite_extension, 
+	TESTSUITE_OPERATION_TEST,
+	cmd_test_operation_dump, 
+	cmd_test_operation_execute 
+};
+
+/* Test_finish operation */
+
+static int cmd_test_finish_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation test_finish_operation = { 
+	"TEST-FINISH",
+	&testsuite_extension, 
+	TESTSUITE_OPERATION_TEST_FINISH,
+	NULL, 
+	cmd_test_finish_operation_execute 
+};
+
+/* 
+ * Validation 
+ */
+
+static bool cmd_test_validate
+(struct sieve_validator *valdtr ATTR_UNUSED, struct sieve_command_context *cmd) 
+{
+	struct sieve_ast_argument *arg = cmd->first_positional;
+		
+ 	/* Check valid command placement */
+	if ( !sieve_command_is_toplevel(cmd) )
+	{
+		sieve_command_validate_error(valdtr, cmd,
+			"tests cannot be nested: test command must be issued at top-level");
+		return FALSE;
+	}
+	
+	if ( !sieve_validate_positional_argument
+		(valdtr, cmd, arg, "test-name", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+	
+	return sieve_validator_argument_activate(valdtr, cmd, arg, FALSE);
+}
+
+/* 
+ * Code generation 
+ */
+
+static inline struct testsuite_generator_context *
+	_get_generator_context(struct sieve_generator *gentr)
+{
+	return (struct testsuite_generator_context *) 
+		sieve_generator_extension_get_context(gentr, &testsuite_extension);
+}
+
+static bool cmd_test_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx)
+{
+	struct testsuite_generator_context *genctx = 
+		_get_generator_context(cgenv->gentr);
+	
+	sieve_operation_emit_code(cgenv->sbin, &test_operation);
+
+	/* Generate arguments */
+	if ( !sieve_generate_arguments(cgenv, ctx, NULL) )
+		return FALSE;
+		
+	/* Prepare jumplist */
+	sieve_jumplist_reset(genctx->exit_jumps);
+		
+	/* Test body */
+	if ( !sieve_generate_block(cgenv, ctx->ast_node) )
+		return FALSE;
+	
+	sieve_operation_emit_code(cgenv->sbin, &test_finish_operation);
+	
+	/* Resolve exit jumps to this point */
+	sieve_jumplist_resolve(genctx->exit_jumps); 
+			
+	return TRUE;
+}
+
+/* 
+ * Code dump
+ */
+ 
+static bool cmd_test_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	sieve_code_dumpf(denv, "TEST:");
+	sieve_code_descend(denv);
+
+	return 
+		sieve_opr_string_dump(denv, address, "test name");
+}
+
+/*
+ * Intepretation
+ */
+
+static int cmd_test_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	string_t *test_name;
+
+	if ( !sieve_opr_string_read(renv, address, &test_name) ) {
+		sieve_runtime_trace_error(renv, "invalid test name operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	sieve_runtime_trace(renv, "TEST \"%s\"", str_c(test_name));
+
+	testsuite_test_start(test_name);
+	return SIEVE_EXEC_OK;
+}
+
+static int cmd_test_finish_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv ATTR_UNUSED, 
+	sieve_size_t *address ATTR_UNUSED)
+{
+	sieve_runtime_trace(renv, "TEST FINISHED");
+	
+	testsuite_test_succeed(NULL);
+	return SIEVE_EXEC_OK;
+}
+
+
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/cmd-test-fail.c dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/cmd-test-fail.c
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/cmd-test-fail.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/cmd-test-fail.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,152 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+#include "sieve-dump.h"
+
+#include "testsuite-common.h"
+
+/* 
+ * Test_fail command
+ *
+ * Syntax:   
+ *   test_fail <reason: string>
+ */
+
+static bool cmd_test_fail_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd);
+static bool cmd_test_fail_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command cmd_test_fail = { 
+	"test_fail", 
+	SCT_COMMAND, 
+	1, 0, FALSE, FALSE,
+	NULL, NULL,
+	cmd_test_fail_validate, 
+	cmd_test_fail_generate, 
+	NULL 
+};
+
+/* 
+ * Test operation 
+ */
+
+static bool cmd_test_fail_operation_dump
+	(const struct sieve_operation *op,
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_test_fail_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation test_fail_operation = { 
+	"TEST_FAIL",
+	&testsuite_extension, 
+	TESTSUITE_OPERATION_TEST_FAIL,
+	cmd_test_fail_operation_dump, 
+	cmd_test_fail_operation_execute 
+};
+
+/* 
+ * Validation 
+ */
+
+static bool cmd_test_fail_validate
+(struct sieve_validator *valdtr ATTR_UNUSED, struct sieve_command_context *cmd) 
+{
+	struct sieve_ast_argument *arg = cmd->first_positional;
+	
+	if ( !sieve_validate_positional_argument
+		(valdtr, cmd, arg, "reason", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+	
+	return sieve_validator_argument_activate(valdtr, cmd, arg, FALSE);
+}
+
+/* 
+ * Code generation 
+ */
+
+static inline struct testsuite_generator_context *
+	_get_generator_context(struct sieve_generator *gentr)
+{
+	return (struct testsuite_generator_context *) 
+		sieve_generator_extension_get_context(gentr, &testsuite_extension);
+}
+
+static bool cmd_test_fail_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx)
+{
+	struct testsuite_generator_context *genctx = 
+		_get_generator_context(cgenv->gentr);
+	
+	sieve_operation_emit_code(cgenv->sbin, &test_fail_operation);
+
+	/* Generate arguments */
+	if ( !sieve_generate_arguments(cgenv, ctx, NULL) )
+		return FALSE;
+		
+	sieve_jumplist_add(genctx->exit_jumps, 
+		sieve_binary_emit_offset(cgenv->sbin, 0));			
+	
+	return TRUE;
+}
+
+/* 
+ * Code dump
+ */
+ 
+static bool cmd_test_fail_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	unsigned int pc;
+	int offset;
+    
+	sieve_code_dumpf(denv, "TEST_FAIL:");
+	sieve_code_descend(denv);
+
+	if ( !sieve_opr_string_dump(denv, address, "reason") ) 
+		return FALSE;
+
+	sieve_code_mark(denv);
+	pc = *address;
+	if ( sieve_binary_read_offset(denv->sbin, address, &offset) )
+		sieve_code_dumpf(denv, "offset: %d [%08x]", offset, pc + offset);
+	else
+		return FALSE;
+
+	return TRUE;
+}
+
+/*
+ * Intepretation
+ */
+
+static int cmd_test_fail_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	string_t *reason;
+
+	if ( !sieve_opr_string_read(renv, address, &reason) ) {
+		sieve_runtime_trace_error(renv, "invalid reason operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	sieve_runtime_trace(renv, "TEST FAIL");
+	testsuite_test_fail(reason);
+	
+	return sieve_interpreter_program_jump(renv->interp, TRUE);
+}
+
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/cmd-test-mailbox.c dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/cmd-test-mailbox.c
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/cmd-test-mailbox.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/cmd-test-mailbox.c	2009-07-31 17:34:58.000000000 +0200
@@ -0,0 +1,248 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+#include "sieve-dump.h"
+
+#include "testsuite-common.h"
+#include "testsuite-mailstore.h"
+
+/*
+ * Test_mailbox command
+ *
+ * Syntax:   
+ *   test_mailbox ( :create / :delete ) <mailbox: string>
+ */
+
+static bool cmd_test_mailbox_registered
+	(struct sieve_validator *valdtr, 
+		struct sieve_command_registration *cmd_reg);
+static bool cmd_test_mailbox_validate
+	(struct sieve_validator *valdtr, struct sieve_command_context *cmd);
+static bool cmd_test_mailbox_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command cmd_test_mailbox = { 
+	"test_mailbox", 
+	SCT_COMMAND, 
+	1, 0, FALSE, FALSE,
+	cmd_test_mailbox_registered, 
+	NULL,
+	cmd_test_mailbox_validate, 
+	cmd_test_mailbox_generate, 
+	NULL 
+};
+
+/* 
+ * Operations
+ */ 
+
+static bool cmd_test_mailbox_operation_dump
+	(const struct sieve_operation *op,
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_test_mailbox_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+ 
+/* Test_mailbox_create operation */
+
+const struct sieve_operation test_mailbox_create_operation = { 
+	"TEST_MAILBOX_CREATE",
+	&testsuite_extension, 
+	TESTSUITE_OPERATION_TEST_MAILBOX_CREATE,
+	cmd_test_mailbox_operation_dump, 
+	cmd_test_mailbox_operation_execute 
+};
+
+/* Test_mailbox_delete operation */
+
+const struct sieve_operation test_mailbox_delete_operation = { 
+	"TEST_MAILBOX_DELETE",
+	&testsuite_extension, 
+	TESTSUITE_OPERATION_TEST_MAILBOX_DELETE,
+	cmd_test_mailbox_operation_dump, 
+	cmd_test_mailbox_operation_execute 
+};
+
+/*
+ * Compiler context data
+ */
+ 
+enum test_mailbox_operation {
+	MAILBOX_OP_CREATE, 
+	MAILBOX_OP_DELETE,
+	MAILBOX_OP_LAST
+};
+
+const struct sieve_operation *test_mailbox_operations[] = {
+	&test_mailbox_create_operation,
+	&test_mailbox_delete_operation
+};
+
+struct cmd_test_mailbox_context_data {
+	enum test_mailbox_operation mailbox_op;
+	const char *folder;
+};
+
+/* 
+ * Command tags 
+ */
+ 
+static bool cmd_test_mailbox_validate_tag
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+
+static const struct sieve_argument test_mailbox_create_tag = { 
+	"create", 
+	NULL, NULL,
+	cmd_test_mailbox_validate_tag,
+	NULL, NULL 
+};
+
+static const struct sieve_argument test_mailbox_delete_tag = { 
+	"delete", 
+	NULL, NULL, 
+	cmd_test_mailbox_validate_tag,
+	NULL, NULL 
+};
+
+static bool cmd_test_mailbox_registered
+(struct sieve_validator *valdtr, struct sieve_command_registration *cmd_reg) 
+{
+	/* Register our tags */
+	sieve_validator_register_tag(valdtr, cmd_reg, &test_mailbox_create_tag, 0); 	
+	sieve_validator_register_tag(valdtr, cmd_reg, &test_mailbox_delete_tag, 0); 	
+
+	return TRUE;
+}
+
+static bool cmd_test_mailbox_validate_tag
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd)
+{
+	struct cmd_test_mailbox_context_data *ctx_data = 
+		(struct cmd_test_mailbox_context_data *) cmd->data;	
+	
+	if ( ctx_data != NULL ) {
+		sieve_argument_validate_error
+			(valdtr, *arg, "exactly one of the ':create' or ':delete' tags must be "
+				"specified for the test_mailbox command, but more were found");
+		return NULL;		
+	}
+	
+	ctx_data = p_new
+		(sieve_command_pool(cmd), struct cmd_test_mailbox_context_data, 1);
+	cmd->data = ctx_data;
+	
+	if ( (*arg)->argument == &test_mailbox_create_tag ) 
+		ctx_data->mailbox_op = MAILBOX_OP_CREATE;
+	else
+		ctx_data->mailbox_op = MAILBOX_OP_DELETE;
+
+	/* Delete this tag */
+	*arg = sieve_ast_arguments_detach(*arg, 1);
+
+	return TRUE;
+}
+
+/* 
+ * Validation 
+ */
+
+static bool cmd_test_mailbox_validate
+(struct sieve_validator *valdtr, struct sieve_command_context *cmd) 
+{
+	struct sieve_ast_argument *arg = cmd->first_positional;
+	
+	if ( cmd->data == NULL ) {
+		sieve_command_validate_error(valdtr, cmd, 
+			"the test_mailbox command requires either the :create or the :delete tag "
+			"to be specified");
+		return FALSE;		
+	}
+		
+	if ( !sieve_validate_positional_argument
+		(valdtr, cmd, arg, "mailbox", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+	
+	return sieve_validator_argument_activate(valdtr, cmd, arg, FALSE);
+}
+
+/* 
+ * Code generation 
+ */
+
+static bool cmd_test_mailbox_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *cmd)
+{
+	struct cmd_test_mailbox_context_data *ctx_data =
+		(struct cmd_test_mailbox_context_data *) cmd->data; 
+
+	i_assert( ctx_data->mailbox_op < MAILBOX_OP_LAST );
+	
+	/* Emit operation */
+	sieve_operation_emit_code(cgenv->sbin, 
+		test_mailbox_operations[ctx_data->mailbox_op]);
+	  	
+ 	/* Generate arguments */
+	if ( !sieve_generate_arguments(cgenv, cmd, NULL) )
+		return FALSE;
+
+	return TRUE;
+}
+
+/* 
+ * Code dump
+ */
+ 
+static bool cmd_test_mailbox_operation_dump
+(const struct sieve_operation *op,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	sieve_code_dumpf(denv, "%s:", op->mnemonic);
+	
+	sieve_code_descend(denv);
+	
+	return sieve_opr_string_dump(denv, address, "mailbox");
+}
+
+
+/*
+ * Intepretation
+ */
+ 
+static int cmd_test_mailbox_operation_execute
+(const struct sieve_operation *op,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	string_t *mailbox = NULL;
+
+	/* 
+	 * Read operands 
+	 */
+
+	/* Index */
+
+	if ( !sieve_opr_string_read(renv, address, &mailbox) ) {
+		sieve_runtime_trace_error(renv, "invalid mailbox operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Perform operation
+	 */
+		
+	sieve_runtime_trace(renv, "%s %s:", op->mnemonic, str_c(mailbox));
+
+	if ( op == &test_mailbox_create_operation )
+		testsuite_mailstore_mailbox_create(renv, str_c(mailbox));
+
+	return SIEVE_EXEC_OK;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/cmd-test-message.c dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/cmd-test-message.c
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/cmd-test-message.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/cmd-test-message.c	2009-08-02 09:44:14.000000000 +0200
@@ -0,0 +1,401 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+#include "sieve-dump.h"
+
+#include "testsuite-common.h"
+#include "testsuite-smtp.h"
+#include "testsuite-mailstore.h"
+
+/*
+ * Test_message command
+ *
+ * Syntax:   
+ *   test_message ( :smtp / :mailbox <mailbox: string> ) <index: number>
+ */
+
+static bool cmd_test_message_registered
+	(struct sieve_validator *valdtr, 
+		struct sieve_command_registration *cmd_reg);
+static bool cmd_test_message_validate
+	(struct sieve_validator *valdtr, struct sieve_command_context *cmd);
+static bool cmd_test_message_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command cmd_test_message = { 
+	"test_message", 
+	SCT_HYBRID, 
+	1, 0, FALSE, FALSE,
+	cmd_test_message_registered, 
+	NULL,
+	cmd_test_message_validate, 
+	cmd_test_message_generate, 
+	NULL 
+};
+
+/* 
+ * Operations
+ */ 
+ 
+/* Test_message_smtp operation */
+
+static bool cmd_test_message_smtp_operation_dump
+	(const struct sieve_operation *op,
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_test_message_smtp_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation test_message_smtp_operation = { 
+	"TEST_MESSAGE_SMTP",
+	&testsuite_extension, 
+	TESTSUITE_OPERATION_TEST_MESSAGE_SMTP,
+	cmd_test_message_smtp_operation_dump, 
+	cmd_test_message_smtp_operation_execute 
+};
+
+/* Test_message_mailbox operation */
+
+static bool cmd_test_message_mailbox_operation_dump
+	(const struct sieve_operation *op,
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_test_message_mailbox_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation test_message_mailbox_operation = { 
+	"TEST_MESSAGE_MAILBOX",
+	&testsuite_extension, 
+	TESTSUITE_OPERATION_TEST_MESSAGE_MAILBOX,
+	cmd_test_message_mailbox_operation_dump, 
+	cmd_test_message_mailbox_operation_execute 
+};
+
+/*
+ * Compiler context data
+ */
+ 
+enum test_message_source {
+	MSG_SOURCE_SMTP, 
+	MSG_SOURCE_MAILBOX,
+	MSG_SOURCE_LAST
+};
+
+const struct sieve_operation *test_message_operations[] = {
+	&test_message_smtp_operation,
+	&test_message_mailbox_operation
+};
+
+struct cmd_test_message_context_data {
+	enum test_message_source msg_source;
+	const char *folder;
+};
+
+#define CMD_TEST_MESSAGE_ERROR_DUP_TAG \
+	"exactly one of the ':smtp' or ':folder' tags must be specified " \
+	"for the test_message command, but more were found"
+
+/* 
+ * Command tags 
+ */
+ 
+static bool cmd_test_message_validate_smtp_tag
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+static bool cmd_test_message_validate_folder_tag
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+
+static const struct sieve_argument test_message_smtp_tag = { 
+	"smtp", 
+	NULL, NULL,
+	cmd_test_message_validate_smtp_tag,
+	NULL, NULL 
+};
+
+static const struct sieve_argument test_message_folder_tag = { 
+	"folder", 
+	NULL, NULL, 
+	cmd_test_message_validate_folder_tag,
+	NULL, NULL 
+};
+
+static bool cmd_test_message_registered
+(struct sieve_validator *valdtr, struct sieve_command_registration *cmd_reg) 
+{
+	/* Register our tags */
+	sieve_validator_register_tag(valdtr, cmd_reg, &test_message_folder_tag, 0); 	
+	sieve_validator_register_tag(valdtr, cmd_reg, &test_message_smtp_tag, 0); 	
+
+	return TRUE;
+}
+
+static struct cmd_test_message_context_data *cmd_test_message_validate_tag
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd)
+{
+	struct cmd_test_message_context_data *ctx_data = 
+		(struct cmd_test_message_context_data *) cmd->data;	
+	
+	if ( ctx_data != NULL ) {
+		sieve_argument_validate_error
+			(valdtr, *arg, CMD_TEST_MESSAGE_ERROR_DUP_TAG);
+		return NULL;		
+	}
+	
+	ctx_data = p_new
+		(sieve_command_pool(cmd), struct cmd_test_message_context_data, 1);
+	cmd->data = ctx_data;
+	
+	/* Delete this tag */
+	*arg = sieve_ast_arguments_detach(*arg, 1);
+
+	return ctx_data;
+}
+
+static bool cmd_test_message_validate_smtp_tag
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd)
+{
+	struct cmd_test_message_context_data *ctx_data = 
+		cmd_test_message_validate_tag(valdtr, arg, cmd);
+
+	/* Return value is NULL on error */
+	if ( ctx_data == NULL ) return FALSE;
+	
+	/* Assign chosen message source */
+	ctx_data->msg_source = MSG_SOURCE_SMTP;
+			
+	return TRUE;
+}
+
+static bool cmd_test_message_validate_folder_tag
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd)
+{
+	struct sieve_ast_argument *tag = *arg;
+	struct cmd_test_message_context_data *ctx_data = 
+		cmd_test_message_validate_tag(valdtr, arg, cmd);
+	
+	/* Return value is NULL on error */
+	if ( ctx_data == NULL ) return FALSE;
+
+	/* Assign chose message source */
+	ctx_data->msg_source = MSG_SOURCE_MAILBOX;
+	
+	/* Check syntax:
+	 *   :folder string
+	 */
+	if ( !sieve_validate_tag_parameter
+		(valdtr, cmd, tag, *arg, SAAT_STRING) ) {
+		return FALSE;
+	}
+
+	/* Skip parameter */
+	*arg = sieve_ast_argument_next(*arg);
+			
+	return TRUE;
+}
+
+/* 
+ * Validation 
+ */
+
+static bool cmd_test_message_validate
+(struct sieve_validator *valdtr, struct sieve_command_context *cmd) 
+{
+	struct sieve_ast_argument *arg = cmd->first_positional;
+	
+	if ( cmd->data == NULL ) {
+		sieve_command_validate_error(valdtr, cmd, 
+			"the test_message command requires either the :smtp or the :mailbox tag "
+			"to be specified");
+		return FALSE;		
+	}
+		
+	if ( !sieve_validate_positional_argument
+		(valdtr, cmd, arg, "index", 1, SAAT_NUMBER) ) {
+		return FALSE;
+	}
+	
+	return sieve_validator_argument_activate(valdtr, cmd, arg, FALSE);
+}
+
+/* 
+ * Code generation 
+ */
+
+static bool cmd_test_message_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *cmd)
+{
+	struct cmd_test_message_context_data *ctx_data =
+		(struct cmd_test_message_context_data *) cmd->data; 
+
+	i_assert( ctx_data->msg_source < MSG_SOURCE_LAST );
+	
+	/* Emit operation */
+	sieve_operation_emit_code(cgenv->sbin, 
+		test_message_operations[ctx_data->msg_source]);
+
+	/* Emit is_test flag */
+	sieve_binary_emit_byte(cgenv->sbin, ( cmd->ast_node->type == SAT_TEST ));
+	  	
+ 	/* Generate arguments */
+	if ( !sieve_generate_arguments(cgenv, cmd, NULL) )
+		return FALSE;
+
+	return TRUE;
+}
+
+/* 
+ * Code dump
+ */
+ 
+static bool cmd_test_message_smtp_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	unsigned int is_test;
+
+    if ( !sieve_binary_read_byte(denv->sbin, address, &is_test) )
+		return FALSE;
+
+	sieve_code_dumpf(denv, "TEST_MESSAGE_SMTP (%s):", 
+		( is_test ? "TEST" : "COMMAND" ));
+	
+	sieve_code_descend(denv);
+	
+	return sieve_opr_number_dump(denv, address, "index");
+}
+
+static bool cmd_test_message_mailbox_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	unsigned int is_test;
+
+    if ( !sieve_binary_read_byte(denv->sbin, address, &is_test) )
+		return FALSE;
+
+	sieve_code_dumpf(denv, "TEST_MESSAGE_MAILBOX (%s):",
+		( is_test ? "TEST" : "COMMAND" ));
+	
+	sieve_code_descend(denv);
+
+	return 
+		sieve_opr_string_dump(denv, address, "folder") &&
+		sieve_opr_number_dump(denv, address, "index");
+}
+
+/*
+ * Intepretation
+ */
+ 
+static int cmd_test_message_smtp_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	sieve_number_t msg_index;
+    unsigned int is_test = -1;
+	bool result;
+
+	/* 
+	 * Read operands 
+	 */
+
+	/* Is test */
+
+    if ( !sieve_binary_read_byte(renv->sbin, address, &is_test) ) {
+		sieve_runtime_trace_error(renv, "invalid is_test flag");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Index */
+
+	if ( !sieve_opr_number_read(renv, address, &msg_index) ) {
+		sieve_runtime_trace_error(renv, "invalid index operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Perform operation
+	 */
+		
+	sieve_runtime_trace(renv, "TEST_MESSAGE_SMTP (%s) [%d]", 
+		( is_test ? "TEST" : "COMMAND" ), msg_index);
+
+	result = testsuite_smtp_get(renv, msg_index);
+
+	if ( is_test ) {
+		sieve_interpreter_set_test_result(renv->interp, result);
+		return SIEVE_EXEC_OK;
+	}
+
+	if ( !result )
+		testsuite_test_failf("no outgoing SMTP message with index %d", msg_index);
+
+	return SIEVE_EXEC_OK;
+}
+
+static int cmd_test_message_mailbox_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	string_t *folder;
+	sieve_number_t msg_index;
+	unsigned int is_test = -1;
+	bool result;
+
+	/*
+	 * Read operands
+	 */
+
+	/* Is test */
+    if ( !sieve_binary_read_byte(renv->sbin, address, &is_test) ) {
+		sieve_runtime_trace_error(renv, "invalid is_test flag");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Folder */
+	if ( !sieve_opr_string_read(renv, address, &folder) ) {
+		sieve_runtime_trace_error(renv, "invalid folder operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/* Index */
+	if ( !sieve_opr_number_read(renv, address, &msg_index) ) {
+		sieve_runtime_trace_error(renv, "invalid index operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Perform operation
+	 */
+		
+	sieve_runtime_trace(renv, "TEST_MESSAGE_MAILBOX (%s) \"%s\" [%d]", 
+		( is_test ? "TEST" : "COMMAND" ), str_c(folder), msg_index);
+
+	result = testsuite_mailstore_mail_index(renv, str_c(folder), msg_index);
+
+	if ( is_test ) {
+		sieve_interpreter_set_test_result(renv->interp, result);
+		return SIEVE_EXEC_OK;
+	}
+
+	if ( !result )
+		testsuite_test_failf("no outgoing SMTP message with index %d", msg_index);
+
+	return SIEVE_EXEC_OK;
+}
+
+
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/cmd-test-result-print.c dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/cmd-test-result-print.c
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/cmd-test-result-print.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/cmd-test-result-print.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,82 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-script.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+#include "sieve-dump.h"
+#include "sieve.h"
+
+#include "testsuite-common.h"
+#include "testsuite-result.h"
+
+/*
+ * Test_result_execute command
+ *
+ * Syntax:   
+ *   test_result_execute
+ */
+
+static bool cmd_test_result_print_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command cmd_test_result_print = { 
+	"test_result_print", 
+	SCT_COMMAND, 
+	0, 0, FALSE, FALSE,
+	NULL, NULL, NULL,
+	cmd_test_result_print_generate, 
+	NULL 
+};
+
+/* 
+ * Operation 
+ */
+
+static int cmd_test_result_print_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation test_result_print_operation = { 
+	"TEST_RESULT_PRINT",
+	&testsuite_extension, 
+	TESTSUITE_OPERATION_TEST_RESULT_PRINT,
+	NULL, 
+	cmd_test_result_print_operation_execute 
+};
+
+/* 
+ * Code generation 
+ */
+
+static bool cmd_test_result_print_generate
+(const struct sieve_codegen_env *cgenv, 
+	struct sieve_command_context *tst ATTR_UNUSED)
+{
+	sieve_operation_emit_code(cgenv->sbin, &test_result_print_operation);
+
+	return TRUE;
+}
+
+/*
+ * Intepretation
+ */
+
+static int cmd_test_result_print_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, 
+	sieve_size_t *address ATTR_UNUSED)
+{
+	testsuite_result_print(renv);
+
+	return SIEVE_EXEC_OK;
+}
+
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/cmd-test-result-reset.c dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/cmd-test-result-reset.c
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/cmd-test-result-reset.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/cmd-test-result-reset.c	2009-02-11 21:38:58.000000000 +0100
@@ -0,0 +1,84 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-script.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+#include "sieve-dump.h"
+#include "sieve.h"
+
+#include "testsuite-common.h"
+#include "testsuite-result.h"
+#include "testsuite-smtp.h"
+
+/*
+ * Test_result_execute command
+ *
+ * Syntax:   
+ *   test_result_execute
+ */
+
+static bool cmd_test_result_reset_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command cmd_test_result_reset = { 
+	"test_result_reset", 
+	SCT_COMMAND, 
+	0, 0, FALSE, FALSE,
+	NULL, NULL, NULL,
+	cmd_test_result_reset_generate, 
+	NULL 
+};
+
+/* 
+ * Operation 
+ */
+
+static int cmd_test_result_reset_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation test_result_reset_operation = { 
+	"TEST_RESULT_RESET",
+	&testsuite_extension, 
+	TESTSUITE_OPERATION_TEST_RESULT_RESET,
+	NULL, 
+	cmd_test_result_reset_operation_execute 
+};
+
+/* 
+ * Code generation 
+ */
+
+static bool cmd_test_result_reset_generate
+(const struct sieve_codegen_env *cgenv, 
+	struct sieve_command_context *tst ATTR_UNUSED)
+{
+	sieve_operation_emit_code(cgenv->sbin, &test_result_reset_operation);
+
+	return TRUE;
+}
+
+/*
+ * Intepretation
+ */
+
+static int cmd_test_result_reset_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv,
+	sieve_size_t *address ATTR_UNUSED)
+{
+	testsuite_result_reset(renv);
+	testsuite_smtp_reset();
+
+	return SIEVE_EXEC_OK;
+}
+
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/cmd-test-set.c dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/cmd-test-set.c
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/cmd-test-set.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/cmd-test-set.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,160 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "ioloop.h"
+#include "str-sanitize.h"
+#include "istream.h"
+#include "istream-header-filter.h"
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-actions.h"
+#include "sieve-validator.h" 
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-code-dumper.h"
+#include "sieve-result.h"
+
+#include "testsuite-common.h"
+#include "testsuite-objects.h"
+
+#include <stdio.h>
+
+/* 
+ * Test_set command 
+ * 
+ * Syntax
+ *   test_set <testsuite object (member): string> <value: string>
+ */
+
+static bool cmd_test_set_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd);
+static bool cmd_test_set_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command cmd_test_set = { 
+	"test_set", 
+	SCT_COMMAND,
+	2, 0, FALSE, FALSE, 
+	NULL, NULL,
+	cmd_test_set_validate, 
+	cmd_test_set_generate, 
+	NULL 
+};
+
+/* 
+ * Test_set operation 
+ */
+
+static bool cmd_test_set_operation_dump
+	(const struct sieve_operation *op,
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_test_set_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation test_set_operation = { 
+	"TEST_SET",
+	&testsuite_extension, 
+	TESTSUITE_OPERATION_TEST_SET,
+	cmd_test_set_operation_dump, 
+	cmd_test_set_operation_execute 
+};
+
+/* 
+ * Validation 
+ */
+ 
+static bool cmd_test_set_validate
+(struct sieve_validator *valdtr, struct sieve_command_context *cmd) 
+{
+	struct sieve_ast_argument *arg = cmd->first_positional;
+
+	/* Check arguments */
+	
+	if ( !sieve_validate_positional_argument
+		(valdtr, cmd, arg, "object", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+	
+	if ( !testsuite_object_argument_activate(valdtr, arg, cmd) )
+		return FALSE;
+	
+	arg = sieve_ast_argument_next(arg);
+	
+	if ( !sieve_validate_positional_argument
+		(valdtr, cmd, arg, "value", 2, SAAT_STRING) ) {
+		return FALSE;
+	}
+	
+	return sieve_validator_argument_activate(valdtr, cmd, arg, FALSE);
+}
+
+/*
+ * Code generation
+ */
+ 
+static bool cmd_test_set_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx) 
+{
+	sieve_operation_emit_code(cgenv->sbin, &test_set_operation);
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, ctx, NULL);
+}
+
+/* 
+ * Code dump
+ */
+ 
+static bool cmd_test_set_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	sieve_code_dumpf(denv, "TEST SET:");
+	sieve_code_descend(denv);
+
+	return 
+		testsuite_object_dump(denv, address) &&
+		sieve_opr_string_dump(denv, address, "value");
+}
+
+/*
+ * Intepretation
+ */
+
+static int cmd_test_set_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	const struct testsuite_object *object;
+	string_t *value;
+	int member_id;
+
+	if ( (object=testsuite_object_read_member(renv->sbin, address, &member_id)) 
+		== NULL ) {
+		sieve_runtime_trace_error(renv, "invalid testsuite object member");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	if ( !sieve_opr_string_read(renv, address, &value) ) {
+		sieve_runtime_trace_error(renv, "invalid string operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	sieve_runtime_trace(renv, "TEST SET command (%s = \"%s\")", 
+		testsuite_object_member_name(object, member_id), str_c(value));
+	
+	if ( object->set_member == NULL ) {
+		sieve_runtime_trace_error(renv, "unimplemented testsuite object");
+		return SIEVE_EXEC_FAILURE;
+	}
+		
+	object->set_member(renv, member_id, value);	
+	return SIEVE_EXEC_OK;
+}
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/ext-testsuite.c dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/ext-testsuite.c
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/ext-testsuite.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/ext-testsuite.c	2009-08-21 00:52:15.000000000 +0200
@@ -0,0 +1,146 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension testsuite
+ * -------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: vendor-specific 
+ *   (FIXME: provide specification for test authors)
+ * Implementation: very basic
+ * Status: under development
+ * Purpose: This custom extension is used to add sieve commands and tests that 
+ *          act the Sieve engine and on the test suite itself. This practically 
+ *          provides the means to completely control and thereby test the Sieve 
+ *          compiler and interpreter. This extension transforms the basic Sieve 
+ *          language into something much more powerful and suitable to perform 
+ *          complex self-test operations. Of course, this extension is only 
+ *          available (as vnd.dovecot.testsuite) when the sieve engine is used
+ *          from within the testsuite commandline tool. Test scripts have the
+ *          extension .svtest by convention to distinguish them from any normal
+ *          sieve scripts that may reside in the same directory. 
+ *
+ * WARNING: Although this code can serve as an example on how to write extensions 
+ *          to the Sieve interpreter, it is generally _NOT_ to be used as a source 
+ *          for ideas on new Sieve extensions. Many of the commands and tests that 
+ *          this extension introduces conflict with the goal and the implied 
+ *          restrictions of the Sieve language. These restrictions were put in 
+ *          place with good reason. Therefore, do _NOT_ export functionality 
+ *          provided by this testsuite extension to your custom extensions that are 
+ *          to be put to general use. 
+ *
+ *          Thank you.
+ */
+
+#include <stdio.h>
+
+#include "sieve-common.h"
+
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-result.h"
+
+#include "testsuite-common.h"
+#include "testsuite-arguments.h"
+
+/* 
+ * Operations 
+ */
+
+const struct sieve_operation *testsuite_operations[] = { 
+	&test_operation, 
+	&test_finish_operation,
+	&test_fail_operation, 
+	&test_set_operation,
+	&test_script_compile_operation,
+	&test_script_run_operation,
+	&test_error_operation,
+	&test_result_operation,
+	&test_result_execute_operation,
+	&test_result_reset_operation,
+	&test_result_print_operation,
+	&test_message_smtp_operation,
+	&test_message_mailbox_operation,
+	&test_mailbox_create_operation,
+	&test_mailbox_delete_operation,
+	&test_binary_load_operation,
+	&test_binary_save_operation
+};
+
+/* 
+ * Operands 
+ */
+
+const struct sieve_operand *testsuite_operands[] = { 
+	&testsuite_object_operand,
+	&testsuite_substitution_operand
+};
+    
+/* 
+ * Extension
+ */
+
+/* Forward declarations */
+
+static bool ext_testsuite_validator_load(struct sieve_validator *valdtr);
+static bool ext_testsuite_generator_load(const struct sieve_codegen_env *cgenv);
+static bool ext_testsuite_binary_load(struct sieve_binary *sbin);
+
+/* Extension object */
+
+static int ext_my_id = -1;
+
+const struct sieve_extension testsuite_extension = { 
+	"vnd.dovecot.testsuite", 
+	&ext_my_id,
+	NULL, NULL,
+	ext_testsuite_validator_load,
+	ext_testsuite_generator_load,
+	NULL,
+	ext_testsuite_binary_load, 
+	NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATIONS(testsuite_operations),
+	SIEVE_EXT_DEFINE_OPERANDS(testsuite_operands)
+};
+
+/* Extension implementation */
+
+static bool ext_testsuite_validator_load(struct sieve_validator *valdtr)
+{
+	sieve_validator_register_command(valdtr, &cmd_test);
+	sieve_validator_register_command(valdtr, &cmd_test_fail);
+	sieve_validator_register_command(valdtr, &cmd_test_set);
+	sieve_validator_register_command(valdtr, &cmd_test_result_print);
+	sieve_validator_register_command(valdtr, &cmd_test_result_reset);
+	sieve_validator_register_command(valdtr, &cmd_test_message);
+	sieve_validator_register_command(valdtr, &cmd_test_mailbox);
+	sieve_validator_register_command(valdtr, &cmd_test_binary);
+
+	sieve_validator_register_command(valdtr, &tst_test_script_compile);
+	sieve_validator_register_command(valdtr, &tst_test_script_run);
+	sieve_validator_register_command(valdtr, &tst_test_error);
+	sieve_validator_register_command(valdtr, &tst_test_result);	
+	sieve_validator_register_command(valdtr, &tst_test_result_execute);	
+
+	sieve_validator_argument_override(valdtr, SAT_VAR_STRING,
+		&testsuite_string_argument);
+
+	return testsuite_validator_context_initialize(valdtr);
+}
+
+static bool ext_testsuite_generator_load(const struct sieve_codegen_env *cgenv)
+{
+	return testsuite_generator_context_initialize(cgenv->gentr);
+}
+
+static bool ext_testsuite_binary_load(struct sieve_binary *sbin ATTR_UNUSED)
+{
+	return TRUE;
+}
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/Makefile.am dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/Makefile.am
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/Makefile.am	2009-08-21 00:52:15.000000000 +0200
@@ -0,0 +1,75 @@
+noinst_PROGRAMS = testsuite
+
+AM_CPPFLAGS = \
+	-I../lib-sieve \
+	-I../lib-sieve-tool \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-index \
+	-I$(dovecot_incdir)/src/lib-storage
+
+testsuite_LDFLAGS = -export-dynamic
+
+libs = \
+	$(top_srcdir)/src/lib-sieve/libsieve.la \
+	$(top_srcdir)/src/lib-sieve-tool/libsieve-tool.la \
+	$(STORAGE_LIBS)
+
+ldadd = \
+	$(libs) \
+ 	$(LIBICONV) \
+	$(RAND_LIBS) \
+	$(MODULE_LIBS)
+
+testsuite_LDADD = $(ldadd)
+testsuite_DEPENDENCIES = $(libs)
+
+commands = \
+	cmd-test.c \
+	cmd-test-fail.c \
+	cmd-test-set.c \
+	cmd-test-result-reset.c \
+	cmd-test-result-print.c \
+	cmd-test-message.c \
+	cmd-test-mailbox.c \
+	cmd-test-binary.c
+
+
+tests = \
+	tst-test-script-compile.c \
+	tst-test-script-run.c \
+	tst-test-error.c \
+	tst-test-result.c \
+	tst-test-result-execute.c
+
+testsuite_SOURCES = \
+	testsuite-common.c \
+	testsuite-objects.c \
+	testsuite-substitutions.c \
+	testsuite-arguments.c \
+	testsuite-message.c \
+	testsuite-log.c \
+	testsuite-script.c \
+	testsuite-result.c \
+	testsuite-smtp.c \
+	testsuite-mailstore.c \
+	testsuite-binary.c \
+	$(commands) \
+	$(tests) \
+	ext-testsuite.c \
+	testsuite.c
+
+noinst_HEADERS = \
+	testsuite-common.h \
+	testsuite-objects.h \
+	testsuite-substitutions.h \
+	testsuite-arguments.h \
+	testsuite-message.h \
+	testsuite-log.h \
+	testsuite-script.h \
+	testsuite-result.h \
+	testsuite-smtp.h \
+	testsuite-mailstore.h \
+	testsuite-binary.h
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/Makefile.in dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/Makefile.in
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/Makefile.in	2009-08-21 00:55:44.000000000 +0200
@@ -0,0 +1,562 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+noinst_PROGRAMS = testsuite$(EXEEXT)
+subdir = src/testsuite
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+PROGRAMS = $(noinst_PROGRAMS)
+am__objects_1 = cmd-test.$(OBJEXT) cmd-test-fail.$(OBJEXT) \
+	cmd-test-set.$(OBJEXT) cmd-test-result-reset.$(OBJEXT) \
+	cmd-test-result-print.$(OBJEXT) cmd-test-message.$(OBJEXT) \
+	cmd-test-mailbox.$(OBJEXT) cmd-test-binary.$(OBJEXT)
+am__objects_2 = tst-test-script-compile.$(OBJEXT) \
+	tst-test-script-run.$(OBJEXT) tst-test-error.$(OBJEXT) \
+	tst-test-result.$(OBJEXT) tst-test-result-execute.$(OBJEXT)
+am_testsuite_OBJECTS = testsuite-common.$(OBJEXT) \
+	testsuite-objects.$(OBJEXT) testsuite-substitutions.$(OBJEXT) \
+	testsuite-arguments.$(OBJEXT) testsuite-message.$(OBJEXT) \
+	testsuite-log.$(OBJEXT) testsuite-script.$(OBJEXT) \
+	testsuite-result.$(OBJEXT) testsuite-smtp.$(OBJEXT) \
+	testsuite-mailstore.$(OBJEXT) testsuite-binary.$(OBJEXT) \
+	$(am__objects_1) $(am__objects_2) ext-testsuite.$(OBJEXT) \
+	testsuite.$(OBJEXT)
+testsuite_OBJECTS = $(am_testsuite_OBJECTS)
+am__DEPENDENCIES_1 =
+am__DEPENDENCIES_2 = $(top_srcdir)/src/lib-sieve/libsieve.la \
+	$(top_srcdir)/src/lib-sieve-tool/libsieve-tool.la \
+	$(am__DEPENDENCIES_1)
+am__DEPENDENCIES_3 = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1) \
+	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1)
+testsuite_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(testsuite_LDFLAGS) $(LDFLAGS) -o $@
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(testsuite_SOURCES)
+DIST_SOURCES = $(testsuite_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+AM_CPPFLAGS = \
+	-I../lib-sieve \
+	-I../lib-sieve-tool \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-index \
+	-I$(dovecot_incdir)/src/lib-storage
+
+testsuite_LDFLAGS = -export-dynamic
+libs = \
+	$(top_srcdir)/src/lib-sieve/libsieve.la \
+	$(top_srcdir)/src/lib-sieve-tool/libsieve-tool.la \
+	$(STORAGE_LIBS)
+
+ldadd = \
+	$(libs) \
+ 	$(LIBICONV) \
+	$(RAND_LIBS) \
+	$(MODULE_LIBS)
+
+testsuite_LDADD = $(ldadd)
+testsuite_DEPENDENCIES = $(libs)
+commands = \
+	cmd-test.c \
+	cmd-test-fail.c \
+	cmd-test-set.c \
+	cmd-test-result-reset.c \
+	cmd-test-result-print.c \
+	cmd-test-message.c \
+	cmd-test-mailbox.c \
+	cmd-test-binary.c
+
+tests = \
+	tst-test-script-compile.c \
+	tst-test-script-run.c \
+	tst-test-error.c \
+	tst-test-result.c \
+	tst-test-result-execute.c
+
+testsuite_SOURCES = \
+	testsuite-common.c \
+	testsuite-objects.c \
+	testsuite-substitutions.c \
+	testsuite-arguments.c \
+	testsuite-message.c \
+	testsuite-log.c \
+	testsuite-script.c \
+	testsuite-result.c \
+	testsuite-smtp.c \
+	testsuite-mailstore.c \
+	testsuite-binary.c \
+	$(commands) \
+	$(tests) \
+	ext-testsuite.c \
+	testsuite.c
+
+noinst_HEADERS = \
+	testsuite-common.h \
+	testsuite-objects.h \
+	testsuite-substitutions.h \
+	testsuite-arguments.h \
+	testsuite-message.h \
+	testsuite-log.h \
+	testsuite-script.h \
+	testsuite-result.h \
+	testsuite-smtp.h \
+	testsuite-mailstore.h \
+	testsuite-binary.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/testsuite/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  src/testsuite/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+clean-noinstPROGRAMS:
+	@list='$(noinst_PROGRAMS)'; for p in $$list; do \
+	  f=`echo $$p|sed 's/$(EXEEXT)$$//'`; \
+	  echo " rm -f $$p $$f"; \
+	  rm -f $$p $$f ; \
+	done
+testsuite$(EXEEXT): $(testsuite_OBJECTS) $(testsuite_DEPENDENCIES) 
+	@rm -f testsuite$(EXEEXT)
+	$(testsuite_LINK) $(testsuite_OBJECTS) $(testsuite_LDADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-test-binary.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-test-fail.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-test-mailbox.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-test-message.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-test-result-print.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-test-result-reset.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-test-set.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-test.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-testsuite.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testsuite-arguments.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testsuite-binary.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testsuite-common.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testsuite-log.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testsuite-mailstore.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testsuite-message.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testsuite-objects.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testsuite-result.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testsuite-script.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testsuite-smtp.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testsuite-substitutions.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testsuite.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-test-error.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-test-result-execute.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-test-result.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-test-script-compile.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-test-script-run.Po@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(PROGRAMS) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstPROGRAMS \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstPROGRAMS ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-arguments.c dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-arguments.c
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-arguments.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-arguments.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,192 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "str-sanitize.h"
+#include "array.h"
+
+#include "sieve-common.h"
+#include "sieve-ast.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-dump.h"
+
+#include "testsuite-common.h"
+#include "testsuite-substitutions.h"
+#include "testsuite-arguments.h"
+
+#include <ctype.h>
+
+/* 
+ * Testsuite string argument 
+ */
+
+static bool arg_testsuite_string_validate
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *context);
+
+const struct sieve_argument testsuite_string_argument = { 
+	"@testsuite-string", 
+	NULL, NULL,
+	arg_testsuite_string_validate, 
+	NULL, 
+	sieve_arg_catenated_string_generate,
+};
+
+static bool arg_testsuite_string_validate
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd)
+{
+	enum { ST_NONE, ST_OPEN, ST_SUBSTITUTION, ST_PARAM, ST_CLOSE } state = 
+		ST_NONE;
+	pool_t pool = sieve_ast_pool((*arg)->ast);
+	struct sieve_arg_catenated_string *catstr = NULL;
+	string_t *str = sieve_ast_argument_str(*arg);
+	const char *p, *strstart, *substart = NULL;
+	const char *strval = (const char *) str_data(str);
+	const char *strend = strval + str_len(str);
+	bool result = TRUE;
+	string_t *subs_name = t_str_new(256);
+	string_t *subs_param = t_str_new(256);
+	
+	T_BEGIN {
+		/* Initialize substitution structure */
+	
+		p = strval;
+		strstart = p;
+		while ( result && p < strend ) {
+			switch ( state ) {
+
+			/* Nothing found yet */
+			case ST_NONE:
+				if ( *p == '%' ) {
+					substart = p;
+					state = ST_OPEN;
+					str_truncate(subs_name, 0);
+					str_truncate(subs_param, 0);
+				}
+				p++;
+				break;
+
+			/* Got '%' */
+			case ST_OPEN:
+				if ( *p == '{' ) {
+					state = ST_SUBSTITUTION;
+					p++;
+				} else 
+					state = ST_NONE;
+				break;
+
+			/* Got '%{' */ 
+			case ST_SUBSTITUTION:
+				state = ST_PARAM;	
+
+				while ( *p != '}' && *p != ':' ) {
+					if ( !i_isalnum(*p) ) {
+						state = ST_NONE;
+						break;
+					}	
+					str_append_c(subs_name, *p);
+					p++;
+				}
+				break;
+				
+			/* Got '%{name' */
+			case ST_PARAM:
+				if ( *p == ':' ) {
+					p++;
+					while ( *p != '}' ) {
+						str_append_c(subs_param, *p);
+						p++;
+					}
+				}
+				state = ST_CLOSE;
+				break;
+
+			/* Finished parsing param, expecting '}' */
+			case ST_CLOSE:
+				if ( *p == '}' ) {				
+					struct sieve_ast_argument *strarg;
+				
+					/* We now know that the substitution is valid */	
+					
+					if ( catstr == NULL ) {
+						catstr = sieve_arg_catenated_string_create(*arg);
+					}
+				
+					/* Add the substring that is before the substitution to the 
+					 * variable-string AST.
+					 */
+					if ( substart > strstart ) {
+						string_t *newstr = str_new(pool, substart - strstart);
+						str_append_n(newstr, strstart, substart - strstart); 
+						
+						strarg = sieve_ast_argument_string_create_raw
+							((*arg)->ast, newstr, (*arg)->source_line);
+						sieve_arg_catenated_string_add_element(catstr, strarg);
+					
+						/* Give other substitution extensions a chance to do their work */
+						if ( !sieve_validator_argument_activate_super
+							(valdtr, cmd, strarg, FALSE) ) {
+							result = FALSE;
+							break;
+						}
+					}
+				
+					strarg = testsuite_substitution_argument_create
+						(valdtr, (*arg)->ast, (*arg)->source_line, str_c(subs_name), 
+							str_c(subs_param));
+					
+					if ( strarg != NULL )
+						sieve_arg_catenated_string_add_element(catstr, strarg);
+					else {
+						sieve_argument_validate_error(valdtr, *arg, 
+							"unknown testsuite substitution type '%s'", str_c(subs_name));
+					}
+
+					strstart = p + 1;
+					substart = strstart;
+
+					p++;	
+				}
+		
+				/* Finished, reset for the next substitution */	
+				state = ST_NONE;
+			}
+		}
+	} T_END;
+
+	/* Bail out early if substitution is invalid */
+	if ( !result ) return FALSE;
+	
+	/* Check whether any substitutions were found */
+	if ( catstr == NULL ) {
+		/* No substitutions in this string, pass it on to any other substution
+		 * extension.
+		 */
+		return sieve_validator_argument_activate_super(valdtr, cmd, *arg, TRUE);
+	}
+	
+	/* Add the final substring that comes after the last substitution to the 
+	 * variable-string AST.
+	 */
+	if ( strend > strstart ) {
+		struct sieve_ast_argument *strarg;
+		string_t *newstr = str_new(pool, strend - strstart);
+		str_append_n(newstr, strstart, strend - strstart); 
+
+		strarg = sieve_ast_argument_string_create_raw
+			((*arg)->ast, newstr, (*arg)->source_line);
+		sieve_arg_catenated_string_add_element(catstr, strarg);
+			
+		/* Give other substitution extensions a chance to do their work */	
+		if ( !sieve_validator_argument_activate_super
+			(valdtr, cmd, strarg, FALSE) )
+			return FALSE;
+	}	
+	
+	return TRUE;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-arguments.h dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-arguments.h
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-arguments.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-arguments.h	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,9 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __TESTSUITE_ARGUMENTS_H
+#define __TESTSUITE_ARGUMENTS_H
+
+extern const struct sieve_argument testsuite_string_argument;
+
+#endif
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-binary.c dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-binary.c
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-binary.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-binary.c	2009-08-21 00:52:15.000000000 +0200
@@ -0,0 +1,74 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "mempool.h"
+#include "imem.h"
+#include "array.h"
+#include "strfuncs.h"
+#include "unlink-directory.h"
+
+#include "sieve.h"
+#include "sieve-common.h" 
+#include "sieve-error.h"
+ 
+#include "testsuite-common.h"
+#include "testsuite-binary.h"
+
+#include <sys/stat.h>
+#include <sys/types.h>
+
+/*
+ * State
+ */
+
+static char *testsuite_binary_tmp = NULL;
+
+/*
+ * Initialization
+ */
+
+void testsuite_binary_init(void)
+{	
+	testsuite_binary_tmp = i_strconcat
+		(testsuite_tmp_dir_get(), "/binaries", NULL);
+
+	if ( mkdir(testsuite_binary_tmp, 0700) < 0 ) {
+		i_fatal("failed to create temporary directory '%s': %m.", 
+			testsuite_binary_tmp);		
+	}
+}
+
+void testsuite_binary_deinit(void)
+{
+	if ( unlink_directory(testsuite_binary_tmp, TRUE) < 0 ) {
+		i_warning("failed to remove temporary directory '%s': %m.",
+			testsuite_binary_tmp);
+	}
+	
+	i_free(testsuite_binary_tmp);		
+}
+
+void testsuite_binary_reset(void)
+{
+	testsuite_binary_init();
+	testsuite_binary_deinit();
+}
+
+/*
+ * Binary Access
+ */
+
+bool testsuite_binary_save(struct sieve_binary *sbin, const char *name)
+{
+	return sieve_save
+    (sbin, t_strdup_printf("%s/%s.svbin", testsuite_binary_tmp, name));
+}
+
+struct sieve_binary *testsuite_binary_load(const char *name)
+{
+	return sieve_load(t_strdup_printf("%s/%s.svbin", testsuite_binary_tmp, name));
+}
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-binary.h dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-binary.h
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-binary.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-binary.h	2009-08-21 00:52:15.000000000 +0200
@@ -0,0 +1,20 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __TESTSUITE_BINARY_H
+#define __TESTSUITE_BINARY_H
+
+#include "sieve-common.h" 
+
+void testsuite_binary_init(void);
+void testsuite_binary_deinit(void);
+void testsuite_binary_reset(void);
+
+/*
+ * Binary Access
+ */
+
+bool testsuite_binary_save(struct sieve_binary *sbin, const char *name);
+struct sieve_binary *testsuite_binary_load(const char *name);
+
+#endif /* __TESTSUITE_BINARY_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite.c dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite.c
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite.c	2009-08-21 00:52:15.000000000 +0200
@@ -0,0 +1,239 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "lib-signals.h"
+#include "ioloop.h"
+#include "ostream.h"
+#include "hostpid.h"
+#include "mail-storage.h"
+#include "mail-namespace.h"
+#include "env-util.h"
+
+#include "sieve.h"
+#include "sieve-extensions.h"
+#include "sieve-script.h"
+#include "sieve-binary.h"
+#include "sieve-result.h"
+#include "sieve-interpreter.h"
+
+#include "mail-raw.h"
+#include "sieve-tool.h"
+
+#include "testsuite-common.h"
+#include "testsuite-result.h"
+#include "testsuite-message.h"
+#include "testsuite-smtp.h"
+#include "testsuite-mailstore.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <pwd.h>
+
+const struct sieve_script_env *testsuite_scriptenv;
+
+/*
+ * Configuration
+ */
+
+#define DEFAULT_SENDMAIL_PATH "/usr/lib/sendmail"
+#define DEFAULT_ENVELOPE_SENDER "MAILER-DAEMON"
+
+/*
+ * Testsuite initialization 
+ */
+
+static void testsuite_tool_init(const char *extensions) 
+{
+	sieve_tool_init();
+
+	sieve_extensions_set_string(extensions);
+
+	(void) sieve_extension_register(&testsuite_extension, TRUE);
+	
+	testsuite_init();
+}
+
+static void testsuite_tool_deinit(void)
+{
+	testsuite_deinit();
+	
+	sieve_tool_deinit();
+}
+
+/*
+ * Testsuite execution
+ */
+
+static void print_help(void)
+{
+	printf(
+"Usage: testsuite [-d <dump filename>] <scriptfile>\n"
+	);
+}
+
+static int testsuite_run
+(struct sieve_binary *sbin, const struct sieve_message_data *msgdata, 
+	const struct sieve_script_env *senv, struct sieve_error_handler *ehandler)
+{
+	struct sieve_interpreter *interp;
+	struct sieve_result *result;
+	int ret = 0;
+
+	/* Create the interpreter */
+	if ( (interp=sieve_interpreter_create(sbin, ehandler)) == NULL )
+		return SIEVE_EXEC_BIN_CORRUPT;
+
+	/* Reset execution status */
+	if ( senv->exec_status != NULL )
+		memset(senv->exec_status, 0, sizeof(*senv->exec_status));
+
+	/* Run the interpreter */
+	result = testsuite_result_get();
+	sieve_result_ref(result);
+	ret = sieve_interpreter_run(interp, msgdata, senv, result);
+	sieve_result_unref(&result);
+
+	/* Free the interpreter */
+	sieve_interpreter_free(&interp);
+
+	return ret;
+}
+
+int main(int argc, char **argv) 
+{
+	const char *scriptfile, *dumpfile, *extensions; 
+	const char *user;
+	int i, ret;
+	struct sieve_binary *sbin;
+	const char *sieve_dir;
+	bool trace = FALSE;
+
+	/* Parse arguments */
+	scriptfile = dumpfile = extensions = NULL;
+	for (i = 1; i < argc; i++) {
+		if (strcmp(argv[i], "-d") == 0) {
+			/* dump file */
+			i++;
+			if (i == argc)
+				i_fatal("Missing -d argument");
+			dumpfile = argv[i];
+		} else if (strcmp(argv[i], "-x") == 0) {
+            /* extensions */
+            i++;
+            if (i == argc) {
+                print_help();
+                i_fatal("Missing -x argument");
+            }
+            extensions = argv[i];
+#ifdef SIEVE_RUNTIME_TRACE
+		} else if (strcmp(argv[i], "-t") == 0) {
+			/* runtime trace */
+			trace = TRUE;
+#endif
+		} else if ( scriptfile == NULL ) {
+			scriptfile = argv[i];
+		} else {
+			print_help();
+			i_fatal("Unknown argument: %s", argv[i]);
+		}
+	}
+	
+	if ( scriptfile == NULL ) {
+		print_help();
+		i_fatal("Missing <scriptfile> argument");
+	}
+
+	printf("Test case: %s:\n\n", scriptfile);
+
+	/* Initialize testsuite */
+	testsuite_tool_init(extensions);
+
+	/* Initialize environment */
+	sieve_dir = strrchr(scriptfile, '/');
+	if ( sieve_dir == NULL )
+		sieve_dir= "./";
+	else
+		sieve_dir = t_strdup_until(scriptfile, sieve_dir+1);
+
+	/* Currently needed for include (FIXME) */
+	env_put(t_strconcat("SIEVE_DIR=", sieve_dir, "included", NULL));
+	env_put(t_strconcat("SIEVE_GLOBAL_DIR=", sieve_dir, "included-global", NULL));
+
+	/* Compile sieve script */
+	if ( (sbin = sieve_tool_script_compile(scriptfile, NULL)) != NULL ) {
+		struct sieve_error_handler *ehandler;
+		struct sieve_script_env scriptenv;
+		const char *home = getenv("HOME");
+
+		/* Dump script */
+		sieve_tool_dump_binary_to(sbin, dumpfile);
+	
+		/* Initialize mail storages */
+		mail_users_init(getenv("AUTH_SOCKET_PATH"), getenv("DEBUG") != NULL);
+		mail_storage_init();
+		mail_storage_register_all();
+		mailbox_list_register_all();
+
+		/* Initialize message environment */
+		user = sieve_tool_get_user();
+		testsuite_mailstore_init(user, home);
+		testsuite_message_init(user);
+
+		memset(&scriptenv, 0, sizeof(scriptenv));
+		scriptenv.namespaces = testsuite_mailstore_get_namespace();
+		scriptenv.default_mailbox = "INBOX";
+		scriptenv.hostname = "testsuite.example.com";
+		scriptenv.postmaster_address = "postmaster@example.com";
+		scriptenv.username = user;
+		scriptenv.smtp_open = testsuite_smtp_open;
+		scriptenv.smtp_close = testsuite_smtp_close;
+		scriptenv.trace_stream = ( trace ? o_stream_create_fd(1, 0, FALSE) : NULL );
+
+		testsuite_scriptenv = &scriptenv;
+
+		testsuite_result_init();
+
+		/* Run the test */
+		ehandler = sieve_stderr_ehandler_create(0);
+		ret = testsuite_run(sbin, &testsuite_msgdata, &scriptenv, ehandler);
+		sieve_error_handler_unref(&ehandler);
+
+		switch ( ret ) {
+		case SIEVE_EXEC_OK:
+			break;
+		case SIEVE_EXEC_FAILURE:
+		case SIEVE_EXEC_KEEP_FAILED:
+			testsuite_testcase_fail("execution aborted");
+			break;
+		case SIEVE_EXEC_BIN_CORRUPT:
+			testsuite_testcase_fail("binary corrupt");
+			break;
+		default:
+			testsuite_testcase_fail("unknown execution exit code");
+		}
+
+		sieve_close(&sbin);
+
+		if ( scriptenv.trace_stream != NULL )
+			o_stream_unref(&scriptenv.trace_stream);
+
+		/* De-initialize message environment */
+		testsuite_message_deinit();
+		testsuite_mailstore_deinit();
+		testsuite_result_deinit();
+
+		/* De-initialize mail storages */
+		mail_storage_deinit();
+		mail_users_deinit();
+	} else {
+		testsuite_testcase_fail("failed to compile testcase script");
+	}
+
+	/* De-initialize testsuite */
+	testsuite_tool_deinit();  
+
+	return testsuite_testcase_result();
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-common.c dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-common.c
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-common.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-common.c	2009-08-21 01:22:51.000000000 +0200
@@ -0,0 +1,250 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "string.h"
+#include "ostream.h"
+#include "hash.h"
+#include "mail-storage.h"
+#include "env-util.h"
+#include "unlink-directory.h"
+
+#include "mail-raw.h"
+
+#include "sieve-common.h"
+#include "sieve-code.h"
+#include "sieve-message.h"
+#include "sieve-commands.h"
+#include "sieve-extensions.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-result.h"
+#include "sieve-dump.h"
+
+#include "testsuite-common.h"
+#include "testsuite-objects.h"
+#include "testsuite-log.h"
+#include "testsuite-script.h"
+#include "testsuite-binary.h"
+#include "testsuite-result.h"
+#include "testsuite-smtp.h"
+
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <time.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+
+/*
+ * Global data
+ */
+
+/* Test context */
+
+static string_t *test_name;
+unsigned int test_index;
+unsigned int test_failures;
+
+/* 
+ * Validator context 
+ */
+
+bool testsuite_validator_context_initialize(struct sieve_validator *valdtr)
+{
+	pool_t pool = sieve_validator_pool(valdtr);
+	struct testsuite_validator_context *ctx = 
+		p_new(pool, struct testsuite_validator_context, 1);
+	
+	/* Setup object registry */
+	ctx->object_registrations = sieve_validator_object_registry_create(valdtr);
+	testsuite_register_core_objects(ctx);
+	
+	sieve_validator_extension_set_context(valdtr, &testsuite_extension, ctx);
+
+	return TRUE;
+}
+
+struct testsuite_validator_context *testsuite_validator_context_get
+(struct sieve_validator *valdtr)
+{
+	return (struct testsuite_validator_context *)
+		sieve_validator_extension_get_context(valdtr, &testsuite_extension);
+}
+
+/* 
+ * Generator context 
+ */
+
+bool testsuite_generator_context_initialize(struct sieve_generator *gentr)
+{
+	pool_t pool = sieve_generator_pool(gentr);
+	struct sieve_binary *sbin = sieve_generator_get_binary(gentr);
+	struct testsuite_generator_context *ctx = 
+		p_new(pool, struct testsuite_generator_context, 1);
+	
+	/* Setup exit jumplist */
+	ctx->exit_jumps = sieve_jumplist_create(pool, sbin);
+	
+	sieve_generator_extension_set_context(gentr, &testsuite_extension, ctx);
+
+	return TRUE;
+}
+
+/*
+ * Test context
+ */
+ 
+static void testsuite_test_context_init(void)
+{
+	test_name = str_new(default_pool, 128);
+	test_index = 0;	
+	test_failures = 0;
+}
+
+void testsuite_test_start(string_t *name)
+{
+	str_truncate(test_name, 0);
+	str_append_str(test_name, name);
+
+	test_index++;
+}
+
+void testsuite_test_fail(string_t *reason)
+{
+	testsuite_test_fail_cstr(str_c(reason));
+}
+
+void testsuite_test_failf(const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+
+	testsuite_test_fail_cstr(t_strdup_vprintf(fmt, args));
+
+	va_end(args);
+}
+
+void testsuite_test_fail_cstr(const char *reason)
+{	
+	if ( str_len(test_name) == 0 ) {
+		if ( reason == NULL || *reason == '\0' )
+			printf("%2d: Test FAILED\n", test_index);
+		else
+			printf("%2d: Test FAILED: %s\n", test_index, reason);
+	} else {
+		if ( reason == NULL || *reason == '\0' )
+			printf("%2d: Test '%s' FAILED\n", test_index, str_c(test_name));
+		else
+			printf("%2d: Test '%s' FAILED: %s\n", test_index, 
+				str_c(test_name), reason);
+	}
+
+	str_truncate(test_name, 0);
+
+	test_failures++;
+}
+
+void testsuite_testcase_fail(const char *reason)
+{	
+	if ( reason == NULL || *reason == '\0' )
+		printf("XX: Test CASE FAILED\n");
+	else
+		printf("XX: Test CASE FAILED: %s\n", reason);
+
+	test_failures++;
+}
+
+void testsuite_test_succeed(string_t *reason)
+{
+	if ( str_len(test_name) == 0 ) {
+		if ( reason == NULL || str_len(reason) == 0 )
+			printf("%2d: Test SUCCEEDED\n", test_index);
+		else
+			printf("%2d: Test SUCCEEDED: %s\n", test_index, str_c(reason));
+	} else {
+		if ( reason == NULL || str_len(reason) == 0 )
+			printf("%2d: Test '%s' SUCCEEDED\n", test_index, str_c(test_name));
+		else
+			printf("%2d: Test '%s' SUCCEEDED: %s\n", test_index, 
+				str_c(test_name), str_c(reason));
+	}
+	str_truncate(test_name, 0);
+}
+
+static void testsuite_test_context_deinit(void)
+{
+	str_free(&test_name);
+}
+
+int testsuite_testcase_result(void)
+{
+	if ( test_failures > 0 ) {
+		printf("\nFAIL: %d of %d tests failed.\n\n", test_failures, test_index);
+		return 1;
+	}
+
+	printf("\nPASS: %d tests succeeded.\n\n", test_index);
+	return 0;
+}
+
+/*
+ * Testsuite temporary directory
+ */
+
+static char *testsuite_tmp_dir;
+
+static void testsuite_tmp_dir_init(void)
+{
+	testsuite_tmp_dir = i_strdup_printf
+		("/tmp/dsieve-testsuite.%s.%s", dec2str(time(NULL)), dec2str(getpid()));
+
+	if ( mkdir(testsuite_tmp_dir, 0700) < 0 ) {
+		i_fatal("failed to create temporary directory '%s': %m.", 
+			testsuite_tmp_dir);		
+	}
+}
+
+static void testsuite_tmp_dir_deinit(void)
+{
+	if ( unlink_directory(testsuite_tmp_dir, TRUE) < 0 )
+		i_warning("failed to remove temporary directory '%s': %m.",
+			testsuite_tmp_dir);
+
+	i_free(testsuite_tmp_dir);
+}
+
+const char *testsuite_tmp_dir_get(void)
+{
+	return testsuite_tmp_dir;
+}
+
+/*
+ * Main testsuite init/deinit
+ */
+
+void testsuite_init(void)
+{
+	testsuite_test_context_init();
+	testsuite_log_init();
+	testsuite_tmp_dir_init();
+	
+	testsuite_script_init();
+	testsuite_binary_init();
+	testsuite_smtp_init();
+}
+
+void testsuite_deinit(void)
+{
+	testsuite_smtp_deinit();
+	testsuite_binary_deinit();
+	testsuite_script_deinit();
+	
+	testsuite_tmp_dir_deinit();
+	testsuite_log_deinit();
+	testsuite_test_context_deinit();
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-common.h dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-common.h
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-common.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-common.h	2009-08-21 00:52:15.000000000 +0200
@@ -0,0 +1,143 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __TESTSUITE_COMMON_H
+#define __TESTSUITE_COMMON_H
+
+#include "sieve-common.h"
+
+/*
+ * Extension
+ */
+
+extern const struct sieve_extension testsuite_extension;
+
+extern const struct sieve_script_env *testsuite_scriptenv;
+
+/* 
+ * Validator context 
+ */
+
+struct testsuite_validator_context {
+	struct sieve_validator_object_registry *object_registrations;
+};
+
+bool testsuite_validator_context_initialize(struct sieve_validator *valdtr);
+struct testsuite_validator_context *testsuite_validator_context_get
+	(struct sieve_validator *valdtr);
+
+/* 
+ * Generator context 
+ */
+
+struct testsuite_generator_context {
+	struct sieve_jumplist *exit_jumps;
+};
+
+bool testsuite_generator_context_initialize(struct sieve_generator *gentr);
+
+/*
+ * Commands
+ */
+
+extern const struct sieve_command cmd_test;
+extern const struct sieve_command cmd_test_fail;
+extern const struct sieve_command cmd_test_set;
+extern const struct sieve_command cmd_test_result_reset;
+extern const struct sieve_command cmd_test_result_print;
+extern const struct sieve_command cmd_test_message;
+extern const struct sieve_command cmd_test_mailbox;
+extern const struct sieve_command cmd_test_binary;
+
+/*
+ * Tests
+ */
+
+extern const struct sieve_command tst_test_script_compile;
+extern const struct sieve_command tst_test_script_run;
+extern const struct sieve_command tst_test_error;
+extern const struct sieve_command tst_test_result;
+extern const struct sieve_command tst_test_result_execute;
+
+/* 
+ * Operations 
+ */
+
+enum testsuite_operation_code {
+	TESTSUITE_OPERATION_TEST,
+	TESTSUITE_OPERATION_TEST_FINISH,
+	TESTSUITE_OPERATION_TEST_FAIL,
+	TESTSUITE_OPERATION_TEST_SET,
+	TESTSUITE_OPERATION_TEST_SCRIPT_COMPILE,
+	TESTSUITE_OPERATION_TEST_SCRIPT_RUN,
+	TESTSUITE_OPERATION_TEST_ERROR,
+	TESTSUITE_OPERATION_TEST_RESULT,
+	TESTSUITE_OPERATION_TEST_RESULT_EXECUTE,
+	TESTSUITE_OPERATION_TEST_RESULT_RESET,
+	TESTSUITE_OPERATION_TEST_RESULT_PRINT,
+	TESTSUITE_OPERATION_TEST_MESSAGE_SMTP,
+	TESTSUITE_OPERATION_TEST_MESSAGE_MAILBOX,
+	TESTSUITE_OPERATION_TEST_MAILBOX_CREATE,
+	TESTSUITE_OPERATION_TEST_MAILBOX_DELETE,
+	TESTSUITE_OPERATION_TEST_BINARY_LOAD,
+	TESTSUITE_OPERATION_TEST_BINARY_SAVE,
+};
+
+extern const struct sieve_operation test_operation;
+extern const struct sieve_operation test_finish_operation;
+extern const struct sieve_operation test_fail_operation;
+extern const struct sieve_operation test_set_operation;
+extern const struct sieve_operation test_script_compile_operation;
+extern const struct sieve_operation test_script_run_operation;
+extern const struct sieve_operation test_error_operation;
+extern const struct sieve_operation test_result_operation;
+extern const struct sieve_operation test_result_execute_operation;
+extern const struct sieve_operation test_result_reset_operation;
+extern const struct sieve_operation test_result_print_operation;
+extern const struct sieve_operation test_message_smtp_operation;
+extern const struct sieve_operation test_message_mailbox_operation;
+extern const struct sieve_operation test_mailbox_create_operation;
+extern const struct sieve_operation test_mailbox_delete_operation;
+extern const struct sieve_operation test_binary_load_operation;
+extern const struct sieve_operation test_binary_save_operation;
+
+/* 
+ * Operands 
+ */
+
+extern const struct sieve_operand testsuite_object_operand;
+extern const struct sieve_operand testsuite_substitution_operand;
+
+enum testsuite_operand_code {
+	TESTSUITE_OPERAND_OBJECT,
+	TESTSUITE_OPERAND_SUBSTITUTION
+};
+
+/* 
+ * Test context 
+ */
+
+void testsuite_test_start(string_t *name);
+void testsuite_test_fail(string_t *reason);
+void testsuite_test_failf(const char *fmt, ...) ATTR_FORMAT(1, 2);
+void testsuite_test_fail_cstr(const char *reason);
+
+void testsuite_test_succeed(string_t *reason);
+
+void testsuite_testcase_fail(const char *reason);
+int testsuite_testcase_result(void);
+
+/*
+ * Testsuite temporary directory
+ */
+ 
+const char *testsuite_tmp_dir_get(void);
+
+/* 
+ * Testsuite init/deinit 
+ */
+
+void testsuite_init(void);
+void testsuite_deinit(void);
+
+#endif /* __TESTSUITE_COMMON_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-log.c dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-log.c
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-log.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-log.c	2009-07-21 01:22:08.000000000 +0200
@@ -0,0 +1,125 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "array.h"
+
+#include "sieve-common.h"
+#include "sieve-error-private.h"
+
+#include "testsuite-log.h"
+
+/* 
+ * Testsuite error handler
+ */
+
+struct sieve_error_handler *testsuite_log_ehandler = NULL;
+
+struct _testsuite_log_message {
+	const char *location;
+	const char *message;
+};
+
+bool _testsuite_log_stdout = FALSE;
+
+unsigned int _testsuite_log_error_index = 0;
+
+static pool_t _testsuite_logmsg_pool = NULL;
+ARRAY_DEFINE(_testsuite_log_errors, struct _testsuite_log_message);
+
+static void _testsuite_log_verror
+(struct sieve_error_handler *ehandler ATTR_UNUSED, const char *location,
+	const char *fmt, va_list args)
+{
+	pool_t pool = _testsuite_logmsg_pool;
+	struct _testsuite_log_message msg;
+
+	if ( _testsuite_log_stdout ) 	
+	{
+		va_list args_copy;
+		VA_COPY(args_copy, args);
+		printf("error: %s: %s.\n", location, t_strdup_vprintf(fmt, args_copy));
+	}
+	
+	msg.location = p_strdup(pool, location);
+	msg.message = p_strdup_vprintf(pool, fmt, args);
+
+	array_append(&_testsuite_log_errors, &msg, 1);	
+}
+
+static struct sieve_error_handler *_testsuite_log_ehandler_create(void)
+{
+	pool_t pool;
+	struct sieve_error_handler *ehandler;
+
+	/* Pool is not strictly necessary, but other handler types will need a pool,
+	 * so this one will have one too.
+	 */
+	pool = pool_alloconly_create
+		("testsuite_log_handler", sizeof(struct sieve_error_handler));
+	ehandler = p_new(pool, struct sieve_error_handler, 1);
+	sieve_error_handler_init(ehandler, pool, 0);
+
+	ehandler->verror = _testsuite_log_verror;
+
+	return ehandler;
+}
+
+void testsuite_log_clear_messages(void)
+{
+	if ( _testsuite_logmsg_pool != NULL ) {
+		if ( array_count(&_testsuite_log_errors) == 0 )
+			return;
+		pool_unref(&_testsuite_logmsg_pool);
+	}
+
+	_testsuite_logmsg_pool = pool_alloconly_create
+		("testsuite_log_messages", 8192);
+	
+	p_array_init(&_testsuite_log_errors, _testsuite_logmsg_pool, 128);	
+
+	sieve_error_handler_reset(testsuite_log_ehandler);
+}
+
+void testsuite_log_get_error_init(void)
+{
+	_testsuite_log_error_index = 0;
+}
+
+const char *testsuite_log_get_error_next(bool location)
+{
+	const struct _testsuite_log_message *msg;
+
+	if ( _testsuite_log_error_index >= array_count(&_testsuite_log_errors) )
+		return NULL;
+
+	msg = array_idx(&_testsuite_log_errors, _testsuite_log_error_index++);
+
+	if ( location ) 
+		return msg->location;
+
+	return msg->message;		
+}
+
+void testsuite_log_init(void)
+{
+	testsuite_log_ehandler = _testsuite_log_ehandler_create(); 	
+	sieve_error_handler_accept_infolog(testsuite_log_ehandler, TRUE);
+
+	sieve_system_ehandler_set(testsuite_log_ehandler);
+
+	testsuite_log_clear_messages();
+}
+
+void testsuite_log_deinit(void)
+{
+	sieve_system_ehandler_reset();
+
+	sieve_error_handler_unref(&testsuite_log_ehandler);
+
+	pool_unref(&_testsuite_logmsg_pool);
+}
+
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-log.h dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-log.h
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-log.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-log.h	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,18 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __TESTSUITE_LOG_H
+#define __TESTSUITE_LOG_H
+
+#include "sieve-common.h"
+
+extern struct sieve_error_handler *testsuite_log_ehandler;
+
+void testsuite_log_init(void);
+void testsuite_log_deinit(void);
+
+void testsuite_log_clear_messages(void);
+void testsuite_log_get_error_init(void);
+const char *testsuite_log_get_error_next(bool location);
+
+#endif /* __TESTSUITE_LOG_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-mailstore.c dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-mailstore.c
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-mailstore.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-mailstore.c	2009-08-02 09:44:14.000000000 +0200
@@ -0,0 +1,181 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "mempool.h"
+#include "imem.h"
+#include "array.h"
+#include "unlink-directory.h"
+#include "env-util.h"
+#include "mail-namespace.h"
+#include "mail-storage.h"
+
+#include "sieve-common.h" 
+#include "sieve-error.h"
+#include "sieve-interpreter.h"
+ 
+#include "testsuite-message.h"
+#include "testsuite-common.h"
+#include "testsuite-smtp.h"
+
+#include "testsuite-mailstore.h"
+
+#include <sys/stat.h>
+#include <sys/types.h>
+
+/*
+ * Forward declarations
+ */
+
+static void testsuite_mailstore_close(void);
+
+/*
+ * State
+ */
+
+static char *testsuite_mailstore_tmp = NULL;
+static struct mail_user *testsuite_mailstore_user = NULL;
+
+static char *testsuite_mailstore_folder = NULL;
+static struct mailbox *testsuite_mailstore_box = NULL;
+static struct mailbox_transaction_context *testsuite_mailstore_trans = NULL;
+static struct mail *testsuite_mailstore_mail = NULL;
+
+/*
+ * Initialization
+ */
+
+void testsuite_mailstore_init(const char *user, const char *home)
+{	
+	testsuite_mailstore_tmp = i_strconcat
+		(testsuite_tmp_dir_get(), "/mailstore", NULL);
+
+	if ( mkdir(testsuite_mailstore_tmp, 0700) < 0 ) {
+		i_fatal("failed to create temporary directory '%s': %m.", 
+			testsuite_mailstore_tmp);		
+	}
+
+	env_put(t_strdup_printf("NAMESPACE_1=maildir:%s", testsuite_mailstore_tmp));
+	env_put("NAMESPACE_1_INBOX=1");
+	env_put("NAMESPACE_1_LIST=1");
+	env_put("NAMESPACE_1_SEP=.");
+	env_put("NAMESPACE_1_SUBSCRIPTIONS=1");
+
+	testsuite_mailstore_user = mail_user_init(user);
+	mail_user_set_home(testsuite_mailstore_user, home);
+	if (mail_namespaces_init(testsuite_mailstore_user) < 0)
+		i_fatal("Namespace initialization failed");	
+}
+
+void testsuite_mailstore_deinit(void)
+{
+	testsuite_mailstore_close();
+
+	/* De-initialize mail user object */
+	if ( testsuite_mailstore_user != NULL )
+		mail_user_unref(&testsuite_mailstore_user);
+
+	if ( unlink_directory(testsuite_mailstore_tmp, TRUE) < 0 ) {
+		i_warning("failed to remove temporary directory '%s': %m.",
+			testsuite_mailstore_tmp);
+	}
+	
+	i_free(testsuite_mailstore_tmp);		
+}
+
+void testsuite_mailstore_reset(void)
+{
+}
+
+/*
+ * Mailbox Access
+ */
+
+struct mail_namespace *testsuite_mailstore_get_namespace(void)
+{
+	return testsuite_mailstore_user->namespaces;
+}
+
+bool testsuite_mailstore_mailbox_create
+(const struct sieve_runtime_env *renv ATTR_UNUSED, const char *folder)
+{
+	struct mail_storage *storage = testsuite_mailstore_user->namespaces->storage;
+
+	/* Try creating it */
+	if ( mail_storage_mailbox_create(storage, folder, FALSE) < 0 )
+		return FALSE;
+
+	return TRUE;
+}
+
+static void testsuite_mailstore_close(void)
+{
+	if ( testsuite_mailstore_mail != NULL )
+		mail_free(&testsuite_mailstore_mail);
+
+	if ( testsuite_mailstore_trans != NULL )
+		mailbox_transaction_rollback(&testsuite_mailstore_trans);
+		
+	if ( testsuite_mailstore_box != NULL )
+		mailbox_close(&testsuite_mailstore_box);
+
+	if ( testsuite_mailstore_folder != NULL )
+		i_free(testsuite_mailstore_folder);
+}
+
+static struct mail *testsuite_mailstore_open(const char *folder)
+{
+	enum mailbox_open_flags open_flags = 
+		MAILBOX_OPEN_FAST | MAILBOX_OPEN_KEEP_RECENT | 
+		MAILBOX_OPEN_SAVEONLY | MAILBOX_OPEN_POST_SESSION;
+	struct mail_storage *storage = testsuite_mailstore_user->namespaces->storage;
+	struct mailbox *box;
+	struct mailbox_transaction_context *t;
+
+	if ( testsuite_mailstore_mail == NULL ) {
+		testsuite_mailstore_close();
+	} else if ( testsuite_mailstore_folder != NULL 
+		&& strcmp(folder, testsuite_mailstore_folder) != 0  ) {
+		testsuite_mailstore_close();	
+	} else {
+		return testsuite_mailstore_mail;
+	}
+
+	box = mailbox_open(&storage, folder, NULL, open_flags);
+	if ( box == NULL ) {
+		sieve_sys_error("testsuite: failed to open mailbox '%s'", folder);
+		return NULL;	
+	}
+	
+	/* Sync mailbox */
+
+	if ( mailbox_sync(box, MAILBOX_SYNC_FLAG_FULL_READ, 0, NULL) < 0 ) {
+		sieve_sys_error("testsuite: failed to sync mailbox '%s'", folder);
+		return NULL;
+	}
+
+	/* Start transaction */
+
+	t = mailbox_transaction_begin(box, 0);
+
+	testsuite_mailstore_folder = i_strdup(folder);
+	testsuite_mailstore_box = box;
+	testsuite_mailstore_trans = t;
+	testsuite_mailstore_mail = mail_alloc(t, 0, NULL);
+
+	return testsuite_mailstore_mail;
+}
+
+bool testsuite_mailstore_mail_index
+(const struct sieve_runtime_env *renv, const char *folder, unsigned int index)
+{
+	struct mail *mail = testsuite_mailstore_open(folder);
+
+	if ( mail == NULL )
+		return FALSE;
+
+	mail_set_seq(mail, index+1);
+	testsuite_message_set_mail(renv, mail);
+
+	return TRUE;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-mailstore.h dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-mailstore.h
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-mailstore.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-mailstore.h	2009-07-31 17:34:58.000000000 +0200
@@ -0,0 +1,34 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __TESTSUITE_MAILSTORE_H
+#define __TESTSUITE_MAILSTORE_H
+
+#include "sieve-common.h" 
+
+/*
+ * Initialization
+ */
+
+void testsuite_mailstore_init(const char *user, const char *home);
+void testsuite_mailstore_deinit(void);
+void testsuite_mailstore_reset(void);
+
+/* 
+ * Namespace
+ */
+
+struct mail_namespace *testsuite_mailstore_get_namespace(void);
+
+/*
+ * Mailbox Access
+ */
+
+bool testsuite_mailstore_mailbox_create
+	(const struct sieve_runtime_env *renv ATTR_UNUSED, const char *folder);
+
+bool testsuite_mailstore_mail_index
+	(const struct sieve_runtime_env *renv, const char *folder, 
+		unsigned int index);
+
+#endif /* __TESTSUITE_MAILSTORE */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-message.c dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-message.c
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-message.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-message.c	2009-08-21 00:52:15.000000000 +0200
@@ -0,0 +1,184 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "istream.h"
+#include "mail-storage.h"
+
+#include "mail-raw.h"
+
+#include "sieve-common.h"
+#include "sieve-message.h"
+#include "sieve-interpreter.h"
+
+#include "testsuite-common.h"
+#include "testsuite-message.h"
+
+/* 
+ * Testsuite message environment 
+ */
+ 
+struct sieve_message_data testsuite_msgdata;
+
+static const char *testsuite_user;
+static struct mail_raw *_raw_message;
+
+static const char *_default_message_data = 
+"From: stephan@rename-it.nl\n"
+"To: sirius@drunksnipers.com\n"
+"Subject: Frop!\n"
+"\n"
+"Friep!\n";
+
+static string_t *envelope_from;
+static string_t *envelope_to;
+static string_t *envelope_auth;
+
+pool_t message_pool;
+
+static void _testsuite_message_set_data(struct mail *mail)
+{
+	const char *recipient = NULL, *sender = NULL;
+	
+	/* 
+	 * Collect necessary message data 
+	 */
+	 
+	/* Get recipient address */ 
+	(void)mail_get_first_header(mail, "Envelope-To", &recipient);
+	if ( recipient == NULL )
+		(void)mail_get_first_header(mail, "To", &recipient);
+	if ( recipient == NULL ) 
+		recipient = "recipient@example.com";
+	
+	/* Get sender address */
+	(void)mail_get_first_header(mail, "Return-path", &sender);
+	if ( sender == NULL ) 
+		(void)mail_get_first_header(mail, "Sender", &sender);
+	if ( sender == NULL ) 
+		(void)mail_get_first_header(mail, "From", &sender);
+	if ( sender == NULL ) 
+		sender = "sender@example.com";
+
+	memset(&testsuite_msgdata, 0, sizeof(testsuite_msgdata));	
+	testsuite_msgdata.mail = mail;
+	testsuite_msgdata.auth_user = testsuite_user;
+	testsuite_msgdata.return_path = sender;
+	testsuite_msgdata.to_address = recipient;
+
+	(void)mail_get_first_header(mail, "Message-ID", &testsuite_msgdata.id);
+}
+
+void testsuite_message_init(const char *user)
+{		
+	message_pool = pool_alloconly_create("testsuite_message", 6096);
+
+	string_t *default_message = str_new(message_pool, 1024);
+	str_append(default_message, _default_message_data);
+
+	testsuite_user = user;
+	mail_raw_init(user);
+	_raw_message = mail_raw_open_data(default_message);
+	_testsuite_message_set_data(_raw_message->mail);
+
+	envelope_to = str_new(message_pool, 256);
+	envelope_from = str_new(message_pool, 256);
+	envelope_auth = str_new(message_pool, 256);
+}
+
+void testsuite_message_set_string
+(const struct sieve_runtime_env *renv, string_t *message)
+{
+	mail_raw_close(_raw_message);
+
+	_raw_message = mail_raw_open_data(message);
+
+	_testsuite_message_set_data(_raw_message->mail);
+
+	sieve_message_context_flush(renv->msgctx);
+
+	/*{ 
+		const unsigned char *data;
+		struct istream *input;
+		size_t size;
+		int ret;
+
+		if (mail_get_stream(_raw_message->mail, NULL, NULL, &input) < 0)
+        	return;
+
+		while ((ret = i_stream_read_data(input, &data, &size, 0)) > 0) {
+			if (write(1, data, size) == 0)
+				break;
+			i_stream_skip(input, size);
+		}
+    }*/
+}
+
+void testsuite_message_set_file
+(const struct sieve_runtime_env *renv, const char *file_path)
+{
+	mail_raw_close(_raw_message);
+	 
+	_raw_message = mail_raw_open_file(file_path);
+
+	_testsuite_message_set_data(_raw_message->mail);
+
+	sieve_message_context_flush(renv->msgctx);
+}
+
+void testsuite_message_set_mail
+(const struct sieve_runtime_env *renv, struct mail *mail)
+{
+	_testsuite_message_set_data(mail);
+
+	sieve_message_context_flush(renv->msgctx);
+}
+	
+void testsuite_message_deinit(void)
+{
+	mail_raw_close(_raw_message);
+	mail_raw_deinit();
+
+	pool_unref(&message_pool);
+}
+
+void testsuite_envelope_set_sender
+(const struct sieve_runtime_env *renv, const char *value)
+{
+	str_truncate(envelope_from, 0);
+
+	if ( value != NULL )
+		str_append(envelope_from, value);
+
+	testsuite_msgdata.return_path = str_c(envelope_from);
+
+	sieve_message_context_flush(renv->msgctx);
+}
+
+void testsuite_envelope_set_recipient
+(const struct sieve_runtime_env *renv, const char *value)
+{
+	str_truncate(envelope_to, 0);
+
+	if ( value != NULL )
+		str_append(envelope_to, value);
+
+	testsuite_msgdata.to_address = str_c(envelope_to);
+
+	sieve_message_context_flush(renv->msgctx);
+}
+
+void testsuite_envelope_set_auth_user
+(const struct sieve_runtime_env *renv, const char *value)
+{
+	str_truncate(envelope_auth, 0);
+
+	if ( value != NULL )
+		str_append(envelope_auth, value);
+
+	testsuite_msgdata.auth_user = str_c(envelope_auth);
+
+	sieve_message_context_flush(renv->msgctx);
+} 
+ 
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-message.h dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-message.h
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-message.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-message.h	2009-07-31 17:34:58.000000000 +0200
@@ -0,0 +1,28 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __TESTSUITE_MESSAGE_H
+#define __TESTSUITE_MESSAGE_H
+
+#include "sieve-common.h"
+
+extern struct sieve_message_data testsuite_msgdata;
+
+void testsuite_message_init(const char *user);
+void testsuite_message_deinit(void);
+
+void testsuite_message_set_string
+	(const struct sieve_runtime_env *renv, string_t *message);
+void testsuite_message_set_file
+	(const struct sieve_runtime_env *renv, const char *file_path);
+void testsuite_message_set_mail
+	(const struct sieve_runtime_env *renv, struct mail *mail);
+
+void testsuite_envelope_set_sender
+	(const struct sieve_runtime_env *renv, const char *value);
+void testsuite_envelope_set_recipient
+	(const struct sieve_runtime_env *renv, const char *value);
+void testsuite_envelope_set_auth_user
+	(const struct sieve_runtime_env *renv, const char *value);
+
+#endif /* __TESTSUITE_MESSAGE_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-objects.c dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-objects.c
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-objects.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-objects.c	2009-07-21 00:46:10.000000000 +0200
@@ -0,0 +1,335 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "string.h"
+#include "ostream.h"
+#include "hash.h"
+#include "mail-storage.h"
+
+#include "sieve.h"
+#include "sieve-code.h"
+#include "sieve-commands.h"
+#include "sieve-extensions.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+#include "sieve-dump.h"
+
+#include "testsuite-common.h"
+#include "testsuite-objects.h"
+#include "testsuite-message.h"
+ 
+/* 
+ * Testsuite core objects
+ */
+ 
+enum testsuite_object_code {
+	TESTSUITE_OBJECT_MESSAGE,
+	TESTSUITE_OBJECT_ENVELOPE
+};
+
+const struct testsuite_object *testsuite_core_objects[] = {
+	&message_testsuite_object, &envelope_testsuite_object
+};
+
+const unsigned int testsuite_core_objects_count =
+	N_ELEMENTS(testsuite_core_objects);
+
+/* 
+ * Testsuite object registry
+ */
+ 
+void testsuite_object_register
+(struct sieve_validator *valdtr, const struct testsuite_object *tobj) 
+{
+	struct testsuite_validator_context *ctx = testsuite_validator_context_get
+		(valdtr);
+	
+	sieve_validator_object_registry_add
+		(ctx->object_registrations, &tobj->object);
+}
+
+const struct testsuite_object *testsuite_object_find
+(struct sieve_validator *valdtr, const char *identifier) 
+{
+	struct testsuite_validator_context *ctx = testsuite_validator_context_get
+		(valdtr);
+	const struct sieve_object *object = 
+		sieve_validator_object_registry_find
+			(ctx->object_registrations, identifier);
+
+	return (const struct testsuite_object *) object;
+}
+
+void testsuite_register_core_objects
+	(struct testsuite_validator_context *ctx)
+{
+	unsigned int i;
+	
+	/* Register core testsuite objects */
+	for ( i = 0; i < testsuite_core_objects_count; i++ ) {
+		sieve_validator_object_registry_add
+			(ctx->object_registrations, &(testsuite_core_objects[i]->object));
+	}
+}
+ 
+/* 
+ * Testsuite object code
+ */ 
+ 
+const struct sieve_operand_class sieve_testsuite_object_operand_class = 
+	{ "testsuite object" };
+
+static const struct sieve_extension_objects core_testsuite_objects =
+	SIEVE_EXT_DEFINE_OBJECTS(testsuite_core_objects);
+
+const struct sieve_operand testsuite_object_operand = { 
+	"testsuite-object",
+	&testsuite_extension, 
+	TESTSUITE_OPERAND_OBJECT, 
+	&sieve_testsuite_object_operand_class,
+	&core_testsuite_objects
+};
+
+static void testsuite_object_emit
+(struct sieve_binary *sbin, const struct testsuite_object *obj,
+	int member_id)
+{ 
+	sieve_opr_object_emit(sbin, &obj->object);
+	
+	if ( obj->get_member_id != NULL ) {
+		(void) sieve_binary_emit_byte(sbin, (unsigned char) member_id);
+	}
+}
+
+const struct testsuite_object *testsuite_object_read
+(struct sieve_binary *sbin, sieve_size_t *address)
+{
+	const struct sieve_operand *operand = sieve_operand_read(sbin, address);
+	
+	return (const struct testsuite_object *) sieve_opr_object_read_data
+		(sbin, operand, &sieve_testsuite_object_operand_class, address);
+}
+
+const struct testsuite_object *testsuite_object_read_member
+(struct sieve_binary *sbin, sieve_size_t *address, int *member_id)
+{
+	const struct testsuite_object *object;
+		
+	if ( (object = testsuite_object_read(sbin, address)) == NULL )
+		return NULL;
+		
+	*member_id = -1;
+	if ( object->get_member_id != NULL ) {
+		if ( !sieve_binary_read_code(sbin, address, member_id) ) 
+			return NULL;
+	}
+	
+	return object;
+}
+
+const char *testsuite_object_member_name
+(const struct testsuite_object *object, int member_id)
+{
+	const char *member = NULL;
+
+	if ( object->get_member_id != NULL ) {
+		if ( object->get_member_name != NULL )
+			member = object->get_member_name(member_id);
+	} else 
+		return object->object.identifier;
+		
+	if ( member == NULL )	
+		return t_strdup_printf("%s.%d", object->object.identifier, member_id);
+	
+	return t_strdup_printf("%s.%s", object->object.identifier, member);
+}
+
+bool testsuite_object_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	const struct testsuite_object *object;
+	int member_id;
+
+	sieve_code_mark(denv);
+		
+	if ( (object = testsuite_object_read_member(denv->sbin, address, &member_id)) 
+		== NULL )
+		return FALSE;
+	
+	sieve_code_dumpf(denv, "%s: %s",
+		sieve_testsuite_object_operand_class.name, 
+		testsuite_object_member_name(object, member_id));
+	
+	return TRUE;
+}
+
+/* 
+ * Testsuite object argument
+ */
+ 
+static bool arg_testsuite_object_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+		struct sieve_command_context *cmd);
+
+const struct sieve_argument testsuite_object_argument = { 
+	"testsuite-object", 
+	NULL, NULL, NULL, NULL,
+	arg_testsuite_object_generate 
+};
+ 
+struct testsuite_object_argctx {
+	const struct testsuite_object *object;
+	int member;
+};
+
+bool testsuite_object_argument_activate
+(struct sieve_validator *valdtr, struct sieve_ast_argument *arg,
+	struct sieve_command_context *cmd) 
+{
+	const char *objname = sieve_ast_argument_strc(arg);
+	const struct testsuite_object *object;
+	int member_id;
+	const char *member;
+	struct testsuite_object_argctx *ctx;
+	
+	/* Parse the object specifier */
+	
+	member = strchr(objname, '.');
+	if ( member != NULL ) {
+		objname = t_strdup_until(objname, member);
+		member++;
+	}
+	
+	/* Find the object */
+	
+	object = testsuite_object_find(valdtr, objname);
+	if ( object == NULL ) {
+		sieve_argument_validate_error(valdtr, arg, 
+			"unknown testsuite object '%s'", objname);
+		return FALSE;
+	}
+	
+	/* Find the object member */
+	
+	member_id = -1;
+	if ( member != NULL ) {
+		if ( object->get_member_id == NULL || 
+			(member_id=object->get_member_id(member)) == -1 ) {
+			sieve_argument_validate_error(valdtr, arg, 
+				"member '%s' does not exist for testsuite object '%s'", member, objname);
+			return FALSE;
+		}
+	}
+	
+	/* Assign argument context */
+	
+	ctx = p_new(sieve_command_pool(cmd), struct testsuite_object_argctx, 1);
+	ctx->object = object;
+	ctx->member = member_id;
+	
+	arg->argument = &testsuite_object_argument;
+	arg->context = (void *) ctx;
+	
+	return TRUE;
+}
+
+static bool arg_testsuite_object_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+	struct sieve_command_context *cmd ATTR_UNUSED)
+{
+	struct testsuite_object_argctx *ctx = 
+		(struct testsuite_object_argctx *) arg->context;
+	
+	testsuite_object_emit(cgenv->sbin, ctx->object, ctx->member);
+		
+	return TRUE;
+}
+
+/* 
+ * Testsuite core object implementation
+ */
+ 
+static bool tsto_message_set_member
+	(const struct sieve_runtime_env *renv, int id, string_t *value);
+
+static int tsto_envelope_get_member_id(const char *identifier);
+static const char *tsto_envelope_get_member_name(int id);
+static bool tsto_envelope_set_member
+	(const struct sieve_runtime_env *renv, int id, string_t *value);
+
+const struct testsuite_object message_testsuite_object = { 
+	SIEVE_OBJECT("message",	&testsuite_object_operand, TESTSUITE_OBJECT_MESSAGE),
+	NULL, NULL, 
+	tsto_message_set_member, 
+	NULL
+};
+
+const struct testsuite_object envelope_testsuite_object = { 
+	SIEVE_OBJECT("envelope", &testsuite_object_operand, TESTSUITE_OBJECT_ENVELOPE),
+	tsto_envelope_get_member_id, 
+	tsto_envelope_get_member_name,
+	tsto_envelope_set_member, 
+	NULL
+};
+
+enum testsuite_object_envelope_field {
+	TESTSUITE_OBJECT_ENVELOPE_FROM,
+	TESTSUITE_OBJECT_ENVELOPE_TO,
+	TESTSUITE_OBJECT_ENVELOPE_AUTH_USER
+};
+
+static bool tsto_message_set_member
+(const struct sieve_runtime_env *renv, int id, string_t *value) 
+{
+	if ( id != -1 ) return FALSE;
+	
+	testsuite_message_set_string(renv, value);
+	
+	return TRUE;
+}
+
+static int tsto_envelope_get_member_id(const char *identifier)
+{
+	if ( strcasecmp(identifier, "from") == 0 )
+		return TESTSUITE_OBJECT_ENVELOPE_FROM;
+	if ( strcasecmp(identifier, "to") == 0 )
+		return TESTSUITE_OBJECT_ENVELOPE_TO;
+	if ( strcasecmp(identifier, "auth") == 0 )
+		return TESTSUITE_OBJECT_ENVELOPE_AUTH_USER;	
+	
+	return -1;
+}
+
+static const char *tsto_envelope_get_member_name(int id) 
+{
+	switch ( id ) {
+	case TESTSUITE_OBJECT_ENVELOPE_FROM: 
+		return "from";
+	case TESTSUITE_OBJECT_ENVELOPE_TO: 
+		return "to";
+	case TESTSUITE_OBJECT_ENVELOPE_AUTH_USER: 
+		return "auth";
+	}
+	
+	return NULL;
+}
+
+static bool tsto_envelope_set_member
+(const struct sieve_runtime_env *renv, int id, string_t *value)
+{
+	switch ( id ) {
+	case TESTSUITE_OBJECT_ENVELOPE_FROM: 
+		testsuite_envelope_set_sender(renv, str_c(value));
+		return TRUE;
+	case TESTSUITE_OBJECT_ENVELOPE_TO:
+		testsuite_envelope_set_recipient(renv, str_c(value));
+		return TRUE;
+	case TESTSUITE_OBJECT_ENVELOPE_AUTH_USER: 
+		testsuite_envelope_set_auth_user(renv, str_c(value));
+		return TRUE;
+	}
+	
+	return FALSE;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-objects.h dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-objects.h
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-objects.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-objects.h	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,75 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __TESTSUITE_OBJECTS_H
+#define __TESTSUITE_OBJECTS_H
+
+#include "sieve-common.h"
+#include "sieve-objects.h"
+
+#include "testsuite-common.h"
+
+/* 
+ * Testsuite object operand 
+ */
+
+struct testsuite_object_operand_interface {
+	struct sieve_extension_objects testsuite_objects;
+};
+
+extern const struct sieve_operand_class testsuite_object_oprclass;
+
+/* 
+ * Testsuite object access 
+ */
+
+struct testsuite_object {
+	struct sieve_object object;
+	
+	int (*get_member_id)(const char *identifier);
+	const char *(*get_member_name)(int id);
+
+	bool (*set_member)(const struct sieve_runtime_env *renv, int id, string_t *value);
+	string_t *(*get_member)(const struct sieve_runtime_env *renv, int id);
+};
+
+/* 
+ * Testsuite object registration 
+ */
+
+const struct testsuite_object *testsuite_object_find
+	(struct sieve_validator *valdtr, const char *identifier);
+void testsuite_object_register
+	(struct sieve_validator *valdtr, const struct testsuite_object *tobj);		
+void testsuite_register_core_objects
+	(struct testsuite_validator_context *ctx);
+		
+/* 
+ * Testsuite object argument 
+ */		
+	
+bool testsuite_object_argument_activate
+	(struct sieve_validator *valdtr, struct sieve_ast_argument *arg,
+		struct sieve_command_context *cmd);		
+		
+/* 
+ * Testsuite object code 
+ */
+
+const struct testsuite_object *testsuite_object_read
+  (struct sieve_binary *sbin, sieve_size_t *address);
+const struct testsuite_object *testsuite_object_read_member
+  (struct sieve_binary *sbin, sieve_size_t *address, int *member_id);
+const char *testsuite_object_member_name
+	(const struct testsuite_object *object, int member_id);
+bool testsuite_object_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+
+/* 
+ * Testsuite core objects 
+ */
+
+extern const struct testsuite_object message_testsuite_object;
+extern const struct testsuite_object envelope_testsuite_object;
+
+#endif /* __TESTSUITE_OBJECTS_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-result.c dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-result.c
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-result.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-result.c	2009-07-21 02:18:49.000000000 +0200
@@ -0,0 +1,91 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "ostream.h"
+
+#include "sieve-common.h"
+#include "sieve-error.h"
+#include "sieve-actions.h"
+#include "sieve-interpreter.h"
+#include "sieve-result.h"
+
+#include "testsuite-common.h"
+#include "testsuite-log.h"
+#include "testsuite-message.h"
+
+#include "testsuite-result.h"
+
+static struct sieve_result *_testsuite_result;
+
+void testsuite_result_init(void)
+{
+	_testsuite_result = sieve_result_create
+		(&testsuite_msgdata, testsuite_scriptenv, testsuite_log_ehandler);
+}
+
+void testsuite_result_deinit(void)
+{
+	if ( _testsuite_result != NULL ) {
+		sieve_result_unref(&_testsuite_result);
+	}
+}
+
+void testsuite_result_reset
+(const struct sieve_runtime_env *renv)
+{
+	if ( _testsuite_result != NULL ) {
+		sieve_result_unref(&_testsuite_result);
+	}
+
+	_testsuite_result = sieve_result_create
+		(&testsuite_msgdata, testsuite_scriptenv, testsuite_log_ehandler);
+	sieve_interpreter_set_result(renv->interp, _testsuite_result);
+}
+
+struct sieve_result *testsuite_result_get(void)
+{
+	return _testsuite_result;
+}
+
+struct sieve_result_iterate_context *testsuite_result_iterate_init(void)
+{
+	if ( _testsuite_result == NULL )
+		return NULL;
+
+	return sieve_result_iterate_init(_testsuite_result);
+}
+
+bool testsuite_result_execute(const struct sieve_runtime_env *renv)
+{
+	int ret;
+
+	if ( _testsuite_result == NULL ) {
+		sieve_runtime_error(renv, sieve_error_script_location(renv->script,0),
+			"testsuite: no result evaluated yet");
+		return FALSE;
+	}
+
+	testsuite_log_clear_messages();
+
+	/* Execute the result */	
+	ret=sieve_result_execute(_testsuite_result, NULL);
+	
+	return ( ret > 0 );
+}
+
+void testsuite_result_print
+(const struct sieve_runtime_env *renv)
+{
+	struct ostream *out;
+	
+	out = o_stream_create_fd(1, 0, FALSE);	
+
+	o_stream_send_str(out, "\n--");
+	sieve_result_print(_testsuite_result, renv->scriptenv, out, NULL);
+	o_stream_send_str(out, "--\n\n");
+
+	o_stream_destroy(&out);	
+}
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-result.h dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-result.h
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-result.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-result.h	2009-02-11 21:38:58.000000000 +0100
@@ -0,0 +1,22 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __TESTSUITE_RESULT_H
+#define __TESTSUITE_RESULT_H
+
+void testsuite_result_init(void);
+void testsuite_result_deinit(void);
+
+void testsuite_result_reset    
+	(const struct sieve_runtime_env *renv);
+
+struct sieve_result *testsuite_result_get(void);
+
+struct sieve_result_iterate_context *testsuite_result_iterate_init(void);
+
+bool testsuite_result_execute(const struct sieve_runtime_env *renv);
+
+void testsuite_result_print
+	(const struct sieve_runtime_env *renv ATTR_UNUSED);
+
+#endif /* __TESTSUITE_RESULT_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-script.c dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-script.c
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-script.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-script.c	2009-08-21 01:23:03.000000000 +0200
@@ -0,0 +1,127 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "env-util.h"
+
+#include "sieve.h"
+#include "sieve-common.h"
+#include "sieve-script.h"
+#include "sieve-binary.h"
+#include "sieve-interpreter.h"
+#include "sieve-result.h"
+
+#include "testsuite-common.h"
+#include "testsuite-log.h"
+#include "testsuite-result.h"
+
+#include "testsuite-script.h"
+
+/*
+ * Tested script environment
+ */ 
+
+struct sieve_binary *_testsuite_compiled_script;
+
+void testsuite_script_init(void)
+{
+	_testsuite_compiled_script = NULL;
+}
+
+void testsuite_script_deinit(void)
+{
+	if ( _testsuite_compiled_script != NULL ) {
+		sieve_binary_unref(&_testsuite_compiled_script);
+	}
+}
+
+bool testsuite_script_compile(const char *script_path)
+{
+	struct sieve_binary *sbin;
+	const char *sieve_dir;
+
+	testsuite_log_clear_messages();
+
+	/* Initialize environment */
+	sieve_dir = strrchr(script_path, '/');
+	if ( sieve_dir == NULL )
+		sieve_dir= "./";
+	else
+		sieve_dir = t_strdup_until(script_path, sieve_dir+1);
+
+	/* Currently needed for include (FIXME) */
+	env_put(t_strconcat("SIEVE_DIR=", sieve_dir, "included", NULL));
+	env_put(t_strconcat("SIEVE_GLOBAL_DIR=", sieve_dir, "included-global", NULL));
+	
+
+	if ( (sbin = sieve_compile(script_path, NULL, testsuite_log_ehandler)) == NULL )
+		return FALSE;
+
+	if ( _testsuite_compiled_script != NULL ) {
+		sieve_binary_unref(&_testsuite_compiled_script);
+	}
+
+	_testsuite_compiled_script = sbin;
+
+	return TRUE;
+}
+
+bool testsuite_script_run(const struct sieve_runtime_env *renv)
+{
+	struct sieve_script_env scriptenv;
+	struct sieve_result *result;
+	struct sieve_interpreter *interp;
+	int ret;
+
+	if ( _testsuite_compiled_script == NULL ) {
+		sieve_runtime_error(renv, sieve_error_script_location(renv->script,0),
+			"testsuite: no script compiled yet");
+		return FALSE;
+	}
+
+	testsuite_log_clear_messages();
+
+	/* Compose script execution environment */
+	memset(&scriptenv, 0, sizeof(scriptenv));
+	scriptenv.default_mailbox = "INBOX";
+	scriptenv.namespaces = NULL;
+	scriptenv.username = "user";
+	scriptenv.hostname = "host.example.com";
+	scriptenv.postmaster_address = "postmaster@example.com";
+	scriptenv.smtp_open = NULL;
+	scriptenv.smtp_close = NULL;
+	scriptenv.duplicate_mark = NULL;
+	scriptenv.duplicate_check = NULL;
+	
+	result = testsuite_result_get();
+
+	/* Execute the script */
+	interp=sieve_interpreter_create
+		(_testsuite_compiled_script, testsuite_log_ehandler);
+	
+	if ( interp == NULL )
+		return SIEVE_EXEC_BIN_CORRUPT;
+		
+	ret = sieve_interpreter_run
+		(interp, renv->msgdata, &scriptenv, result);
+
+	sieve_interpreter_free(&interp);
+
+	return ( ret > 0 );
+}
+
+struct sieve_binary *testsuite_script_get_binary(void)
+{
+	return _testsuite_compiled_script;
+}
+
+void testsuite_script_set_binary(struct sieve_binary *sbin)
+{
+	if ( _testsuite_compiled_script != NULL ) {
+		sieve_binary_unref(&_testsuite_compiled_script);
+	}
+
+	_testsuite_compiled_script = sbin;
+	sieve_binary_ref(sbin);
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-script.h dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-script.h
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-script.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-script.h	2009-08-21 00:52:15.000000000 +0200
@@ -0,0 +1,18 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __TESTSUITE_SCRIPT_H
+#define __TESTSUITE_SCRIPT_H
+
+#include "sieve-common.h"
+
+void testsuite_script_init(void);
+void testsuite_script_deinit(void);
+
+bool testsuite_script_compile(const char *script_path);
+bool testsuite_script_run(const struct sieve_runtime_env *renv);
+
+struct sieve_binary *testsuite_script_get_binary(void);
+void testsuite_script_set_binary(struct sieve_binary *sbin);
+
+#endif /* __TESTSUITE_SCRIPT_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-smtp.c dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-smtp.c
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-smtp.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-smtp.c	2009-07-21 00:49:18.000000000 +0200
@@ -0,0 +1,129 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "array.h"
+#include "unlink-directory.h"
+
+#include "sieve-common.h" 
+#include "sieve-error.h"
+#include "sieve-interpreter.h"
+ 
+#include "testsuite-message.h"
+#include "testsuite-common.h"
+#include "testsuite-smtp.h"
+
+#include <sys/stat.h>
+#include <sys/types.h>
+
+struct testsuite_smtp_message {
+	const char *envelope_from;
+	const char *envelope_to;
+	const char *file;
+};
+
+static pool_t testsuite_smtp_pool;
+static const char *testsuite_smtp_tmp;
+static ARRAY_DEFINE(testsuite_smtp_messages, struct testsuite_smtp_message);
+
+/*
+ * Initialize
+ */
+
+void testsuite_smtp_init(void)
+{
+	pool_t pool;
+	
+	testsuite_smtp_pool = pool = pool_alloconly_create("testsuite_smtp", 8192);	
+	
+	testsuite_smtp_tmp = p_strconcat
+		(pool, testsuite_tmp_dir_get(), "/smtp", NULL);
+
+	if ( mkdir(testsuite_smtp_tmp, 0700) < 0 ) {
+		i_fatal("failed to create temporary directory '%s': %m.", 
+			testsuite_smtp_tmp);		
+	}
+	
+	p_array_init(&testsuite_smtp_messages, pool, 16);
+}
+
+void testsuite_smtp_deinit(void)
+{
+	if ( unlink_directory(testsuite_smtp_tmp, TRUE) < 0 )
+		i_warning("failed to remove temporary directory '%s': %m.",
+			testsuite_smtp_tmp);
+	
+	pool_unref(&testsuite_smtp_pool);		
+}
+
+void testsuite_smtp_reset(void)
+{
+	testsuite_smtp_deinit();
+	testsuite_smtp_init();
+}
+
+/*
+ * Simulated SMTP out
+ */
+ 
+struct testsuite_smtp {
+	const char *tmp_path;
+	FILE *mfile;
+};
+ 
+void *testsuite_smtp_open
+	(const char *destination, const char *return_path, FILE **file_r)
+{	
+	struct testsuite_smtp_message smtp_msg;
+	struct testsuite_smtp *smtp;
+	unsigned int smtp_count = array_count(&testsuite_smtp_messages);
+	
+	smtp_msg.file = p_strdup_printf(testsuite_smtp_pool, 
+		"%s/%d.eml", testsuite_smtp_tmp, smtp_count);
+	smtp_msg.envelope_from = 
+		( return_path != NULL ? p_strdup(testsuite_smtp_pool, return_path) : NULL );
+	smtp_msg.envelope_to = p_strdup(testsuite_smtp_pool, destination);
+	 
+	array_append(&testsuite_smtp_messages, &smtp_msg, 1);
+	
+	smtp = t_new(struct testsuite_smtp, 1);
+	smtp->tmp_path = smtp_msg.file;
+	smtp->mfile = fopen(smtp->tmp_path, "w");
+
+	if ( smtp->mfile == NULL )
+		i_fatal("failed to open tmp file for SMTP simulation.");
+
+	*file_r = smtp->mfile;
+	
+	return (void *) smtp;	
+}
+
+bool testsuite_smtp_close(void *handle)
+{
+	struct testsuite_smtp *smtp = (struct testsuite_smtp *) handle;
+
+	fclose(smtp->mfile);
+	
+	return TRUE;
+}
+
+/*
+ * Access
+ */
+
+bool testsuite_smtp_get
+(const struct sieve_runtime_env *renv, unsigned int index)
+{
+	const struct testsuite_smtp_message *smtp_msg;
+
+	if ( index >= array_count(&testsuite_smtp_messages) )
+		return FALSE;
+
+	smtp_msg = array_idx(&testsuite_smtp_messages, index);
+
+	testsuite_message_set_file(renv, smtp_msg->file);
+	testsuite_envelope_set_sender(renv, smtp_msg->envelope_from);
+	testsuite_envelope_set_recipient(renv, smtp_msg->envelope_to);
+
+	return TRUE;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-smtp.h dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-smtp.h
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-smtp.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-smtp.h	2009-02-14 09:54:17.000000000 +0100
@@ -0,0 +1,26 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#ifndef __TESTSUITE_SMTP_H
+#define __TESTSUITE_SMTP_H
+ 
+void testsuite_smtp_init(void);
+void testsuite_smtp_deinit(void);
+void testsuite_smtp_reset(void);
+
+/*
+ * Simulated SMTP out
+ */
+ 
+void *testsuite_smtp_open
+	(const char *destination, const char *return_path, FILE **file_r);
+bool testsuite_smtp_close(void *handle);
+
+/*
+ * Access
+ */
+
+bool testsuite_smtp_get
+	(const struct sieve_runtime_env *renv, unsigned int index);
+
+#endif /* __TESTSUITE_SMTP_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-substitutions.c dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-substitutions.c
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-substitutions.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-substitutions.c	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,277 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+
+#include "sieve.h"
+#include "sieve-code.h"
+#include "sieve-commands.h"
+#include "sieve-binary.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "testsuite-common.h"
+#include "testsuite-substitutions.h"
+
+/*
+ * Forward declarations
+ */
+ 
+void testsuite_opr_substitution_emit
+	(struct sieve_binary *sbin, const struct testsuite_substitution *tsub,
+		const char *param);
+			
+/*
+ * Testsuite substitutions
+ */
+ 
+/* FIXME: make this extendible */
+
+enum {
+	TESTSUITE_SUBSTITUTION_FILE,
+	TESTSUITE_SUBSTITUTION_MAILBOX,
+	TESTSUITE_SUBSTITUTION_SMTPOUT
+};
+
+static const struct testsuite_substitution testsuite_file_substitution;
+static const struct testsuite_substitution testsuite_mailbox_substitution;
+static const struct testsuite_substitution testsuite_smtpout_substitution;
+
+static const struct testsuite_substitution *substitutions[] = {
+	&testsuite_file_substitution,
+	&testsuite_mailbox_substitution,
+	&testsuite_smtpout_substitution
+};
+
+static const unsigned int substitutions_count = N_ELEMENTS(substitutions);
+ 
+static inline const struct testsuite_substitution *testsuite_substitution_get
+(unsigned int code)
+{
+	if ( code > substitutions_count )
+		return NULL;
+	
+	return substitutions[code];
+}
+
+const struct testsuite_substitution *testsuite_substitution_find
+(const char *identifier)
+{
+	unsigned int i; 
+	
+	for ( i = 0; i < substitutions_count; i++ ) {
+		if ( strcasecmp(substitutions[i]->object.identifier, identifier) == 0 )
+			return substitutions[i];
+	}
+	
+	return NULL;
+}
+
+/*
+ * Substitution argument
+ */
+ 
+static bool arg_testsuite_substitution_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+		struct sieve_command_context *context);
+
+struct _testsuite_substitution_context {
+	const struct testsuite_substitution *tsub;
+	const char *param;
+};
+
+const struct sieve_argument testsuite_substitution_argument = { 
+	"@testsuite-substitution", 
+	NULL, NULL, NULL, NULL,
+	arg_testsuite_substitution_generate 
+};
+
+struct sieve_ast_argument *testsuite_substitution_argument_create
+(struct sieve_validator *validator ATTR_UNUSED, struct sieve_ast *ast, 
+	unsigned int source_line, const char *substitution, const char *param)
+{
+	const struct testsuite_substitution *tsub;
+	struct _testsuite_substitution_context *tsctx;
+	struct sieve_ast_argument *arg;
+	pool_t pool;
+	
+	tsub = testsuite_substitution_find(substitution);
+	if ( tsub == NULL ) 
+		return NULL;
+	
+	arg = sieve_ast_argument_create(ast, source_line);
+	arg->type = SAAT_STRING;
+	arg->argument = &testsuite_substitution_argument;
+
+	pool = sieve_ast_pool(ast);
+	tsctx = p_new(pool, struct _testsuite_substitution_context, 1);
+	tsctx->tsub = tsub;
+	tsctx->param = p_strdup(pool, param);
+	arg->context = (void *) tsctx;
+	
+	return arg;
+}
+
+static bool arg_testsuite_substitution_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+	struct sieve_command_context *context ATTR_UNUSED)
+{
+	struct _testsuite_substitution_context *tsctx =  
+		(struct _testsuite_substitution_context *) arg->context;
+	
+	testsuite_opr_substitution_emit(cgenv->sbin, tsctx->tsub, tsctx->param);
+
+	return TRUE;
+}
+
+/*
+ * Substitution operand
+ */
+
+static bool opr_substitution_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address, 
+		const char *field_name);
+static bool opr_substitution_read_value
+	(const struct sieve_runtime_env *renv, sieve_size_t *address, string_t **str);
+	
+const struct sieve_opr_string_interface testsuite_substitution_interface = { 
+	opr_substitution_dump,
+	opr_substitution_read_value
+};
+		
+const struct sieve_operand testsuite_substitution_operand = { 
+	"test-substitution", 
+	&testsuite_extension, 
+	TESTSUITE_OPERAND_SUBSTITUTION,
+	&string_class,
+	&testsuite_substitution_interface
+};
+
+void testsuite_opr_substitution_emit
+(struct sieve_binary *sbin, const struct testsuite_substitution *tsub,
+	const char *param) 
+{
+	/* Default variable storage */
+	(void) sieve_operand_emit_code(sbin, &testsuite_substitution_operand);
+	(void) sieve_binary_emit_unsigned(sbin, tsub->object.code);
+	(void) sieve_binary_emit_cstring(sbin, param);
+}
+
+static bool opr_substitution_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+	const char *field_name) 
+{
+	unsigned int code = 0;
+	const struct testsuite_substitution *tsub;
+	string_t *param; 
+
+	if ( !sieve_binary_read_unsigned(denv->sbin, address, &code) )
+		return FALSE;
+		
+	tsub = testsuite_substitution_get(code);
+	if ( tsub == NULL )
+		return FALSE;	
+			
+	if ( !sieve_binary_read_string(denv->sbin, address, &param) )
+		return FALSE;
+	
+	if ( field_name != NULL ) 
+		sieve_code_dumpf(denv, "%s: TEST_SUBS %%{%s:%s}", 
+			field_name, tsub->object.identifier, str_c(param));
+	else
+		sieve_code_dumpf(denv, "TEST_SUBS %%{%s:%s}", 
+			tsub->object.identifier, str_c(param));
+	return TRUE;
+}
+
+static bool opr_substitution_read_value
+(const struct sieve_runtime_env *renv, sieve_size_t *address, string_t **str)
+{ 
+	const struct testsuite_substitution *tsub;
+	unsigned int code = 0;
+	string_t *param;
+	
+	if ( !sieve_binary_read_unsigned(renv->sbin, address, &code) )
+		return FALSE;
+		
+	tsub = testsuite_substitution_get(code);
+	if ( tsub == NULL )
+		return FALSE;	
+
+	/* Parameter str can be NULL if we are requested to only skip and not 
+	 * actually read the argument.
+	 */	
+	if ( str == NULL ) 
+		return sieve_binary_read_string(renv->sbin, address, NULL);
+	
+	if ( !sieve_binary_read_string(renv->sbin, address, &param) )
+		return FALSE;
+				
+	return tsub->get_value(str_c(param), str);
+}
+
+/*
+ * Testsuite substitution definitions
+ */
+ 
+static bool testsuite_file_substitution_get_value
+	(const char *param, string_t **result); 
+static bool testsuite_mailbox_substitution_get_value
+	(const char *param, string_t **result); 
+static bool testsuite_smtpout_substitution_get_value
+	(const char *param, string_t **result); 
+ 
+static const struct testsuite_substitution testsuite_file_substitution = {
+	SIEVE_OBJECT(
+		"file", 
+		&testsuite_substitution_operand, 
+		TESTSUITE_SUBSTITUTION_FILE
+	),
+	testsuite_file_substitution_get_value
+};
+
+static const struct testsuite_substitution testsuite_mailbox_substitution = {
+	SIEVE_OBJECT(
+		"mailbox", 
+		&testsuite_substitution_operand, 
+		TESTSUITE_SUBSTITUTION_MAILBOX
+	),
+	testsuite_mailbox_substitution_get_value
+};
+
+static const struct testsuite_substitution testsuite_smtpout_substitution = {
+	SIEVE_OBJECT(
+		"smtpout",
+		&testsuite_substitution_operand,
+		TESTSUITE_SUBSTITUTION_SMTPOUT
+	),
+	testsuite_smtpout_substitution_get_value
+};
+ 
+static bool testsuite_file_substitution_get_value
+	(const char *param, string_t **result)
+{
+	*result = t_str_new(256);
+
+	str_printfa(*result, "[FILE: %s]", param);
+	return TRUE;
+}
+
+static bool testsuite_mailbox_substitution_get_value
+	(const char *param, string_t **result)
+{
+	*result = t_str_new(256);
+
+	str_printfa(*result, "[MAILBOX: %s]", param);
+	return TRUE;
+}
+
+static bool testsuite_smtpout_substitution_get_value
+	(const char *param, string_t **result) 
+{
+	*result = t_str_new(256);
+
+	str_printfa(*result, "[SMTPOUT: %s]", param);
+	return TRUE;
+} 
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-substitutions.h dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-substitutions.h
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/testsuite-substitutions.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/testsuite-substitutions.h	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,23 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __TESTSUITE_SUBSTITUTIONS_H
+#define __TESTSUITE_SUBSTITUTIONS_H
+
+#include "sieve-common.h"
+#include "sieve-objects.h"
+
+struct testsuite_substitution {
+	struct sieve_object object;
+	
+	bool (*get_value)(const char *param, string_t **result);
+};
+
+const struct testsuite_substitution *testsuite_substitution_find
+	(const char *identifier);
+
+struct sieve_ast_argument *testsuite_substitution_argument_create
+	(struct sieve_validator *validator, struct sieve_ast *ast, 
+		unsigned int source_line, const char *substitution, const char *param);
+
+#endif /* __TESTSUITE_SUBSTITUTIONS_H */
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/tst-test-error.c dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/tst-test-error.c
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/tst-test-error.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/tst-test-error.c	2009-07-30 00:46:26.000000000 +0200
@@ -0,0 +1,309 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-error.h"
+#include "sieve-script.h"
+#include "sieve-commands.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+#include "testsuite-common.h"
+#include "testsuite-log.h"
+
+/*
+ * Test_error command
+ *
+ * Syntax:   
+ *   test [MATCH-TYPE] [COMPARATOR] [:index number] <key-list: string-list>
+ */
+
+static bool tst_test_error_registered
+    (struct sieve_validator *validator, struct sieve_command_registration *cmd_reg);
+static bool tst_test_error_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd);
+static bool tst_test_error_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command tst_test_error = { 
+	"test_error", 
+	SCT_TEST, 
+	1, 0, FALSE, FALSE,
+	tst_test_error_registered, 
+	NULL,
+	tst_test_error_validate, 
+	tst_test_error_generate, 
+	NULL 
+};
+
+/* 
+ * Operation 
+ */
+
+static bool tst_test_error_operation_dump
+	(const struct sieve_operation *op,
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_test_error_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation test_error_operation = { 
+	"TEST_ERROR",
+	&testsuite_extension, 
+	TESTSUITE_OPERATION_TEST_ERROR,
+	tst_test_error_operation_dump, 
+	tst_test_error_operation_execute 
+};
+
+/*
+ * Tagged arguments
+ */ 
+
+/* NOTE: This will be merged with the date-index extension when it is 
+ * implemented.
+ */
+
+static bool tst_test_error_validate_index_tag
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg,
+		struct sieve_command_context *cmd);
+
+static const struct sieve_argument test_error_index_tag = {
+	"index",
+	NULL, NULL,
+	tst_test_error_validate_index_tag,
+	NULL, NULL
+};
+
+enum tst_test_error_optional {
+	OPT_INDEX = SIEVE_MATCH_OPT_LAST,
+};
+
+
+/*
+ * Argument implementation
+ */
+
+static bool tst_test_error_validate_index_tag
+(struct sieve_validator *validator, struct sieve_ast_argument **arg,
+	struct sieve_command_context *cmd)
+{
+	struct sieve_ast_argument *tag = *arg;
+
+	/* Detach the tag itself */
+	*arg = sieve_ast_arguments_detach(*arg,1);
+
+	/* Check syntax:
+	 *   :index number
+	 */
+	if ( !sieve_validate_tag_parameter
+		(validator, cmd, tag, *arg, SAAT_NUMBER) ) {
+		return FALSE;
+	}
+
+	/* Skip parameter */
+	*arg = sieve_ast_argument_next(*arg);
+	return TRUE;
+}
+
+
+/*
+ * Command registration
+ */
+
+static bool tst_test_error_registered
+(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg)
+{
+	/* The order of these is not significant */
+	sieve_comparators_link_tag(validator, cmd_reg, SIEVE_MATCH_OPT_COMPARATOR);
+	sieve_match_types_link_tags(validator, cmd_reg, SIEVE_MATCH_OPT_MATCH_TYPE);
+
+	sieve_validator_register_tag
+		(validator, cmd_reg, &test_error_index_tag, OPT_INDEX);
+
+	return TRUE;
+}
+
+/* 
+ * Validation 
+ */
+
+static bool tst_test_error_validate
+(struct sieve_validator *valdtr ATTR_UNUSED, struct sieve_command_context *tst) 
+{
+	struct sieve_ast_argument *arg = tst->first_positional;
+	
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "key list", 2, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(valdtr, tst, arg, FALSE) )
+		return FALSE;
+
+	/* Validate the key argument to a specified match type */
+	return sieve_match_type_validate
+		(valdtr, tst, arg, &is_match_type, &i_octet_comparator);
+}
+
+/* 
+ * Code generation 
+ */
+
+static inline struct testsuite_generator_context *
+_get_generator_context(struct sieve_generator *gentr)
+{
+	return (struct testsuite_generator_context *) 
+		sieve_generator_extension_get_context(gentr, &testsuite_extension);
+}
+
+static bool tst_test_error_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *tst)
+{
+	sieve_operation_emit_code(cgenv->sbin, &test_error_operation);
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, tst, NULL);
+}
+
+/* 
+ * Code dump
+ */
+ 
+static bool tst_test_error_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	int opt_code = 0;
+
+	sieve_code_dumpf(denv, "TEST_ERROR:");
+	sieve_code_descend(denv);
+
+	/* Handle any optional arguments */
+	do {
+		if ( !sieve_match_dump_optional_operands(denv, address, &opt_code) )
+			return FALSE;
+
+		switch ( opt_code ) {
+		case SIEVE_MATCH_OPT_END:
+			break;
+		case OPT_INDEX:
+			if ( !sieve_opr_number_dump(denv, address, "index") )
+				return FALSE;
+			break;
+		default:
+			return FALSE;
+		}
+	} while ( opt_code != SIEVE_MATCH_OPT_END );
+
+	return sieve_opr_stringlist_dump(denv, address, "key list");
+}
+
+/*
+ * Intepretation
+ */
+
+static int tst_test_error_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{	
+	int opt_code = 0;
+	bool result = TRUE;
+	const struct sieve_comparator *cmp = &i_octet_comparator;
+	const struct sieve_match_type *mtch = &is_match_type;
+	struct sieve_match_context *mctx;
+	struct sieve_coded_stringlist *key_list;
+	bool matched;
+	const char *error;
+	int cur_index = 0, index = 0;
+	int ret;
+
+	/*
+	 * Read operands
+	 */
+
+	/* Handle optional operands */
+	do {
+		sieve_number_t number; 
+
+		if ( (ret=sieve_match_read_optional_operands
+			(renv, address, &opt_code, &cmp, &mtch)) <= 0 )
+ 			return ret;
+
+		switch ( opt_code ) {
+		case SIEVE_MATCH_OPT_END:
+			break;
+		case OPT_INDEX:
+			if ( !sieve_opr_number_read(renv, address, &number) ) {
+				sieve_runtime_trace_error(renv, "invalid index operand");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+			index = (int) number;
+			break;
+		default:
+			sieve_runtime_trace_error(renv, "invalid optional operand");
+			return SIEVE_EXEC_BIN_CORRUPT;
+		}	
+	} while ( opt_code != SIEVE_MATCH_OPT_END);
+
+	/* Read key-list */
+	if ( (key_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid key-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Perform operation
+	 */
+	
+	sieve_runtime_trace(renv, "TEST_ERROR test (index: %d)", index);
+
+	testsuite_log_get_error_init();
+
+	/* Initialize match */
+	mctx = sieve_match_begin(renv->interp, mtch, cmp, NULL, key_list);
+
+	/* Iterate through all errors to match */
+	error = NULL;
+	matched = FALSE;
+	cur_index = 1;
+	ret = 0;
+	while ( result && !matched &&
+		(error=testsuite_log_get_error_next(FALSE)) != NULL ) {
+		
+		if ( index == 0 || index == cur_index ) {
+			if ( (ret=sieve_match_value(mctx, error, strlen(error))) < 0 ) {
+				result = FALSE;
+				break;
+			}
+		}
+
+		matched = ret > 0;
+		cur_index++;
+	}
+
+	/* Finish match */
+	if ( (ret=sieve_match_end(&mctx)) < 0 )
+		result = FALSE;
+	else
+		matched = ( ret > 0 || matched );
+
+	/* Set test result for subsequent conditional jump */
+	if ( result ) {
+		sieve_interpreter_set_test_result(renv->interp, matched);
+		return SIEVE_EXEC_OK;
+	}
+
+	sieve_runtime_trace_error(renv, "invalid string-list item");
+	return SIEVE_EXEC_BIN_CORRUPT;
+}
+
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/tst-test-result.c dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/tst-test-result.c
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/tst-test-result.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/tst-test-result.c	2009-07-30 00:46:15.000000000 +0200
@@ -0,0 +1,325 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* FIXME: this file is very similar to tst-test-error.c. Maybe it is best to 
+ * implement errors and actions as testsuite-objects and implement a common
+ * interface to test these.
+ */
+
+#include "sieve-common.h"
+#include "sieve-error.h"
+#include "sieve-script.h"
+#include "sieve-commands.h"
+#include "sieve-actions.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+#include "sieve-result.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+#include "testsuite-common.h"
+#include "testsuite-result.h"
+
+/*
+ * test_result command
+ *
+ * Syntax:   
+ *   test_result [MATCH-TYPE] [COMPARATOR] [:index number] 
+ *     <key-list: string-list>
+ */
+
+static bool tst_test_result_registered
+    (struct sieve_validator *validator, struct sieve_command_registration *cmd_reg);
+static bool tst_test_result_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd);
+static bool tst_test_result_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command tst_test_result = { 
+	"test_result", 
+	SCT_TEST, 
+	1, 0, FALSE, FALSE,
+	tst_test_result_registered, 
+	NULL,
+	tst_test_result_validate, 
+	tst_test_result_generate, 
+	NULL 
+};
+
+/* 
+ * Operation 
+ */
+
+static bool tst_test_result_operation_dump
+	(const struct sieve_operation *op,
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_test_result_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation test_result_operation = { 
+	"test_result",
+	&testsuite_extension, 
+	TESTSUITE_OPERATION_TEST_RESULT,
+	tst_test_result_operation_dump, 
+	tst_test_result_operation_execute 
+};
+
+/*
+ * Tagged arguments
+ */ 
+
+/* NOTE: This will be merged with the date-index extension when it is 
+ * implemented.
+ */
+
+/* FIXME: at least merge this with the test_error version of this tag */
+
+static bool tst_test_result_validate_index_tag
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg,
+		struct sieve_command_context *cmd);
+
+static const struct sieve_argument test_result_index_tag = {
+    "index",
+    NULL, NULL,
+    tst_test_result_validate_index_tag,
+    NULL, NULL
+};
+
+enum tst_test_result_optional {
+	OPT_INDEX = SIEVE_MATCH_OPT_LAST,
+};
+
+/*
+ * Argument implementation
+ */
+
+static bool tst_test_result_validate_index_tag
+(struct sieve_validator *validator, struct sieve_ast_argument **arg,
+	struct sieve_command_context *cmd)
+{
+	struct sieve_ast_argument *tag = *arg;
+
+	/* Detach the tag itself */
+	*arg = sieve_ast_arguments_detach(*arg,1);
+
+	/* Check syntax:
+	 *   :index number
+	 */
+	if ( !sieve_validate_tag_parameter
+		(validator, cmd, tag, *arg, SAAT_NUMBER) ) {
+		return FALSE;
+	}
+
+	/* Skip parameter */
+	*arg = sieve_ast_argument_next(*arg);
+	return TRUE;
+}
+
+
+/*
+ * Command registration
+ */
+
+static bool tst_test_result_registered
+(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg)
+{
+	/* The order of these is not significant */
+	sieve_comparators_link_tag(validator, cmd_reg, SIEVE_MATCH_OPT_COMPARATOR);
+	sieve_match_types_link_tags(validator, cmd_reg, SIEVE_MATCH_OPT_MATCH_TYPE);
+
+	sieve_validator_register_tag
+		(validator, cmd_reg, &test_result_index_tag, OPT_INDEX);
+
+	return TRUE;
+}
+
+/* 
+ * Validation 
+ */
+
+static bool tst_test_result_validate
+(struct sieve_validator *valdtr ATTR_UNUSED, struct sieve_command_context *tst) 
+{
+	struct sieve_ast_argument *arg = tst->first_positional;
+	
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "key list", 2, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(valdtr, tst, arg, FALSE) )
+		return FALSE;
+
+	/* Validate the key argument to a specified match type */
+	return sieve_match_type_validate
+		(valdtr, tst, arg, &is_match_type, &i_octet_comparator);
+}
+
+/* 
+ * Code generation 
+ */
+
+static inline struct testsuite_generator_context *
+_get_generator_context(struct sieve_generator *gentr)
+{
+	return (struct testsuite_generator_context *) 
+		sieve_generator_extension_get_context(gentr, &testsuite_extension);
+}
+
+static bool tst_test_result_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *tst)
+{
+	sieve_operation_emit_code(cgenv->sbin, &test_result_operation);
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, tst, NULL);
+}
+
+/* 
+ * Code dump
+ */
+ 
+static bool tst_test_result_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	int opt_code = 0;
+
+	sieve_code_dumpf(denv, "TEST_RESULT:");
+	sieve_code_descend(denv);
+
+	/* Handle any optional arguments */
+	do {
+		if ( !sieve_match_dump_optional_operands(denv, address, &opt_code) )
+			return FALSE;
+
+		switch ( opt_code ) {
+		case SIEVE_MATCH_OPT_END:
+			break;
+		case OPT_INDEX:
+			if ( !sieve_opr_number_dump(denv, address, "index") )
+				return FALSE;
+			break;
+		default:
+			return FALSE;
+		}
+	} while ( opt_code != SIEVE_MATCH_OPT_END );
+
+	return sieve_opr_stringlist_dump(denv, address, "key list");
+}
+
+/*
+ * Intepretation
+ */
+
+static int tst_test_result_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{	
+	int opt_code = 0;
+	bool result = TRUE;
+	const struct sieve_comparator *cmp = &i_octet_comparator;
+	const struct sieve_match_type *mtch = &is_match_type;
+	struct sieve_match_context *mctx;
+	struct sieve_coded_stringlist *key_list;
+	bool matched;
+	struct sieve_result_iterate_context *rictx;
+	const struct sieve_action *action;
+	bool keep;
+	int cur_index = 0, index = 0;
+	int ret;
+
+	/*
+	 * Read operands
+	 */
+
+	/* Handle optional operands */
+	do {
+		sieve_number_t number; 
+
+		if ( (ret=sieve_match_read_optional_operands
+			(renv, address, &opt_code, &cmp, &mtch)) <= 0 )
+ 			return ret;
+
+		switch ( opt_code ) {
+		case SIEVE_MATCH_OPT_END:
+			break;
+		case OPT_INDEX:
+			if ( !sieve_opr_number_read(renv, address, &number) ) {
+				sieve_runtime_trace_error(renv, "invalid index operand");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+			index = (int) number;
+			break;
+		default:
+			sieve_runtime_trace_error(renv, "invalid optional operand");
+			return SIEVE_EXEC_BIN_CORRUPT;
+		}	
+	} while ( opt_code != SIEVE_MATCH_OPT_END);
+
+	/* Read key-list */
+	if ( (key_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid key-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Perform operation
+	 */
+	
+	sieve_runtime_trace(renv, "TEST_RESULT test (index: %d)", index);
+
+	rictx = testsuite_result_iterate_init();
+
+  /* Initialize match */
+  mctx = sieve_match_begin(renv->interp, mtch, cmp, NULL, key_list);
+
+  /* Iterate through all errors to match */
+	matched = FALSE;
+	cur_index = 1;
+	ret = 0;
+	while ( result && !matched &&
+		(action=sieve_result_iterate_next(rictx, &keep, NULL)) != NULL ) {
+		const char *act_name;
+		
+		if ( keep ) 
+			act_name = "keep";
+		else
+			act_name = ( action == NULL || action->name == NULL ) ? "" : action->name;
+
+		if ( index == 0 || index == cur_index ) {
+			if ( (ret=sieve_match_value(mctx, act_name, strlen(act_name))) < 0 ) {
+				result = FALSE;
+				break;
+			}
+		}
+
+		matched = ret > 0;
+		cur_index++;
+	}
+
+	/* Finish match */
+	if ( (ret=sieve_match_end(&mctx)) < 0 )
+		result = FALSE;
+	else
+		matched = ( ret > 0 || matched );
+
+	/* Set test result for subsequent conditional jump */
+	if ( result ) {
+		sieve_interpreter_set_test_result(renv->interp, matched);
+		return SIEVE_EXEC_OK;
+	}
+
+	sieve_runtime_trace_error(renv, "invalid string-list item");
+	return SIEVE_EXEC_BIN_CORRUPT;
+}
+
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/tst-test-result-execute.c dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/tst-test-result-execute.c
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/tst-test-result-execute.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/tst-test-result-execute.c	2009-02-11 21:38:58.000000000 +0100
@@ -0,0 +1,93 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-script.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+#include "sieve-dump.h"
+#include "sieve.h"
+
+#include "testsuite-common.h"
+#include "testsuite-result.h"
+
+/*
+ * Test_result_execute command
+ *
+ * Syntax:   
+ *   test_result_execute
+ */
+
+static bool tst_test_result_execute_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command tst_test_result_execute = { 
+	"test_result_execute", 
+	SCT_TEST, 
+	0, 0, FALSE, FALSE,
+	NULL, NULL, NULL,
+	tst_test_result_execute_generate, 
+	NULL 
+};
+
+/* 
+ * Operation 
+ */
+
+static int tst_test_result_execute_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation test_result_execute_operation = { 
+	"TEST_RESULT_EXECUTE",
+	&testsuite_extension, 
+	TESTSUITE_OPERATION_TEST_RESULT_EXECUTE,
+	NULL, 
+	tst_test_result_execute_operation_execute 
+};
+
+/* 
+ * Code generation 
+ */
+
+static bool tst_test_result_execute_generate
+(const struct sieve_codegen_env *cgenv, 
+	struct sieve_command_context *tst ATTR_UNUSED)
+{
+	sieve_operation_emit_code(cgenv->sbin, &test_result_execute_operation);
+
+	return TRUE;
+}
+
+/*
+ * Intepretation
+ */
+
+static int tst_test_result_execute_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, 
+	sieve_size_t *address ATTR_UNUSED)
+{
+	bool result = TRUE;
+
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "TEST_RESULT_EXECUTE test");
+
+	result = testsuite_result_execute(renv);
+
+	/* Set result */
+	sieve_interpreter_set_test_result(renv->interp, result);
+
+	return SIEVE_EXEC_OK;
+}
+
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/tst-test-script-compile.c dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/tst-test-script-compile.c
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/tst-test-script-compile.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/tst-test-script-compile.c	2009-01-27 00:27:22.000000000 +0100
@@ -0,0 +1,158 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-script.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+#include "sieve-dump.h"
+#include "sieve.h"
+
+#include "testsuite-common.h"
+#include "testsuite-script.h"
+
+/*
+ * Test_script_compile command
+ *
+ * Syntax:   
+ *   test_script_compile <scriptpath: string>
+ */
+
+static bool tst_test_script_compile_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd);
+static bool tst_test_script_compile_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command tst_test_script_compile = { 
+	"test_script_compile", 
+	SCT_TEST, 
+	1, 0, FALSE, FALSE,
+	NULL, NULL,
+	tst_test_script_compile_validate, 
+	tst_test_script_compile_generate, 
+	NULL 
+};
+
+/* 
+ * Operation 
+ */
+
+static bool tst_test_script_compile_operation_dump
+	(const struct sieve_operation *op,
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_test_script_compile_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation test_script_compile_operation = { 
+	"TEST_SCRIPT_COMPILE",
+	&testsuite_extension, 
+	TESTSUITE_OPERATION_TEST_SCRIPT_COMPILE,
+	tst_test_script_compile_operation_dump, 
+	tst_test_script_compile_operation_execute 
+};
+
+/* 
+ * Validation 
+ */
+
+static bool tst_test_script_compile_validate
+(struct sieve_validator *valdtr ATTR_UNUSED, struct sieve_command_context *tst) 
+{
+	struct sieve_ast_argument *arg = tst->first_positional;
+	
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "script", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+	
+	return sieve_validator_argument_activate(valdtr, tst, arg, FALSE);
+}
+
+/* 
+ * Code generation 
+ */
+
+static inline struct testsuite_generator_context *
+	_get_generator_context(struct sieve_generator *gentr)
+{
+	return (struct testsuite_generator_context *) 
+		sieve_generator_extension_get_context(gentr, &testsuite_extension);
+}
+
+static bool tst_test_script_compile_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *tst)
+{
+	sieve_operation_emit_code(cgenv->sbin, &test_script_compile_operation);
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, tst, NULL);
+}
+
+/* 
+ * Code dump
+ */
+ 
+static bool tst_test_script_compile_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	sieve_code_dumpf(denv, "TEST_SCRIPT_COMPILE:");
+	sieve_code_descend(denv);
+
+	if ( !sieve_opr_string_dump(denv, address, "script") ) 
+		return FALSE;
+
+	return TRUE;
+}
+
+/*
+ * Intepretation
+ */
+
+static int tst_test_script_compile_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	string_t *script_name;
+	const char *script_path;
+	bool result = TRUE;
+
+	/*
+	 * Read operands
+	 */
+
+	if ( !sieve_opr_string_read(renv, address, &script_name) ) {
+		sieve_runtime_trace_error(renv, "invalid script name operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "TEST COMPILE: %s", str_c(script_name));
+
+	script_path = sieve_script_dirpath(renv->script);
+	if ( script_path == NULL ) 
+		return SIEVE_EXEC_FAILURE;
+
+	script_path = t_strconcat(script_path, "/", str_c(script_name), NULL);
+
+	/* Attempt script compile */
+
+	result = testsuite_script_compile(script_path);
+
+	/* Set result */
+	sieve_interpreter_set_test_result(renv->interp, result);
+
+	return SIEVE_EXEC_OK;
+}
+
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/src/testsuite/tst-test-script-run.c dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/tst-test-script-run.c
--- dovecot-1.2.4/dovecot-libsieve/src/testsuite/tst-test-script-run.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/src/testsuite/tst-test-script-run.c	2009-02-11 21:38:58.000000000 +0100
@@ -0,0 +1,197 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-script.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+#include "sieve-dump.h"
+#include "sieve.h"
+
+#include "testsuite-common.h"
+#include "testsuite-script.h"
+#include "testsuite-result.h"
+
+/*
+ * Test_script_run command
+ *
+ * Syntax:   
+ *   test_script_run
+ */
+
+static bool tst_test_script_run_registered
+(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg);
+static bool tst_test_script_run_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command tst_test_script_run = { 
+	"test_script_run", 
+	SCT_TEST, 
+	0, 0, FALSE, FALSE,
+	tst_test_script_run_registered, 
+	NULL, NULL,
+	tst_test_script_run_generate, 
+	NULL 
+};
+
+/* 
+ * Operation 
+ */
+
+static bool tst_test_script_run_operation_dump
+	(const struct sieve_operation *op,
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_test_script_run_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation test_script_run_operation = { 
+	"test_script_run",
+	&testsuite_extension, 
+	TESTSUITE_OPERATION_TEST_SCRIPT_RUN,
+	tst_test_script_run_operation_dump, 
+	tst_test_script_run_operation_execute 
+};
+
+/*
+ * Tagged arguments
+ */
+
+/* Codes for optional arguments */
+
+enum cmd_vacation_optional {
+	OPT_END,
+	OPT_APPEND_RESULT
+};
+
+/* Tags */
+
+static const struct sieve_argument append_result_tag = { 
+	"append_result",	
+	NULL, NULL, NULL, NULL, NULL
+};
+
+static bool tst_test_script_run_registered
+(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg) 
+{
+	sieve_validator_register_tag
+		(validator, cmd_reg, &append_result_tag, OPT_APPEND_RESULT); 	
+
+	return TRUE;
+}
+
+
+/* 
+ * Code generation 
+ */
+
+static bool tst_test_script_run_generate
+(const struct sieve_codegen_env *cgenv, 
+	struct sieve_command_context *tst)
+{
+	sieve_operation_emit_code(cgenv->sbin, &test_script_run_operation);
+
+	return sieve_generate_arguments(cgenv, tst, NULL);
+}
+
+/*
+ * Code dump
+ */
+
+static bool tst_test_script_run_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{	
+	int opt_code = 1;
+	
+	sieve_code_dumpf(denv, "TEST_SCRIPT_RUN");
+	sieve_code_descend(denv);	
+
+	/* Dump optional operands */
+	if ( sieve_operand_optional_present(denv->sbin, address) ) {
+		while ( opt_code != 0 ) {
+			sieve_code_mark(denv);
+			
+			if ( !sieve_operand_optional_read(denv->sbin, address, &opt_code) ) 
+				return FALSE;
+
+			switch ( opt_code ) {
+			case 0:
+				break;
+			case OPT_APPEND_RESULT:
+				sieve_code_dumpf(denv, "append_result");	
+				break;
+			
+			default:
+				return FALSE;
+			}
+		}
+	}
+	
+	return TRUE;
+}
+
+
+/*
+ * Intepretation
+ */
+
+static int tst_test_script_run_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, 
+	sieve_size_t *address ATTR_UNUSED)
+{
+	bool append_result = FALSE;
+	int opt_code = 1;
+	bool result = TRUE;
+
+	/*
+	 * Read operands
+	 */
+
+	/* Optional operands */	
+	if ( sieve_operand_optional_present(renv->sbin, address) ) {
+		while ( opt_code != 0 ) {
+			if ( !sieve_operand_optional_read(renv->sbin, address, &opt_code) ) {
+				sieve_runtime_trace_error(renv, "invalid optional operand");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+
+			switch ( opt_code ) {
+			case 0:
+				break;
+			case OPT_APPEND_RESULT:
+				append_result = TRUE;
+				break;
+			default:
+				sieve_runtime_trace_error(renv, 
+					"unknown optional operand");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+		}
+	}
+
+	/*
+	 * Perform operation
+	 */
+
+	/* Reset result object */
+	if ( !append_result ) 
+		testsuite_result_reset(renv);
+
+	/* Run script */
+	result = testsuite_script_run(renv);
+
+	/* Indicate test status */
+	sieve_interpreter_set_test_result(renv->interp, result);
+
+	return SIEVE_EXEC_OK;
+}
+
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/stamp.h.in dovecot-1.2.4.debian/dovecot-libsieve/stamp.h.in
--- dovecot-1.2.4/dovecot-libsieve/stamp.h.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/stamp.h.in	2009-09-02 07:26:02.000000000 +0200
@@ -0,0 +1,2 @@
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/address.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/address.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/address.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/address.svtest	2009-04-10 14:10:07.000000000 +0200
@@ -0,0 +1,111 @@
+require "vnd.dovecot.testsuite";
+
+/*
+ * If an address is not syntactically valid, then it will not be matched
+ * by tests specifying ":localpart" or ":domain".
+ */
+
+test_set "message" text:
+From: stephan@
+To: @rename-it.nl
+Cc: nonsense
+Resent-To:
+Subject: Invalid addresses
+
+Test.
+.
+;
+
+test "Invalid single addresses" {
+	if address :localpart "from" "stephan" {
+		test_fail ":localpart matched invalid address";
+	}	
+
+	if address :domain "to" "rename-it.nl" {
+		test_fail ":domain matched invalid address";
+	}	
+
+	if not address :is :all "resent-to" "" {
+		test_fail ":all failed to match empty address";
+	}	
+
+	if not address :is :all "cc" "nonsense" {
+		test_fail ":all failed to match invalid address";
+	}
+}
+
+/*
+ * Errors in address lists
+ */ 
+
+test_set "message" text:
+From: stephan@
+To: nico@vestingbar.nl, @rename-it.nl
+Cc: stephan@rename-it.nl, nonsense
+Subject: Invalid addresses
+
+Test.
+.
+;
+
+test "Invalid address list" {
+	if address :is :localpart "to" "" {
+		test_fail ":localpart matched invalid address";
+	}	
+
+	if address :is :domain "to" "rename-it.nl" {
+		test_fail ":domain matched invalid address";
+	}	
+}
+
+/*
+ * Undisclosed recipients
+ */
+
+test_set "message" text:
+From: stephan@
+To: undisclosed-recipients:;
+Subject: Invalid addresses
+
+Test.
+.
+;
+
+test "Undisclosed recipients" {
+    if address :is :domain "to" "undisclosed-recipients:;" {
+        test_fail ":domain matched group name";
+    }
+
+    if address :is :localpart "to" "undisclosed-recipients:;" {
+        test_fail ":localpart matched group name";
+    }
+}
+
+/*
+ * Strange
+ */
+
+test_set "message" text:
+From: SPAM@MYDOMAIN
+To: stephan@renane-it.nl
+Subject: Spam
+
+Spam!
+.
+;
+
+test "Questionable address" {
+	if address :domain :is "from" "MYDOMAIN" {
+		if address :localpart :is "from" "SPAM" {
+			
+		} elsif header :contains "subject" "Cron" {
+			test_fail "message erroneously recognized as cron";
+		} else {
+			test_fail "message erroneously recognized as normal";
+		}
+	} else {
+		test_fail "message domain not recognized";
+	}
+}
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/comparators/core.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/comparators/core.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/comparators/core.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/comparators/core.svtest	2008-07-30 15:17:37.000000000 +0200
@@ -0,0 +1,65 @@
+require "vnd.dovecot.testsuite";
+
+test_set "message" text:
+From: stephan@rename-it.nl
+Cc: frop@example.com
+To: test@dovecot.org
+X-A: This is a TEST header
+Subject: Test Message
+
+Test!
+.
+;
+
+# Comparator Tests
+
+test "CMP-octet-CONTAINS" {
+	if not header :contains :comparator "i;octet" "X-A" "TEST" {
+		test_fail "should have matched";
+	}
+}
+
+test "CMP-octet-NOTCONTAINS" {
+	if header :contains :comparator "i;octet" "X-A" "test" {
+		test_fail "should not have matched";
+	}
+}
+
+test "CMP-octet-MATCH" {
+	if not header :matches :comparator "i;octet" "X-A" "This*TEST*r" {
+		test_fail "should have matched";
+	}
+}
+
+test "CMP-octet-NOTMATCH" {
+	if header :matches :comparator "i;octet" "X-A" "ThIs*tEsT*R" {
+		test_fail "should not have matched";
+	}
+}
+
+test "CMP-ascii-casemap-CONTAINS-1" {
+	if not header :contains :comparator "i;ascii-casemap" "X-A" "TEST" {
+		test_fail "should have matched";
+	}
+}
+
+test "CMP-ascii-casemap-CONTAINS-2" {
+	if not header :contains :comparator "i;ascii-casemap" "X-A" "test" {
+		test_fail "should have matched";
+	}
+}
+
+test "CMP-ascii-casemap-MATCH-1" {
+	if not header :matches :comparator "i;ascii-casemap" "X-A" "This*TEST*r" {
+		test_fail "should have matched";
+	}
+}
+
+test "CMP-ascii-casemap-MATCH-2" {
+	if not header :matches :comparator "i;ascii-casemap" "X-A" "ThIs*tEsT*R" {
+		test_fail "should have matched";
+	}
+}
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/compile/compile.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/compile.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/compile/compile.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/compile.svtest	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,16 @@
+require "vnd.dovecot.testsuite";
+
+# Just test whether valid scripts will compile without problems
+
+test "Trivial" {
+	if not test_script_compile "trivial.sieve" {
+		test_fail "could not compile";
+	}
+}
+
+test "Redirect" {
+	if not test_script_compile "redirect.sieve" {
+		test_fail "could not compile";
+	}
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/compile/errors/address-part.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors/address-part.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/compile/errors/address-part.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors/address-part.sieve	2008-07-30 15:17:37.000000000 +0200
@@ -0,0 +1,17 @@
+/*
+ * Address part errors
+ *
+ * Total errors: 2 (+1 = 3)
+ */
+
+# Duplicate address part (1)
+if address :all :comparator "i;octet" :domain "from" "STEPHAN" {
+
+	# Duplicate address part (2)
+	if address :domain :localpart :comparator "i;octet" "from" "drunksnipers.com" {
+		keep;
+	}
+
+	stop;
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/compile/errors/address.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors/address.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/compile/errors/address.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors/address.sieve	2008-07-30 15:17:37.000000000 +0200
@@ -0,0 +1,71 @@
+require "comparator-i;ascii-numeric";
+
+/* 
+ * Address test errors
+ *
+ * Total count: 8 (+1 = 9)
+ */
+
+/*
+ * Command structure
+ */ 
+
+# Invalid tag
+if address :nonsense :comparator "i;ascii-casemap" :localpart "From" "nico" {
+	discard;
+}
+
+# Invalid first argument
+if address :is :comparator "i;ascii-numeric" :localpart 45 "nico" {
+	discard;
+}
+
+# Invalid second argument
+if address :is :comparator "i;ascii-numeric" :localpart "From" 45 {
+	discard;
+}
+
+# Invalid second argument
+if address :comparator "i;ascii-numeric" :localpart "From" :is {
+	discard;
+}
+
+# Missing second argument
+if address :is :comparator "i;ascii-numeric" :localpart "From" {
+	discard;
+}
+
+# Missing arguments
+if address :is :comparator "i;ascii-numeric" :localpart {
+	discard;
+}
+
+# Not an error
+if address :localpart :is :comparator "i;ascii-casemap" "from" ["frop", "frop"] {
+	discard;
+}
+
+/*
+ * Specified headers must contain addresses
+ */
+
+# Invalid header 
+if address :is "frop" "frml" {
+	keep;
+}
+
+# Not an error
+if address :is "reply-to" "frml" {
+	keep;
+}
+
+# Invalid header (#2)
+if address :is ["to", "frop"] "frml" {
+	keep;
+}
+
+# Not an error
+if address :is ["to", "reply-to"] "frml" {
+	keep;
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/compile/errors/encoded-character.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors/encoded-character.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/compile/errors/encoded-character.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors/encoded-character.sieve	2008-07-30 15:17:37.000000000 +0200
@@ -0,0 +1,23 @@
+/*
+ * Encoded-character errors
+ *
+ * Total errors: 2 (+1 = 3)
+ */
+
+require "encoded-character";
+require "fileinto";
+
+# Invalid unicode character (1)
+fileinto "INBOX.${unicode:200000}";
+
+# Not an error
+fileinto "INBOX.${unicode:200000";
+
+# Invalid unicode character (2)
+fileinto "INBOX.${Unicode:DF01}";
+
+# Not an error
+fileinto "INBOX.${Unicode:DF01";
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/compile/errors/envelope.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors/envelope.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/compile/errors/envelope.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors/envelope.sieve	2008-07-30 15:17:37.000000000 +0200
@@ -0,0 +1,23 @@
+/*
+ * Envelope test errors
+ *
+ * Total errors: 2 (+1 = 3)
+ */
+
+require "envelope";
+
+# Not an error 
+if envelope :is "to" "frop@rename-it.nl" {
+}
+
+# Unknown envelope part (1)
+if envelope :is "frop" "frop@rename-it.nl" {
+}
+
+# Not an error
+if envelope :is ["to","from"] "frop@rename-it.nl" {
+}
+
+# Unknown envelope part (2)
+if envelope :is ["to","frop"] "frop@rename-it.nl" {
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/compile/errors/header.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors/header.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/compile/errors/header.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors/header.sieve	2008-07-30 15:17:37.000000000 +0200
@@ -0,0 +1,57 @@
+require "comparator-i;ascii-numeric";
+
+/*
+ * Compile errors for the header test
+ *
+ * Total errors: 9 (+1 validation failed msg = 10)
+ */
+
+# Unknown tagged argument
+if header :all :comparator "i;ascii-casemap" "From" "nico" {
+	keep;
+}
+
+# Wrong first argument
+if header :is :comparator "i;ascii-numeric" 45 "nico" {
+	keep;
+}
+
+# Wrong second argument
+if header :is :comparator "i;ascii-numeric" "From" 45 {
+	discard;
+}
+
+# Wrong second argument
+if header :is :comparator "i;ascii-numeric" "From" :tag {
+	stop;
+}
+
+# Missing second argument
+if header :is :comparator "i;ascii-numeric" "From" {
+	stop;
+}
+
+# Missing arguments
+if header :is :comparator "i;ascii-numeric" {
+	keep;
+}
+
+# Not an error
+if header :is :comparator "i;ascii-casemap" "frop" ["frop", "frop"] {
+	discard;
+}
+
+# Spurious sub-test
+if header "frop" "frop" true {
+	discard;
+}
+
+# Test used as command with block
+header "frop" "frop" {
+    discard;
+}
+
+# Test used as command
+header "frop" "frop";
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/compile/errors/if.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors/if.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/compile/errors/if.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors/if.sieve	2008-07-30 15:17:37.000000000 +0200
@@ -0,0 +1,78 @@
+/*
+ * If command errors 
+ *
+ * Total errors: 11 (+1 = 12)
+ */
+
+# Spurious argument
+if "frop" true {}
+
+# Spurious argument
+elsif "frop" true {}
+
+# Spurious string list
+if [ "false", "false", "false" ] false {
+	stop;
+}
+
+# No block
+if true;
+
+# No test
+if {
+	keep;
+}
+
+# Spurious test list
+if ( false, false, true ) {
+	keep;
+}
+
+stop;
+
+# If-less else
+else {
+	keep;
+}
+
+# Not an error
+if true {
+	keep;
+}
+
+stop;
+
+# If-less if structure (should produce only one error)
+elsif true {
+	keep;
+}
+elsif true {
+	keep;
+}
+else {
+}
+
+# Elsif after else
+if true {
+	keep;
+} else {
+	stop;
+} elsif true {
+	stop;
+}
+
+# If used as test
+if if true {
+} 
+
+# Else if in stead of elsif
+
+if true {
+	stop;
+} else if false {
+	keep;
+}
+
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/compile/errors/keep.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors/keep.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/compile/errors/keep.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors/keep.sieve	2008-07-30 15:17:37.000000000 +0200
@@ -0,0 +1,14 @@
+/*
+ * Keep errors
+ *
+ * Total erors: 2 (+1 = 3)
+ */
+
+# Spurious string argument
+keep "frop";
+
+# Spurious test 
+keep true;
+
+# Not an error
+keep;
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/compile/errors/lexer.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors/lexer.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/compile/errors/lexer.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors/lexer.sieve	2008-08-10 20:30:25.000000000 +0200
@@ -0,0 +1,71 @@
+/*
+ * Lexer tests
+ *
+ * Total errors: 7 (+1 = 8)
+ */
+
+/*
+ * Number limits
+ */
+ 
+# Number too large
+if size :under 4294967300 {
+	stop;
+}
+
+# Number too large
+if size :under 4294967296 {
+	stop;
+}
+
+# Number too large
+if size :over 35651584k {
+	stop;
+}
+
+# Number too large
+if size :over 34816M {
+	stop;
+}
+
+# Number too large
+if size :over 34G {
+	stop;
+}
+
+# Number too large
+if size :over 4G {
+	stop;
+}
+
+# Number far too large
+if size :over 49834598293485814273947921734981723971293741923 {
+	stop;
+}
+
+# Not an error
+if size :under 4294967295 {
+	stop;
+}
+
+# Not an error
+if size :under 4294967294 {
+	stop;
+}
+
+# Not an error
+if size :under 1G {
+	stop;
+}
+
+/*
+ * Identifier limits
+ */
+
+if this_is_a_rediculously_long_test_name {
+	stop;
+}
+
+if test :this_is_an_even_more_rediculously_long_tagged_argument_name {
+	stop;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/compile/errors/match-type.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors/match-type.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/compile/errors/match-type.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors/match-type.sieve	2008-08-25 10:25:08.000000000 +0200
@@ -0,0 +1,7 @@
+require "comparator-i;ascii-numeric";
+
+if header :contains :comparator "i;ascii-numeric" "from" "drunksnipers.com" {
+    keep;
+}
+
+keep;
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/compile/errors/out-address.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors/out-address.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/compile/errors/out-address.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors/out-address.sieve	2009-01-21 23:50:10.000000000 +0100
@@ -0,0 +1,27 @@
+require "vacation";
+
+# Error 
+
+redirect "@wrong.example.com";
+redirect "error";
+redirect "error@";
+redirect "Stephan Bosch error@rename-it.nl";
+redirect "Stephan Bosch <error@rename-it.nl";
+redirect " more error @  example.com  ";
+redirect "@";
+redirect "<>";
+redirect "Error <";
+redirect "Error <stephan";
+redirect "Error <stephan@";
+redirect "stephan@rename-it.nl,tss@iki.fi";
+redirect "stephan@rename-it.nl,%&^&!!~";
+
+vacation :from "Error" "Ik ben er niet.";
+
+# Ok
+
+redirect "Ok Good <stephan@rename-it.nl>";
+redirect "ok@example.com";
+redirect " more  @  example.com  ";
+
+vacation :from "good@voorbeeld.nl" "Ik ben weg!";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/compile/errors/parser.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors/parser.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/compile/errors/parser.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors/parser.sieve	2008-08-10 20:30:25.000000000 +0200
@@ -0,0 +1,78 @@
+/*
+ * Parser errors
+ *
+ * Total errors: 8 (+1 = 9)
+ */
+
+# Too many arguments (1)
+frop :this "is" "a" 2 :long "argument" "list" :and :it :should "fail" :during "parsing" :but "it" "should" "be" 
+	"recoverable" "." :this "is" "a" 2 :long "argument" "list" :and :it :should "fail" :during "parsing" :but 
+	"it" "should" "be" "recoverable" {
+	stop;
+}
+
+# Garbage argument (2)
+friep $$$;
+
+# Deep block nesting (1)
+if true { if true { if true { if true { if true { if true { if true { if true {
+	if true { if true { if true { if true { if true { if true { if true { if true {
+		if true { if true { if true { if true { if true { if true { if true { if true {
+			if true { if true {	if true { if true {	if true { if true { if true { if true {
+				if true { if true { if true { if true { if true { if true { if true { if true {
+					stop;
+				} } } } } } } }
+			} } } } } } } }
+		} } } } } } } }
+	} } } } } } } }
+} } } } } } } }
+
+# Deepest block and too deep test (list) nesting (1)
+if true { if true { if true { if true { if true { if true { if true { if true {
+	if true { if true { if true { if true { if true { if true { if true { if true {
+		if true { if true { if true { if true { if true { if true { if true { if true {
+			if true { if true {	if true { if true {	if true { if true { 
+				if	
+					anyof ( anyof ( anyof ( anyof ( anyof ( anyof ( anyof ( anyof ( 
+					anyof ( anyof ( anyof ( anyof ( anyof ( anyof ( anyof ( anyof ( 
+					anyof ( anyof ( anyof ( anyof ( anyof ( anyof ( anyof ( anyof ( 
+					anyof ( anyof ( anyof ( anyof ( anyof ( anyof ( anyof ( anyof ( 
+					anyof ( anyof ( anyof ( anyof ( anyof ( anyof ( anyof ( anyof (
+						true 
+					)))))))) 
+					)))))))) 
+					)))))))) 
+					)))))))) 
+					)))))))) 
+				{
+					stop;
+				} 
+			} } } } } }
+		} } } } } } } }
+	} } } } } } } }
+} } } } } } } }
+
+# Deepest block and too deep test nesting (1)
+if true { if true { if true { if true { if true { if true { if true { if true {
+	if true { if true { if true { if true { if true { if true { if true { if true {
+		if true { if true { if true { if true { if true { if true { if true { if true {
+			if true { if true {	if true { if true {	if true { if true { 
+				if	
+					not not not not not not not not
+					not not not not not not not not
+					not not not not not not not not
+					not not not not not not not not
+					not not not not not not not not false
+				{
+					stop;
+				} 
+			} } } } } }
+		} } } } } } } }
+	} } } } } } } }
+} } } } } } } }
+
+
+# Garbage command; test wether previous errors were resolved (2)
+frop $$$$;
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/compile/errors/require.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors/require.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/compile/errors/require.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors/require.sieve	2009-04-18 09:57:35.000000000 +0200
@@ -0,0 +1,42 @@
+/*
+ * Require errors
+ *
+ * Total errors: 11 (+1 = 12)
+ */
+
+# Not an error
+require "fileinto";
+
+# Missing argument
+require;
+
+# Too many arguments
+require "fileinto" "vacation";
+
+# Invalid argument
+require 45;
+
+# Invalid extensions (3 errors)
+require ["_frop", "_friep", "_frml"];
+
+# Core commands required
+require ["redirect", "keep", "discard"];
+
+# Invalid arguments
+require "dovecot.test" true;
+
+# Invalid extension
+require "_frop";
+
+# Spurious command block
+require "fileinto" { 
+  keep;
+}
+
+# Nested require
+if true {
+  require "relional";
+}
+
+# Require after other command than require
+require "copy";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/compile/errors/size.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors/size.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/compile/errors/size.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors/size.sieve	2008-07-30 15:17:37.000000000 +0200
@@ -0,0 +1,47 @@
+/*
+ * Size test errors
+ * 
+ * Total errors: 6 (+1 = 7)
+ */
+
+# Used as command (1)
+size :under 23;
+
+# Missing argument (2)
+if size {
+}
+
+# Missing :over/:under (3)
+if size 45 {
+	discard;
+}
+
+# No error
+if size :over 34K {
+	stop;
+}
+
+# No error
+if size :under 34M {
+	stop;
+}
+
+# Conflicting tags (4)
+if size :under :over 34 {
+	keep;
+}
+
+# Duplicate tags (5)
+if size :over :over 45M {
+	stop;
+}
+
+# Wrong argument order (6)
+if size 34M :over {
+	stop;
+}
+
+# No error; but worthy of a warning
+if size :under 0 {
+	stop;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/compile/errors/stop.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors/stop.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/compile/errors/stop.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors/stop.sieve	2008-07-30 15:17:37.000000000 +0200
@@ -0,0 +1,33 @@
+/*
+ * Stop command errors
+ *
+ * Total errors: 7 (+1 = 8)
+ */
+
+# Spurious string argument
+stop "frop";
+
+# Spurious number argument
+stop 13;
+
+# Spurious string list argument
+stop [ "frop", "frop" ];
+
+# Spurious test
+stop true;
+
+# Spurious test list
+stop ( true, false );
+
+# Spurious command block
+stop {
+  keep;
+}
+
+# Spurious argument and test
+stop "frop" true {
+  stop;
+}
+
+# Not an error
+stop;
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/compile/errors/tag.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors/tag.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/compile/errors/tag.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors/tag.sieve	2008-10-04 10:41:25.000000000 +0200
@@ -0,0 +1,16 @@
+/*
+ * Tag errors
+ * 
+ * Total errors: 2 (+1 = 3)
+ */
+
+# Unknown tag (1)
+if envelope :isnot :comparator "i;ascii-casemap" :localpart "From" "nico" {
+	discard;
+}
+
+# Spurious tag (1)
+if true :comparator "i;ascii-numeric" {
+  	keep;
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/compile/errors/typos.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors/typos.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/compile/errors/typos.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors/typos.sieve	2008-10-20 01:35:49.000000000 +0200
@@ -0,0 +1,29 @@
+/*
+ * This test is primarily meant to check the compiler's handing of typos
+ * at various locations.
+ */
+
+require "fileinto";
+
+/* 
+ * Missing semicolon 
+ */
+
+fileinto "frop"
+keep;
+
+/* Other situations */
+
+fileinto "frup" 
+true;
+
+fileinto "friep" 
+snot;
+
+/*
+ * Forgot tag colon
+ */ 
+
+if address matches "from" "*frop*" {
+	stop;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/compile/errors/unsupported.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors/unsupported.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/compile/errors/unsupported.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors/unsupported.sieve	2008-10-20 01:35:49.000000000 +0200
@@ -0,0 +1,39 @@
+/* 
+ * Handling of unsupported language features.
+ *
+ *   Total errors: 3 (+1 = 4)
+ */
+
+require "variables";
+require "include";
+require "regex";
+
+/* 
+ * Unsupported use of variables
+ */
+
+/* Comparator argument */ 
+
+set "comp" "i;ascii-numeric";
+
+if address :comparator "${comp}" "from" "stephan@rename-it.nl" {
+	stop;
+}
+
+/* Included script */
+
+set "script" "blacklist";
+
+include "${blacklist}";
+
+/* Variable regexp */
+
+set "match" "(.*)rename-it(.*)";
+
+if address :regex "from" "${match}" {
+	stop;
+}
+ 
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/compile/errors.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/compile/errors.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/errors.svtest	2009-04-18 10:02:11.000000000 +0200
@@ -0,0 +1,368 @@
+require "vnd.dovecot.testsuite";
+
+require "relational";
+require "comparator-i;ascii-numeric";
+
+/*
+ * Errors triggered in the compiled scripts are pretty reduntant over the
+ * tested commands, but we want to be thorough. 
+ */
+
+/*
+ * Lexer errors
+ */
+
+test "Lexer errors (FIXME: count only)" {
+    if test_script_compile "errors/lexer.sieve" {
+        test_fail "compile should have failed.";
+    }
+
+    if not test_error :count "eq" :comparator "i;ascii-numeric" "10" {
+        test_fail "wrong number of errors reported";
+    }
+}
+
+/*
+ * Parser errors
+ */
+
+test "Parser errors (FIXME: count only)" {
+    if test_script_compile "errors/parser.sieve" {
+        test_fail "compile should have failed.";
+    }
+
+    if not test_error :count "eq" :comparator "i;ascii-numeric" "9" {
+        test_fail "wrong number of errors reported";
+    }
+}
+
+/*
+ * Header test
+ */
+
+test "Header errors" {
+	if test_script_compile "errors/header.sieve" {
+		test_fail "compile should have failed.";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "10" {
+		test_fail "wrong number of errors reported";
+	}
+
+	if not test_error :index 1 :matches 
+		"unknown * ':all' for * header test *" {
+		test_fail "error 1 is invalid";
+	}
+
+	if not test_error :index 2 :matches 
+		"*header test * string list * 1 (header names), but * number *" {
+		test_fail "error 2 is invalid";
+	}
+
+	if not test_error :index 3 :matches
+		"*header test * string list * 2 (key list), * number *" {
+		test_fail "error 3 is invalid";
+	}
+
+	if not test_error :index 4 :matches 
+		"* unexpected tagged argument ':tag' while *" {
+		test_fail "error 4 is invalid";
+	}
+
+	if not test_error :index 5 :matches 
+		"* header test requires 2 *, but 1 *" {
+		test_fail "error 5 is invalid";
+	}
+
+	if not test_error :index 6 :matches 
+		"* header test requires 2 *, but 0 *" {
+		test_fail "error 6 is invalid";
+	}
+
+	if not test_error :index 7 :matches 
+		"*header test accepts no sub-tests* specified*" {
+		test_fail "error 7 is invalid";
+	}
+
+	if not test_error :index 8 :matches 
+		"* use test 'header' * command*" {
+		test_fail "error 8 is invalid";
+	}
+
+	if not test_error :index 9 :matches 
+		"* use test 'header' * command*" {
+		test_fail "error 9 is invalid";
+	}
+
+	if test_error :index 4 :contains "radish" {
+		test_fail "error test matched nonsense";
+	}
+}	
+
+/*
+ * Address test
+ */
+
+
+test "Address errors" {
+	if test_script_compile "errors/address.sieve" {
+		test_fail "compile should have failed.";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "9" {
+		test_fail "wrong number of errors reported";
+	}	
+
+	if not test_error :index 1 :matches
+		"*unknown * ':nonsense' * address test*" {
+		test_fail "error 1 is invalid";
+	}
+
+	if not test_error :index 2 :matches
+		"*address test expects *string list * 1 (header list),* number * found*" {
+		test_fail "error 2 is invalid";
+	}
+
+	if not test_error :index 3 :matches
+		"*address test expects *string list * 2 (key list),* number * found*" {
+		test_fail "error 3 is invalid";
+	}
+
+	if not test_error :index 4 :matches
+		"*unexpected *':is' * address test*" {
+		test_fail "error 4 is invalid";
+	}
+
+	if not test_error :index 5 :matches
+		"*address test * 2 positional arg*, but 1*" {
+		test_fail "error 5 is invalid";
+	}
+
+	if not test_error :index 6 :matches
+		"*address test * 2 positional arg*, but 0*" {
+		test_fail "error 6 is invalid";
+	}
+
+	if not test_error :index 7 :matches
+		"*'frop' *not allowed *address test*" {
+		test_fail "error 7 is invalid";
+	}
+
+	if not test_error :index 8 :matches
+		"*'frop' *not allowed *address test*" {
+		test_fail "error 8 is invalid";
+	}
+
+	if test_error :index 23 :contains "radish" {
+		test_fail "error test matched nonsense";
+	}
+}
+
+/*
+ * If command
+ */
+
+test "If errors (FIXME: count only)" {
+	if test_script_compile "errors/if.sieve" {
+		test_fail "compile should have failed.";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "12" {
+		test_fail "wrong number of errors reported";
+	}	
+}
+
+/*
+ * Require command
+ */
+
+test "Require errors (FIXME: count only)" {
+	if test_script_compile "errors/require.sieve" {
+		test_fail "compile should have failed.";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "15" {
+		test_fail "wrong number of errors reported";
+	}	
+}
+
+/*
+ * Size test
+ */
+
+test "Size errors (FIXME: count only)" {
+    if test_script_compile "errors/size.sieve" {
+        test_fail "compile should have failed.";
+    }
+
+    if not test_error :count "eq" :comparator "i;ascii-numeric" "7" {
+        test_fail "wrong number of errors reported";
+    }
+}
+
+/*
+ * Envelope test
+ */
+
+test "Envelope errors (FIXME: count only)" {
+    if test_script_compile "errors/envelope.sieve" {
+        test_fail "compile should have failed.";
+    }
+
+    if not test_error :count "eq" :comparator "i;ascii-numeric" "3" {
+        test_fail "wrong number of errors reported";
+    }
+}
+
+/*
+ * Stop command
+ */
+
+test "Stop errors (FIXME: count only)" {
+    if test_script_compile "errors/stop.sieve" {
+        test_fail "compile should have failed.";
+    }
+
+    if not test_error :count "eq" :comparator "i;ascii-numeric" "9" {
+        test_fail "wrong number of errors reported";
+    }
+}
+
+/*
+ * Keep command
+ */
+
+test "Keep errors (FIXME: count only)" {
+    if test_script_compile "errors/keep.sieve" {
+        test_fail "compile should have failed.";
+    }
+
+    if not test_error :count "eq" :comparator "i;ascii-numeric" "3" {
+        test_fail "wrong number of errors reported";
+    }
+}
+
+/*
+ * ADDRESS-PART errors
+ */
+
+test "ADDRESS-PART errors (FIXME: count only)" {
+    if test_script_compile "errors/address-part.sieve" {
+        test_fail "compile should have failed.";
+    }
+
+    if not test_error :count "eq" :comparator "i;ascii-numeric" "3" {
+        test_fail "wrong number of errors reported";
+    }
+}
+
+/*
+ * MATCH-TYPE errors
+ */
+
+test "MATCH-TYPE errors (FIXME: count only)" {
+    if test_script_compile "errors/match-type.sieve" {
+        test_fail "compile should have failed.";
+    }
+
+    if not test_error :count "eq" :comparator "i;ascii-numeric" "2" {
+        test_fail "wrong number of errors reported";
+    }
+}
+
+/*
+ * Encoded-character errors
+ */
+
+test "Encoded-character errors (FIXME: count only)" {
+    if test_script_compile "errors/encoded-character.sieve" {
+        test_fail "compile should have failed.";
+    }
+
+    if not test_error :count "eq" :comparator "i;ascii-numeric" "3" {
+        test_fail "wrong number of errors reported";
+    }
+}
+
+/*
+ * Outgoing address errors
+ */
+
+test "Outgoing address errors (FIXME: count only)" {
+    if test_script_compile "errors/out-address.sieve" {
+        test_fail "compile should have failed.";
+    }
+
+    if not test_error :count "eq" :comparator "i;ascii-numeric" "15" {
+        test_fail "wrong number of errors reported";
+    }
+}
+
+
+/*
+ * Tagged argument errors
+ */
+
+test "Tagged argument errors (FIXME: count only)" {
+    if test_script_compile "errors/tag.sieve" {
+        test_fail "compile should have failed.";
+    }
+
+    if not test_error :count "eq" :comparator "i;ascii-numeric" "3" {
+        test_fail "wrong number of errors reported";
+    }
+}
+
+/*
+ * Typos
+ */
+
+test "Typos" {
+	if test_script_compile "errors/typos.sieve" {
+		test_fail "compile should have failed.";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "6" {
+		test_fail "wrong number of errors reported";
+	}
+
+	if not test_error :index 1 :matches
+		"missing semicolon * fileinto *" {
+		test_fail "error 1 is invalid";
+	}
+
+	if not test_error :index 2 :matches
+		"*fileinto command * no *tests* specified*" {
+		test_fail "error 2 is invalid";
+	}
+
+	if not test_error :index 3 :matches
+		"missing semicolon * fileinto *" {
+		test_fail "error 3 is invalid";
+	}
+
+	if not test_error :index 4 :matches
+		"*address test requires 2 * 0 * specified" {
+		test_fail "error 4 is invalid";
+	}
+
+	if not test_error :index 5 :matches
+		"missing colon *matches* tag * address test" {
+		test_fail "error 5 is invalid";
+	}
+}
+
+
+/*
+ * Unsupported language features
+ */
+
+test "Unsupported language features (FIXME: count only)" {
+    if test_script_compile "errors/unsupported.sieve" {
+        test_fail "compile should have failed.";
+    }
+
+    if not test_error :count "eq" :comparator "i;ascii-numeric" "4" {
+        test_fail "wrong number of errors reported";
+    }
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/compile/redirect.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/redirect.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/compile/redirect.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/redirect.sieve	2008-07-30 15:17:37.000000000 +0200
@@ -0,0 +1,23 @@
+# Test various white space occurences
+redirect "stephan@rename-it.nl";
+redirect " stephan@rename-it.nl";
+redirect "stephan @rename-it.nl";
+redirect "stephan@ rename-it.nl";
+redirect "stephan@rename-it.nl ";
+redirect " stephan @ rename-it.nl ";
+redirect "Stephan Bosch<stephan@rename-it.nl>";
+redirect " Stephan Bosch<stephan@rename-it.nl>";
+redirect "Stephan Bosch <stephan@rename-it.nl>";
+redirect "Stephan Bosch< stephan@rename-it.nl>";
+redirect "Stephan Bosch<stephan @rename-it.nl>";
+redirect "Stephan Bosch<stephan@ rename-it.nl>";
+redirect "Stephan Bosch<stephan@rename-it.nl >";
+redirect "Stephan Bosch<stephan@rename-it.nl> ";
+redirect "  Stephan Bosch  <  stephan  @  rename-it.nl  > ";
+
+# Test address syntax
+redirect "\"Stephan Bosch\"@rename-it.nl";
+redirect "Stephan.Bosch@rename-it.nl";
+redirect "Stephan.Bosch@ReNaMe-It.Nl";
+redirect "Stephan Bosch <stephan@rename-it.nl>";
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/compile/trivial.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/trivial.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/compile/trivial.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/trivial.sieve	2008-08-04 10:39:20.000000000 +0200
@@ -0,0 +1,17 @@
+# Commands must be case-insensitive
+keep;
+Keep;
+KEEP;
+discard;
+DisCaRD;
+
+# Tags must be case-insensitive
+if size :UNDER 34 {
+}
+
+if header :Is "from" "tukker@rename-it.n" {
+}
+
+# Numbers must be case-insensitive
+if anyof( size :UNDER 34m, size :oVeR 50M ) {
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/compile/warnings/invalid-headers.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/warnings/invalid-headers.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/compile/warnings/invalid-headers.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/compile/warnings/invalid-headers.sieve	2008-12-09 19:02:55.000000000 +0100
@@ -0,0 +1,11 @@
+if header "from:" "frop@rename-it.nl" {
+	stop;
+}
+
+if address "from:" "frop@rename-it.nl" {
+	stop;
+}
+
+if exists "from:" {
+	stop;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/control-structures.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/control-structures.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/control-structures.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/control-structures.svtest	2008-07-30 15:17:37.000000000 +0200
@@ -0,0 +1,149 @@
+require "vnd.dovecot.testsuite";
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: test@dovecot.org
+Subject: Test
+
+Test!
+.
+;
+
+test "IF-true" {
+	if true {
+	} else {
+		test_fail "executed wrong alternative";
+	}
+}
+
+test "IF-false" {
+	if false {
+		test_fail "executed wrong alternative";
+	}
+}
+
+test "ELSEIF-true" {
+	if false {
+		test_fail "executed wrong alternative (if)";
+	} elsif true {
+	} else {
+		test_fail "executed wrong alternative (else)";	
+	}
+}
+
+test "ELSEIF-false" {
+	if false {
+		test_fail "executed wrong alternative (if)";
+	} elsif false {
+		test_fail "executed wrong alternative (elsif)";	
+	} else {
+	}
+}
+
+test "IF-address-true" {
+	if address :is "from" "stephan@rename-it.nl" {
+	} else {
+		test_fail "executed wrong alternative";
+	}
+}
+
+test "IF-address-false" {
+	if address :is "from" "tss@iki.fi" {
+		test_fail "executed wrong alternative";
+	}
+}
+
+test "ELSEIF-address-true" {
+	if address :is "from" "tss@iki.fi" {
+		test_fail "executed wrong alternative (if)";
+	} elsif address :is "from" "stephan@rename-it.nl" {
+	} else {
+		test_fail "executed wrong alternative (else)";	
+	}
+}
+
+test "ELSEIF-address-false" {
+	if address :is "from" "tss@iki.fi" {
+		test_fail "executed wrong alternative (if)";
+	} elsif address :is "to" "stephan@rename-it.nl" {
+		test_fail "executed wrong alternative (elsif)";	
+	} else {
+	}
+}
+
+test "IF-nesting-static" {
+	if true {
+		if true {
+			if false {
+				test_fail "chose wrong outcome: true->true->false";
+			} else {
+			}
+		} else {
+			test_fail "chose wrong outcome: true->false";
+		}
+	} elsif true {
+		if false {
+			test_fail "chose wrong outcome: false->true->false";	
+		} elsif true {
+			test_fail "chose wrong outcome: false->true->true";
+		}
+	} else {
+		test_fail "chose wrong outcome: false->false";
+	}
+}
+
+test "ALLOF-ANYOF-static" {
+	if allof ( true, true, true, true, anyof (false, false, true, false) ) {
+		if anyof( allof(false, false), allof(false, true), allof(true, false) ) {
+			test_fail "chose wrong outcome: true->true";
+		} elsif allof( anyof(false, true), true, anyof(true, false), anyof(true, true)) {
+			
+		} else {
+			test_fail "chose wrong outcome: true->false->false";			
+		}
+	} else {
+		test_fail "chose wrong outcome: false";
+	}
+}
+
+test "ALLOF-ANYOF-single" {
+	# Static 
+	if not allof ( true ) {
+		test_fail "allof ( true ) evaluates to false";
+	}
+
+	if allof ( false ) {
+		test_fail "allof ( false ) evaluates to true";
+	}
+
+	if not anyof ( true ) {
+		test_fail "anyof ( true ) evaluates to false";
+	}
+
+	if anyof ( false ) {
+		test_fail "anyof ( false ) evaluates to true";
+	}	
+
+	# Dynamic
+	if not allof ( exists "subject" ) {
+        test_fail "allof ( 'true' ) evaluates to false";
+    }
+
+    if allof ( exists "x-nonsense" ) {
+        test_fail "allof ( 'false' ) evaluates to true";
+    }
+
+    if not anyof ( exists "subject" ) {
+        test_fail "anyof ( 'true' ) evaluates to false";
+    }
+
+    if anyof ( exists "x-nonsense" ) {
+        test_fail "anyof ( 'false' ) evaluates to true";
+    }
+}
+
+test "STOP" {
+	stop;
+	test_fail "continued after stop";
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/deprecated/notify/basic.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/deprecated/notify/basic.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/deprecated/notify/basic.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/deprecated/notify/basic.svtest	2009-07-19 15:54:39.000000000 +0200
@@ -0,0 +1,11 @@
+require "vnd.dovecot.testsuite";
+require "notify";
+
+test "Execute" {
+	/* Test to catch runtime segfaults */
+	notify 
+		:message "This is probably very important"
+		:low
+		:method "mailto" 
+		:options ["stephan@example.com", "stephan@rename-it.nl"];
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/deprecated/notify/errors/options.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/deprecated/notify/errors/options.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/deprecated/notify/errors/options.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/deprecated/notify/errors/options.sieve	2009-07-19 15:54:39.000000000 +0200
@@ -0,0 +1,11 @@
+require "notify";
+
+# 1: empty option
+notify :options "";
+
+# 2: invalid address syntax
+notify :options "frop#vestingbar.nl";
+
+# Valid
+notify :options "frop@vestingbar.nl";
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/deprecated/notify/errors.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/deprecated/notify/errors.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/deprecated/notify/errors.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/deprecated/notify/errors.svtest	2009-07-19 15:54:39.000000000 +0200
@@ -0,0 +1,13 @@
+require "vnd.dovecot.testsuite";
+require "comparator-i;ascii-numeric";
+require "relational";
+
+test "Invalid :options argument (FIXME: count only)" {
+	if test_script_compile "errors/options.sieve" {
+		test_fail "compile should have failed";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "3" {
+		test_fail "wrong number of errors reported";
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/deprecated/notify/execute/duplicates.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/deprecated/notify/execute/duplicates.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/deprecated/notify/execute/duplicates.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/deprecated/notify/execute/duplicates.sieve	2009-07-19 15:54:39.000000000 +0200
@@ -0,0 +1,4 @@
+require "notify";
+
+notify :message "Incoming stupidity." :options ["stephan@rename-it.nl", "stephan@drunksnipers.com", "idiot@rename-it.nl"];
+notify :message "There it is." :options ["tss@iki.fi", "stephan@rename-it.nl", "idiot@rename-it.nl", "nico@vestingbar.nl", "stephan@drunksnipers.com"];
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/deprecated/notify/execute.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/deprecated/notify/execute.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/deprecated/notify/execute.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/deprecated/notify/execute.svtest	2009-07-19 15:54:39.000000000 +0200
@@ -0,0 +1,25 @@
+require "vnd.dovecot.testsuite";
+require "relational";
+
+
+/*
+ * Execution testing (currently just meant to trigger any segfaults)
+ */
+
+test "Duplicate recipients" {
+	if not test_script_compile "execute/duplicates.sieve" {
+		test_fail "script compile failed";
+	}
+
+	if not test_script_run {
+		test_fail "script execute failed";
+	}
+
+	if test_result :count "ne" "2" {
+		test_fail "second notify action was discarded entirely";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed";
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/deprecated/notify/mailto.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/deprecated/notify/mailto.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/deprecated/notify/mailto.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/deprecated/notify/mailto.svtest	2009-07-19 15:54:39.000000000 +0200
@@ -0,0 +1,155 @@
+require "vnd.dovecot.testsuite";
+require "notify";
+require "relational";
+require "comparator-i;ascii-numeric";
+
+/*
+ * Simple test
+ */
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Subject: Frop!
+
+Klutsefluts.
+.
+;
+
+test "Simple" {
+	notify :method "mailto" :options "stephan@rename-it.nl";
+
+	if not test_result_execute {
+		test_fail "failed to execute notify";
+	}
+
+	test_message :smtp 0;
+
+	if not header :matches "Auto-Submitted" "auto-generated*" {
+		test_fail "auto-submitted header set inappropriately";
+	}
+
+	if not exists "X-Sieve" {
+		test_fail "x-sieve header missing from outgoing message";
+	}
+}
+
+/*
+ * Multiple recipients
+ */
+
+test_result_reset;
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Subject: Frop!
+
+Klutsefluts.
+.
+;
+
+test "Multiple recipients" {
+	notify :options ["timo@example.com","stephan@dovecot.org","postmaster@vestingbar.nl"];
+
+	if not test_result_execute {
+		test_fail "failed to execute notify";
+	}
+
+	test_message :smtp 0;
+
+	if not address :is "to" "timo@example.com" {
+		test_fail "first To address missing";
+	}
+
+	test_message :smtp 1;
+
+	if not address :is "to" "stephan@dovecot.org" {
+		test_fail "second To address missing";
+	}
+
+	if not header :matches "Auto-Submitted" "auto-generated*" {
+		test_fail "auto-submitted header not found for second message";
+	}
+
+	test_message :smtp 2;
+
+	if not address :is "to" "postmaster@vestingbar.nl" {
+		test_fail "third To address missing";
+	}
+
+	if not header :matches "Auto-Submitted" "auto-generated*" {
+		test_fail "auto-submitted header not found for third message";
+	}
+
+	if not address :count "eq" :comparator "i;ascii-numeric" "to" "1" {
+		test_fail "too many recipients in To header";
+	} 
+
+	if not address :count "eq" :comparator "i;ascii-numeric" "cc" "0" {
+		test_fail "too many recipients in Cc header";
+	} 
+}
+
+/*
+ * Duplicate recipients
+ */
+
+test_result_reset;
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Subject: Frop!
+
+Klutsefluts.
+.
+;
+
+test "Duplicate recipients" {
+	notify :options ["timo@example.com", "stephan@dovecot.org", "stephan@dovecot.org"];
+	notify :options ["timo@example.com", "stephan@rename-it.nl"];
+
+	if not test_result_execute {
+		test_fail "failed to execute notify";
+	}
+
+	test_message :smtp 2;
+
+	if address "To" "stephan@dovecot.org" {
+		test_fail "duplicate recipient not removed from first message";
+	}
+
+	if address "To" "timo@example.com" {
+		test_fail "duplicate recipient not removed from second message";
+	}
+}
+
+/*
+ * Notifying on automated messages
+ */
+
+test_result_reset;
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Auto-submitted: auto-notify
+Subject: Frop!
+
+Klutsefluts.
+.
+;
+
+test "Notifying on automated messages" {
+	notify :options "stephan@rename-it.nl";
+
+	if not test_result_execute {
+		test_fail "failed to execute notify";
+	}
+
+	if test_message :smtp 0 {
+		test_fail "notified of auto-submitted message";
+	}
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/execute/actions/fileinto.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/execute/actions/fileinto.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/execute/actions/fileinto.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/execute/actions/fileinto.sieve	2008-10-20 01:35:49.000000000 +0200
@@ -0,0 +1,17 @@
+require "fileinto";
+
+/* Three store actions */
+
+if address :contains "to" "vestingbar" {
+	/* #1 */
+	fileinto "INBOX.VB";
+}
+
+/* #2 */
+fileinto "INBOX.backup";
+
+/* #3 */
+keep;
+
+/* Duplicate of keep */
+fileinto "INBOX";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/execute/actions/redirect.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/execute/actions/redirect.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/execute/actions/redirect.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/execute/actions/redirect.sieve	2008-10-20 01:35:49.000000000 +0200
@@ -0,0 +1,17 @@
+if address :contains "to" "vestingbar" {
+	/* #1 */
+	redirect "stephan@example.com";
+	
+	/* #2 */
+	keep;
+}
+
+/* #3 */
+redirect "stephan@rename-it.nl";
+
+/* #4 */
+redirect "nico@example.nl";
+
+/* Duplicates */
+redirect "Stephan Bosch <stephan@example.com>";
+keep;
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/execute/actions.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/execute/actions.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/execute/actions.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/execute/actions.svtest	2009-07-31 17:34:58.000000000 +0200
@@ -0,0 +1,80 @@
+require "vnd.dovecot.testsuite";
+require "relational";
+require "comparator-i;ascii-numeric";
+
+test_set "message" text:
+To: nico@vestingbar.nl
+From: stephan@rename-it.nl
+Subject: Test
+
+Test.
+.
+;
+
+test_mailbox :create "INBOX.VB";
+test_mailbox :create "INBOX.backup";
+
+test "Fileinto" {
+	if not test_script_compile "actions/fileinto.sieve" {
+		test_fail "script compile failed";
+	}
+
+	if not test_script_run {
+		test_fail "script run failed";
+	}
+
+	if not test_result :count "eq" :comparator "i;ascii-numeric" "3" {
+		test_fail "wrong number of actions in result";
+	} 
+
+	if not test_result :index 1 "store" {
+		test_fail "first action is not 'store'";
+	} 
+
+	if not test_result :index 2 "store" {
+		test_fail "second action is not 'store'";
+	} 
+
+	if not test_result :index 3 "keep" {
+		test_fail "third action is not 'keep'";
+	} 
+
+	if not test_result_execute {
+		test_fail "result execute failed";
+	}
+}
+
+test "Redirect" {
+	if not test_script_compile "actions/redirect.sieve" {
+		test_fail "compile failed";
+	}
+
+	if not test_script_run {
+		test_fail "execute failed";
+	}
+
+	if not test_result :count "eq" :comparator "i;ascii-numeric" "4" {
+		test_fail "wrong number of actions in result";
+	} 
+
+	if not test_result :index 1 "redirect" {
+		test_fail "first action is not 'redirect'";
+	} 
+
+	if not test_result :index 2 "keep" {
+		test_fail "second action is not 'keep'";
+	} 
+
+	if not test_result :index 3 "redirect" {
+		test_fail "third action is not 'redirect'";
+	} 
+
+	if not test_result :index 4 "redirect" {
+		test_fail "fourth action is not 'redirect'";
+	} 
+
+	if not test_result_execute {
+		test_fail "result execute failed";
+	}
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/execute/errors/action-duplicates.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/execute/errors/action-duplicates.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/execute/errors/action-duplicates.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/execute/errors/action-duplicates.sieve	2008-08-25 17:35:24.000000000 +0200
@@ -0,0 +1,4 @@
+require "reject";
+
+reject "Message is not appreciated.";
+reject "No, really, it is not appreciated.";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/execute/errors/actions-limit.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/execute/errors/actions-limit.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/execute/errors/actions-limit.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/execute/errors/actions-limit.sieve	2008-09-06 12:59:49.000000000 +0200
@@ -0,0 +1,35 @@
+require "fileinto";
+
+fileinto "box1";
+fileinto "box2";
+fileinto "box3";
+fileinto "box4";
+fileinto "box5";
+fileinto "box6";
+fileinto "box7";
+fileinto "box8";
+fileinto "box9";
+fileinto "box10";
+fileinto "box11";
+fileinto "box12";
+fileinto "box13";
+fileinto "box14";
+fileinto "box15";
+fileinto "box16";
+fileinto "box17";
+fileinto "box18";
+fileinto "box19";
+fileinto "box20";
+fileinto "box21";
+fileinto "box22";
+fileinto "box23";
+fileinto "box24";
+fileinto "box25";
+fileinto "box26";
+fileinto "box27";
+fileinto "box28";
+redirect "address1@example.com";
+redirect "address2@example.com";
+redirect "address3@example.com";
+redirect "address4@example.com";
+keep;
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/execute/errors/conflict-reject-fileinto.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/execute/errors/conflict-reject-fileinto.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/execute/errors/conflict-reject-fileinto.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/execute/errors/conflict-reject-fileinto.sieve	2008-08-26 15:53:02.000000000 +0200
@@ -0,0 +1,5 @@
+require "reject";
+require "fileinto";
+
+reject "No nonsense in my mailbox.";
+fileinto "Spam";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/execute/errors/conflict-reject-keep.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/execute/errors/conflict-reject-keep.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/execute/errors/conflict-reject-keep.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/execute/errors/conflict-reject-keep.sieve	2008-08-26 15:56:33.000000000 +0200
@@ -0,0 +1,4 @@
+require "reject";
+
+reject "I am not interested in your nonsense.";
+keep;
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/execute/errors/conflict-reject-redirect.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/execute/errors/conflict-reject-redirect.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/execute/errors/conflict-reject-redirect.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/execute/errors/conflict-reject-redirect.sieve	2008-08-26 15:54:24.000000000 +0200
@@ -0,0 +1,4 @@
+require "reject";
+
+reject "I am not interested in your nonsense.";
+redirect "frop@example.com";
Binary files dovecot-1.2.4/dovecot-libsieve/tests/execute/errors/conflict-reject-redirect.svbin and dovecot-1.2.4.debian/dovecot-libsieve/tests/execute/errors/conflict-reject-redirect.svbin differ
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/execute/errors/redirect-limit.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/execute/errors/redirect-limit.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/execute/errors/redirect-limit.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/execute/errors/redirect-limit.sieve	2008-09-06 12:59:49.000000000 +0200
@@ -0,0 +1,5 @@
+redirect "address1@example.com";
+redirect "address2@example.com";
+redirect "address3@example.com";
+redirect "address4@example.com";
+redirect "address5@example.com";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/execute/errors.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/execute/errors.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/execute/errors.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/execute/errors.svtest	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,82 @@
+require "vnd.dovecot.testsuite";
+
+require "relational";
+require "comparator-i;ascii-numeric";
+
+test "Action conflicts: reject <-> fileinto" {
+	if not test_script_compile "errors/conflict-reject-fileinto.sieve" {
+		test_fail "compile failed";
+	}
+
+	if test_script_run {
+		test_fail "execution should have failed";
+	}
+
+	if test_error :count "gt" :comparator "i;ascii-numeric" "1" {
+		test_fail "too many runtime errors reported";
+	}
+}
+
+test "Action conflicts: reject <-> keep" {
+	if not test_script_compile "errors/conflict-reject-keep.sieve" {
+		test_fail "compile failed";
+	}
+
+	if test_script_run {
+		test_fail "execution should have failed";
+	}
+
+	if test_error :count "gt" :comparator "i;ascii-numeric" "1" {
+		test_fail "too many runtime errors reported";
+	}
+}
+
+test "Action conflicts: reject <-> redirect" {
+	if not test_script_compile "errors/conflict-reject-redirect.sieve" {
+		test_fail "compile failed";
+	}
+
+	if test_script_run {
+		test_fail "execution should have failed";
+	}
+
+	if test_error :count "gt" :comparator "i;ascii-numeric" "1" {
+		test_fail "too many runtime errors reported";
+	}
+}
+
+test "Action limit" {
+	if not test_script_compile "errors/actions-limit.sieve" {
+		test_fail "compile failed";
+	}
+
+	if test_script_run {
+		test_fail "execution should have failed";
+	}
+
+	if test_error :count "gt" :comparator "i;ascii-numeric" "1" {
+		test_fail "too many runtime errors reported";
+	}
+	
+	if not test_error :index 1 :contains "total number of actions exceeds policy limit"{
+		test_fail "unexpected error reported";
+	}
+}
+
+test "Redirect limit" {
+	if not test_script_compile "errors/redirect-limit.sieve" {
+		test_fail "compile failed";
+	}
+
+	if test_script_run {
+		test_fail "execution should have failed";
+	}
+
+	if test_error :count "gt" :comparator "i;ascii-numeric" "1" {
+		test_fail "too many runtime errors reported";
+	}
+	
+	if not test_error :index 1 :contains "number of redirect actions exceeds policy limit"{
+		test_fail "unexpected error reported";
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/execute/examples.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/execute/examples.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/execute/examples.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/execute/examples.svtest	2009-08-21 00:52:15.000000000 +0200
@@ -0,0 +1,115 @@
+require "vnd.dovecot.testsuite";
+
+/* Compile and execute all example scripts to trigger 
+ * any Segfaults. No message is set and no results are checked.
+ */
+
+test "Elvey example" {
+	if not test_script_compile "../../examples/elvey.sieve" {
+		test_fail "could not compile";
+	}
+
+	test_binary :save "elvey";
+	test_binary :load "elvey";
+
+	if not test_script_run { }
+}
+
+test "M. Johnson example" {
+	if not test_script_compile "../../examples/mjohnson.sieve" {
+		test_fail "could not compile";
+	}
+
+	test_binary :save "mjohnson";
+	test_binary :load "mjohnson";
+
+	if not test_script_run { }
+}
+
+test "RFC 3028 example" {
+	if not test_script_compile "../../examples/rfc3028.sieve" {
+		test_fail "could not compile";
+	}
+
+	test_binary :save "rfc3028";
+	test_binary :load "rfc3028";
+
+	if not test_script_run { }
+}
+
+test "Sieve examples" {
+	if not test_script_compile "../../examples/sieve_examples.sieve" {
+		test_fail "could not compile";
+	}
+
+	test_binary :save "sieve_examples";
+	test_binary :load "sieve_examples";
+
+	if not test_script_run { }
+}
+
+test "Vivil example" {
+	if not test_script_compile "../../examples/vivil.sieve" {
+		test_fail "could not compile";
+	}
+
+	test_binary :save "vivil";
+	test_binary :load "vivil";
+
+	if not test_script_run { }
+}
+
+test "Jerry example" {
+	if not test_script_compile "../../examples/jerry.sieve" {
+		test_fail "could not compile";
+	}
+
+	test_binary :save "jerry";
+	test_binary :load "jerry";
+
+	if not test_script_run { }
+}
+
+test "M. Klose example" {
+	if not test_script_compile "../../examples/mklose.sieve" {
+		test_fail "could not compile";
+	}
+
+	test_binary :save "mklose";
+	test_binary :load "mklose";
+
+	if not test_script_run { }
+}
+
+test "Sanjay example" {
+	if not test_script_compile "../../examples/sanjay.sieve" {
+		test_fail "could not compile";
+	}
+
+	test_binary :save "sanjay";
+	test_binary :load "sanjay";
+
+	if not test_script_run { }
+}
+
+test "Relational (RFC5231) example" {
+	if not test_script_compile "../../examples/relational.rfc5231.sieve" {
+		test_fail "could not compile";
+	}
+
+	test_binary :save "relational";
+	test_binary :load "relational";
+
+	if not test_script_run { }
+}
+
+test "Subaddress (RFC5233) example" {
+	if not test_script_compile "../../examples/subaddress.rfc5233.sieve" {
+		test_fail "could not compile";
+	}
+
+	test_binary :save "subaddress";
+	test_binary :load "subaddress";
+
+	if not test_script_run { }
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/execute/mailstore.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/execute/mailstore.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/execute/mailstore.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/execute/mailstore.svtest	2009-08-02 09:44:14.000000000 +0200
@@ -0,0 +1,84 @@
+require "vnd.dovecot.testsuite";
+require "fileinto";
+require "variables";
+require "mailbox";
+
+set "message1" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Subject: First message
+
+Frop
+.
+;
+
+set "message2" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Subject: Second message
+
+Frop
+.
+;
+
+set "message3" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Subject: Third message
+
+Frop
+.
+;
+
+test "Duplicates" {
+	test_set "message" "${message1}";
+
+	fileinto :create "Folder";
+	fileinto :create "Folder";
+
+	if not test_result_execute {
+		test_fail "failed to execute first result";
+	}
+
+	test_result_reset;
+
+	test_set "message" "${message2}";
+
+	fileinto :create "Folder";
+	fileinto :create "Folder";
+
+	if not test_result_execute {
+		test_fail "failed to execute second result";
+	}
+
+	test_result_reset;
+
+	test_set "message" "${message3}";
+
+	fileinto :create "Folder";
+	fileinto :create "Folder";
+
+	if not test_result_execute {
+		test_fail "failed to execute third result";
+	}
+
+	test_message :folder "Folder" 0;
+	
+	if not header :is "subject" "First message" {
+		test_fail "first message incorrect";
+	}
+
+	test_message :folder "Folder" 1;
+
+	if not header :is "subject" "Second message" {
+		test_fail "first message incorrect";
+	}
+
+	test_message :folder "Folder" 2;
+
+	if not header :is "subject" "Third message" {
+		test_fail "first message incorrect";
+	}
+}
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/execute/smtp.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/execute/smtp.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/execute/smtp.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/execute/smtp.svtest	2009-07-21 12:28:37.000000000 +0200
@@ -0,0 +1,61 @@
+require "vnd.dovecot.testsuite";
+require "envelope";
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: tss@iki.fi
+Subject: Frop!
+
+Frop!
+.
+;
+
+test_set "envelope.from" "sirius@rename-it.nl";
+test_set "envelope.to" "timo@iki.fi";
+
+test "Redirect" {
+	redirect "cras@iki.fi";
+
+	if not test_result_execute {
+        test_fail "failed to execute redirect";
+    }
+
+    test_message :smtp 0;
+
+    if not address :is "to" "tss@iki.fi" {
+        test_fail "to address incorrect (strange forward)";
+    }
+
+    if not address :is "from" "stephan@rename-it.nl" {
+        test_fail "from address incorrect (strange forward)";
+    }
+
+	if not envelope :is "to" "cras@iki.fi" {
+		test_fail "envelope recipient incorrect";
+	}
+
+	if not envelope :is "from" "sirius@rename-it.nl" {
+		test_fail "envelope sender incorrect";
+	}
+}
+
+test_result_reset;
+
+test "Redirect from <>" {
+
+	test_set "envelope.from" "<>";
+
+	redirect "cras@iki.fi";
+
+	if not test_result_execute {
+        test_fail "failed to execute redirect";
+    }
+
+	if envelope :is "from" "sirius@rename-it.nl" {
+        test_fail "envelope sender incorrect (not changed)";
+    }
+
+	if not envelope :is "from" "" {
+        test_fail "envelope sender incorrect";
+    }
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/exists.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/exists.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/exists.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/exists.svtest	2008-07-30 15:17:37.000000000 +0200
@@ -0,0 +1,42 @@
+require "vnd.dovecot.testsuite";
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.bl
+Subject: Test message
+X-Spam-Status: Not Spam
+Resent-To: nico@vestingbar.nl
+
+Test!
+.
+;
+
+test "EXISTS-one" {
+	if not exists "from" {
+		test_fail "exists test missed from header";
+	}
+
+	if exists "x-nonsense" {
+        test_fail "exists test found non-existant header";
+    }
+}
+
+test "EXISTS-two" {
+    if not exists ["from","to"] {
+        test_fail "exists test missed from or to header";
+    }
+
+    if exists ["from","to","x-nonsense"] {
+        test_fail "exists test found non-existant header";
+    }
+}
+
+test "EXISTS-three" {
+    if not exists ["Subject","X-spam-STATUS","resent-to"] {
+        test_fail "exists test missed from or to header";
+    }
+
+    if exists ["x-spam", "sub", "resent"] {
+        test_fail "exists test found non-existant header";
+    }
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/body/basic.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/body/basic.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/body/basic.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/body/basic.svtest	2008-08-10 22:09:49.000000000 +0200
@@ -0,0 +1,188 @@
+require "vnd.dovecot.testsuite";
+require "relational";
+require "comparator-i;ascii-numeric";
+
+require "body";
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: tss@iki.fi
+Subject: Test message.
+
+Test!
+
+.
+;
+
+/* Empty line
+ * 
+ *  RFC 5173: 
+ *    'The body test matches content in the body of an email message, that
+ *     is, anything following the first empty line after the header.  (The
+ *     empty line itself, if present, is not considered to be part of the
+ *     body.)'
+ */
+test "The empty line" {
+
+	if not body :raw :is text:
+Test!
+
+.
+	{
+		test_fail "invalid message body extracted";
+	}
+
+	if body :raw :is text:
+
+Test!
+
+.
+	{
+		test_fail "invalid message body extracted";
+	}
+
+	if body :raw :is "Test"
+	{
+		test_fail "body test matches nonsense";
+	}
+}
+
+/* Default comparator and match type
+ *
+ *  RFC 5173:
+ *    'The COMPARATOR and MATCH-TYPE keyword parameters are defined in
+ *     [SIEVE].  As specified in Sections 2.7.1 and 2.7.3 of [SIEVE], the
+ *     default COMPARATOR is "i;ascii-casemap" and the default MATCH-TYPE is
+ *     ":is".'
+ */
+
+test "Defaults" {
+	if anyof ( body :raw "Test", body :raw "*Test*" ) {
+		test_fail "default match type is not :is as is required";
+	}
+
+	if allof( not body :raw :contains "tesT", body :raw :contains "Test" ) {
+		test_fail "default comparator is not i;ascii-casemap as is required";
+	}
+}
+
+/* No body
+ *
+ *  RFC 5173:
+ *    'If a message consists of a header only, not followed by an empty line, 
+ *     then that set is empty and all "body" tests return false, including 
+ *     those that test for an empty string.  (This is similar to how the 
+ *     "header" test always fails when the named header fields aren't present.)'
+ */
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: tss@iki.fi
+Subject: No body is here!
+.
+;
+
+test "No body" {
+	if body :raw :contains "" {
+		test_fail "matched against non-existant body (:contains \"\")";
+	}
+
+	if body :raw :is "" {
+		test_fail "matched against non-existant body (:is \"\")";
+	}
+
+	if body :raw :matches "*" {
+		test_fail "matched against non-existant body (:matches \"*\")";
+	}
+}
+
+/*
+ *
+ */
+
+test_set "message" text:
+From: Whomever <whomever@domain.dom>
+To: Someone <someone@domain.com>
+Date: Fri, 08 Aug 2008 10:14:34 -0700
+Subject: whatever
+Content-Type: multipart/mixed; boundary=outer
+
+This is a multi-part message in MIME format.
+
+--outer
+Content-Type: multipart/alternative; boundary=inner
+
+This is a nested multi-part message in MIME format.
+
+--inner
+Content-Type: text/plain; charset="us-ascii"
+
+Hello
+
+--inner
+Content-Type: text/html; charset="us-ascii"
+
+<html><body>Hello</body></html>
+
+--inner--
+
+This is the end of the inner MIME multipart.
+
+--outer
+Content-Type: message/rfc822
+From: Someone Else <someone.else@domain.dom>
+Subject: hello request
+
+Please say Hello
+
+--outer--
+
+This is the end of the outer MIME multipart.
+.
+;
+
+test "RFC nested example - :content \"text\"" {
+	if not body :content "text" :contains "html" {
+		test_fail "failed to acquire nested MIME body part (1)";	
+	}
+
+	if not body :content "text/html" :contains "hello" {
+		test_fail "failed to acquire nested MIME body part (2)";	
+	}
+	
+	if not body :content "text/plain" :contains "hello" {
+        test_fail "failed to acquire nested MIME body part (3)";
+    }
+
+	if not body :content "text" :contains "hello" {
+        test_fail "failed to acquire nested MIME body part (4)";
+    }
+
+/* FIXME: fails
+	if not body :content "text" :count "eq" :comparator "i;ascii-numeric" "2" {
+		test_fail "matched wrong number of \"text/*\" body parts";
+	}*/
+}
+
+/* FIXME: fails
+test "RFC nested example - :content \"multipart\"" {
+	if not body :content "multipart" :contains
+		"This is a multi-part message in MIME format" {
+		test_fail "missed first multipart body part";
+	}
+
+	if not body :content "multipart" :contains
+		"This is a nested multi-part message in MIME format" {
+		test_fail "missed second multipart body part";
+	}
+	
+	if not body :content "multipart" :contains
+		"This is the end of the inner MIME multipart" {
+		test_fail "missed third multipart body part";
+	}
+
+	if not body :content "multipart" :contains
+		"This is the end of the outer MIME multipart." {
+		test_fail "missed fourth multipart body part";
+	}	
+}*/
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/body/match-values.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/body/match-values.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/body/match-values.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/body/match-values.svtest	2008-08-25 10:25:08.000000000 +0200
@@ -0,0 +1,55 @@
+require "vnd.dovecot.testsuite";
+
+require "body";
+require "variables";
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: s.bosch@utwente.nl
+Subject: Body test
+
+The big bad body test.
+.
+;
+
+# Test whether body test ignores match values
+test "Match values disabled" {
+	if not body :raw :matches "The * bad * test*" {
+		test_fail "should have matched";
+	}
+
+	if anyof (
+		string :is "${1}" "big",
+		string :is "${2}" "body",
+		not string :is "${0}" "",
+		not string :is "${1}" "",
+		not string :is "${2}" "") {
+		test_fail "match values not disabled";
+	}
+}
+
+test "Match values re-enabled" {
+	if not header :matches "from" "*@*" {
+		test_fail "should have matched";
+	}
+
+	if anyof (
+		not string :is "${0}" "stephan@rename-it.nl",
+		not string :is "${1}" "stephan",
+		not string :is "${2}" "rename-it.nl" ) {
+		test_fail "match values not re-enabled properly.";
+	}
+}
+
+test "Match values retained" {
+	if not body :raw :matches "The * bad * test*" {
+		test_fail "should have matched";
+	}
+
+	if anyof (
+		not string :is "${0}" "stephan@rename-it.nl",
+		not string :is "${1}" "stephan",
+		not string :is "${2}" "rename-it.nl" ) {
+		test_fail "match values not retained after body test.";
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/date/basic.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/date/basic.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/date/basic.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/date/basic.svtest	2009-08-21 00:52:15.000000000 +0200
@@ -0,0 +1,41 @@
+require "vnd.dovecot.testsuite";
+require "date";
+require "variables";
+require "relational";
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: sirius@drunksnipers.com
+Subject: Frop!
+Date: Mon, 20 Jul 2009 21:44:43 +0300
+Delivery-Date: Mon, 22 Jul 2009 23:30:14 +0300
+Invalid-Date: Moo, 34 Juul 3060 25:30:42 +6600
+Wanna date?
+.
+;
+
+test "Defaults" {
+	if not date :originalzone "date" "std11" "mon, 20 jul 2009 21:44:43 +0300" {
+		test_fail "default comparator is not i;ascii-casemap";	
+	}
+
+	if anyof ( date "date" "std11" "Mon", date "date" "std11" "*") {
+		test_fail "default match type appears to be :contains or :matches";
+	}
+}
+
+test "Count" {
+	if not date :count "eq" "date" "date" "1" {
+		test_fail "count of existing date header field is not 1";	
+	}
+
+	if not date :count "eq" "resent-date" "date" "0" {
+		test_fail "count of non-existent date header field is not 0";	
+	}
+}
+
+test "Invalid" {
+	if date :matches "invalid-date" "std11" "*" {
+		test_fail "matched invalid date: ${0}";	
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/date/date-parts.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/date/date-parts.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/date/date-parts.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/date/date-parts.svtest	2009-08-21 00:52:15.000000000 +0200
@@ -0,0 +1,120 @@
+require "vnd.dovecot.testsuite";
+require "date";
+require "variables";
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: sirius@drunksnipers.com
+Subject: Frop!
+Date: Mon, 20 Jul 2009 21:44:43 +0300
+Delivery-Date: Mon, 22 Jul 2009 23:30:14 +0300
+
+Wanna date?
+.
+;
+
+/* "year"      => the year, "0000" .. "9999". */
+test "Year" {
+	if not date :originalzone "date" "year" "2009" {
+		test_fail "failed to extract year part";
+	}
+}
+
+/* "month"     => the month, "01" .. "12". */
+test "Month" {
+	if not date :originalzone "date" "month" "07" {
+		test_fail "failed to extract month part";
+	}
+}
+
+/* "day"       => the day, "01" .. "31". */
+test "Day" {
+	if not date :originalzone "date" "day" "20" {
+		test_fail "failed to extract day part";
+	}
+}
+
+/* "date"      => the date in "yyyy-mm-dd" format. */
+test "Date" {
+	if not date :originalzone "date" "date" "2009-07-20" {
+		test_fail "failed to extract date part";
+	}
+}
+
+/* "julian"    => the Modified Julian Day, that is, the date
+              expressed as an integer number of days since
+              00:00 UTC on November 17, 1858 (using the Gregorian
+              calendar).  This corresponds to the regular
+              Julian Day minus 2400000.5.  */
+test "Julian" {
+	if not date :originalzone "date" "julian" "55032" {
+		if date :matches :originalzone "date" "julian" "*" { }
+		test_fail "failed to extract julian part: ${0}";
+	}
+	if not date :originalzone "delivery-date" "julian" "55034" {
+		if date :matches :originalzone "delivery-date" "julian" "*" { }
+		test_fail "failed to extract julian part: ${0}";
+	}
+}
+
+/* "hour"      => the hour, "00" .. "23". */
+test "Hour" {
+	if not date :originalzone "date" "hour" "21" {
+		test_fail "failed to extract hour part";
+	}
+}
+
+/* "minute"    => the minute, "00" .. "59". */
+test "Minute" {
+	if not date :originalzone "date" "minute" "44" {
+		test_fail "failed to extract minute part";
+	}
+}
+
+/* "second"    => the second, "00" .. "60". */
+test "Second" {
+	if not date :originalzone "date" "second" "43" {
+		test_fail "failed to extract second part";
+	}
+}
+
+/* "time"      => the time in "hh:mm:ss" format. */
+test "Time" {
+	if not date :originalzone "date" "time" "21:44:43" {
+		test_fail "failed to extract time part";
+	}
+}
+
+/* "iso8601"   => the date and time in restricted ISO 8601 format. */
+test "ISO8601" {
+	if not date :originalzone "date" "iso8601" "2009-07-20T21:44:43+03:00" {
+		test_fail "failed to extract iso8601 part";
+	}
+}
+
+/* "std11"     => the date and time in a format appropriate
+                  for use in a Date: header field [RFC2822]. */
+test "STD11" {
+	if not date :originalzone "date" "std11" "Mon, 20 Jul 2009 21:44:43 +0300" {
+		test_fail "failed to extract std11 part";
+	}
+}
+
+/* "zone"      => the time zone in use.  */
+test "zone" {
+	if not date :originalzone "date" "zone" "+0300" {
+		test_fail "failed to extract zone part";
+	}
+
+	if not date :zone "+0200" "date" "zone" "+0200" {
+		test_fail "failed to extract zone part";
+	}
+}
+
+/* "weekday"   => the day of the week expressed as an integer between
+                  "0" and "6". "0" is Sunday, "1" is Monday, etc. */
+test "Weekday" {
+	if not date :originalzone "date" "weekday" "1" {
+		test_fail "failed to extract weekday part";
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/date/zones.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/date/zones.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/date/zones.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/date/zones.svtest	2009-08-21 00:52:15.000000000 +0200
@@ -0,0 +1,76 @@
+require "vnd.dovecot.testsuite";
+require "date";
+require "variables";
+
+/* Extract local timezone first */
+test "Local-Zone" {
+	if not currentdate :matches "zone" "*" {
+		test_fail "matches '*' failed for zone part.";
+	}
+	set "local_zone" "${0}";	
+}
+
+/* FIXME: using variables somehow fails here */
+if string "${local_zone}" "+0200" {
+test_set "message" text:
+From: stephan@rename-it.nl
+To: sirius@drunksnipers.com
+Subject: Frop!
+Date: Mon, 20 Jul 2009 21:44:43 +0300
+Delivery-Date: Mon, 23 Jul 2009 05:30:14 +0800
+
+Wanna date?
+.
+;
+} else {
+test_set "message" text:
+From: stephan@rename-it.nl
+To: sirius@drunksnipers.com
+Subject: Frop!
+Date: Mon, 20 Jul 2009 21:44:43 +0300
+Delivery-Date: Mon, 22 Jul 2009 23:30:14 +0200
+
+Wanna date?
+.
+;
+}
+
+test "Specified Zone" {
+	if not date :zone "+0200" "date" "zone" "+0200" {
+		if date :matches :zone "+0200" "date" "zone" "*" {}
+		test_fail "zone is incorrect: ${0}";	
+	}
+
+	if not date :zone "+0200" "date" "time" "20:44:43" {
+		test_fail "zone is not applied";	
+	}
+}
+
+test "Original Zone" {
+	if not date :originalzone "date" "zone" "+0300" {
+		if date :matches :originalzone "date" "zone" "*" {}
+		test_fail "zone is incorrect: ${0}";	
+	}
+
+	if not date :originalzone "date" "time" "21:44:43" {
+		test_fail "time should be left untouched";	
+	}
+}
+
+test "Local Zone Shift" {
+	if anyof ( 
+			allof ( 
+				string "${local_zone}" "+0200",
+				date "delivery-date" "iso8601" "2009-07-23T05:30:14+08:00"),
+			allof ( 
+				not string "${local_zone}" "+0200",
+				date "delivery-date" "iso8601" "2009-07-22T23:30:14+02:00")) {
+	
+		if date :matches "delivery-date" "iso8601" "*" 
+			{ set "a" "${0}"; }
+		if date :originalzone :matches "delivery-date" "iso8601" "*" 
+			{ set "b" "${0}"; }
+
+		test_fail "time not shifted to local zone: ${b} => ${a}";
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/encoded-character.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/encoded-character.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/encoded-character.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/encoded-character.svtest	2008-08-01 16:50:38.000000000 +0200
@@ -0,0 +1,180 @@
+require "vnd.dovecot.testsuite";
+
+require "encoded-character";
+require "variables";
+
+test "HEX equality one" {
+	if not string "${hex:42}" "B" {
+		test_fail "failed to match the string 'B'";
+	}
+
+	if string "${hex:42}" "b" {
+		test_fail "matched nonsense";
+	}
+
+	if string "${hex:42}" "" {
+		test_fail "substitution failed";
+	}
+}
+
+test "HEX equality one middle" {
+	if not string " ${hex:42} " " B " {
+		test_fail "failed to match the string ' B '";
+	}
+
+	if string " ${hex:42} " " b " {
+		test_fail "matched nonsense";
+	}
+
+	if string " ${hex:42} " "  " {
+		test_fail "substitution failed";
+	}
+}
+
+test "HEX equality one begin" {
+	if not string "${hex:42} " "B " {
+		test_fail "failed to match the string 'B '";
+	}
+
+	if string "${hex:42} " " b" {
+		test_fail "matched nonsense";
+	}
+
+	if string "${hex:42} " " " {
+		test_fail "substitution failed";
+	}
+}
+
+test "HEX equality one end" {
+	if not string " ${hex:42}" " B" {
+		test_fail "failed to match the string ' B'";
+	}
+
+	if string " ${hex:42}" " b " {
+		test_fail "matched nonsense";
+	}
+
+	if string " ${hex:42}" " " {
+		test_fail "substitution failed";
+	}
+}
+
+test "HEX equality two triple" {
+	if not string "${hex:42 61 64}${hex: 61 73 73}" "Badass" {
+		test_fail "failed to match the string 'Badass'";
+	}
+
+	if string "${hex:42 61 64}${hex: 61 73 73}" "Sadass" {
+		test_fail "matched nonsense";
+	}
+
+	if string "${hex:42 61 64}${hex: 61 73 73}" "" {
+		test_fail "substitution failed";
+	}
+}
+
+test "HEX equality braindead" {
+	if not string "${hex:42 72 61 69 6E 64 65 61 64}" "Braindead" {
+		test_fail "failed to match the string 'Braindead'";
+	}
+
+	if string "${hex:42 72 61 69 6E 64 65 61 64}" "Brian Nut" {
+		test_fail "matched nonsense";
+	}
+}
+
+test "Syntax errors" {
+	if anyof( not string "$" "${hex:24}", not string "$ " "${hex:24} ", not string " $" " ${hex:24}" ) {
+        test_fail "loose $ handled inappropriately";
+    }
+
+	if anyof( not string "${" "${hex:24}{", not string "a${" "a${hex:24}{", not string "${a" "${hex:24}{a" ) {
+        test_fail "loose ${ handled inappropriately";
+    }
+
+	if anyof( not string "${}" "${hex:24}{}", not string "b${}" "b${hex:24}{}", not string "${}b" "${hex:24}{}b" ) {
+		test_fail "entirely missing content handled inappropriately";
+	}
+		
+	if not string "${:}" "${hex:24}{:}" {
+        test_fail "missing content handled inappropriately";
+    }
+	
+	if not string "${hex:}" "${hex:24}{hex:}" {
+        test_fail "missing hex content handled inappropriately";
+    }
+
+	if not string "${unicode:}" "${hex:24}{unicode:}" {
+        test_fail "missing unicode content handled inappropriately";
+    }
+
+	if not string "${hex:sss}" "${hex:24}{hex:sss}" {
+        test_fail "erroneous hex content handled inappropriately";
+    }
+
+    if not string "${unicode:ttt}" "${hex:24}{unicode:ttt}" {
+        test_fail "erroneous unicode content handled inappropriately";
+    }
+	
+	if not string "${hex:aa aa" "${hex:24}{hex:aa aa" {
+        test_fail "unterminated hex content handled inappropriately";
+    }
+
+    if not string "${unicode: aaaa aaaa" "${hex:24}{unicode: aaaa aaaa" {
+        test_fail "unterminated unicode content handled inappropriately";
+    }
+}
+
+/*
+ * RFC Examples
+ */
+
+test "RFC Examples" {
+	if not string "$${hex:40}" "$@" {
+		test_fail "failed RFC example 1";
+	}
+
+	if not string "${hex: 40 }" "@" {
+		test_fail "failed RFC example 2";
+	}
+
+	if not string "${HEX: 40}" "@" {
+		test_fail "failed RFC example 3";
+	}
+	
+	if not string "${hex:40" "${hex:40" {
+		test_fail "failed RFC example 4";
+	}
+
+	if not string "${hex:400}" "${hex:400}" {
+		test_fail "failed RFC example 5";
+	}
+
+	if not string "${hex:4${hex:30}}" "${hex: 24}{hex:40}" {
+		test_fail "failed RFC example 6";
+	}
+
+	if not string "${unicode:40}" "@" {
+		test_fail "failed RFC example 7";
+	}
+     
+	if not string "${ unicode:40}" "${ unicode:40}" {
+		test_fail "failed RFC example 8";
+	}
+
+	if not string "${UNICODE:40}" "@" {
+		test_fail "failed RFC example 9";
+	}
+
+	if not string "${UnICoDE:0000040}" "@" {
+		test_fail "failed RFC example 10";
+	}
+
+	if not string "${Unicode:40}" "@" {
+		test_fail "failed RFC example 11";
+	}
+
+	if not string "${Unicode:Cool}" "${Unicode:Cool}" {
+		test_fail "failed RFC example 12";
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/enotify/basic.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/enotify/basic.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/enotify/basic.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/enotify/basic.svtest	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,15 @@
+require "vnd.dovecot.testsuite";
+require "enotify";
+
+test "Execute" {
+	/* Test to catch runtime segfaults */
+	if valid_notify_method 
+		"mailto:stephan@example.com" {
+
+		/* Test to catch runtime segfaults */
+		notify 
+			:message "This is probably very important"
+			:importance "1" 
+			"mailto:stephan@example.com%2cstephan@rename-it.nl?subject=Important%20message%20received";
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/enotify/encodeurl.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/enotify/encodeurl.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/enotify/encodeurl.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/enotify/encodeurl.svtest	2008-11-28 22:33:49.000000000 +0100
@@ -0,0 +1,11 @@
+require "vnd.dovecot.testsuite";
+require "variables";
+require "enotify";
+
+test "Encode Simple" {
+	set :encodeurl "url_data" "\\frop\\&fruts/^@";
+
+	if not string :is :comparator "i;octet" "${url_data}" "%5Cfrop%5C%26fruts%2F%5E%40" {
+		test_fail "url data encoded incorrectly '${url_data}'";
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/enotify/errors/from-mailto.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/enotify/errors/from-mailto.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/enotify/errors/from-mailto.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/enotify/errors/from-mailto.sieve	2009-07-19 15:54:39.000000000 +0200
@@ -0,0 +1,7 @@
+require "enotify";
+
+# 1: Invalid from address
+notify :from "stephan#rename-it.nl" "mailto:stephan@example.com";
+
+# 2: Empty from address
+notify :from "" "mailto:stephan@example.com";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/enotify/errors/options.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/enotify/errors/options.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/enotify/errors/options.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/enotify/errors/options.sieve	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,18 @@
+require "enotify";
+
+# 1: empty option
+notify :options "" "mailto:stephan@rename-it.nl";
+
+# 2: invalid option name syntax
+notify :options "frop" "mailto:stephan@rename-it.nl";
+
+# 3: invalid option name syntax
+notify :options "_frop=" "mailto:stephan@rename-it.nl";
+
+# 4: invalid option name syntax
+notify :options "=frop" "mailto:stephan@rename-it.nl";
+
+# 5: invalid value
+notify :options "frop=frml
+frop" "mailto:stephan@rename-it.nl";
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/enotify/errors/uri-mailto.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/enotify/errors/uri-mailto.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/enotify/errors/uri-mailto.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/enotify/errors/uri-mailto.sieve	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,20 @@
+require "enotify";
+
+# 1: Invalid character in to part
+notify "mailto:stephan@rename-it.nl;?header=frop";
+
+# 2: Invalid character in hname
+notify "mailto:stephan@rename-it.nl?header<=frop";
+
+# 3: Invalid character in hvalue
+notify "mailto:stephan@rename-it.nl?header=fr>op";
+
+# 4: Invalid header name 
+notify "mailto:stephan@rename-it.nl?header:=frop";
+
+# 5: Invalid recipient
+notify "mailto:stephan%23rename-it.nl";
+
+# 6: Invalid to header recipient
+notify "mailto:stephan@rename-it.nl?to=nico%23vestingbar.nl";
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/enotify/errors/uri.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/enotify/errors/uri.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/enotify/errors/uri.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/enotify/errors/uri.sieve	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,5 @@
+require "enotify";
+
+# 1: Invalid url scheme
+notify "snailto:stephan@rename-it.nl";
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/enotify/errors.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/enotify/errors.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/enotify/errors.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/enotify/errors.svtest	2009-07-19 15:54:39.000000000 +0200
@@ -0,0 +1,45 @@
+require "vnd.dovecot.testsuite";
+require "comparator-i;ascii-numeric";
+require "relational";
+
+require "enotify";
+
+test "Invalid URI (FIXME: count only)" {
+	if test_script_compile "errors/uri.sieve" {
+		test_fail "compile should have failed";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "2" {
+		test_fail "wrong number of errors reported";
+	}
+}
+
+test "Invalid mailto URI (FIXME: count only)" {
+	if test_script_compile "errors/uri-mailto.sieve" {
+		test_fail "compile should have failed";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "7" {
+		test_fail "wrong number of errors reported";
+	}
+}
+
+test "Invalid mailto :from address (FIXME: count only)" {
+	if test_script_compile "errors/from-mailto.sieve" {
+		test_fail "compile should have failed";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "3" {
+		test_fail "wrong number of errors reported";
+	}
+}
+
+test "Invalid :options argument (FIXME: count only)" {
+	if test_script_compile "errors/options.sieve" {
+		test_fail "compile should have failed";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "6" {
+		test_fail "wrong number of errors reported";
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/enotify/execute/draft-rfc-ex1.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/enotify/execute/draft-rfc-ex1.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/enotify/execute/draft-rfc-ex1.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/enotify/execute/draft-rfc-ex1.sieve	2008-11-21 22:05:14.000000000 +0100
@@ -0,0 +1,26 @@
+require ["enotify", "fileinto", "variables"];
+
+if header :contains "from" "boss@example.org" {
+	notify :importance "1"
+		:message "This is probably very important"
+		"mailto:alm@example.com";
+	# Don't send any further notifications
+	stop;
+}
+
+if header :contains "to" "sievemailinglist@example.org" {
+	# :matches is used to get the value of the Subject header
+	if header :matches "Subject" "*" {
+		set "subject" "${1}";
+	}
+
+	# :matches is used to get the value of the From header
+	if header :matches "From" "*" {
+		set "from" "${1}";
+	}
+
+	notify :importance "3"
+		:message "[SIEVE] ${from}: ${subject}"
+		"mailto:alm@example.com";
+	fileinto "INBOX.sieve";
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/enotify/execute/draft-rfc-ex2.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/enotify/execute/draft-rfc-ex2.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/enotify/execute/draft-rfc-ex2.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/enotify/execute/draft-rfc-ex2.sieve	2008-11-21 22:05:14.000000000 +0100
@@ -0,0 +1,22 @@
+require ["enotify", "fileinto", "variables", "envelope"];
+
+if header :matches "from" "*@*.example.org" {
+	# :matches is used to get the MAIL FROM address
+	if envelope :all :matches "from" "*" {
+		set "env_from" " [really: ${1}]";
+	}
+
+	# :matches is used to get the value of the Subject header
+	if header :matches "Subject" "*" {
+		set "subject" "${1}";
+	}
+
+	# :matches is used to get the address from the From header
+	if address :matches :all "from" "*" {
+		set "from_addr" "${1}";
+	}
+
+	notify :message "${from_addr}${env_from}: ${subject}"
+		"mailto:alm@example.com";
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/enotify/execute/draft-rfc-ex3.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/enotify/execute/draft-rfc-ex3.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/enotify/execute/draft-rfc-ex3.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/enotify/execute/draft-rfc-ex3.sieve	2008-11-21 22:05:14.000000000 +0100
@@ -0,0 +1,31 @@
+require ["enotify", "variables"];
+
+set "notif_method"
+	"xmpp:tim@example.com?message;subject=SIEVE;body=You%20got%20mail";
+
+if header :contains "subject" "Your dog" {
+	set "notif_method" "tel:+14085551212";
+}
+
+if header :contains "to" "sievemailinglist@example.org" {
+	set "notif_method" "";
+}
+
+if not string :is "${notif_method}" "" {
+	notify "${notif_method}";
+}
+
+if header :contains "from" "boss@example.org" {
+	# :matches is used to get the value of the Subject header
+	if header :matches "Subject" "*" {
+		set "subject" "${1}";
+	}
+
+	# don't need high importance notification for
+	# a 'for your information'
+	if not header :contains "subject" "FYI:" {
+		notify :importance "1" :message "BOSS: ${subject}"
+			"tel:+14085551212";
+	}
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/enotify/execute/draft-rfc-ex5.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/enotify/execute/draft-rfc-ex5.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/enotify/execute/draft-rfc-ex5.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/enotify/execute/draft-rfc-ex5.sieve	2008-11-21 22:05:14.000000000 +0100
@@ -0,0 +1,11 @@
+require ["enotify"];
+
+if notify_method_capability
+	"xmpp:tim@example.com?message;subject=SIEVE"
+	"Online"
+	"yes" {
+	notify :importance "1" :message "You got mail"
+		"xmpp:tim@example.com?message;subject=SIEVE";
+} else {
+	notify :message "You got mail" "tel:+14085551212";
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/enotify/execute/draft-rfc-ex6.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/enotify/execute/draft-rfc-ex6.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/enotify/execute/draft-rfc-ex6.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/enotify/execute/draft-rfc-ex6.sieve	2008-11-21 22:05:14.000000000 +0100
@@ -0,0 +1,5 @@
+require ["enotify", "variables"];
+
+set :encodeurl "body_param" "Safe body&evil=evilbody";
+
+notify "mailto:tim@example.com?body=${body_param}";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/enotify/execute/duplicates.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/enotify/execute/duplicates.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/enotify/execute/duplicates.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/enotify/execute/duplicates.sieve	2009-01-21 23:50:11.000000000 +0100
@@ -0,0 +1,4 @@
+require "enotify";
+
+notify :message "Incoming stupidity." "mailto:stephan@rename-it.nl%2cstephan@drunksnipers.com%2cidiot@rename-it.nl";
+notify :message "There it is." "mailto:tss@iki.fi%2cstephan@rename-it.nl%2cidiot@rename-it.nl%2cnico@vestingbar.nl%2cstephan@drunksnipers.com";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/enotify/execute.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/enotify/execute.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/enotify/execute.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/enotify/execute.svtest	2009-01-21 23:50:11.000000000 +0100
@@ -0,0 +1,99 @@
+require "vnd.dovecot.testsuite";
+require "relational";
+
+
+/*
+ * Execution testing (currently just meant to trigger any segfaults)
+ */
+
+test "RFC Example 1" {
+	if not test_script_compile "execute/draft-rfc-ex1.sieve" {
+		test_fail "script compile failed";
+	}
+
+	if not test_script_run {
+		test_fail "script run failed";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed";
+	}
+}
+
+test "RFC Example 2" {
+	if not test_script_compile "execute/draft-rfc-ex2.sieve" {
+		test_fail "script compile failed";
+	}
+
+	if not test_script_run {
+		test_fail "script execute failed";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed";
+	}
+}
+
+/* tel: not supported
+test "RFC Example 3" {
+	if not test_script_compile "execute/draft-rfc-ex3.sieve" {
+		test_fail "script compile failed";
+	}
+
+	if not test_script_run {
+		test_fail "script execute failed";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed";
+	}
+}
+*/
+
+/* tel: and xmmp: not supported
+test "RFC Example 5" {
+	if not test_script_compile "execute/draft-rfc-ex5.sieve" {
+		test_fail "script compile failed";
+	}
+
+	if not test_script_run {
+		test_fail "script execute failed";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed";
+	}
+}
+*/
+
+test "RFC Example 6" {
+	if not test_script_compile "execute/draft-rfc-ex6.sieve" {
+		test_fail "script compile failed";
+	}
+
+	if not test_script_run {
+		test_fail "script execute failed";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed";
+	}
+}
+
+test "Duplicate recipients" {
+	if not test_script_compile "execute/duplicates.sieve" {
+		test_fail "script compile failed";
+	}
+
+	if not test_script_run {
+		test_fail "script execute failed";
+	}
+
+	if test_result :count "ne" "2" {
+		test_fail "second notify action was discarded entirely";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed";
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/enotify/mailto.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/enotify/mailto.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/enotify/mailto.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/enotify/mailto.svtest	2009-07-21 13:08:06.000000000 +0200
@@ -0,0 +1,302 @@
+require "vnd.dovecot.testsuite";
+require "enotify";
+require "relational";
+require "envelope";
+require "comparator-i;ascii-numeric";
+
+/*
+ * Simple test
+ */
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Subject: Frop!
+
+Klutsefluts.
+.
+;
+
+test "Simple" {
+	notify "mailto:stephan@rename-it.nl";
+
+	if not test_result_execute {
+		test_fail "failed to execute notify";
+	}
+
+	test_message :smtp 0;
+
+	if not header :matches "Auto-Submitted" "auto-notified*" {
+		test_fail "auto-submitted header set inappropriately";
+	}
+
+	if not exists "X-Sieve" {
+		test_fail "x-sieve header missing from outgoing message";
+	}
+}
+
+/*
+ * Multiple recipients
+ */
+
+test_result_reset;
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Subject: Frop!
+
+Klutsefluts.
+.
+;
+
+test "Multiple recipients" {
+	notify "mailto:timo@example.com%2cstephan@dovecot.org?cc=postmaster@vestingbar.nl&subject=Frop%20received";
+
+	if not test_result_execute {
+		test_fail "failed to execute notify";
+	}
+
+	test_message :smtp 0;
+
+	if not address :is "to" "timo@example.com" {
+		test_fail "first To address missing";
+	}
+
+	if not address :is "to" "stephan@dovecot.org" {
+		test_fail "second To address missing";
+	}
+
+	if not address :is "cc" "postmaster@vestingbar.nl" {
+		test_fail "first Cc address missing";
+	}
+
+	if not address :count "eq" :comparator "i;ascii-numeric" "to" "2" {
+		test_fail "too many recipients in To header";
+	} 
+
+	if not address :count "eq" :comparator "i;ascii-numeric" "cc" "1" {
+		test_fail "too many recipients in Cc header";
+	} 
+
+	if not header "subject" "Frop received" {
+		test_fail "subject header set incorrectly";
+	}
+
+	test_message :smtp 1;
+
+	if not header :matches "Auto-Submitted" "auto-notified*" {
+		test_fail "auto-submitted header not found for second message";
+	}
+
+	test_message :smtp 2;
+
+	if not header :matches "Auto-Submitted" "auto-notified*" {
+		test_fail "auto-submitted header not found for third message";
+	}
+}
+
+/*
+ * Duplicate recipients
+ */
+
+test_result_reset;
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Subject: Frop!
+
+Klutsefluts.
+.
+;
+
+test "Duplicate recipients" {
+	notify "mailto:timo@example.com%2cstephan@dovecot.org?cc=stephan@dovecot.org";
+	notify "mailto:stephan@rename-it.nl?cc=timo@example.com";
+
+	if not test_result_execute {
+		test_fail "failed to execute notify";
+	}
+
+	test_message :smtp 0;
+
+	if address "Cc" "stephan@dovecot.org" {
+		test_fail "duplicate recipient not removed from first message";
+	}
+
+	test_message :smtp 1;
+
+	if address "Cc" "timo@example.com" {
+		test_fail "duplicate recipient not removed from second message";
+	}
+}
+
+
+/*
+ * Notifying on automated messages
+ */
+
+test_result_reset;
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Auto-submitted: auto-notify
+Subject: Frop!
+
+Klutsefluts.
+.
+;
+
+test "Notifying on automated messages" {
+	notify "mailto:stephan@rename-it.nl?cc=timo@example.com";
+
+	if not test_result_execute {
+		test_fail "failed to execute notify";
+	}
+
+	if test_message :smtp 0 {
+		test_fail "notified of auto-submitted message";
+	}
+}
+
+/*
+ * Envelope
+ */
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Subject: Frop!
+
+Klutsefluts.
+.
+;
+
+test_result_reset;
+
+test_set "envelope.from" "sirius@rename-it.nl";
+test_set "envelope.to" "bertus@vestingbar.nl";
+
+test "Envelope" {
+	notify "mailto:stephan@rename-it.nl?cc=timo@example.com";
+
+	if not test_result_execute {
+		test_fail "failed to execute notify";
+	}
+
+	test_message :smtp 0;
+
+	if not envelope :localpart :is "from" "postmaster" {
+		test_fail "envelope sender set incorrectly";
+	}
+
+	if not envelope :is "to" "stephan@rename-it.nl" {
+		test_fail "envelope sender set incorrectly";
+	}
+
+	test_message :smtp 1;
+
+	if not envelope :localpart :is "from" "postmaster" {
+		test_fail "envelope sender set incorrectly";
+	}
+
+	if not envelope :is "to" "timo@example.com" {
+		test_fail "envelope sender set incorrectly";
+	}	
+}
+
+/* 
+ * Envelope :from 
+ */
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Subject: Frop!
+
+Klutsefluts.
+.
+;
+
+test_set "envelope.from" "sirius@rename-it.nl";
+test_set "envelope.to" "bertus@vestingbar.nl";
+
+test_result_reset;
+
+test "Envelope :from" {
+	notify :from "nico@vestingbar.nl"
+		"mailto:stephan@rename-it.nl?cc=timo@example.com";
+
+	if not test_result_execute {
+		test_fail "failed to execute notify";
+	}
+
+	test_message :smtp 0;
+
+	if not envelope :is "from" "nico@vestingbar.nl" {
+		test_fail "envelope sender set incorrectly";
+	}
+
+	if not envelope :is "to" "stephan@rename-it.nl" {
+		test_fail "envelope sender set incorrectly";
+	}
+
+	test_message :smtp 1;
+
+	if not envelope :is "from" "nico@vestingbar.nl" {
+		test_fail "envelope sender set incorrectly";
+	}
+
+	if not envelope :is "to" "timo@example.com" {
+		test_fail "envelope sender set incorrectly";
+	}	
+}
+
+/* 
+ * Envelope <> 
+ */
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Subject: Frop!
+
+Klutsefluts.
+.
+;
+
+test_set "envelope.from" "<>";
+test_set "envelope.to" "bertus@vestingbar.nl";
+
+test_result_reset;
+
+test "Envelope <>" {
+	notify :from "nico@vestingbar.nl"
+		"mailto:stephan@rename-it.nl?cc=timo@example.com";
+
+	if not test_result_execute {
+		test_fail "failed to execute notify";
+	}
+
+	test_message :smtp 0;
+
+	if not envelope :is "from" "" {
+		test_fail "envelope sender set incorrectly";
+	}
+
+	if not envelope :is "to" "stephan@rename-it.nl" {
+		test_fail "envelope sender set incorrectly";
+	}
+
+	test_message :smtp 1;
+
+	if not envelope :is "from" "" {
+		test_fail "envelope sender set incorrectly";
+	}
+
+	if not envelope :is "to" "timo@example.com" {
+		test_fail "envelope sender set incorrectly";
+	}	
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/enotify/notify_method_capability.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/enotify/notify_method_capability.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/enotify/notify_method_capability.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/enotify/notify_method_capability.svtest	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,12 @@
+require "vnd.dovecot.testsuite";
+require "enotify";
+
+test "Mailto" {
+	if not notify_method_capability :is "mailto:stephan@rename-it.nl" "online" "maybe" {
+		test_fail "test should have matched";
+	}
+
+	if notify_method_capability :is "mailto:stephan@rename-it.nl" "online" "yes" {
+		test_fail "test should not have matched";
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/enotify/valid_notify_method.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/enotify/valid_notify_method.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/enotify/valid_notify_method.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/enotify/valid_notify_method.svtest	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,31 @@
+require "vnd.dovecot.testsuite";
+
+require "enotify";
+
+test "Mailto: invalid header name" {
+	if valid_notify_method 
+		"mailto:stephan@rename-it.nl?header:=frop" {
+		test_fail "invalid uri accepted";
+	}
+}
+
+test "Mailto: invalid recipient" {
+	if valid_notify_method 
+		"mailto:stephan%23rename-it.nl" {
+		test_fail "invalid uri accepted";
+	}
+}
+
+test "Mailto: invalid to header recipient" {
+	if valid_notify_method
+		"mailto:stephan@rename-it.nl?to=nico%23vestingbar.nl" {
+		test_fail "invalid uri accepted";
+	}
+}
+
+test "Mailto: valid URI" {
+	if not valid_notify_method
+		"mailto:stephan@rename-it.nl" {
+		test_fail "valid uri denied";
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/envelope.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/envelope.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/envelope.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/envelope.svtest	2008-08-01 16:26:09.000000000 +0200
@@ -0,0 +1,218 @@
+require "vnd.dovecot.testsuite";
+
+require "envelope";
+
+/*
+ * Empty envelope addresses
+ */
+
+test "Envelope - from empty" {
+	/* Return_path: "" */
+
+	test_set "envelope.from" "";
+
+	if not envelope :all :is "from" "" {
+		test_fail "failed to (:all :is)-match a \"\" return path";
+	}
+
+	if not envelope :all :contains "from" "" {
+		test_fail "failed to (:all :contains)-match a \"\" return path";
+	}
+
+	if not envelope :domain :is "from" "" {
+		test_fail "failed to (:domain :is)-match a \"\" return path";
+	}
+
+	if not envelope :domain :contains "from" "" {
+		test_fail "failed to (:domain :contains)-match a \"\" return path";
+	}
+
+	/* Return path: <> */
+
+	test_set "envelope.from" "<>";
+
+	if not envelope :all :is "from" "" {
+		test_fail "failed to (:all :is)-match a <> return path";
+	}
+
+	if not envelope :all :contains "from" "" {
+		test_fail "failed to (:all :contains)-match a <> return path";
+	}
+
+	if not envelope :domain :is "from" "" {
+		test_fail "failed to (:domain :is)-match a <> return path";
+	}
+
+	if not envelope :domain :contains "from" "" {
+		test_fail "failed to (:domain :contains)-match a <> return path";
+	}
+
+	if envelope :all :is "from" "nico@vestingbar.nl" {
+		test_fail "envelope test matches nonsense";
+	}
+
+	/* Forward path: <> */
+
+    test_set "envelope.to" "<>";
+
+    if envelope :all :is "to" "" {
+        test_fail "successfully matched a <> forward path, which is wrong";
+    }
+}
+
+/*
+ * Invalid envelope addresses
+ */
+
+test "Envelope - invalid paths" {
+    /* Return_path: "hutsefluts" */
+
+	test_set "envelope.from" "hutsefluts";
+	test_set "envelope.to" "knurft";
+
+	if not envelope :all :is "from" "hutsefluts" {
+		test_fail ":all address part mangled syntactically incorrect reverse path";
+	}
+
+	if envelope :localpart :is "from" "hutsefluts" {
+        test_fail ":localpart address part matched syntactically incorrect reverse path";
+    }
+
+	if envelope :domain :contains "from" "" {
+        test_fail ":domain address part matched syntactically incorrect reverse path";
+    }
+
+	if not envelope :all :is "to" "knurft" {
+		test_fail ":all address part mangled syntactically incorrect forward path";
+	}
+
+	if envelope :localpart :is "to" "knurft" {
+        test_fail ":localpart address part matched syntactically incorrect forward path";
+    }
+
+	if envelope :domain :contains "to" "" {
+        test_fail ":domain address part matched syntactically incorrect forward path";
+    }
+}
+
+/*
+ * Syntax errors 
+ */
+
+test "Envelope - syntax errors" {
+	/* Control */
+	test_set "envelope.from" "<stephan@rename-it.nl>";
+	if not envelope :all :is "from" "stephan@rename-it.nl" {
+		test_fail "correct control test failed";
+	}
+
+	# Duplicate <
+	test_set "envelope.from" "<<stephan@rename-it.nl>";
+    if envelope :all :is "from" "stephan@rename-it.nl" {
+        test_fail "failed to recognize syntax error";
+    }
+
+	# Spurious >
+	test_set "envelope.from" "stephan@rename-it.nl>";
+    if envelope :all :is "from" "stephan@rename-it.nl" {
+        test_fail "failed to recognize syntax error";
+    }
+
+	# Missing >
+	test_set "envelope.from" "<stephan@rename-it.nl";
+    if envelope :all :is "from" "stephan@rename-it.nl" {
+        test_fail "failed to recognize syntax error";
+    }
+	
+	# No @
+	test_set "envelope.from" "<stephan rename-it.nl>";
+    if envelope :domain :contains "from" "" {
+        test_fail "failed to recognize syntax error";
+    }
+
+	# Duplicate @
+	test_set "envelope.from" "<stephan@@rename-it.nl>";
+    if envelope :domain :contains "from" "" {
+        test_fail "failed to recognize syntax error";
+    }
+}
+
+/*
+ * Ignoring source routes
+ */
+
+test "Envelope - source route" {
+	/* Single */
+	test_set "envelope.from" "<@cola.rename-it.nl:stephan@rename-it.nl>";
+	if not envelope :localpart :is "from" "stephan" {
+		test_fail "parsing path with source route (single) failed";
+
+	}
+
+	/* Dual */
+	test_set "envelope.from" "<@cola.rename-it.nl,@mx.utwente.nl:stephan@rename-it.nl>";
+	if not envelope :localpart :is "from" "stephan" {
+		test_fail "parsing path with source route (dual) failed";
+
+	}
+	
+	/* Multiple */
+	test_set "envelope.from" "<@cola.rename-it.nl,@mx.utwente.nl,@smtp.iki.fi:stephan@rename-it.nl>";
+	if not envelope :localpart :is "from" "stephan" {
+		test_fail "parsing path with source route (multiple) failed";
+
+	}
+
+	/* Bare */
+	test_set "envelope.from" "@cola.rename-it.nl,@mx.utwente.nl,@smtp.iki.fi:stephan@rename-it.nl";
+	if not envelope :domain :is "from" "rename-it.nl" {
+		test_fail "parsing path with source route (bare) failed";
+	}	
+
+	/* Whitespace */
+	test_set "envelope.from" "   < @ cola . rename-it . nl , @ mx . utwente .   nl , 	@ smtp  .  iki  . fi	:   stephan		@     rename-it   .		nl >  ";
+    if not envelope :domain :is "from" "rename-it.nl" {
+        test_fail "parsing path with source route (whitespace) failed";
+    }
+}
+
+test "Envelope - source route errors" {
+	test_set "envelope.to" "<cola.rename-it.nl:stephan@rename-it.nl>";
+	if envelope :domain :contains "to" "" {
+		test_fail "parsing syntactically incorrect path should have failed (1)";
+	}
+
+	test_set "envelope.to" "<@.rename-it.nl:stephan@rename-it.nl>";
+	if envelope :domain :contains "to" "" {
+		test_fail "parsing syntactically incorrect path should have failed (2)";
+	}
+
+	test_set "envelope.to" "<@cola..nl:stephan@rename-it.nl>";
+	if envelope :domain :contains "to" "" {
+		test_fail "parsing syntactically incorrect path should have failed (3)";
+	}
+
+	test_set "envelope.to" "<@cola.rename-it.nlstephan@rename-it.nl>";
+	if envelope :domain :contains "to" "" {
+		test_fail "parsing syntactically incorrect path should have failed (4)";
+	}
+
+	test_set "envelope.to" "<@cola.rename-it.nl@mx.utwente.nl:stephan@rename-it.nl>";
+	if envelope :domain :contains "to" "" {
+		test_fail "parsing syntactically incorrect path should have failed (5)";
+	}
+
+	test_set "envelope.to" "<@cola.rename-it.nl,mx.utwente.nl:stephan@rename-it.nl>";
+	if envelope :domain :contains "to" "" {
+		test_fail "parsing syntactically incorrect path should have failed (6)";
+	}
+
+	test_set "envelope.to" "<@cola.rename-it.nl,@mx.utwente.nl,stephan@rename-it.nl>";
+	if envelope :domain :contains "to" "" {
+		test_fail "parsing syntactically incorrect path should have failed (7)";
+	}
+
+	if not envelope :all :is "to" "<@cola.rename-it.nl,@mx.utwente.nl,stephan@rename-it.nl>" {
+		test_fail ":all address part mangled syntactically incorrect path";
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/environment/basic.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/environment/basic.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/environment/basic.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/environment/basic.svtest	2009-04-13 21:35:39.000000000 +0200
@@ -0,0 +1,26 @@
+require "vnd.dovecot.testsuite";
+require "environment";
+
+test "Name" {
+	if not environment :contains "name" "dovecot" {
+		test_fail "name environment returned invalid value";
+	}
+
+	if not environment :contains "name" "sieve" {
+		test_fail "name environment returned invalid value";
+	}
+
+	if environment :contains "name" "cyrus" {
+		test_fail "something is definitely wrong here";
+	}
+
+	if not environment :is :comparator "i;octet" "name" "Dovecot Sieve" {
+		test_fail "name environment does not match exactly with what is expected";
+	}
+}
+
+test "Host" {
+	if not environment "host" "testsuite.example.com" {
+		test_fail "wrong testsuite hostname";
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/environment/rfc.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/environment/rfc.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/environment/rfc.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/environment/rfc.svtest	2009-04-13 21:35:39.000000000 +0200
@@ -0,0 +1,28 @@
+require "vnd.dovecot.testsuite";
+require "environment";
+require "relational";
+
+test "Non-existant" {
+	if environment :contains "nonsense" "" {
+		test_fail "matched unknown environment item";	
+	}
+}
+
+test "Exists" {
+	if not environment :contains "version" "" {
+		test_fail "failed to match known environment item";
+	}
+}
+
+test "Count" {
+	if anyof (
+			environment :count "eq" "nonsense" "0",
+			environment :count "eq" "nonsense" "1"
+		) {
+		test_fail "count should not match unknown environment item";
+	}
+		
+	if not environment :count "eq" "host" "1" {
+		test_fail "count of non-empty environment should be 1";
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/imap4flags/basic.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/imap4flags/basic.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/imap4flags/basic.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/imap4flags/basic.svtest	2009-08-02 10:30:31.000000000 +0200
@@ -0,0 +1,108 @@
+require "vnd.dovecot.testsuite";
+
+require "imap4flags";
+require "relational";
+require "variables";
+require "comparator-i;ascii-numeric";
+
+/*
+ * Basic functionality tests
+ */
+
+test "Hasflag empty" {
+	if hasflag "\\Seen" {
+		test_fail "hasflag sees initial \\seen flag were there should be none";
+	}
+	if hasflag "\\draft" {
+		test_fail "hasflag sees initial \\draft flag were there should be none";
+	}
+	if hasflag "\\recent" {
+		test_fail "hasflag sees initial \\recent flag were there should be none";
+	}
+	if hasflag "\\flagged" {
+		test_fail "hasflag sees initial \\flagged flag were there should be none";
+	}
+	if hasflag "\\answered" {
+		test_fail "hasflag sees initial \\answered flag were there should be none";
+	}
+	if hasflag "\\deleted" {
+		test_fail "hasflag sees initial \\deleted flag were there should be none";
+	}
+
+	if hasflag :comparator "i;ascii-numeric" :count "ge" "1" {
+		test_fail "hasflag sees initial flags were there should be none";
+	}
+}
+
+test "Setflag; Hasflag one" {
+	setflag "\\seen";
+
+	if not hasflag "\\Seen" {
+		test_fail "flag not set of hasflag fails to see it";
+	}
+
+	if not hasflag :comparator "i;ascii-numeric" :count "eq" "1" {
+		test_fail "flag not set of hasflag fails to see it";
+	}
+
+	if hasflag "$Nonsense" {
+		test_fail "hasflag sees other flag that the one set";
+	}
+}
+
+test "Hasflag; duplicates" {
+	set "Flags" "A B C D E F A B C D E F";
+
+	if hasflag :comparator "i;ascii-numeric" :count "gt" "Flags" "6" {
+		test_fail "hasflag must ignore duplicates";
+	}
+
+	if not hasflag :comparator "i;ascii-numeric" :count "eq" "Flags" "6" {
+		test_fail "hasflag :count gives strange results";
+	}
+}
+
+test "Flag operations" {
+	setflag "A";
+
+	if not hasflag "A" {
+		test_fail "hasflag misses set flag";
+	}
+
+	if hasflag :comparator "i;ascii-numeric" :count "gt" "1" {
+		test_fail "hasflag sees more than one flag";
+	}
+
+	addflag "B";
+
+	if not hasflag "B" {
+		test_fail "flag \"B\" not added";
+	}
+	
+	if not hasflag "A" {
+		test_fail "flag \"A\" not retained";
+	}
+
+	if hasflag :comparator "i;ascii-numeric" :count "gt" "2" {
+                test_fail "hasflag sees more than two flags";
+        }
+
+	addflag ["C", "D", "E F"];	
+
+	if not hasflag :comparator "i;ascii-numeric" :count "eq" "6" {
+                test_fail "hasflag sees more than two flags";
+        }
+
+	removeflag ["D"];
+
+	if not hasflag :comparator "i;ascii-numeric" :count "eq" "5" {
+                test_fail "hasflag sees more than two flags";
+        }	
+	
+	if hasflag "D" {
+		test_fail "removed flag still present";
+	}
+}
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/imap4flags/errors/imapflags.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/imap4flags/errors/imapflags.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/imap4flags/errors/imapflags.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/imap4flags/errors/imapflags.sieve	2009-02-04 22:48:19.000000000 +0100
@@ -0,0 +1,4 @@
+require "imapflags";
+require "imap4flags";
+
+addflag "\\flagged";
Binary files dovecot-1.2.4/dovecot-libsieve/tests/extensions/imap4flags/errors/imapflags.svbin and dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/imap4flags/errors/imapflags.svbin differ
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/imap4flags/errors.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/imap4flags/errors.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/imap4flags/errors.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/imap4flags/errors.svtest	2009-02-04 23:40:19.000000000 +0100
@@ -0,0 +1,14 @@
+require "vnd.dovecot.testsuite";
+
+require "comparator-i;ascii-numeric";
+require "relational";
+
+test "Depricated imapflags extension used with imap4flags" {
+	if test_script_compile "errors/imapflags.sieve" {
+		test_fail "compile should have failed";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "2" {
+		test_fail "wrong number of errors reported";
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/imap4flags/execute/flags-side-effect.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/imap4flags/execute/flags-side-effect.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/imap4flags/execute/flags-side-effect.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/imap4flags/execute/flags-side-effect.sieve	2009-02-04 21:30:41.000000000 +0100
@@ -0,0 +1,18 @@
+require "imap4flags"; 
+require "fileinto";
+
+/*
+ * When keep/fileinto is used multiple times in a script and duplicate 
+ * message elimination is performed, the last flag list value MUST win.
+ */
+
+setflag "IMPLICIT";
+
+fileinto :flags "\\Seen \\Draft" "INBOX.Junk";
+fileinto :flags "NONSENSE" "INBOX.Junk";
+
+keep;
+keep :flags "\\Seen";
+
+fileinto :flags "\\Seen" "Inbox.Nonsense";
+fileinto "Inbox.Nonsense";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/imap4flags/execute/imapflags.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/imap4flags/execute/imapflags.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/imap4flags/execute/imapflags.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/imap4flags/execute/imapflags.sieve	2009-02-05 00:20:18.000000000 +0100
@@ -0,0 +1,7 @@
+require "imapflags";
+
+mark;
+unmark;
+mark;
+
+addflag "$label1";
Binary files dovecot-1.2.4/dovecot-libsieve/tests/extensions/imap4flags/execute/imapflags.svbin and dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/imap4flags/execute/imapflags.svbin differ
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/imap4flags/execute.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/imap4flags/execute.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/imap4flags/execute.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/imap4flags/execute.svtest	2009-07-31 17:34:58.000000000 +0200
@@ -0,0 +1,22 @@
+require "vnd.dovecot.testsuite";
+
+/*
+ * Execution testing (currently just meant to trigger any segfaults)
+ */
+
+test_mailbox :create "INBOX.Junk";
+test_mailbox :create "INBOX.Nonsense";
+
+test "Flags Side Effect" {
+	if not test_script_compile "execute/flags-side-effect.sieve" {
+		test_fail "script compile failed";
+	}
+
+	if not test_script_run {
+		test_fail "script execute failed";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed";	
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/imap4flags/flagstore.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/imap4flags/flagstore.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/imap4flags/flagstore.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/imap4flags/flagstore.svtest	2009-08-02 14:39:59.000000000 +0200
@@ -0,0 +1,146 @@
+require "vnd.dovecot.testsuite";
+require "fileinto";
+require "imap4flags";
+require "relational";
+require "comparator-i;ascii-numeric";
+require "mailbox";
+
+test_set "message" text:
+From: Henry von Flockenstoffen <henry@example.com>
+To: Dieter von Ausburg <dieter@example.com>
+Subject: Test message.
+
+Test message.
+.
+;
+
+test "Basic" {
+    if hasflag :comparator "i;ascii-numeric" :count "ge" "1" {
+        test_fail "some flags or keywords are already set";
+    }
+	
+	setflag "$label1 \\answered";
+
+	fileinto :create "Uninteresting";
+
+	if not test_result_execute {
+		test_fail "failed to execute first result";
+	}
+
+	test_result_reset;
+
+	setflag "\\draft \\seen Junk";
+
+	fileinto "Uninteresting";
+
+	if not test_result_execute {
+		test_fail "failed to execute second result";
+	}
+
+	test_result_reset;
+
+	fileinto :flags "\\flagged" "Uninteresting";
+
+    if not test_result_execute {
+        test_fail "failed to execute third result";
+    }
+
+    test_result_reset;
+
+	test_message :folder "Uninteresting" 0;
+
+	if not hasflag "$label1 \\answered" {
+		test_fail "flags not stored for first message";
+	}
+
+	if not hasflag :comparator "i;ascii-numeric" :count "eq" "2" {
+        test_fail "invalid number of flags set for first message";
+    }
+
+    test_result_reset;
+
+	test_message :folder "Uninteresting" 1;
+
+    if not hasflag "\\draft \\seen Junk" {
+        test_fail "flags not stored for second message";
+    }
+
+	if not hasflag :comparator "i;ascii-numeric" :count "eq" "3" {
+        test_fail "invalid number of flags set for second message";
+    }
+
+    test_result_reset;
+
+	test_message :folder "Uninteresting" 2;
+
+    if not hasflag "\\flagged" {
+        test_fail "flags not stored for third message";
+    }
+
+	if not hasflag :comparator "i;ascii-numeric" :count "eq" "1" {
+        test_fail "invalid number of flags set for third message";
+    }
+}
+
+test_result_reset;
+test_set "message" text:
+From: Henry von Flockenstoffen <henry@example.com>
+To: Dieter von Ausburg <dieter@example.com>
+Subject: Test message.
+
+Test message.
+.
+;
+
+test "Flag changes between stores" {
+    if hasflag :comparator "i;ascii-numeric" :count "ge" "1" {
+        test_fail "some flags or keywords are already set";
+    }
+	
+	setflag "$label1 \\answered";
+	fileinto :create "FolderA";
+
+	setflag "$label2";
+	fileinto :create "FolderB";
+
+	fileinto :create :flags "\\seen \\draft \\flagged" "FolderC";
+
+	if not test_result_execute {
+		test_fail "failed to execute first result";
+	}
+
+	test_result_reset;
+	test_message :folder "FolderA" 0;
+
+	if not hasflag "\\answered $label1" {
+		test_fail "flags not stored for first message";
+	}
+
+	if not hasflag :comparator "i;ascii-numeric" :count "eq" "2" {
+        test_fail "invalid number of flags set for first message";
+    }
+
+    test_result_reset;
+	test_message :folder "FolderB" 0;
+
+    if not hasflag "$label2" {
+        test_fail "flag not stored for second message";
+    }
+
+	if not hasflag :comparator "i;ascii-numeric" :count "eq" "1" {
+        test_fail "invalid number of flags set for second message";
+    }
+
+    test_result_reset;
+	test_message :folder "FolderC" 0;
+
+    if not hasflag "\\seen \\flagged \\draft" {
+        test_fail "flags not stored for third message";
+    }
+
+	if not hasflag :comparator "i;ascii-numeric" :count "eq" "3" {
+        test_fail "invalid number of flags set for third message";
+    }
+}
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/imap4flags/hasflag.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/imap4flags/hasflag.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/imap4flags/hasflag.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/imap4flags/hasflag.svtest	2009-08-02 10:30:48.000000000 +0200
@@ -0,0 +1,91 @@
+require "vnd.dovecot.testsuite";
+
+require "imap4flags";
+require "relational";
+require "variables";
+require "comparator-i;ascii-numeric";
+
+/*
+ * Generic tests
+ */
+
+test "Ignoring \"\"" {
+	setflag "";
+
+	if hasflag "" {
+		test_fail "hasflag fails to ignore empty string";
+	}
+}
+
+/*
+ * Variables
+ */
+
+test "Multiple variables" {
+	setflag "A" "Aflag";
+	setflag "B" "Bflag";
+	setflag "C" "Cflag";
+
+	if not hasflag ["a", "b", "c"] ["Bflag"] {
+		test_fail "hasflag failed to match multiple flags variables";
+	}
+}
+
+/*
+ * RFC examples
+ */ 
+
+test "RFC hasflag example - :is" {
+	setflag "A B";
+
+	if not hasflag ["b","A"] {
+		test_fail "list representation did not match";
+	}
+ 
+	if not hasflag :is "b A" {
+		test_fail "string representation did not match";
+	}
+}
+
+test "RFC hasflag example - :contains variable" {
+	set "MyVar" "NonJunk Junk gnus-forward $Forwarded NotJunk JunkRecorded $Junk $NotJunk";
+
+	if not hasflag :contains "MyVar" "Junk" {
+		test_fail "failed true example 1";
+	}
+
+	if not hasflag :contains "MyVar" "forward" {
+		test_fail "failed true example 2";
+	}
+      
+	if not hasflag :contains "MyVar" ["label", "forward"] {
+		test_fail "failed true example 3";
+	}
+     
+	if not hasflag :contains "MyVar" ["junk", "forward"] {
+		test_fail "failed true example 4";
+	}
+
+	if not hasflag :contains "MyVar" "junk forward" {
+		test_fail "failed true example 4 (rewrite 1)";
+	}
+
+	if not hasflag :contains "MyVar" "forward junk" {
+		test_fail "failed true example 4 (rewrite 2)";
+	}
+
+	if hasflag :contains "MyVar" "label" {
+		test_fail "failed false example 1";
+	}
+
+	if hasflag :contains "MyVar" ["label1", "label2"] {
+		test_fail "failed false example 2";
+	}
+}
+
+test "RFC hasflag example - :count variable" {
+	set "MyFlags" "A B";
+	if not hasflag :count "ge" :comparator "i;ascii-numeric" "MyFlags" "2" {
+		test_fail "failed count \"ge\" comparison";
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/errors/action-conflicts.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/errors/action-conflicts.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/errors/action-conflicts.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/errors/action-conflicts.sieve	2008-09-06 12:59:49.000000000 +0200
@@ -0,0 +1,4 @@
+require "include";
+
+include "action-fileinto";
+include "action-reject";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/errors/circular-1.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/errors/circular-1.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/errors/circular-1.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/errors/circular-1.sieve	2008-08-04 10:39:20.000000000 +0200
@@ -0,0 +1,5 @@
+require "include";
+
+discard;
+
+include "circular-one.sieve";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/errors/circular-2.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/errors/circular-2.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/errors/circular-2.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/errors/circular-2.sieve	2008-08-04 10:39:20.000000000 +0200
@@ -0,0 +1,5 @@
+require "include";
+
+discard;
+
+include "circular-two.sieve";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/errors/circular-3.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/errors/circular-3.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/errors/circular-3.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/errors/circular-3.sieve	2008-08-04 10:39:20.000000000 +0200
@@ -0,0 +1,5 @@
+require "include";
+
+discard;
+
+include "circular-three";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/errors/generic.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/errors/generic.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/errors/generic.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/errors/generic.sieve	2008-08-11 00:07:54.000000000 +0200
@@ -0,0 +1,7 @@
+require "include";
+
+# Non-existant sieve script
+include "frop.sieve";
+
+# Use of / in script names
+include "../frop.sieve";
Binary files dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/errors/import-runtime.svbin and dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/errors/import-runtime.svbin differ
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/errors/included/action-fileinto.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/errors/included/action-fileinto.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/errors/included/action-fileinto.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/errors/included/action-fileinto.sieve	2008-09-06 12:59:49.000000000 +0200
@@ -0,0 +1,3 @@
+require "fileinto";
+
+fileinto "frop";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/errors/included/action-reject.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/errors/included/action-reject.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/errors/included/action-reject.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/errors/included/action-reject.sieve	2008-09-06 12:59:49.000000000 +0200
@@ -0,0 +1,3 @@
+require "reject";
+
+reject "Ik heb geen zin in die rommel.";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/errors/included/circular-one.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/errors/included/circular-one.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/errors/included/circular-one.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/errors/included/circular-one.sieve	2008-08-04 10:39:20.000000000 +0200
@@ -0,0 +1,5 @@
+require "include";
+
+keep;
+
+include "circular-one.sieve";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/errors/included/circular-three-2.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/errors/included/circular-three-2.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/errors/included/circular-three-2.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/errors/included/circular-three-2.sieve	2008-08-04 10:39:20.000000000 +0200
@@ -0,0 +1,3 @@
+require "include";
+
+include "circular-three-3.sieve";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/errors/included/circular-three-3.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/errors/included/circular-three-3.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/errors/included/circular-three-3.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/errors/included/circular-three-3.sieve	2008-08-04 10:39:20.000000000 +0200
@@ -0,0 +1,3 @@
+require "include";
+
+include "circular-three.sieve";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/errors/included/circular-three.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/errors/included/circular-three.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/errors/included/circular-three.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/errors/included/circular-three.sieve	2008-08-04 10:39:20.000000000 +0200
@@ -0,0 +1,7 @@
+require "include";
+
+keep;
+
+include "circular-three-2.sieve";
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/errors/included/circular-two-2.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/errors/included/circular-two-2.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/errors/included/circular-two-2.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/errors/included/circular-two-2.sieve	2008-08-04 10:39:20.000000000 +0200
@@ -0,0 +1,3 @@
+require "include";
+
+include "circular-two.sieve";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/errors/included/circular-two.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/errors/included/circular-two.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/errors/included/circular-two.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/errors/included/circular-two.sieve	2008-08-04 10:39:20.000000000 +0200
@@ -0,0 +1,7 @@
+require "include";
+
+keep;
+
+include "circular-two-2.sieve";
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/errors/variables-inactive.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/errors/variables-inactive.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/errors/variables-inactive.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/errors/variables-inactive.sieve	2009-04-10 15:23:24.000000000 +0200
@@ -0,0 +1,7 @@
+require "include";
+require "fileinto";
+
+global "friep";
+global "frop";
+
+fileinto "Frop";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/errors/variables.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/errors/variables.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/errors/variables.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/errors/variables.sieve	2009-04-10 15:15:58.000000000 +0200
@@ -0,0 +1,8 @@
+require "include";
+require "variables";
+
+keep;
+
+# Global after command not being require or global
+global "friep";
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/errors.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/errors.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/errors.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/errors.svtest	2009-04-10 15:23:50.000000000 +0200
@@ -0,0 +1,77 @@
+require "vnd.dovecot.testsuite";
+
+require "relational";
+require "comparator-i;ascii-numeric";
+
+/*
+ * Generic include errors
+ */
+
+test "Generic" {
+	if test_script_compile "errors/generic.sieve" {
+		test_fail "compile should have failed";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "3" {
+		test_fail "wrong number of errors reported";
+	}
+}
+
+test "Circular - direct" {
+	if test_script_compile "errors/circular-1.sieve" {
+		test_fail "compile should have failed";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "3" {
+		test_fail "wrong number of errors reported";
+	}
+}
+
+test "Circular - one intermittent" {
+	if test_script_compile "errors/circular-2.sieve" {
+		test_fail "compile should have failed";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "4" {
+		test_fail "wrong number of errors reported";
+	}
+}
+
+test "Circular - two intermittent" {
+	if test_script_compile "errors/circular-3.sieve" {
+		test_fail "compile should have failed";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "5" {
+		test_fail "wrong number of errors reported";
+	}
+}
+
+/*
+ * Using global without variables required
+ */
+
+test "Variables inactive" {
+	if test_script_compile "errors/variables-inactive.sieve" {
+		test_fail "compile should have failed";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "3" {
+		test_fail "wrong number of errors reported";
+	}
+}
+
+/*
+ * Generic variables errors
+ */
+
+test "Variables" {
+	if test_script_compile "errors/variables.sieve" {
+		test_fail "compile should have failed";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "2" {
+		test_fail "wrong number of errors reported";
+	}
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/execute/actions-fileinto.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/execute/actions-fileinto.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/execute/actions-fileinto.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/execute/actions-fileinto.sieve	2009-08-21 00:52:15.000000000 +0200
@@ -0,0 +1,5 @@
+require "include";
+
+include "actions-fileinto1";
+include "actions-fileinto2";
+include "actions-fileinto3";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/execute/included/actions-fileinto1.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/execute/included/actions-fileinto1.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/execute/included/actions-fileinto1.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/execute/included/actions-fileinto1.sieve	2009-08-21 00:52:15.000000000 +0200
@@ -0,0 +1,3 @@
+require "fileinto";
+
+fileinto "aaaa";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/execute/included/actions-fileinto2.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/execute/included/actions-fileinto2.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/execute/included/actions-fileinto2.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/execute/included/actions-fileinto2.sieve	2009-08-21 00:52:15.000000000 +0200
@@ -0,0 +1,4 @@
+require "fileinto";
+
+fileinto "bbbb";
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/execute/included/actions-fileinto3.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/execute/included/actions-fileinto3.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/execute/included/actions-fileinto3.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/execute/included/actions-fileinto3.sieve	2009-08-21 00:52:15.000000000 +0200
@@ -0,0 +1,3 @@
+require "fileinto";
+
+fileinto "aaaa";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/execute.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/execute.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/execute.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/execute.svtest	2009-08-21 00:52:15.000000000 +0200
@@ -0,0 +1,42 @@
+require "vnd.dovecot.testsuite";
+
+test_set "message" text:
+From: idiot@example.com
+To: idiot@rename-it.nl
+Subject: Frop!
+
+Frop.
+.
+;
+
+test "Actions Fileinto" {
+	test_mailbox :create "aaaa";
+	test_mailbox :create "bbbb";
+	
+	if not test_script_compile "execute/actions-fileinto.sieve" {
+		test_fail "failed to compile sieve script";
+	}
+
+	test_binary :save "actions-fileinto";
+	test_binary :load "actions-fileinto";
+
+	if not test_script_run {
+		test_fail "failed to execute sieve script";
+	}
+
+	if not test_result_execute {
+		test_fail "failed to execute result";
+	}
+
+	test_message :folder "aaaa" 0;
+
+	if not header "subject" "Frop!" {
+		test_fail "fileinto \"aaaa\" not executed.";
+	}	
+
+	test_message :folder "aaaa" 0;
+
+	if not header "subject" "Frop!" {
+		test_fail "fileinto \"bbbb\" not executed.";
+	}	
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/included/once-1.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/included/once-1.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/included/once-1.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/included/once-1.sieve	2009-04-10 18:02:35.000000000 +0200
@@ -0,0 +1,9 @@
+require "include";
+require "variables";
+
+global "result";
+
+set "result" "${result} ONE";
+
+return;
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/included/once-2.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/included/once-2.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/included/once-2.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/included/once-2.sieve	2009-04-11 17:47:41.000000000 +0200
@@ -0,0 +1,12 @@
+require "include";
+require "variables";
+
+global "result";
+
+set "result" "${result} TWO";
+
+keep;
+
+include :once "once-1.sieve";
+
+return;
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/included/once-3.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/included/once-3.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/included/once-3.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/included/once-3.sieve	2009-04-11 17:47:41.000000000 +0200
@@ -0,0 +1,3 @@
+require "include";
+
+include "once-4";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/included/once-4.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/included/once-4.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/included/once-4.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/included/once-4.sieve	2009-04-11 17:47:41.000000000 +0200
@@ -0,0 +1,3 @@
+require "include";
+
+include :once "once-3";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/included/rfc-ex1-always_allow.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/included/rfc-ex1-always_allow.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/included/rfc-ex1-always_allow.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/included/rfc-ex1-always_allow.sieve	2009-04-11 17:47:41.000000000 +0200
@@ -0,0 +1,8 @@
+if header :is "From" "boss@example.com"
+{
+     keep;
+}
+elsif header :is "From" "ceo@example.com"
+{
+     keep;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/included/rfc-ex1-mailing_lists.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/included/rfc-ex1-mailing_lists.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/included/rfc-ex1-mailing_lists.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/included/rfc-ex1-mailing_lists.sieve	2009-04-11 17:47:41.000000000 +0200
@@ -0,0 +1,10 @@
+require ["fileinto"];
+
+if header :is "Sender" "owner-ietf-mta-filters@imc.org"
+{
+     fileinto "lists.sieve";
+}
+elsif header :is "Sender" "owner-ietf-imapext@imc.org"
+{
+     fileinto "lists.imapext";
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/included/rfc-ex1-spam_tests.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/included/rfc-ex1-spam_tests.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/included/rfc-ex1-spam_tests.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/included/rfc-ex1-spam_tests.sieve	2009-04-11 17:47:41.000000000 +0200
@@ -0,0 +1,10 @@
+require ["reject"];
+
+if header :contains "Subject" "XXXX"
+{
+	reject "Not wanted";
+}
+elsif header :is "From" "money@example.com"
+{
+	reject "Not wanted";
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/included/rfc-ex2-spam_filter_script.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/included/rfc-ex2-spam_filter_script.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/included/rfc-ex2-spam_filter_script.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/included/rfc-ex2-spam_filter_script.sieve	2009-04-11 17:47:41.000000000 +0200
@@ -0,0 +1,8 @@
+require ["variables", "include"];
+global ["test", "test_mailbox"];
+
+if header :contains "Subject" "${test}"
+{
+	set "test_mailbox" "spam-${test}";
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/included/twice-1.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/included/twice-1.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/included/twice-1.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/included/twice-1.sieve	2009-04-11 17:47:41.000000000 +0200
@@ -0,0 +1,7 @@
+require "include";
+require "variables";
+
+global "result";
+
+set "result" "${result} TWO";
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/included/twice-2.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/included/twice-2.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/included/twice-2.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/included/twice-2.sieve	2009-04-11 17:47:41.000000000 +0200
@@ -0,0 +1,8 @@
+require "include";
+require "variables";
+
+global "result";
+
+set "result" "${result} THREE";
+
+include "twice-1.sieve";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/included/variables-included1.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/included/variables-included1.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/included/variables-included1.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/included/variables-included1.sieve	2009-04-10 15:21:45.000000000 +0200
@@ -0,0 +1,7 @@
+require "include";
+require "variables";
+
+global ["value1", "value2"];
+global ["result1"];
+
+set "result1" "${value1} ${value2}";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/included/variables-included2.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/included/variables-included2.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/included/variables-included2.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/included/variables-included2.sieve	2009-04-10 15:22:03.000000000 +0200
@@ -0,0 +1,6 @@
+require "include";
+require "variables";
+
+global ["value3", "value4", "result2"];
+
+set "result2" "${value3} ${value4}";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/included/variables-included3.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/included/variables-included3.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/included/variables-included3.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/included/variables-included3.sieve	2009-04-10 15:22:24.000000000 +0200
@@ -0,0 +1,8 @@
+require "include";
+require "variables";
+
+global "result1";
+global "result2";
+global "result";
+
+set "result" "${result1} ${result2}";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/included-global/rfc-ex1-spam_tests.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/included-global/rfc-ex1-spam_tests.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/included-global/rfc-ex1-spam_tests.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/included-global/rfc-ex1-spam_tests.sieve	2009-04-11 17:47:41.000000000 +0200
@@ -0,0 +1,7 @@
+require ["reject"];
+
+if anyof (header :contains "Subject" "$$",
+	header :contains "Subject" "Make money")
+{
+	reject "Not wanted";
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/once.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/once.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/once.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/once.svtest	2009-04-11 17:47:41.000000000 +0200
@@ -0,0 +1,24 @@
+require "vnd.dovecot.testsuite";
+require "include";
+require "variables";
+
+global "result";
+
+set "result" "";
+
+test "Included Once" {
+	include "once-1";
+	include "once-2";
+
+	if string "${result}" " ONE TWO ONE" {
+		test_fail "duplicate included :once script";
+	}
+
+	if not string "${result}" " ONE TWO" {
+		test_fail "unexpected result value: ${result}";
+	}
+}
+
+test "Included Once recursive" {
+	include "once-3";
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/rfc-ex1-default.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/rfc-ex1-default.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/rfc-ex1-default.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/rfc-ex1-default.sieve	2009-04-11 17:47:41.000000000 +0200
@@ -0,0 +1,6 @@
+require ["include"];
+
+include :personal "rfc-ex1-always_allow";
+include :global "rfc-ex1-spam_tests";
+include :personal "rfc-ex1-spam_tests";
+include :personal "rfc-ex1-mailing_lists";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/rfc-ex2-default.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/rfc-ex2-default.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/rfc-ex2-default.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/rfc-ex2-default.sieve	2009-04-11 17:47:41.000000000 +0200
@@ -0,0 +1,21 @@
+require ["variables", "include", "relational", "fileinto"];
+global "test";
+global "test-mailbox";
+
+# The included script may contain repetitive code that is
+# effectively a subroutine that can be factored out.
+set "test" "$$";
+include "rfc-ex2-spam_filter_script";
+
+set "test" "Make money";
+include "rfc-ex2-spam_filter_script";
+
+# Message will be filed according to the test that matched last.
+if string :count "eq" "${test_mailbox}" "1"
+{
+	fileinto "INBOX${test_mailbox}";
+	stop;
+}
+
+# If nothing matched, the message is implicitly kept.
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/rfc.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/rfc.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/rfc.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/rfc.svtest	2009-04-11 17:47:41.000000000 +0200
@@ -0,0 +1,13 @@
+require "vnd.dovecot.testsuite";
+
+test "RFC example 1" {
+	if not test_script_compile "rfc-ex1-default.sieve" {
+		test_fail "failed to compile sieve script";
+	}
+}
+
+test "RFC example 2" {
+	if not test_script_compile "rfc-ex2-default.sieve" {
+		test_fail "failed to compile sieve script";
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/twice.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/twice.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/twice.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/twice.svtest	2009-04-11 17:47:41.000000000 +0200
@@ -0,0 +1,20 @@
+require "vnd.dovecot.testsuite";
+require "include";
+require "variables";
+
+global "result";
+
+set "result" "ONE";
+
+test "Twice included" {
+	include "twice-1";
+	include "twice-2";
+
+	if string "${result}" "ONE TWO THREE" {
+		test_fail "duplicate include failed";
+	}
+
+	if not string "${result}" "ONE TWO THREE TWO" {
+		test_fail "unexpected result: ${result}";
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/variables.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/variables.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/include/variables.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/include/variables.svtest	2009-04-10 15:21:30.000000000 +0200
@@ -0,0 +1,28 @@
+require "vnd.dovecot.testsuite";
+
+require "include";
+require "variables";
+
+global ["value1", "value2"];
+global ["value3", "value4"];
+global "result";
+
+set "value1" "Works";
+set "value2" "fine.";
+set "value3" "Yeah";
+set "value4" "it does.";
+
+include "variables-included1";
+include "variables-included2";
+include "variables-included3";
+
+test "Basic" {
+	if not string :is "${result}" "Works fine. Yeah it does." {
+		test_fail "invalid result: ${result}";
+	}
+
+	if string :is "${result}" "nonsense" {
+		test_fail "string test succeeds inappropriately";
+	}
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/mailbox/execute.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/mailbox/execute.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/mailbox/execute.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/mailbox/execute.svtest	2009-08-02 09:44:14.000000000 +0200
@@ -0,0 +1,80 @@
+require "vnd.dovecot.testsuite";
+require "mailbox";
+require "fileinto";
+
+test "MailboxExists - None exist" {
+	if mailboxexists "frop" {
+		test_fail "mailboxexists confirms existance of unknown folder";
+	}
+}
+
+test_mailbox :create "frop";
+test_mailbox :create "friep";
+
+test "MailboxExists - Not all exist" {
+	if mailboxexists ["frop", "friep", "frml"] {
+		test_fail "mailboxexists confirms existance of unknown folder";
+	}
+}
+
+test_mailbox :create "frml";
+
+test "MailboxExists - One exists" {
+	if not mailboxexists ["frop"] {
+		test_fail "mailboxexists fails to recognize folder";
+	}
+}
+
+test "MailboxExists - All exist" {
+	if not mailboxexists ["frop", "friep", "frml"] {
+		test_fail "mailboxexists fails to recognize folders";
+	}
+}
+
+test ":Create" {
+	if mailboxexists "created" {
+		test_fail "mailbox exists already";
+	}
+
+	test_set "message" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Subject: Frop 1
+
+Frop!
+.
+	;
+
+	fileinto :create "created";
+
+	if not test_result_execute {
+		test_fail "execution of result failed";
+	}
+
+	if not mailboxexists "created" {
+		test_fail "mailbox somehow not created";
+	}
+
+	test_result_reset;
+
+	test_set "message" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Subject: Frop 2
+
+Frop!
+.
+	;
+
+	fileinto "created";
+
+	if not test_result_execute {
+		test_fail "execution of result failed second time";
+	}
+
+	test_message :folder "created" 0;
+
+	if not header :is "subject" "Frop 1" {
+		test_fail "incorrect message read back from mail store";
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/regex/basic.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/regex/basic.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/regex/basic.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/regex/basic.svtest	2008-08-25 10:25:08.000000000 +0200
@@ -0,0 +1,21 @@
+require "vnd.dovecot.testsuite";
+
+require "regex";
+
+test_set "message" text:
+From: stephan+sieve@drunksnipers.com
+To: tss@iki.fi
+Subject: Test
+
+Test message.
+.
+;
+
+test "Basic example" {
+	if not address :regex :comparator "i;ascii-casemap" "from" [
+		"stephan(\\+.*)?@rename-it\\.com", 
+		"stephan(\\+.*)?@drunksnipers\\.com" 
+		] {
+		test_fail "failed to match";
+	}
+}	
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/regex/errors/compile.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/regex/errors/compile.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/regex/errors/compile.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/regex/errors/compile.sieve	2008-08-25 10:25:08.000000000 +0200
@@ -0,0 +1,25 @@
+require "regex";
+require "comparator-i;ascii-numeric";
+require "envelope";
+
+if address :regex :comparator "i;ascii-numeric" "from" "sirius(\\+.*)?@drunksnipers\\.com" {
+	keep;
+	stop;
+}
+
+if address :regex "from" "sirius(+\\+.*)?@drunksnipers\\.com" {
+	keep;
+	stop;
+}
+
+if header :regex "from" "sirius(\\+.*)?@drunk[]snipers.com" {
+    keep;
+    stop;
+}
+
+if envelope :regex "from" "sirius(\\+.*)?@drunksni[]pers.com" {
+    keep;
+    stop;
+}
+
+discard;
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/regex/errors.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/regex/errors.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/regex/errors.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/regex/errors.svtest	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,14 @@
+require "vnd.dovecot.testsuite";
+
+require "relational";
+require "comparator-i;ascii-numeric";
+
+test "Compile errors" {
+	if test_script_compile "errors/compile.sieve" {
+		test_fail "compile should have failed";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "5" {
+		test_fail "wrong number of errors reported";
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/regex/match-values.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/regex/match-values.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/regex/match-values.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/regex/match-values.svtest	2009-01-22 00:18:13.000000000 +0100
@@ -0,0 +1,68 @@
+require "vnd.dovecot.testsuite";
+
+require "regex";
+require "variables";
+
+test_set "message" text:
+From: Andy Howell <AndyHowell@example.com>
+Sender: antlr-interest-bounces@antlr.org
+To: Stephan Bosch <stephan@rename-it.nl>
+Subject: [Dovecot] Sieve regex match problem
+
+Hi,
+
+I is broken.
+.
+;
+
+test "Basic match values 1" {
+	if header :regex ["Sender"] ["([^-@]*)-([^-@]*)(-bounces)?@antlr.org"] {
+
+		if not string :is "${1}" "antlr" {
+			test_fail "first match value is not correct";
+		}	
+
+		if not string :is "${2}" "interest" {
+			test_fail "second match value is not correct";
+		}	
+
+		if not string :is "${3}" "-bounces" {
+			test_fail "third match value is not correct";
+		}	
+
+		if string :is "${4}" "-bounces" {
+			test_fail "fourth match contains third value";
+		}
+	}
+}
+
+test "Basic match values 2" {
+	if header :regex ["Sender"] ["(.*>[ \\t]*,?[ \\t]*)?([^-@]*)-([^-@]*)(-bounces)?@antlr.org"] {
+
+		if not string :is "${1}" "" {
+            test_fail "first match value is not correct: ${1}";
+        }
+
+		if not string :is "${2}" "antlr" {
+			test_fail "second match value is not correct: ${2}";
+		}	
+
+		if not string :is "${3}" "interest" {
+			test_fail "third match value is not correct: ${3}";
+		}	
+
+		if not string :is "${4}" "-bounces" {
+			test_fail "fourth match value is not correct: ${4}";
+		}	
+
+		if string :is "${5}" "-bounces" {
+			test_fail "fifth match contains fourth value: ${5}";
+		}
+	}
+}
+
+
+
+
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/reject/execute/basic.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/reject/execute/basic.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/reject/execute/basic.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/reject/execute/basic.sieve	2008-10-04 10:41:25.000000000 +0200
@@ -0,0 +1,8 @@
+require "reject";
+
+if address :contains "to" "vestingbar" {
+	reject "Don't send unrequested messages.";
+	stop;
+}
+
+keep;
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/reject/execute.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/reject/execute.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/reject/execute.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/reject/execute.svtest	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,34 @@
+require "vnd.dovecot.testsuite";
+require "relational";
+require "comparator-i;ascii-numeric";
+
+test_set "message" text:
+To: nico@vestingbar.nl
+From: stephan@rename-it.nl
+Subject: Test
+
+Test.
+.
+;
+
+test "Execute" {
+	if not test_script_compile "execute/basic.sieve" {
+		test_fail "script compile failed";
+	}
+
+	if not test_script_run {
+		test_fail "script run failed";
+	}
+
+	if not test_result :count "eq" :comparator "i;ascii-numeric" "1" {
+		test_fail "invalid number of actions in result";
+	}
+
+	if not test_result :index 1 "reject" {
+		test_fail "reject action missing from result";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed";
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/reject/smtp.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/reject/smtp.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/reject/smtp.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/reject/smtp.svtest	2009-07-21 12:41:19.000000000 +0200
@@ -0,0 +1,56 @@
+require "vnd.dovecot.testsuite";
+require "envelope";
+require "reject";
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: tss@iki.fi
+Subject: Frop!
+
+Frop!
+.
+;
+
+test_set "envelope.from" "sirius@rename-it.nl";
+test_set "envelope.to" "timo@iki.fi";
+
+test "Basic" {
+	reject "I don't want your mail";
+
+	if not test_result_execute {
+        test_fail "failed to execute reject";
+    }
+
+    test_message :smtp 0;
+
+    if not address :is "to" "sirius@rename-it.nl" {
+        test_fail "to address incorrect";
+    }
+
+    if not header :contains "from" "Mail Delivery Subsystem" {
+        test_fail "from address incorrect";
+    }
+
+	if not envelope :is "to" "sirius@rename-it.nl" {
+		test_fail "envelope recipient incorrect";
+	}
+
+	if not envelope :is "from" "" {
+		test_fail "envelope sender not null";
+	}
+}
+
+test_result_reset;
+test_set "envelope.from" "<>";
+
+test "Null Sender" {
+	reject "I don't want your mail";
+
+	if not test_result_execute {
+		test_fail "failed to execute reject";
+	}
+
+	if test_message :smtp 0 {
+		test_fail "reject sent message to NULL sender";
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/relational/basic.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/relational/basic.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/relational/basic.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/relational/basic.svtest	2008-08-25 10:25:08.000000000 +0200
@@ -0,0 +1,178 @@
+require "vnd.dovecot.testsuite";
+
+require "relational";
+require "comparator-i;ascii-numeric";
+
+/* 
+ * Test message
+ */
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Cc: frop@rename-it.nl
+CC: timo@rename-it.nl
+X-Spam-Score: 300
+X-Nonsense: 1000
+X-Nonsense: 20
+X-Alpha: abcdzyx
+X-Count: a
+X-Count: b
+X-Count: c
+X-Count: d
+X-Count: e
+X-Count: f
+X-Count: g
+X-Count: h
+X-Count: i
+X-Count: j
+X-Count: k
+X-Count: l
+X-Count: m
+X-Count: n
+X-Count: o
+X-Count: p
+X-Count: q
+X-Count: r
+X-Count: s
+X-Count: t
+X-Count: u
+X-Count: v
+X-Count: w
+X-Count: x
+X-Count: y
+X-Count: z
+Subject: Test
+Comment:                                    
+
+Test!
+.
+;
+
+/*
+ * Empty strings
+ */
+
+test "Value \"\" eq 40 (vs)" {
+	if header :value "eq" :comparator "i;ascii-numeric" "comment" "40" {
+		test_fail ":value matched empty string with i;ascii-numeric";
+	}
+
+	if header :value "gt" :comparator "i;ascii-numeric" "x-spam-score" "" {
+		test_fail ":value 300 exceeded empty string with i;ascii-numeric";
+	}
+
+	if header :value "gt" :comparator "i;ascii-numeric" "x-spam-score" "" {
+        test_fail ":count exceeded empty string with i;ascii-numeric";
+    }
+}
+
+/* 
+ * Match type :value
+ */
+
+test "Value 300 eq 2" {
+	if header :value "eq" :comparator "i;ascii-numeric" "x-spam-score" "2" {
+		test_fail "should not have matched";
+	} 
+}
+
+test "Value 300 lt 2" {
+	if header :value "lt" :comparator "i;ascii-numeric" "x-spam-score" "2" {
+		test_fail "should not have matched";
+	}
+}
+
+test "Value 300 le 300" {
+	if not header :value "le" :comparator "i;ascii-numeric" "x-spam-score" "300" {
+		test_fail "should have matched";
+	}
+}
+
+test "Value 300 le 302" {
+	if not header :value "le" :comparator "i;ascii-numeric" "x-spam-score" "302" {
+		test_fail "should have matched";
+	}
+}
+
+test "Value 302 le 00302" {
+	if not header :value "le" :comparator "i;ascii-numeric" "x-spam-score" "00302" {
+		test_fail "should have matched";
+    }
+}
+
+test "Value {1000,20} le 300" {
+    if not header :value "le" :comparator "i;ascii-numeric" "x-nonsense" "300" {
+        test_fail "should have matched";
+    }
+}
+
+test "Value {1000,20} lt 3" {
+    if header :value "lt" :comparator "i;ascii-numeric" "x-nonsense" "3" {
+        test_fail "should not have matched";
+    }
+}
+
+test "Value {1000,20} gt 3000" {
+    if header :value "gt" :comparator "i;ascii-numeric" "x-nonsense" "3000" {
+        test_fail "should not have matched";
+    }
+}
+
+test "Value {1000,20} gt {3000,30}" {
+    if not header :value "gt" :comparator "i;ascii-numeric" "x-nonsense" ["3000","30"] {
+        test_fail "should have matched";
+    }
+}
+
+test "Value {1000,20} lt {3, 19})" {
+    if header :value "lt" :comparator "i;ascii-numeric" "x-nonsense" ["3","19"] {
+        test_fail "should not have matched";
+    }
+}
+
+test "Value {1000,20} gt {3000,1001}" {
+    if header :value "gt" :comparator "i;ascii-numeric" "x-nonsense" ["3000","1001"] {
+        test_fail "should not have matched";
+    }
+}
+
+test "Value abcdzyz gt aaaaaaa" {
+    if not header :value "gt" :comparator "i;octet" "x-alpha" "aaaaaaa" {
+        test_fail "should have matched";
+    }
+}
+
+/* 
+ * Match type :count
+ */
+
+test "Count 2 ne 2" {
+	if header :count "ne" :comparator "i;ascii-numeric" "cc" "2" {
+		test_fail "should not have matched";
+	}
+}
+
+test "Count 2 ge 2" {
+	if not header :count "ge" :comparator "i;ascii-numeric" "cc" "2" {
+		test_fail "should have matched";
+	}
+}
+
+test "Count 2 ge 002" {
+	if not header :count "ge" :comparator "i;ascii-numeric" "cc" "002" {
+		test_fail "should have matched";
+	}
+}
+
+test "Count 26 lt {4,5,6,10,20}" {
+	if header :count "lt" :comparator "i;ascii-numeric" "x-count" ["4","5","6","10","20"] {
+		test_fail "should not have matched";
+	}
+}
+
+test "Count 26 lt {4,5,6,10,20,100}" {
+	if not header :count "lt" :comparator "i;ascii-numeric" "x-count" ["4","5","6","10","20","100"] {
+		test_fail "should have matched";
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/relational/errors/validation.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/relational/errors/validation.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/relational/errors/validation.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/relational/errors/validation.sieve	2008-08-25 10:25:08.000000000 +0200
@@ -0,0 +1,11 @@
+require "relational";
+
+# Not a valid relation (1)
+if header :value "gr" "from" "ah" {
+	keep;
+} 
+
+# Not a valid relation (1)
+if header :count "lf" "from" "eek" {
+	keep;
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/relational/errors.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/relational/errors.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/relational/errors.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/relational/errors.svtest	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,15 @@
+require "vnd.dovecot.testsuite";
+
+# A bit awkward to test the extension with itself
+require "relational";
+require "comparator-i;ascii-numeric";
+
+test "Validation errors" {
+	if test_script_compile "errors/validation.sieve" {
+		test_fail "compile should have failed";
+	}
+
+	if test_error :count "ne" "3" {
+		test_fail "wrong number of errors reported";
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/relational/rfc.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/relational/rfc.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/relational/rfc.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/relational/rfc.svtest	2008-08-25 10:25:08.000000000 +0200
@@ -0,0 +1,71 @@
+require "vnd.dovecot.testsuite";
+
+require "relational";
+require "comparator-i;ascii-numeric";
+
+test_set "message" text:
+Received: ...
+Received: ...
+Subject: example
+To: foo@example.com, baz@example.com
+CC: qux@example.com
+
+RFC Example
+.
+;
+
+test "Example 1" {
+	# The test:
+
+	if not address :count "ge" :comparator "i;ascii-numeric"
+		["to", "cc"] ["3"] {
+	
+		test_fail "should have counted three addresses";
+	}
+
+    # would evaluate to true, and the test
+
+	if anyof ( 
+			address :count "ge" :comparator "i;ascii-numeric"
+				["to"] ["3"],
+			address :count "ge" :comparator "i;ascii-numeric"
+				["cc"] ["3"] 
+	) {
+	
+		test_fail "should not have counted three addresses";
+	}
+
+	# would evaluate to false.
+
+	# To check the number of received fields in the header, the following
+	# test may be used:
+
+	if header :count "ge" :comparator "i;ascii-numeric"
+ 		["received"] ["3"] {
+	
+		test_fail "should not have counted three received headers";
+	}
+
+	# This would evaluate to false.  But
+
+	if not header :count "ge" :comparator "i;ascii-numeric"
+		["received", "subject"] ["3"] {
+
+		test_fail "should have counted three headers";
+	}
+
+	# would evaluate to true.
+	
+	# The test:
+
+	if header :count "ge" :comparator "i;ascii-numeric"
+		["to", "cc"] ["3"] {
+
+		test_fail "should not have counted three to or cc headers";
+	}
+
+	# will always evaluate to false on an RFC 2822 compliant message
+	# [RFC2822], since a message can have at most one "to" field and at
+	# most one "cc" field.  This test counts the number of fields, not the
+	# number of addresses.
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/subaddress/basic.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/subaddress/basic.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/subaddress/basic.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/subaddress/basic.svtest	2009-07-19 15:54:39.000000000 +0200
@@ -0,0 +1,111 @@
+require "vnd.dovecot.testsuite";
+require "envelope";
+require "subaddress";
+
+test_set "message" text:
+From: stephan+sieve@renane-it.nl
+To: test+failed@example.com
+Subject: subaddress test
+
+Test!
+.
+;
+
+test_set "envelope.to" "friep+frop@dovecot.org";
+test_set "envelope.from" "list+request@lists.dovecot.org";
+
+test "Address from :user" {
+	if not address :is :user "from" "stephan" {
+		test_fail "wrong user part extracted";
+	}
+
+	if address :is :user "from" "nonsence" {
+		test_fail "address test failed";
+	}
+}
+
+test "Address from :detail" {
+	if not address :is :detail "from" "sieve" {
+		test_fail "wrong user part extracted";
+	}
+
+	if address :is :detail "from" "nonsence" {
+		test_fail "address test failed";
+	}
+}
+
+test "Address to :user" {
+	if not address :contains :user "to" "est" {
+		test_fail "wrong user part extracted";
+	}
+
+	if address :contains :user "to" "ail" {
+		test_fail "address test failed";
+	}
+}
+
+test "Address to :detail" {
+	if not address :contains :detail "to" "fai" {
+		test_fail "wrong user part extracted";
+	}
+
+	if address :contains :detail "to" "sen" {
+		test_fail "address test failed";
+	}
+}
+
+
+test "Envelope :user" {
+    if not envelope :is :user "to" "friep" {
+        test_fail "wrong user part extracted 1";
+    }
+
+    if not envelope :comparator "i;ascii-casemap" :is :user "to" "FRIEP" {
+        test_fail "wrong user part extracted";
+    }
+
+    if envelope :comparator "i;ascii-casemap" :is :user "to" "FROP" {
+        test_fail "envelope test failed";
+    }
+}
+
+test "Envelope :detail" {
+    if not envelope :comparator "i;ascii-casemap" :contains :detail "from" "QUES" {
+        test_fail "wrong user part extracted";
+    }
+
+    if envelope :comparator "i;ascii-casemap" :contains :detail "from" "LIS" {
+        test_fail "address test failed";
+    }
+}
+
+test_set "message" text:
+From: frop@examples.com
+To: undisclosed-recipients:;
+Subject: subaddress test
+
+Test!
+.
+;
+
+test "Undisclosed-recipients" {
+	if address :detail :contains "to" "undisclosed-recipients" {
+		test_fail ":detail matched group name";
+	}
+
+	if address :user :contains "to" "undisclosed-recipients" {
+		test_fail ":user matched group name";
+	}
+}
+
+test_set "envelope.to" "frop@sieve.nl";
+
+test "No detail" {
+	if envelope :detail "to" "virus" {
+		test_fail ":detail matched non-existant detail element in envelope (separator is missing)";
+	}
+
+	if address :detail "from" "virus" {
+		test_fail ":detail matched non-existant detail element in from header (separator is missing)";		
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/subaddress/rfc.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/subaddress/rfc.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/subaddress/rfc.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/subaddress/rfc.svtest	2008-08-25 10:25:08.000000000 +0200
@@ -0,0 +1,59 @@
+require "vnd.dovecot.testsuite";
+
+require "subaddress";
+
+test_set "message" text:
+From: stephan+@rename-it.nl
+To: timo+spam@iki.fi
+CC: nico@example.com
+Subject: fetch my spam
+
+Mouhahahaha... Spam!
+.
+;
+
+
+/*
+ * The ":user" argument specifies the user sub-part of the local-part of
+ * an address.  If the address is not encoded to contain a detail sub-
+ * part, then ":user" specifies the entire left side of the address
+ * (equivalent to ":localpart").
+ */
+
+test "User sub-part" {
+	if not address :user "cc" "nico" {
+		test_fail "wrong :user part extracted (1)";
+	}
+
+	if not address :user "to" "timo" {
+		test_fail "wrong :user part extracted (2)";
+	}
+
+	if not address :user "from" "stephan" {
+		test_fail "wrong :user part extracted (3)";
+	}
+}
+
+/* The ":detail" argument specifies the detail sub-part of the local-
+ * part of an address.  If the address is not encoded to contain a
+ * detail sub-part, then the address fails to match any of the specified
+ * keys.  If a zero-length string is encoded as the detail sub-part,
+ * then ":detail" resolves to the empty value ("").
+ */
+
+test "Detail sub-part" {
+	if not address :detail "to" "spam" {
+		test_fail "wrong :detail part extracted";
+	}	
+
+	if anyof (
+		address :detail :matches "cc" ["*", "?"],
+		address :detail :contains "cc" "",
+		address :detail :is "cc" "" ) {
+		test_fail ":detail inappropriately matched missing detail sub-part";
+	}
+
+	if not address :detail "from" "" {
+		test_fail "wrong empty :detail part extracted";
+	}		
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/vacation/errors/conflict-reject.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/vacation/errors/conflict-reject.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/vacation/errors/conflict-reject.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/vacation/errors/conflict-reject.sieve	2008-09-06 12:59:49.000000000 +0200
@@ -0,0 +1,5 @@
+require "vacation";
+require "reject";
+
+vacation "Ik ben ff weg.";
+reject "Ik heb nu geen zin aan mail.";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/vacation/errors.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/vacation/errors.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/vacation/errors.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/vacation/errors.svtest	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,19 @@
+require "vnd.dovecot.testsuite";
+
+require "relational";
+require "comparator-i;ascii-numeric";
+
+test "Action conflicts: reject <-> vacation" {
+	if not test_script_compile "errors/conflict-reject.sieve" {
+		test_fail "compile failed";
+	}
+
+	if test_script_run {
+		test_fail "execution should have failed";
+	}
+
+	if test_error :count "gt" :comparator "i;ascii-numeric" "1" {
+		test_fail "too many runtime errors reported";
+	}
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/vacation/execute/action.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/vacation/execute/action.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/vacation/execute/action.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/vacation/execute/action.sieve	2009-02-11 21:38:58.000000000 +0100
@@ -0,0 +1,4 @@
+require "vacation";
+
+vacation :addresses "stephan@rename-it.nl" "I am not at home today";
+keep;
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/vacation/execute/no-handle.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/vacation/execute/no-handle.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/vacation/execute/no-handle.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/vacation/execute/no-handle.sieve	2008-09-06 12:59:49.000000000 +0200
@@ -0,0 +1,7 @@
+require "vacation";
+require "variables";
+
+set "reason" "I have a conference in Seattle";
+
+vacation :subject "I am not in: ${reason}" :from "stephan@rename-it.nl" "I am gone for today: ${reason}.";
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/vacation/execute.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/vacation/execute.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/vacation/execute.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/vacation/execute.svtest	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,43 @@
+require "vnd.dovecot.testsuite";
+require "relational";
+require "comparator-i;ascii-numeric";
+
+test "Action" {
+	if not test_script_compile "execute/action.sieve" {
+		test_fail "script compile failed";
+	}
+
+	if not test_script_run {
+		test_fail "script run failed";
+	}
+
+	if not test_result :count "eq" :comparator "i;ascii-numeric" "2" {
+		test_fail "invalid number of actions in result";
+	}
+
+	if not test_result :index 1 "vacation" {
+		test_fail "vacation action is not present as first item in result";
+	}
+	
+	if not test_result :index 2 "keep" {
+		test_fail "keep action is missing in result";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed";
+	}
+}
+
+test "No :handle specified" {
+	if not test_script_compile "execute/no-handle.sieve" {
+		test_fail "script compile failed";
+	}
+
+	if not test_script_run {
+		test_fail "script execute failed";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed";
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/vacation/message.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/vacation/message.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/vacation/message.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/vacation/message.svtest	2009-07-15 17:59:21.000000000 +0200
@@ -0,0 +1,48 @@
+require "vnd.dovecot.testsuite";
+require "vacation";
+
+test_set "message" text:
+From: stephan@rename-it.nl
+Subject: frop
+References: <1234@local.machine.example> <3456@example.net>
+ <435444@ttms.com> <4223@froop.nl> <m345444444@message-id.exp>
+Message-ID: <432df324@rename-it.nl>
+To: nico@vestingbar.nl
+
+Frop
+.
+;
+
+test "References" {
+	vacation "I am not in today!";
+
+	if not test_result_execute {
+		test_fail "execution of result failed";
+	}
+
+	test_message :smtp 0;
+
+	if not header :contains "references" "432df324@rename-it.nl" {
+		test_fail "references header does not contain new id";
+	}
+
+	if anyof ( 
+		not header :contains "references" "1234@local.machine.example", 
+		not header :contains "references" "3456@example.net",
+		not header :contains "references" "435444@ttms.com", 
+		not header :contains "references" "4223@froop.nl", 
+		not header :contains "references" "m345444444@message-id.exp" 
+		) {
+		test_fail "references header does not contain all existing ids";
+	}
+
+	if header :contains "references" "hutsefluts" {
+		test_fail "references header contains nonsense";
+	}
+}
+
+test "In-Reply-To" {
+	if not header :is "in-reply-to" "<432df324@rename-it.nl>" {
+		test_fail "in-reply-to header set incorrectly";
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/vacation/references.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/vacation/references.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/vacation/references.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/vacation/references.sieve	2008-12-18 00:22:42.000000000 +0100
@@ -0,0 +1,4 @@
+require "vacation";
+
+vacation "I am on vacation.";
+discard;
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/vacation/smtp.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/vacation/smtp.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/vacation/smtp.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/vacation/smtp.svtest	2009-07-21 12:44:25.000000000 +0200
@@ -0,0 +1,56 @@
+require "vnd.dovecot.testsuite";
+require "envelope";
+require "vacation";
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: tss@iki.fi
+Subject: Frop!
+
+Frop!
+.
+;
+
+test_set "envelope.from" "sirius@rename-it.nl";
+test_set "envelope.to" "timo@iki.fi";
+
+test "Basic" {
+	vacation :addresses "tss@iki.fi" :from "Timo Sirainen <tss@iki.fi>" "I am gone";
+
+	if not test_result_execute {
+        test_fail "failed to execute vacation";
+    }
+
+    test_message :smtp 0;
+
+    if not address :is "to" "sirius@rename-it.nl" {
+        test_fail "to address incorrect";
+    }
+
+    if not address :is "from" "tss@iki.fi" {
+        test_fail "from address incorrect";
+    }
+
+	if not envelope :is "to" "sirius@rename-it.nl" {
+		test_fail "envelope recipient incorrect";
+	}
+
+	if not envelope :is "from" "" {
+		test_fail "envelope sender not null";
+	}
+}
+
+test_result_reset;
+test_set "envelope.from" "<>";
+
+test "Null Sender" {
+	vacation :addresses "tss@iki.fi" "I am gone";
+
+	if not test_result_execute {
+		test_fail "failed to execute vacation";
+	}
+
+	if test_message :smtp 0 {
+		test_fail "reject sent message to NULL sender";
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/variables/basic.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/variables/basic.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/variables/basic.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/variables/basic.svtest	2008-08-13 00:27:45.000000000 +0200
@@ -0,0 +1,223 @@
+require "vnd.dovecot.testsuite";
+require "variables";
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: test@example.com
+Subject: Variables test
+
+Testing variables...
+.
+;
+
+/*
+ * Substitution syntax
+ */
+
+test "Unknown variables" {
+	set "q" "a";
+	set "qw" "bb";
+	set "qwe" "ccc";
+	set "qwer" "dddd";
+	set "qwert" "ccc";
+
+	if anyof (
+		not string "[${qwerty}]" "[]",
+		not string "[${20}]" "[]"
+	) {
+		test_fail "unknown variable not substituted with empty string";
+	}
+}
+
+test "One pass" {
+	set "something" "value";
+	set "s" "$";
+	
+	if string "${s}{something}" "value" {
+		test_fail "somehow variable string is scanned multiple times";
+	}
+
+	if not string :matches "${s}{something}" "?{something}" {
+		test_fail "unexpected result";
+	}
+}
+
+test "Syntax errors" {
+	set "s" "$";
+	set "variable" "nonsense";
+
+	if anyof ( 
+		not string "$" "${s}",
+		not string "${" "${s}{",
+		not string "${a" "${s}{a",
+		not string "${$}" "${s}{$}",
+		not string "${%%%%}" "${s}{%%%%}",
+		not string "${0.s}" "${s}{0.s}",
+		not string "&%${}!" "&%${s}{}!",
+		not string "${doh!}" "${s}{doh!}" )
+	{
+		test_fail "variables substitution changed substring not matching variable-ref";
+	}	
+}
+
+test "RFC syntax examples" {
+	# The variable "company" holds the value "ACME".  No other variables
+    # are set. 
+	set "company" "ACME";
+
+	# "${full}"         => the empty string
+	if not string :is "${full}" "" {
+		test_fail "unknown variable did not yield empty string";
+	}
+
+	# "${company}"      => "ACME"
+	if not string :is "${company}" "ACME" {
+		test_fail "assigned variable did not get substituted";
+	}
+
+	# "${BAD${Company}" => "${BADACME"
+	if not string :is "${BAD${Company}" "${BADACME" {
+		test_fail "'BADACME' test did not yield expected result";
+	}
+
+	#"${President, ${Company} Inc.}" 
+	#                        => "${President, ACME Inc.}"
+	if not string "${President, ${Company} Inc.}"
+		"${President, ACME Inc.}" {
+		test_fail "'Company president' test did not yield expected result";
+	}
+}
+
+/*
+ * Variable assignments
+ */
+
+test "Basic assignment" {
+	set "test" "Value";
+
+	if not string :is "${test}" "Value" {
+		test_fail "variable assignment failed";
+	}
+
+	if string :is "${test}" "value" {
+		test_fail "string test failed";
+	}
+}
+
+test "Assignment overwritten" {
+	set "test" "Value";
+	set "test" "More";
+
+	if not string :is "${test}" "More" {
+		test_fail "variable assignment failed";
+	}
+
+	if string :is "${test}" "Value" {
+		test_fail "value not overwritten";
+	}
+
+	if string :is "${test}" "nonsense" {
+		test_fail "string test failed";
+	}
+}
+
+test "Two assignments" {
+	set "test" "Value";
+	set "test2" "More";
+
+	if not string :is "${test}" "Value" {
+		test_fail "variable assignment failed";
+	}
+
+	if string :is "${test}" "More" {
+		test_fail "assignments to different variables overlap";
+	}
+
+	if string :is "${test}" "nonsense" {
+		test_fail "string test failed";
+	}
+}
+
+test "Variables case-insensitive" {
+	set "VeRyElAboRATeVaRIABLeName" "interesting value";
+
+	if not string "${veryelaboratevariablename}" "interesting value" {
+		test_fail "variable names are case sensitive (lower case try)";
+	}
+
+	if not string "${VERYELABORATEVARIABLENAME}" "interesting value" {
+		test_fail "variable names are case sensitive (upper case try)";
+	}
+}
+
+test "RFC set command example" {
+	set "honorific"  "Mr";
+	set "first_name" "Wile";
+	set "last_name"  "Coyote";
+	set "vacation" text:
+Dear ${HONORIFIC} ${last_name},
+I'm out, please leave a message after the meep.
+.
+;
+	if not string :is :comparator "i;octet" "${VAcaTION}" text:
+Dear Mr Coyote,
+I'm out, please leave a message after the meep.
+.
+	{
+		test_fail "failed to set variable correctly: ${VAcaTION}";
+	}
+}
+
+/*
+ * Variable substitution
+ */
+
+test "Multi-line string substitution" {
+	set "name" "Stephan Bosch";
+	set "address" "stephan@rename-it.nl";
+	set "subject" "Test message";
+	
+	set "message" text: # Message with substitutions
+From: ${name} <${address}>
+To: Bertus van Asseldonk <b.vanasseldonk@hetkennet.nl>
+Subject: ${subject}
+
+This is a test message.
+.
+;
+	if not string :is "${message}" text:
+From: Stephan Bosch <stephan@rename-it.nl>
+To: Bertus van Asseldonk <b.vanasseldonk@hetkennet.nl>
+Subject: Test message
+
+This is a test message.
+.
+	{
+		test_fail "variable substitution failed";
+	}
+}
+
+test "Multiple substitutions" {
+	set "a" "the monkey";
+	set "b" "a nut";
+	set "c" "the fish";
+	set "d" "on fire";
+	set "e" "eats";
+	set "f" "is";
+
+	if not string :is "${a} ${e} ${b}" "the monkey eats a nut" {
+		test_fail "variable substitution failed (1)";
+	}
+
+	if not string :is "${c} ${f} ${d}" "the fish is on fire" {
+		test_fail "variable substitution failed (2)";
+	}
+
+	set :upperfirst "sentence" "${a} ${e} ${b}";
+
+	if not string :is "${sentence}" "The monkey eats a nut" {
+		test_fail "modified variable substitution failed";
+	}	
+}
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/variables/errors/limits.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/variables/errors/limits.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/variables/errors/limits.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/variables/errors/limits.sieve	2008-08-13 00:27:45.000000000 +0200
@@ -0,0 +1,287 @@
+require "variables";
+
+# Not an error (0)
+set "var123456789012345678901234567890" "value";
+
+# Exceed the maximum variable name length (1)
+set "var123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890" "value";
+
+# Must yield unknown namespace error (no limit exceeded) (1)
+set "namespace.sub.sub.variable" "value"; 
+
+# Must yield unknown namespace error (exceeds element limit) (1)
+set "namespace.sub.sub.sub.variable" "value";
+
+# Not an error (0)
+if string "${32}" "value" {
+	stop;
+}
+
+# Exceed the maximum match value index (1)
+if string "${33}" "value" {
+	stop;
+}
+
+# Exceed the maximum number of declared variables (1!)
+set "var001" "value";
+set "var002" "value";
+set "var003" "value";
+set "var004" "value";
+set "var005" "value";
+set "var006" "value";
+set "var007" "value";
+set "var008" "value";
+set "var009" "value";
+set "var010" "value";
+set "var011" "value";
+set "var012" "value";
+set "var013" "value";
+set "var014" "value";
+set "var015" "value";
+set "var016" "value";
+set "var017" "value";
+set "var018" "value";
+set "var019" "value";
+set "var020" "value";
+set "var021" "value";
+set "var022" "value";
+set "var023" "value";
+set "var024" "value";
+set "var025" "value";
+set "var026" "value";
+set "var027" "value";
+set "var028" "value";
+set "var029" "value";
+set "var030" "value";
+set "var031" "value";
+set "var032" "value";
+set "var033" "value";
+set "var034" "value";
+set "var035" "value";
+set "var036" "value";
+set "var037" "value";
+set "var038" "value";
+set "var039" "value";
+set "var040" "value";
+set "var041" "value";
+set "var042" "value";
+set "var043" "value";
+set "var044" "value";
+set "var045" "value";
+set "var046" "value";
+set "var047" "value";
+set "var048" "value";
+set "var049" "value";
+set "var050" "value";
+set "var051" "value";
+set "var052" "value";
+set "var053" "value";
+set "var054" "value";
+set "var055" "value";
+set "var056" "value";
+set "var057" "value";
+set "var058" "value";
+set "var059" "value";
+set "var060" "value";
+set "var061" "value";
+set "var062" "value";
+set "var063" "value";
+set "var064" "value";
+set "var065" "value";
+set "var066" "value";
+set "var067" "value";
+set "var068" "value";
+set "var069" "value";
+set "var070" "value";
+set "var071" "value";
+set "var072" "value";
+set "var073" "value";
+set "var074" "value";
+set "var075" "value";
+set "var076" "value";
+set "var077" "value";
+set "var078" "value";
+set "var079" "value";
+set "var080" "value";
+set "var081" "value";
+set "var082" "value";
+set "var083" "value";
+set "var084" "value";
+set "var085" "value";
+set "var086" "value";
+set "var087" "value";
+set "var088" "value";
+set "var089" "value";
+set "var090" "value";
+set "var091" "value";
+set "var092" "value";
+set "var093" "value";
+set "var094" "value";
+set "var095" "value";
+set "var096" "value";
+set "var097" "value";
+set "var098" "value";
+set "var099" "value";
+
+set "var100" "value";
+set "var101" "value";
+set "var102" "value";
+set "var103" "value";
+set "var104" "value";
+set "var105" "value";
+set "var106" "value";
+set "var107" "value";
+set "var108" "value";
+set "var109" "value";
+set "var110" "value";
+set "var111" "value";
+set "var112" "value";
+set "var113" "value";
+set "var114" "value";
+set "var115" "value";
+set "var116" "value";
+set "var117" "value";
+set "var118" "value";
+set "var119" "value";
+set "var120" "value";
+set "var121" "value";
+set "var122" "value";
+set "var123" "value";
+set "var124" "value";
+set "var125" "value";
+set "var126" "value";
+set "var127" "value";
+set "var128" "value";
+set "var129" "value";
+set "var130" "value";
+set "var131" "value";
+set "var132" "value";
+set "var133" "value";
+set "var134" "value";
+set "var135" "value";
+set "var136" "value";
+set "var137" "value";
+set "var138" "value";
+set "var139" "value";
+set "var140" "value";
+set "var141" "value";
+set "var142" "value";
+set "var143" "value";
+set "var144" "value";
+set "var145" "value";
+set "var146" "value";
+set "var147" "value";
+set "var148" "value";
+set "var149" "value";
+set "var150" "value";
+set "var151" "value";
+set "var152" "value";
+set "var153" "value";
+set "var154" "value";
+set "var155" "value";
+set "var156" "value";
+set "var157" "value";
+set "var158" "value";
+set "var159" "value";
+set "var160" "value";
+set "var161" "value";
+set "var162" "value";
+set "var163" "value";
+set "var164" "value";
+set "var165" "value";
+set "var166" "value";
+set "var167" "value";
+set "var168" "value";
+set "var169" "value";
+set "var170" "value";
+set "var171" "value";
+set "var172" "value";
+set "var173" "value";
+set "var174" "value";
+set "var175" "value";
+set "var176" "value";
+set "var177" "value";
+set "var178" "value";
+set "var179" "value";
+set "var180" "value";
+set "var181" "value";
+set "var182" "value";
+set "var183" "value";
+set "var184" "value";
+set "var185" "value";
+set "var186" "value";
+set "var187" "value";
+set "var188" "value";
+set "var189" "value";
+set "var190" "value";
+set "var191" "value";
+set "var192" "value";
+set "var193" "value";
+set "var194" "value";
+set "var195" "value";
+set "var196" "value";
+set "var197" "value";
+set "var198" "value";
+set "var199" "value";
+set "var200" "value";
+
+set "var201" "value";
+set "var202" "value";
+set "var203" "value";
+set "var204" "value";
+set "var205" "value";
+set "var206" "value";
+set "var207" "value";
+set "var208" "value";
+set "var209" "value";
+set "var210" "value";
+set "var211" "value";
+set "var212" "value";
+set "var213" "value";
+set "var214" "value";
+set "var215" "value";
+set "var216" "value";
+set "var217" "value";
+set "var218" "value";
+set "var219" "value";
+set "var220" "value";
+set "var221" "value";
+set "var222" "value";
+set "var223" "value";
+set "var224" "value";
+set "var225" "value";
+set "var226" "value";
+set "var227" "value";
+set "var228" "value";
+set "var229" "value";
+set "var230" "value";
+set "var231" "value";
+set "var232" "value";
+set "var233" "value";
+set "var234" "value";
+set "var235" "value";
+set "var236" "value";
+set "var237" "value";
+set "var238" "value";
+set "var239" "value";
+set "var240" "value";
+set "var241" "value";
+set "var242" "value";
+set "var243" "value";
+set "var244" "value";
+set "var245" "value";
+set "var246" "value";
+set "var247" "value";
+set "var248" "value";
+set "var249" "value";
+set "var250" "value";
+set "var251" "value";
+set "var252" "value";
+set "var253" "value";
+set "var254" "value";
+set "var255" "value";
+set "var256" "value";
+set "var257" "value";
+set "var258" "value";
+set "var259" "value";
+set "var260" "value";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/variables/errors/namespace.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/variables/errors/namespace.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/variables/errors/namespace.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/variables/errors/namespace.sieve	2008-08-04 10:39:20.000000000 +0200
@@ -0,0 +1,8 @@
+require "variables";
+require "fileinto";
+
+set "namespace.frop" "value";
+set "complex.struct.frop" "value";
+
+fileinto "${namespace.frop}";
+fileinto "${complex.struct.frop}";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/variables/errors/set.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/variables/errors/set.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/variables/errors/set.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/variables/errors/set.sieve	2008-08-04 10:39:20.000000000 +0200
@@ -0,0 +1,19 @@
+require "variables";
+
+# Invalid variable name
+set "${frop}" "frop";
+set "...." "frop";
+set "name." "frop";
+set ".name" "frop";
+
+# Not an error
+set "\n\a\m\e" "frop";
+
+# Trying to assign match variable;
+set "0" "frop";
+
+# Not an error
+set :UPPER "name" "frop";
+
+# Invalid tag
+set :inner "name" "frop";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/variables/errors.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/variables/errors.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/variables/errors.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/variables/errors.svtest	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,34 @@
+require "vnd.dovecot.testsuite";
+
+require "comparator-i;ascii-numeric";
+require "relational";
+
+test "Invalid namespaces (FIXME: count only)" {
+	if test_script_compile "errors/namespace.sieve" {
+		test_fail "compile should have failed";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "5" {
+		test_fail "wrong number of errors reported";
+	}
+}
+
+test "Invalid set command invocations (FIXME: count only)" {
+	if test_script_compile "errors/set.sieve" {
+		test_fail "compile should have failed";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "7" {
+		test_fail "wrong number of errors reported";
+	}
+}
+
+test "Limits (FIXME: count only)" {
+	if test_script_compile "errors/limits.sieve" {
+		test_fail "compile should have failed";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "6" {
+		test_fail "wrong number of errors reported";
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/variables/match.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/variables/match.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/variables/match.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/variables/match.svtest	2009-02-11 22:16:39.000000000 +0100
@@ -0,0 +1,365 @@
+require "vnd.dovecot.testsuite";
+
+require "variables";
+
+/*
+ * RFC compliance
+ */
+
+# Test acceptance of leading zeroes
+test "RFC - leading zeroes" {
+	if not string :matches "frop:frup:frop" "*:*:*" {
+		test_fail "failed to match";
+	}
+
+	if not string :is "${0000002}" "frup" {
+		test_fail "incorrect match value (0000002): ${0000002}";
+	}
+}
+
+# Test non-greedyness
+test "RFC - not greedy" {
+	if not string :matches "frop.......frop.........frop...." "?*frop*" {
+		test_fail "failed to match";
+	}
+
+	if not string :is "${1}${2}${3}" "frop................frop...." {
+		test_fail "incorrect match values: ${1}${2}${3}";
+	}
+}
+
+# Index out of range
+test "RFC - index out of range" {
+	if not string :matches "test" "*" {
+		test_fail "failed to match (impossible)";
+	}
+
+	if not string :is "${2}" "" {
+		test_fail "incorrect match value: '${2}'";
+	}
+}
+
+# Index 0
+test "RFC - index 0" {
+	if not string :matches "a b c d e f g" "? ? ? ? ? ? ?" {
+		test_fail "failed to match";
+	}
+
+	if not string :is "${0}" "a b c d e f g" {
+        test_fail "incorrect match value: ${0}";
+    }
+}
+
+# Test short-circuit
+test "RFC - test short-circuit" {
+	if not anyof (
+		string :matches "a b c d e f g" "? ?",
+		string :matches "puk pok puk pok" "pu*ok",
+		string :matches "snot kip snot" "snot*snot"
+	) {
+		test_fail "failed to match any";
+	}
+
+	if string :is "${1}" " kip " {
+		test_fail "did not short-circuit test execution or intented test failed.";
+	}
+
+	if not string :is "${1}" "k pok puk p" {
+		test_fail "incorrect match value: ${1}";
+	}
+}
+
+# Test overwriting only on match 
+test "RFC - values overwrite" {
+	set "sentence1" "the cat jumps off the table";
+	set "sentence2" "the dog barks at the cat in the alley";
+
+	if not string :matches "${sentence1}" "the * jumps off the *" {
+		test_fail "failed to match first sentence";
+	} 
+	
+	if not string :is "${1}:${2}" "cat:table" {
+		test_fail "invalid match values";
+	}
+
+	if string :matches "${sentence2}" "the * barks at the * in the store" {
+		test_fail "should not have matched second sentence";
+	}
+
+	if not string :is "${1}:${2}" "cat:table" {
+		test_fail "should have preserved match values";
+	}
+
+	if not string :matches "${sentence2}" "the * barks at the * in the alley" {
+		test_fail "failed to match the second sentence (second time)";
+	}
+
+	if not string :is "${1}:${2}" "dog:cat" {
+		test_fail "should have overwritten match values";
+	}
+}
+
+test "RFC - example" {
+	test_set "message" text:
+Subject: [acme-users] [fwd] version 1.0 is out
+List-Id: Dovecot Mailing List <dovecot@dovecot.org>     
+To: coyote@ACME.Example.COM
+Fom: stephan@rename-it.nl
+
+Test message.
+.
+;
+	if header :matches "List-ID" "*<*@*" {	
+		if not string "INBOX.lists.${2}" "INBOX.lists.dovecot" {
+			test_fail "incorrect match value: INBOX.lists.${2}";
+		}
+	} else {
+		test_fail "failed to match list header";
+	}
+
+	# Imagine the header
+	# Subject: [acme-users] [fwd] version 1.0 is out
+	if header :matches "Subject" "[*] *" {
+		# ${1} will hold "acme-users",
+		# ${2} will hold "[fwd] version 1.0 is out"
+
+		if anyof (
+			not string "${1}" "acme-users",
+			not string "${2}" "[fwd] version 1.0 is out"
+		) {
+			test_fail "invalid match values: ${1} ${2}";
+		}
+	} else {
+		test_fail "failed to match subject";
+	}
+
+	# Imagine the header
+	# To: coyote@ACME.Example.COM
+	if address :matches ["To", "Cc"] ["coyote@**.com", 
+		"wile@**.com"] {
+		# ${0} is the matching address
+		# ${1} is always the empty string
+		# ${2} is part of the domain name ("ACME.Example")
+
+		if anyof (
+			not string "${0}" "coyote@ACME.Example.COM",
+			not string "${1}" "",
+			not string "${2}" "ACME.Example"
+		) {
+			test_fail "invalid match values: ${0}, ${1}, ${2}";
+		}      
+	} else {
+		# Control wouldn't reach this block if any match was
+		# successful, so no match variables are set at this
+ 		# point.
+
+		test_fail "failed to match to address";
+ 	}
+
+	if anyof (true, address :domain :matches "To" "*.com") {
+		# The second test is never evaluated, so there are
+		# still no match variables set.
+		
+		/* FIXME: not compliant */
+	}
+}
+
+/*
+ * Generic tests
+ */
+
+set "match1" "Test of general stupidity";
+
+test "Begin" {
+	if not string :matches "${match1}" "Test of *" {
+		test_fail "should have matched";
+	} 
+
+	if not string :is "${1}" "general stupidity" {
+		test_fail "match value incorrect";
+	}
+}
+
+test "Begin no match" {
+	if string :matches "${match1}" "of *" {
+		test_fail "should not have matched";
+	}
+}
+
+set "match2" "toptoptop";
+
+test "End" {
+	if not string :matches "${match2}" "*top" {
+		test_fail "should have matched";
+	}
+
+	if not string :is "${1}" "toptop" {
+		test_fail "match value incorrect";
+	}
+}
+
+set "match3" "ik ben een tukker met grote oren en een lelijke broek.";
+
+test "Multiple" {
+	if not string :matches "${match3}" "ik ben * met * en *." {
+		test_fail "should have matched";
+	} 
+
+	set "line" "Hij is ${1} met ${2} en ${3}!";
+
+	if not string :is "${line}"
+		"Hij is een tukker met grote oren en een lelijke broek!" {
+		test_fail "match values incorrect: ${line}";
+	}
+}
+
+set "match4" "beter van niet?";
+
+test "Escape" {
+	if not string :matches "${match4}" "*\\?" {
+		test_fail "should have matched";
+	} 
+
+	if not string :is "${1}" "beter van niet" {
+		test_fail "match value incorrect: ${1}";
+	}
+}
+
+set "match5" "The quick brown fox jumps over the lazy dog.";
+
+test "Alphabet ?" {
+	if not string :matches "${match5}" "T?? ????? ????? ?o? ?u??? o?er ?he ???? ?o?." {
+		test_fail "should have matched";
+	} 
+
+	set "alphabet" "${22}${8}${6}${25}${2}${13}${26}${1}${5}${15}${7}${21}${16}${12}${10}${17}${3}${9}${18}${20}${4}${19}${11}${14}${24}${23}";
+
+	if not string :is "${alphabet}" "abcdefghijklmnopqrstuvwxyz" {
+		test_fail "match values incorrect: ${alphabet}";
+	}
+
+	if string :matches "${match5}" "T?? ????? ?w??? ?o? ?u??? o?er ?he ???? ?o?." {
+		test_fail "should not have matched";
+	}
+}
+
+set "match6" "zero:one:zero|three;one;zero/five";
+
+test "Words sep ?" {
+
+	if not string :matches "${match6}" "*one?zero?five" {
+		test_fail "should have matched";
+	}
+
+	if not string :is "${1}${2}${3}" "zero:one:zero|three;;/" {
+		test_fail "incorrect match values: ${1} ${2} ${3}";
+	}
+}
+
+set "match7" "frop";
+
+test "Letters begin ?" {
+	if not string :matches "${match7}" "??op" {
+		test_fail "should have matched";
+	}
+		
+	set "val" "${0}:${1}:${2}:${3}:";
+	
+	if not string :is "${val}" "frop:f:r::" {
+		test_fail "incorrect match values: ${val}";
+	}
+}
+
+test "Letters end ?" {
+    if not string :matches "${match7}" "fr??" {
+        test_fail "should have matched";
+    }
+
+    set "val" "${0}:${1}:${2}:${3}:";
+
+    if not string :is "${val}" "frop:o:p::" {
+        test_fail "incorrect match values: ${val}";
+    }
+}
+
+set "match8" "klopfropstroptop";
+
+test "Letters words *? - 1" {
+	if not string :matches "${match8}" "*fr??*top" {
+		test_fail "should have matched";
+	}
+
+	set "val" ":${0}:${1}:${2}:${3}:${4}:${5}:";
+	
+	if not string :is "${val}" ":klopfropstroptop:klop:o:p:strop::" {
+		test_fail "incorrect match values: ${val}";
+	}
+}
+
+test "Letters words *? - 2" {
+	if not string :matches "${match8}" "?*fr??*top" {
+		test_fail "should have matched";
+	}
+	
+	set "val" ":${0}:${1}:${2}:${3}:${4}:${5}:${6}:";
+
+	if not string :is "${val}" ":klopfropstroptop:k:lop:o:p:strop::" {
+		test_fail "incorrect match values: ${val}";
+	}
+}
+
+test "Letters words *? backtrack" {
+	if not string :matches "${match8}" "*?op" {
+		test_fail "should have matched";
+	}
+
+	set "val" ":${0}:${1}:${2}:${3}:${4}:";
+	
+	if not string :is "${val}" ":klopfropstroptop:klopfropstrop:t:::" {
+		test_fail "incorrect match values: ${val}";
+	}
+}
+
+test "Letters words *? first" {
+	if not string :matches "${match8}" "*?op*" {
+		test_fail "failed to match";
+	}
+
+	set "val" ":${0}:${1}:${2}:${3}:${4}:";
+
+	if not string :is "${val}" ":klopfropstroptop:k:l:fropstroptop::" {
+		test_fail "incorrect match values: ${val}";
+	}
+}
+
+/*
+ * Specific tests
+ */
+
+test_set "message" text:
+Return-path: <stephan@xi.rename-it.nl>
+Envelope-to: stephan@xi.rename-it.nl
+Delivery-date: Sun, 01 Feb 2009 11:29:57 +0100
+Received: from stephan by xi.rename-it.nl with local (Exim 4.69)
+	(envelope-from <stephan@xi.rename-it.nl>)
+	id 1LTZaP-0007h3-2e
+	for stephan@xi.rename-it.nl; Sun, 01 Feb 2009 11:29:57 +0100
+From: Dovecot Debian Builder <stephan.rename-it.nl@xi.rename-it.nl>
+To: stephan@xi.rename-it.nl
+Subject: Log for failed build of dovecot_2:1.2.alpha5-0~auto+159 (dist=hardy)
+Message-Id: <E1LTZaP-0007h3-2e@xi.rename-it.nl>
+Date: Sun, 01 Feb 2009 11:29:57 +0100
+
+Automatic build of dovecot_1.2.alpha5-0~auto+159 on xi by sbuild/i386 0.57.7
+.
+;
+
+test "Match combined" {
+	if not header :matches "subject" "Log for ?* build of *" {
+		test_fail "failed to match";
+	}
+
+	if not string "${1}${2}" "failed" {
+		test_fail "incorrect match values: ${1}${2}";
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/variables/modifiers.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/variables/modifiers.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/variables/modifiers.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/variables/modifiers.svtest	2008-08-01 19:59:33.000000000 +0200
@@ -0,0 +1,140 @@
+require "vnd.dovecot.testsuite";
+require "variables";
+
+/*
+ * Modifiers
+ */
+
+test "Modifier :lower" {
+	set :lower "test" "VaLuE";
+
+	if not string :is "${test}" "value" {
+		test_fail "modified variable assignment failed";
+	}
+}
+
+test "Modifiers :lower :upperfirst" {
+	set :lower :upperfirst "test" "vAlUe";
+
+	if string :is "${test}" "value" {
+		test_fail "modifiers applied with wrong precedence";
+	}
+
+	if not string :is "${test}" "Value" {
+		test_fail "modified variable assignment failed";
+	}
+}
+
+test "Modifiers :upperfirst :lower" {
+	set :upperfirst :lower "test" "vAlUe";
+
+	if string :is "${test}" "value" {
+		test_fail "modifiers applied with wrong precedence";
+	}
+
+	if not string :is "${test}" "Value" {
+		test_fail "modified variable assignment failed";
+	}
+}
+
+test "Modifier :upper" {
+	set :upper "test" "vAlUe";
+
+	if not string :is "${test}" "VALUE" {
+		test_fail "modified variable assignment failed";
+	}
+}
+
+test "Modifiers :upper :lowerfirst" {
+	set :upper :lowerfirst "test" "VaLuE";
+
+	if string :is "${test}" "VALUE" {
+		test_fail "modifiers applied with wrong precedence";
+	}
+
+	if not string :is "${test}" "vALUE" {
+		test_fail "modified variable assignment failed";
+	}
+}
+
+test "Modifiers :lowerfirst :upper" {
+	set :lowerfirst :upper "test" "VaLuE";
+
+	if string :is "${test}" "VALUE" {
+		test_fail "modifiers applied with wrong precedence";
+	}
+
+	if not string :is "${test}" "vALUE" {
+		test_fail "modified variable assignment failed";
+	}
+}
+
+test "Modifier :length" {
+	set :length "test" "VaLuE";
+
+	if not string :is "${test}" "5" {
+		test_fail "modified variable assignment failed";
+	}
+}
+
+test "Modifier :length (elaborate)" {
+	set "a" "abcdefghijklmnopqrstuvwxyz";
+	set "b" "1234567890";
+	set :length "test" " ${a}:${b}  ";
+
+	if not string :is "${test}" "40" {
+		test_fail "modified variable assignment failed";
+	}
+}
+
+test "Modifier :quotewildcard" {
+	set :quotewildcard "test" "^^***??**^^";
+
+	if not string :is "${test}" "^^\\*\\*\\*\\?\\?\\*\\*^^" {
+		test_fail "modified variable assignment failed";
+	}
+}
+
+test "Modifier :length :quotewildcard" {
+	set :length :quotewildcard "test" "^^***??**^^";
+
+	if string :is "${test}" "11" {
+		test_fail "modifiers applied with wrong precedence";
+	}
+
+	if not string :is "${test}" "18" {
+		test_fail "modified variable assignment failed";
+	}
+}
+
+test "RFC examples" {
+	set "a" "juMBlEd lETteRS";             # => "juMBlEd lETteRS"
+	if not string "${a}" "juMBlEd lETteRS" {
+		test_fail "modified assignment failed (1): ${a}";
+	}
+	
+	set :length "b" "${a}";                # => "15"
+	if not string "${b}" "15" {
+		test_fail "modified assignment failed (2): ${a}";
+	}
+	
+	set :lower "b" "${a}";                 #  => "jumbled letters"
+	if not string "${b}" "jumbled letters" {
+		test_fail "modified assignment failed (3): ${a}";
+	}
+	
+    set :upperfirst "b" "${a}";            # => "JuMBlEd lETteRS"
+	if not string "${b}" "JuMBlEd lETteRS" {
+		test_fail "modified assignment failed (4): ${a}";
+	}
+	
+	set :upperfirst :lower "b" "${a}";     # => "Jumbled letters"
+	if not string "${b}" "Jumbled letters" {
+		test_fail "modified assignment failed (5): ${a}";
+	}
+	
+	set :quotewildcard "b" "Rock*";        # => "Rock\*"
+	if not string "${b}" "Rock\\*" {
+		test_fail "modified assignment failed (6): ${a}";
+	}	
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/variables/quoting.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/variables/quoting.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/variables/quoting.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/variables/quoting.svtest	2008-08-01 16:55:54.000000000 +0200
@@ -0,0 +1,36 @@
+require "vnd.dovecot.testsuite";
+
+require "variables";
+require "encoded-character";
+
+test "Encodings - RFC examples" {
+	set "s" "$";
+	set "foo" "bar";
+
+	# "${fo\o}"  => ${foo}  => the expansion of variable foo.
+	if not string :is "${fo\o}" "bar" {
+		test_fail "failed 'the expansion of variable foo (${s}{fo\\o})'";
+	}
+
+	# "${fo\\o}" => ${fo\o} => illegal identifier => left verbatim.      
+	if not string :is "${fo\\o}" "${s}{fo\\o}" {
+		test_fail "failed 'illegal identifier => left verbatim'";
+	}
+
+	# "\${foo}"  => ${foo}  => the expansion of variable foo.
+	if not string "\${foo}" "bar" {
+		test_fail "failed 'the expansion of variable foo (\\${s}{foo})'";
+	}
+
+	# "\\${foo}" => \${foo} => a backslash character followed by the
+	#                          expansion of variable foo.
+	if not string "\\${foo}" "\\bar" {
+		test_fail "failed 'a backslash character followed by expansion of variable foo";
+	}
+
+	set "name" "Ethelbert";
+	if not string "dear${hex:20 24 7b 4e}ame}" "dear Ethelbert" {
+		test_fail "failed 'dear Ethelbert' example";
+    }
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/variables/regex.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/variables/regex.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/variables/regex.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/variables/regex.svtest	2008-08-25 10:25:08.000000000 +0200
@@ -0,0 +1,35 @@
+require "vnd.dovecot.testsuite";
+
+require "regex";
+require "variables";
+
+# Test overwriting only on match 
+test "RFC - values overwrite" {
+	set "sentence1" "the cat jumps off the table";
+	set "sentence2" "the dog barks at the cat in the alley";
+
+	if not string :regex "${sentence1}" "the (.*) jumps off the (.*)" {
+		test_fail "failed to match first sentence";
+	} 
+	
+	if not string :is "${1}:${2}" "cat:table" {
+		test_fail "invalid match values";
+	}
+
+	if string :regex "${sentence2}" "the (.*) barks at the (.*) in the store" {
+		test_fail "should not have matched second sentence";
+	}
+
+	if not string :is "${1}:${2}" "cat:table" {
+		test_fail "should have preserved match values";
+	}
+
+	if not string :regex "${sentence2}" "the (.*) barks at the (.*) in the alley" {
+		test_fail "failed to match the second sentence (second time)";
+	}
+
+	if not string :is "${1}:${2}" "dog:cat" {
+		test_fail "should have overwritten match values";
+	}
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/extensions/variables/string.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/variables/string.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/extensions/variables/string.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/extensions/variables/string.svtest	2008-08-04 10:39:20.000000000 +0200
@@ -0,0 +1,37 @@
+require "vnd.dovecot.testsuite";
+
+require "relational";
+require "comparator-i;ascii-numeric";
+
+require "variables";
+
+test "String - :count" {
+	if not string :count "eq" :comparator "i;ascii-numeric" ["a", "b", "c"] "3" {
+		test_fail "string test failed :count match";
+	}
+}
+
+test "String - :count \"\"" {
+	if not string :count "eq" :comparator "i;ascii-numeric" ["a", "", "c"] "2" {
+		test_fail "string test failed :count match";
+	}
+}
+
+test "RFC example" {
+	set "state" "${state} pending";
+
+	if not string :matches " ${state} " "* pending *" {
+    	# the above test always succeeds
+		
+		test_fail "test should have matched: \" ${state} \"";
+	}
+}
+
+test "No whitespace stripping" {
+	set "vara" "      value       ";
+	set "varb" "value";
+
+	if not string :is :comparator "i;octet" "${vara}" "      ${varb}       " {
+		test_fail "string test seems to have stripped white space";
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/header.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/header.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/header.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/header.svtest	2008-11-19 20:58:39.000000000 +0100
@@ -0,0 +1,57 @@
+require "vnd.dovecot.testsuite";
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Subject:         Help        
+X-A:     Text
+X-B: Text            
+X-Multiline: This is a multi-line
+ header body, which should be
+ unfolded correctly.
+
+Text
+
+.
+;
+
+test "Strip center" {
+	if not header :is "subject" "Help" {
+		test_fail "header test does not strip leading or trailing whitespace";
+	}
+}
+
+test "Strip lead" {
+    if not header :is "x-a" "Text" {
+        test_fail "header test does not strip leading whitespace";
+    }
+}
+
+test "Strip trail" {
+    if not header :is "x-b" "Text" {
+        test_fail "header test does not strip trailing whitespace";
+    }
+}
+
+test "Contains empty - exist" {
+	if not header :contains "subject" "" {
+		test_fail "header test :contains match type fails to match \"\" on existing header";
+	}
+
+	if header :contains "subject" "a" {
+		test_fail "header test :contains match type matches nonsense";
+	}
+}
+
+test "Contains empty - not exist" {
+	if header :contains "x-nonsense" "" {
+		test_fail "header test :contains match type matches \"\" on non-existant header";
+	}
+}
+
+test "Folded - equals" {
+	if not header :is "x-multiline" 
+		"This is a multi-line header body, which should be unfolded correctly." {
+		test_fail "failed to properly unfold folded header.";
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/lexer.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/lexer.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/lexer.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/lexer.svtest	2008-07-30 15:17:37.000000000 +0200
@@ -0,0 +1,39 @@
+require "vnd.dovecot.testsuite";
+require "variables";
+
+/* Test conformance to RFC 5228 - 2.4.2. Strings */
+
+set "text" text: # Comment
+Line 1
+.Line 2
+..Line 3
+.Line 4
+Line 5
+.
+;
+
+set "quoted"
+"Line 1
+.Line 2
+.Line 3
+.Line 4
+Line 5
+";
+
+test "String Literal" {
+	if not string :is "${text}" "${quoted}" {
+		test_fail "lexer messed-up dot stuffing";
+	}
+
+	if string :is "${text}" "" {
+		test_fail "variable substitution failed";
+	}
+}
+
+test "Unknown Escapes" {
+	if not string :is "\a\a\a\a\a" "aaaaa" {
+		test_fail "unknown quoted string escape sequences are handled inappropriately";
+	}
+}
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/match-types/contains.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/match-types/contains.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/match-types/contains.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/match-types/contains.svtest	2008-08-01 20:51:44.000000000 +0200
@@ -0,0 +1,81 @@
+require "vnd.dovecot.testsuite";
+
+test_set "message" text:
+From: stephan@rename-it.nl
+Cc: frop@example.com
+To: test@dovecot.org
+X-Bullshit: f fr fro frop frob frobn frobnitzn
+Subject: Test Message
+Comment:                                 
+
+Test!
+.
+;
+
+# Match tests
+
+test "Match empty" {
+	if not header :contains "x-bullshit" "" {
+		test_fail "contains tests fails to match \"\" against non-empty string";
+	}
+
+	if not header :contains "comment" "" {
+        test_fail "contains tests fails to match \"\" against empty string";
+    }
+}
+
+test "Match full" {
+	if not address :contains "from" "stephan@rename-it.nl" {
+		test_fail "should have matched";
+	}
+}
+
+test "Match begin" {
+	if not address :contains "from" "stephan" {
+		test_fail "should have matched";
+	}
+}
+
+test "Match end" {
+	if not address :contains "from" "rename-it.nl" {
+		test_fail "should have matched";
+	}
+}
+
+test "Match middle" {
+	if not address :contains "from" "@" {
+		test_fail "should have matched";
+	}
+}
+
+test "Match similar beginnings" {
+	if not header :contains "x-bullshit" "frobnitzn" {
+		test_fail "should have matched";
+	}
+}
+
+test "Match case-insensitive" {
+	if not address :contains :comparator "i;ascii-casemap" "from" "RENAME-IT" {
+		test_fail "match fails to apply correct comparator";	
+	}
+
+	if not address :contains "from" "RENAME-IT" {
+        test_fail "default comparator is wrong";
+    }
+}
+
+# Non-match tests
+
+test "No match full (typo)" {
+	if address :contains "to" "frob@example.com" {
+		test_fail "should not have matched";
+	}
+}
+
+test "No match end (typo)" {
+	if header :contains "x-bullshit" "frobnitzm" {
+		test_fail "should not have matched";
+	}
+}
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/match-types/is.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/match-types/is.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/match-types/is.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/match-types/is.svtest	2008-08-01 20:49:51.000000000 +0200
@@ -0,0 +1,22 @@
+require "vnd.dovecot.testsuite";
+
+test_set "message" text:
+From: Stephan Bosch <stephan@rename-it.nl>
+To: nico@vestingbar.nl
+Subject: Test message
+Comment:                                     
+
+Test!
+
+.
+;
+
+test "Empty key" {
+	if header :is "from" "" {
+		test_fail "erroneously matched empty key against non-empty string"; 
+	}
+
+	if not header :is "comment" "" {
+		test_fail "failed to match empty string";
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/match-types/matches.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/match-types/matches.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/match-types/matches.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/match-types/matches.svtest	2009-02-02 10:17:30.000000000 +0100
@@ -0,0 +1,214 @@
+require "vnd.dovecot.testsuite";
+
+test_set "message" text:
+From: stephan+sieve@drunksnipers.com
+To: sirius@rename-it.nl
+To: nico@vestingbar.nl
+Cc: me@example.com
+Cc: timo@dovecot.com
+X-Hufter: TRUE
+Subject: make your money very fast!!!
+X-Spam-Score: **********
+X-Bullshit: 33333???a
+Message-ID: <90a02fe01fc25e131d0e9c4c45975894@example.com>
+Comment:                                            
+X-Subject: Log for successful build of Dovecot.
+
+Het werkt!
+.
+;
+
+/*
+ * General conformance testing
+ */
+
+/*
+test "Empty string" {
+	if not header :matches "comment" "" {
+		test_fail "failed to match \"\" against \"\"";
+	}
+
+	if not header :matches "comment" "*" {
+		test_fail "failed to match \"\" against \"*\"";
+	}
+
+	if header :matches "comment" "?" {
+		test_fail "inappropriately matched \"\" against \"?\"";
+	}
+}
+
+test "Multiple '*'" {
+	if not address :matches "from" "*@d*ksn*ers.com" {
+		test_fail "should have matched";
+	}
+
+	if address :matches "from" "*@d*kn*ers.com" {
+		test_fail "should not have matched";
+	}
+}
+
+test "End '*'" {
+	if not address :matches "from" "stephan+sieve@drunksnipers.*" {
+		test_fail "should have matched";
+	}
+
+	if address :matches "from" "stepan+sieve@drunksnipers.*" {
+		test_fail "should not have matched";
+	}
+}
+
+test "Begin '*'" {
+	if not address :matches "from" "*+sieve@drunksnipers.com" {
+		test_fail "should have matched";
+	}
+
+	if address :matches "from" "*+sieve@drunksnipers.om" {
+		test_fail "should not have matched";
+	}
+}
+
+test "Middle '?'" {
+	if not address :matches "from" "stephan+sieve?drunksnipers.com" {
+		test_fail "should have matched";
+	}
+
+	if address :matches "from" "stephan+sieve?drunksipers.com" {
+		test_fail "should not have matched";
+	}
+}
+
+test "Begin '?'" {
+	if not address :matches "from" "?tephan+sieve@drunksnipers.com" {
+		test_fail "should have matched";
+	}
+
+	if address :matches "from" "?tephan+sievedrunksnipers.com" {
+		test_fail "should not have matched";
+	}
+}
+
+test "End '?'" {
+	if not address :matches "from" "stephan+sieve@drunksnipers.co?" {
+		test_fail "should have matched";
+	}
+
+	if address :matches "from" "sephan+sieve@drunksnipers.co?" {
+		test_fail "should not have matched";
+	}
+}
+
+test "Multiple '?'" {
+	if not address :matches "from" "?t?phan?sieve?drunksnip?rs.co?" {
+		test_fail "should have matched";
+	}
+
+	if address :matches "from" "?t?phan?sieve?dunksnip?rs.co?" {
+		test_fail "should not have matched";
+	}
+}
+
+test "Escaped '?'" {
+	if not header :matches "x-bullshit" "33333\\?\\?\\??" {
+		test_fail "should have matched";
+	}
+
+	if header :matches "x-bullshit" "33333\\?\\?\\?" {
+		test_fail "should not have matched";
+	}
+}
+
+test "Escaped '?' following '*'" {
+	if not header :matches "x-bullshit" "33333*\\?\\??" {
+		test_fail "should have matched";
+	}
+
+}
+
+test "Escaped '?' directly following initial '*'" {
+	if not header :matches "X-Bullshit" "*\\?\\?\\?a" {
+		test_fail "should have matched";
+	}
+}
+
+test "Escaped '?' following initial '*'" {
+	if not header :matches "x-bullshit" "*3333\\?\\?\\?a" {
+		test_fail "should have matched";
+	}
+}
+
+test "Escaped '*' with active '*' at the end" {
+	if not header :matches "x-spam-score" "\\*\\*\\*\\*\\**" {
+		test_fail "should have matched";
+	}
+}
+
+test "All escaped '*'" {
+	if not header :matches "x-spam-score" "\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*" {
+		test_fail "should have matched";
+	}
+
+	if header :matches "x-spam-score" "\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*" {
+		test_fail "should not have matched";
+	}
+}
+
+test "Middle not escaped '*'" {
+	if not header :matches "x-spam-score" "\\*\\*\\***\\*\\*" {
+		test_fail "should have matched";
+	}
+}
+
+test "Escaped '*' alternating with '?'" {
+	if not header :matches "x-spam-score" "\\*?\\*?\\*?\\*?\\*?" {
+		test_fail "should have matched";
+	}
+
+	if header :matches "x-spam-score" "\\*?\\*?\\*?\\*?\\*??" {
+		test_fail "should not have matched";
+	}
+}
+
+test "All escaped" {
+	if header :matches "x-bullshit" "\\*3333\\?\\?\\?a" {
+		test_fail "should not have matched";
+	}
+
+
+	if header :matches "x-bullshit" "33333\\?\\?\\?aa" {
+		test_fail "should not have matched";
+	}
+
+	if header :matches "x-bullshit" "\\f3333\\?\\?\\?a" {
+		test_fail "should not have matched";
+	}
+}
+
+test "Put '*' directly before '?'" {
+	if header :matches "x-subject" "Log for *??????????? build of *" {
+		test_fail "should not have matched";
+	}
+
+	if not header :matches "x-subject" "Log for *?????????? build of *" {
+		test_fail "should have matched";
+	}
+
+	if not header :matches "x-subject" "Log for *? build of *" {
+		test_fail "should have matched";
+	}
+}*/
+
+test "Put '?' directly before '*'" {
+	if header :matches "x-subject" "Log for ???????????* build of *" {
+		test_fail "should not have matched";
+	}
+
+	if not header :matches "x-subject" "Log for ??????????* build of *" {
+		test_fail "should have matched";
+	}
+
+	if not header :matches "x-subject" "Log for ?* build of *" {
+		test_fail "should have matched";
+	}
+}
+
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/multiscript/basic.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/multiscript/basic.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/multiscript/basic.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/multiscript/basic.svtest	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,91 @@
+require "vnd.dovecot.testsuite";
+
+test_set "message" text:
+From: stephan@rename-it.nl
+Message-ID: <frop33333333333333333@frutsens.nl>
+To: nico@vestingbar.nl
+Subject: Frop.
+
+Friep.
+.
+;
+
+test "Append" {
+	if not allof (
+		test_script_compile "fileinto-inbox.sieve",
+		test_script_run ){
+		test_fail "failed to compile and run first script";
+	}
+
+	if not allof ( 
+		test_script_compile "vacation.sieve",
+		test_script_run :append_result ) {
+		test_fail "failed to compile and run second script";
+	}
+
+	if not allof ( 
+		test_script_compile "notify.sieve",
+		test_script_run :append_result ) {
+		test_fail "failed to compile and run third script";
+	}
+
+	if not test_result :index 1 "store" {
+		test_fail "first action is not 'store'";
+	}
+
+	if not test_result :index 2 "vacation" {
+		test_fail "second action is not 'vacation'";
+	}
+
+	if not test_result :index 3 "notify" {
+		test_fail "third action is not 'notify'";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed";
+	}
+}
+
+test "Sequential Execute" {
+	if not allof (
+		test_script_compile "fileinto-inbox.sieve",
+		test_script_run ) {
+		test_fail "failed to compile and run first script";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed after first script";
+	}
+
+	if not allof (
+		test_script_compile "vacation.sieve",
+		test_script_run :append_result ) {
+		test_fail "failed to compile and run second script";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed after second script";
+	}
+
+	if not allof (
+		test_script_compile "notify.sieve",
+		test_script_run :append_result ) {
+		test_fail "failed to compile and run third script";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed after third script";
+	}
+
+	if not test_result :index 1 "store" {
+		test_fail "first action is not 'store'";
+	}
+
+	if not test_result :index 2 "vacation" {
+		test_fail "second action is not 'vacation'";
+	}
+
+	if not test_result :index 3 "notify" {
+		test_fail "third action is not 'notify'";
+	}
+}
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/multiscript/conflicts.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/multiscript/conflicts.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/multiscript/conflicts.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/multiscript/conflicts.svtest	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,94 @@
+require "vnd.dovecot.testsuite";
+
+test_set "message" text:
+From: stephan@rename-it.nl
+Message-ID: <frop33333333333333333@frutsens.nl>
+To: nico@vestingbar.nl
+Subject: Frop.
+
+Friep.
+.
+;
+
+test "Graceful Conflicts" {
+	if not allof (
+		test_script_compile "fileinto-inbox.sieve",
+		test_script_run ){
+		test_fail "failed to compile and run first script";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed after first script";
+	}
+
+	if not allof ( 
+		test_script_compile "reject-1.sieve",
+		test_script_run :append_result ) {
+		test_fail "failed to compile and run second script";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed after second script";
+	}
+
+	if not allof ( 
+		test_script_compile "reject-2.sieve",
+		test_script_run :append_result ) {
+		test_fail "failed to compile and run third script";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed after third script";
+	}
+
+	if not test_result :index 1 "store" {
+		test_fail "first action is not 'store'";
+	}
+
+	if test_result :index 2 "reject" {
+		test_fail "reject action not discarded";
+	}
+}
+
+test "Duplicates" {
+	if not allof (
+		test_script_compile "fileinto-inbox.sieve",
+		test_script_run ){
+		test_fail "failed to compile and run first script";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed after first script";
+	}
+
+	if not allof ( 
+		test_script_compile "fileinto-inbox.sieve",
+		test_script_run :append_result ) {
+		test_fail "failed to compile and run second script";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed after second script";
+	}
+
+	if not allof ( 
+		test_script_compile "keep.sieve",
+		test_script_run :append_result ) {
+		test_fail "failed to compile and run third script";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed after third script";
+	}
+
+	test_result_print;
+
+	if not test_result :index 1 "keep" {
+		test_fail "first action is not 'keep'";
+	}
+
+	if test_result :index 2 "store" {
+		test_fail "fileinto action not discarded";
+	}
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/multiscript/fileinto-frop.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/multiscript/fileinto-frop.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/multiscript/fileinto-frop.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/multiscript/fileinto-frop.sieve	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,3 @@
+require "fileinto";
+
+fileinto "frop";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/multiscript/fileinto-inbox.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/multiscript/fileinto-inbox.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/multiscript/fileinto-inbox.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/multiscript/fileinto-inbox.sieve	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,4 @@
+require "fileinto";
+
+fileinto "INBOX";
+
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/multiscript/keep.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/multiscript/keep.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/multiscript/keep.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/multiscript/keep.sieve	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1 @@
+keep;
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/multiscript/notify.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/multiscript/notify.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/multiscript/notify.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/multiscript/notify.sieve	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,3 @@
+require "enotify";
+
+notify "mailto:stephan@rename-it.nl";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/multiscript/reject-1.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/multiscript/reject-1.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/multiscript/reject-1.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/multiscript/reject-1.sieve	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,3 @@
+require "reject";
+
+reject "Message is not wanted.";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/multiscript/reject-2.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/multiscript/reject-2.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/multiscript/reject-2.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/multiscript/reject-2.sieve	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,3 @@
+require "reject";
+
+reject "Will not accept this nonsense.";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/multiscript/vacation.sieve dovecot-1.2.4.debian/dovecot-libsieve/tests/multiscript/vacation.sieve
--- dovecot-1.2.4/dovecot-libsieve/tests/multiscript/vacation.sieve	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/multiscript/vacation.sieve	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,3 @@
+require "vacation";
+
+vacation "I am not home";
diff -urN dovecot-1.2.4/dovecot-libsieve/tests/testsuite.svtest dovecot-1.2.4.debian/dovecot-libsieve/tests/testsuite.svtest
--- dovecot-1.2.4/dovecot-libsieve/tests/testsuite.svtest	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/tests/testsuite.svtest	2009-01-06 00:15:52.000000000 +0100
@@ -0,0 +1,75 @@
+require "vnd.dovecot.testsuite";
+require "envelope";
+
+/* Test message environment */
+
+test "Message Environment" {
+	test_set "message" text:
+From: sirius@rename-it.nl
+To: nico@vestingbar.nl
+Subject: Frop!
+
+Frop!
+.
+	;
+
+	if not header :contains "from" "rename-it.nl" {
+		test_fail "message data not set properly.";
+	}
+
+	test_set "message" text:
+From: nico@vestingbar.nl
+To: stephan@zuiphol.nl
+Subject: Friep!
+
+Friep!
+.
+	;
+
+	if not header :is "from" "nico@vestingbar.nl" {
+    	test_fail "message data not set properly.";
+	} 
+
+	keep;
+}
+
+/* Test envelope environment */
+
+test "Envelope Environment" {
+	test_set "envelope.from" "stephan@hutsefluts.nl";
+
+	if not envelope :is "from" "stephan@hutsefluts.nl" {
+        test_fail "envelope.from data not set properly (1).";
+    }
+
+	test_set "envelope.to" "news@rename-it.nl";
+
+	if not envelope :is "to" "news@rename-it.nl" {
+        test_fail "envelope.to data not set properly (1).";
+    }
+
+	test_set "envelope.auth" "sirius";
+
+    if not envelope :is "auth" "sirius" {
+        test_fail "envelope.auth data not set properly (1).";
+    }
+
+	test_set "envelope.from" "stephan@rename-it.nl";
+
+	if not envelope :is "from" "stephan@rename-it.nl" {
+        test_fail "envelope.from data not reset properly (2).";
+    }
+
+	test_set "envelope.to" "past-news@rename-it.nl";
+
+	if not envelope :is "to" "past-news@rename-it.nl" {
+        test_fail "envelope.to data not reset properly (2).";
+    }
+
+	test_set "envelope.auth" "zilla";
+
+    if not envelope :is "auth" "zilla" {
+        test_fail "envelope.auth data not reset properly (2).";
+    }
+}
+
diff -urN dovecot-1.2.4/dovecot-libsieve/TODO dovecot-1.2.4.debian/dovecot-libsieve/TODO
--- dovecot-1.2.4/dovecot-libsieve/TODO	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4.debian/dovecot-libsieve/TODO	2009-08-21 00:52:15.000000000 +0200
@@ -0,0 +1,99 @@
+Current activities:
+
+* Build a sieve tool to filter an entire existing mailbox through a Sieve 
+  script:
+	- Add commandline options to fully customize execution
+	- Write manual page
+
+Next (in order of descending priority/precedence):
+
+* Implement namespace support for variables extension (to complete include 
+  extension)
+* Update include extension to latest draft:
+	- Perform script name check
+	- Implement global namespace
+	- Allow placing the global command anywhere in the script
+* Implement mechanism for implicitly including an account's aliases in the
+  vacation command's :addresses list.
+* Improve error handling. Now it is not very consistent, especially for the 
+  Sieve command line tools. 
+* Detect permission errors when writing global script binaries and advise the 
+  administrator on using sievec to precompile the scripts. 
+* Improve debugging support in the sieve-test tool:
+	- Improve trace debugging towards something more intuitively readable.
+	- Give trace debugging multiple levels of verbosity (e.g. to include more 
+    messy output like value matching).
+* Implement dropping errors in the user's mailbox as a mail message.
+* Implement a better way to encode source line numbers into a binary for
+  reporting errors at runtime. Currently, this is done explicitly for each 
+  command that adds actions to the result. However, some tests, match types etc. 
+  will also need this when the variables extension is active. Many of the RFC 
+  deviations listed below depend on this. Also trace debugging will benefit.
+* Fix remaining RFC deviations:
+	- Fix issues listed in doc/rfc/RFC-questions.txt based on answers
+	- Allow for the existance of dynamic comparators (i.e. specified by 
+	  variables). 
+	- Allow for :regex matching with variable key.
+	- Detect assignment of too large constant values to variables at compile
+	  time.
+	- Verify outgoing mail addresses at runtime when necessary
+	  (e.g. after variables substitution)
+	- Vacation: the ":subject" parameter specifies a subject line to attach to 
+	  any vacation response that is generated. UTF-8 characters can be used in
+	  the string argument; implementations MUST convert the string to [RFC2047]
+ 	  encoded words if and only if non-ASCII characters are present.
+	- Body: contains various issues that need to be resolved for standards
+	  compliance. Body test support currently matches but barely exceeds the
+	  original CMU Sieve implentation in terms of standards compliance.
+	- Improve handling of invalid addresses in headers (requires Dovecot changes)
+* Add normalize() method to comparators to normalize the string before matching
+  (for efficiency).
+* Properly implement Sieve internationalization support (utf-8 handling), 
+  currently it is not complete:
+	- Make this implementation conform section 2.7.2 of RFC5228 (Comparisons 
+	  Across Character Sets). 
+	- Verify validity of utf8 where necessary.
+	- Implement comparator-i;unicode-casemap.
+* Make testsuite much more exhaustive:
+	- add support for testing the content of result actions
+	- test as many error/warning/info conditions as possible. 
+	- review the specification documents and check whether the given conditions
+	  are tested at least once.
+* Code cleanup:
+	- Make address handling more uniform. 
+	- Review all FIXMEs 
+
+* Build a server with test mail accounts that processes lots and lots of mail 
+  (e.g. spam, mailing lists etc.)
+
+* ## MAKE A SECOND RELEASE (0.2.x) ##
+
+* Provide a solution for mail_get_headers_utf8 reparsing the whole message each
+  time it is called (header and address test; Timo might provide solution from
+  within Dovecot)
+* Optimize code containing true/false tests to omit explicit JMP opcodes
+  (i.e. optimize the test away and any code that negatively depends on it)
+* Use lib/str-find.h for :contains and :matches match types 
+* Warn during compile if using non-existent folders.
+* Implement index extension
+* Enotify extension: detect use of variable values extracted from the message 
+  that are used in the method argument. RFC reports this as a security issue.
+* Implement editheader extension
+* Implement mimeloop extension
+* Import ManageSieve into this package and provide support for alternate types
+  of script storage like LDAP or SQL database.
+
+* Implement IMAP plugin for IMAPSieve support:
+	- This may include support for manually running a script on a set of messages
+	  through IMAP (no specification for something like this is available; we will 
+	  have to provide our own)
+* Variables extension: implement compile time evaluation of constant values
+* Make the engine and its extensions much more configurable. Possibly this can 
+  be merged with Dovecot's new master config implementation.
+* Add development documentation, i.e. comment on library functions and document
+  the binary and byte-code format. 
+* Give the byte code format some more thought, it is currently quite rough and
+  to the point. 
+* Implement proposed notify mechanisms other than mailto. Currently defined: 
+  xmpp and sip
+
